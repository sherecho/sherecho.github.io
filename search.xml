<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>6.S081-Lab4 traps实验笔记</title>
    <url>/2024/03/27/MIT6S081/6.S081-Lab4%20traps/</url>
    <content><![CDATA[<h1 id="risc-v-assembly">RISC-V assembly</h1>
<p>There is a file <code>user/call.c</code> in your xv6 repo. make
fs.img compiles it and also produces a readable assembly version of the
program in <code>user/call.asm</code>.</p>
<p>我们启动qemu可以看到有call.c文件，执行<code>make fs.img</code>可以生成汇编文件</p>
<p><img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240329190931704.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Which registers contain arguments to functions? For example, which
register holds 13 in main's call to <code>printf</code>?</p>
<p>那几个寄存器保存了函数的参数，例如main函数里面那个寄存器保存了printf的入参13这个值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">  1c:	1141                	addi	sp,sp,-16</span><br><span class="line">  1e:	e406                	sd	ra,8(sp)</span><br><span class="line">  20:	e022                	sd	s0,0(sp)</span><br><span class="line">  22:	0800                	addi	s0,sp,16</span><br><span class="line">  printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:	4635                	li	a2,13</span><br></pre></td></tr></table></figure>
<p>从上面可以看出li a2,13
。将13加载到了a2寄存器中，从下图中可以看出，a2寄存器一般是用来传递函数的参数的</p>
<p><img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240327162636289.png"></p>
<blockquote>
<p>Where is the call to function <code>f</code> in the assembly code for
main? Where is the call to <code>g</code>? (Hint: the compiler may
inline functions.)</p>
<p>没有这样的代码。 g(x) 被内链到 f(x) 中，然后 f(x) 又被进一步内链到
main() 中</p>
</blockquote>
<blockquote>
<p>At what address is the function <code>printf</code> located?</p>
</blockquote>
<p><img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240329193740981.png"></p>
<p>可以看出printf的入口地址是0x630</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000630 &lt;printf&gt;:</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">printf(const char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line"> 630:	711d                	addi	sp,sp,-96</span><br><span class="line"> 632:	ec06                	sd	ra,24(sp)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>What value is in the register <code>ra</code> just after the
<code>jalr</code> to <code>printf</code> in <code>main</code>?</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">34:	600080e7          	jalr	1536(ra) # 630 &lt;printf&gt;</span><br></pre></td></tr></table></figure>
<p>jalr,参考<a href="https://msyksphinz-self.github.io/riscv-isadoc/html/rvi.html">riscv指令集</a>发现，其功能是</p>
<ol type="1">
<li>把pc + 4 的值记为t</li>
<li>把pc的值设置成 $ra + 1536</li>
<li>把ra寄存器的值设置成t</li>
</ol>
<p>所以要跳转的位置是ra+1536</p>
<p>可以看出。ra寄存器里面存的是0x30，1536在16进制下就是0x600.所以最后就是跳转到printf的入口函数地址</p>
<p><img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240329194628165.png"></p>
<blockquote>
<p>Run the following code.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">printf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br><span class="line">     </span><br></pre></td></tr></table></figure>
<p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here's an ASCII
table</a> that maps bytes to characters.</p>
<p>The output depends on that fact that the RISC-V is little-endian. If
the RISC-V were instead big-endian what would you set <code>i</code> to
in order to yield the same output? Would you need to change
<code>57616</code> to a different value?</p>
</blockquote>
<p>执行上述代码的输出是HE110 World</p>
<p><img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240329200031903.png"></p>
<p>为了知道ox00646c72是怎么代表字母的：</p>
<p><img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240329200423350.png"></p>
<p>大端序：<strong>高位</strong>字节在<strong>低</strong>地址。</p>
<p>小端序：<strong>低位</strong>字节在<strong>低</strong>地址。</p>
<p>RSIC-V是小端序的所以高字节在低地址显示出来就是rld</p>
<p>要是大端序的话需要换一下顺序：ox00726c64</p>
<h1 id="backtrace">Backtrace</h1>
<p>在调试的过程中，有一个发生错误的点之上的堆栈上的函数调用列表通常很有用</p>
<p>Implement a <code>backtrace()</code> function in
<code>kernel/printf.c</code>. Insert a call to this function in
<code>sys_sleep</code>, and then run bttest, which calls
<code>sys_sleep</code>. Your output should be as
follows。将写好的backtrace函数加入到sys_sleep系统调用里面，方便后面的测试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">backtrace:</span><br><span class="line">0x0000000080002cda</span><br><span class="line">0x0000000080002bb6</span><br><span class="line">0x0000000080002898</span><br></pre></td></tr></table></figure>
<p>The compiler puts in each stack frame a frame pointer that holds the
address of the caller's frame pointer. Your <code>backtrace</code>
should use these frame pointers to walk up the stack and print the saved
return address in each stack frame.</p>
<h2 id="栈帧">栈帧</h2>
<blockquote>
<p>The compiler puts in each stack frame a frame pointer that holds the
address of the caller's frame pointer. Your <code>backtrace</code>
should use these frame pointers to walk up the stack and print the saved
return address in each stack frame.</p>
<p>编译器在每一个栈帧里面存放一个栈的指针,这个栈的指针保存了调用这个栈帧的栈帧的地址</p>
</blockquote>
<ul>
<li>函数调用栈（Stack）</li>
</ul>
<ol type="1">
<li>由高地址往低地址增长</li>
<li>在xv6里，栈有一页大小（4KB）</li>
<li>栈指针（stack pointer）保存在sp寄存器里</li>
</ol>
<p><img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240330101304561.png"></p>
<p>gdb调试一下理解栈帧的调用</p>
<ul>
<li>栈帧（Stack Frame）</li>
</ul>
<ol type="1">
<li>当前栈帧的地址保存在 s0/fp寄存器 里</li>
<li>当前栈帧的地址也叫栈帧的指针（frame pointer，
fp），指向该栈帧的最高处</li>
<li>栈帧指针往下偏移8个字节是函数返回地址 return address</li>
<li>往下偏移16个字节是上一个栈帧的栈帧指针（previous frame
pointer）</li>
</ol>
<p><img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240330101849803.png"></p>
<blockquote>
<p>栈从高地址向低地址增长，每个大的box叫一个stack
frame（栈帧），栈帧由函数调用来分配，每个栈帧大小不一定一样，但是栈帧的最高处一定是return
address</p>
<p>sp是stack pointer，用于指向栈顶（低地址），保存在寄存器中</p>
<p>fp是frame
pointer，用于指向当前帧底部（高地址），保存在寄存器中，同时每个函数栈帧中保存了调用当前函数的函数（父函数）的fp（保存在to
prev frame那一栏中）</p>
<p>这些栈帧都是由编译器编译生成的汇编文件生成的</p>
</blockquote>
<p>首先我们在backtrace函数打断点后，启动gdb调试。此时我们<code>info frame</code>可看到当前的栈帧情况：</p>
<p><img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240329234148613.png"></p>
<p>可以看出现在的栈帧的地址是<img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240329234303847.png" alt="image-20240329234303847"></p>
<p>我们可以看出这个栈的上一个栈在<img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240329234417086.png" alt="image-20240329234417086"></p>
<p>这个上一栈的地址是存在fp寄存器里面的：</p>
<figure>
<img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240329234516532.png" alt="image-20240329234516532">
<figcaption aria-hidden="true">image-20240329234516532</figcaption>
</figure>
<p><img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240329234819654.png"></p>
<p>比如我们打印栈帧1，可以看出ra里面存的返回寄存器里面存的栈针的内容就是syscall函数的地址</p>
<p><img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240329235341408.png"></p>
<h2 id="hints">hints</h2>
<ul>
<li><p>Add the prototype for backtrace to <code>kernel/defs.h</code> so
that you can invoke <code>backtrace</code> in
<code>sys_sleep</code>.</p>
<p>在 defs.h 中添加声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span>            <span class="title function_">printf</span><span class="params">(<span class="type">char</span>*, ...)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">panic</span><span class="params">(<span class="type">char</span>*)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">printfinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// new function for backtrace</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>The GCC compiler stores the frame pointer of the currently
executing function in the register s0.
GCC编译器把当前执行函数的栈帧指针存储在寄存器s0里面</p></li>
<li><p>Add the following function to kernel/riscv.h:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline uint64</span><br><span class="line">r_fp()</span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) );</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>asm volatile("mv %0, s0" : "=r" (x) );</code>：这是内联汇编的部分。<code>asm volatile</code>
是内联汇编的开始标记，<code>mv</code> 是 MIPS 汇编指令，用于将寄存器
<code>s0</code> 的值移动到 <code>%0</code> 中。<code>%0</code>
是内联汇编语法中的占位符，表示第一个输出操作数（output
operand）。<code>=</code> 表示这是一个输出操作数。<code>(x)</code>
表示要将结果存储到变量 <code>x</code> 中。<code>r</code>
表示使用寄存器约束，告诉编译器将变量 <code>x</code>
放置在一个通用寄存器中。</p>
<p>and call this function inbacktrace to read the current frame pointer.
This function usesin-line assembly to read s0.</p></li>
</ul>
<h2 id="实现-backtrace-函数">实现 backtrace 函数</h2>
<p>小技巧,因为是栈指针往下偏移8个字节是函数返回地址,为了更好偏移8个字节,可以指定为uint_64指针,这样一个就是8个字节,因栈的地址是从高地址向低地址生长的所以是-1</p>
<p><img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240330104814023.png"></p>
<p>Xv6 allocates one page for each stack in the xv6 kernel at
PAGE-aligned address. You can compute the top and bottom address of the
stack page by using <code>PGROUNDDOWN(fp)</code> and
<code>PGROUNDUP(fp)</code> (see <code>kernel/riscv.h</code>. These
number are helpful for <code>backtrace</code> to terminate its loop.
可以通过判断是否超过一页的大小判断栈指针是否越界来终止循环</p>
<p>函数实现:</p>
<p>Once your backtrace is working, call it from <code>panic</code> in
<code>kernel/printf.c</code> so that you see the kernel's backtrace when
it panics.</p>
<p>实现后,将backtrace函数放到panic里面,当函数出现问题的时候就能看到backtrace</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  pr.locking = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;panic: &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  panicked = <span class="number">1</span>; <span class="comment">// freeze uart output from other CPUs</span></span><br><span class="line">  backtrace();</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="trap-的原理">trap 的原理</h1>
<p><img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240330143153643.png"></p>
<h1 id="alarm">Alarm</h1>
<p>In this exercise you'll add a feature to xv6 that periodically alerts
a process as it uses CPU time.</p>
<p>给XV6内核增添一个周期性报警的功能来限制进程使用CPU的时间</p>
<p>This might be useful for compute-bound processes that want to limit
how much CPU time they chew up, or for processes that want to compute
but also want to take some periodic action.</p>
<p>More generally, you'll be implementing a primitive form of user-level
interrupt/fault handlers; 实现一种更原始的用户级别的中断错误处理接口</p>
<p>you could use something similar to handle page faults in the
application可以用相似的方式去处理页错误.</p>
<ul>
<li><p>You should add a new <code>sigalarm(interval, handler)</code>
system
call.新增一个系统调用,功能:当应用程序调用<code>sigalarm(n, fn)</code></p>
<p>then after every <code>n</code> "ticks" of CPU time that the program
consumes, the kernel should cause application function <code>fn</code>
to be called. (有点类似软中断的定时器功能)</p>
<p>When <code>fn</code> returns, the application should resume where it
left off. A tick is a fairly arbitrary unit of time in xv6, determined
by how often a hardware timer generates interrupts. If an application
calls <code>sigalarm(0, 0)</code>, the kernel should stop generating
periodic alarm calls.</p></li>
<li><p>首先修改<em><strong>Makefile*</strong>以使</em><strong>alarmtest.c*</strong>被编译为xv6用户程序.</p></li>
<li><p>到<strong>user/user.h</strong>声明</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler)())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>更新user/usys.pl（此文件生成user/usys.S）、kernel/syscall.h和kernel/syscall.c以允许<code>alarmtest</code>调用<code>sigalarm</code>和<code>sigreturn</code>系统调用。然后在sysproc.c里面实现这两个系统调用的函数体</li>
</ul>
<h2 id="invoke-handler调用处理程序">invoke handler(调用处理程序)</h2>
<ul>
<li>你的<code>sys_sigalarm()</code>应该将报警间隔和指向处理程序函数的指针存储在<code>struct proc</code>的新字段中（位于*<strong>kernel/proc.h*</strong>）。</li>
<li>你也需要在<code>struct proc</code>新增一个新字段。用于跟踪自上一次调用（或直到下一次调用）到进程的报警处理程序间经历了多少滴答；您可以在*<strong>proc.c*</strong>的<code>allocproc()</code>中初始化<code>proc</code>字段。</li>
<li>每一个滴答声，硬件时钟就会强制一个中断，这个中断在kernel/trap.c中的<code>usertrap()</code>中处理。</li>
<li>如果产生了计时器中断，您只想操纵进程的报警滴答；你需要写类似下面的代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) ...</span><br></pre></td></tr></table></figure>
<ul>
<li><p>仅当进程有未完成的计时器时才调用报警函数。请注意，用户报警函数的地址可能是0（例如，在<strong>user/alarmtest.asm</strong>中，<code>periodic</code>位于地址0）。</p></li>
<li><p>您需要修改<code>usertrap()</code>，以便当进程的报警间隔期满时，用户进程执行处理程序函数。当RISC-V上的陷阱返回到用户空间时，什么决定了用户空间代码恢复执行的指令地址？</p>
<p>首先我们知道,32个通用寄存器的值都保存在了proc结构体的trapframe里面<code>struct trapframe *trapframe; // data page for trampoline.S</code></p>
<p><img src="/2024/03/27/MIT6S081/6.S081-Lab4%20traps/image-20240330161143031.png"></p>
<p>用户程序的pc指针保存在epc里面.所以我们想让trap恢复后去执行handler的函数只需要把这里的epc指向handler就可以</p>
<p>注意:如果您告诉qemu只使用一个CPU，那么使用gdb查看陷阱会更容易，这可以通过运行</p></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make CPUS=1 qemu-gdb</span><br></pre></td></tr></table></figure>
<p>在 proc 结构体的定义中，增加 alarm 相关字段：</p>
<ul>
<li>alarm_interval：时钟周期，0 为禁用</li>
<li>alarm_handler：时钟回调处理函数</li>
<li>alarm_ticks：下一次时钟响起前还剩下的 ticks 数</li>
<li>alarm_trapframe：时钟中断时刻的
trapframe，用于中断处理完成后恢复原程序的正常执行</li>
<li>alarm_goingoff：是否已经有一个时钟回调正在执行且还未返回（用于防止在
alarm_handler 中途闹钟到期再次调用 alarm_handler，导致 alarm_trapframe
被覆盖）</li>
</ul>
<p>函数句柄,定义一个函数指针来保存:
<code>void(*alarm_handler)();</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  <span class="comment">//接收传进来的两个参数</span></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//设置proc结构体</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;alarm_interval = ticks;</span><br><span class="line">  p-&gt;alarm_handler =(<span class="type">void</span>(*)()) handler;</span><br><span class="line">  p-&gt;alarm_ticks = ticks;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在allocproc的时候进行初始化工作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a trapframe page for alarm_trapframe.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;alarm_trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p-&gt;alarm_interval = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_handler = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_ticks = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_goingoff = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>freefroc的时候同样要进行操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;alarm_trapframe)</span><br><span class="line">  kfree((<span class="type">void</span>*)p-&gt;alarm_trapframe);</span><br><span class="line">p-&gt;alarm_trapframe = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarm_goingoff=<span class="number">0</span>;</span><br><span class="line">p-&gt;alarm_handler=<span class="number">0</span>;</span><br><span class="line">p-&gt;alarm_interval=<span class="number">0</span>;</span><br><span class="line">p-&gt;alarm_ticks=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>在 usertrap() 函数中，实现时钟机制:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span>(p-&gt;alarm_interval!=<span class="number">0</span>)&#123;   <span class="comment">//设定了时钟事件</span></span><br><span class="line">       <span class="keyword">if</span>(--p-&gt;alarm_ticks&lt;=<span class="number">0</span>)&#123;<span class="comment">//检查是否到达定时时间</span></span><br><span class="line">       <span class="comment">//确保没有时钟正在运行,如果此时有另一个时钟到期的处理函数在执行，则推迟</span></span><br><span class="line">       <span class="comment">//有可能在一个handler没执行完的时候，用户设置了新的定时且时间刚好到了</span></span><br><span class="line">       <span class="keyword">if</span>(!p-&gt;alarm_goingoff)</span><br><span class="line">           *p-&gt;alarm_trapframe=*p-&gt;trapframe;<span class="comment">//保存以前的内容</span></span><br><span class="line">           <span class="comment">//执行handler 函数句柄</span></span><br><span class="line">           p-&gt;trapframe-&gt;epc=(uint64) p-&gt;alarm_handler;</span><br><span class="line">           p-&gt;alarm_goingoff=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     yield();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>执行完handel后恢复原来的执行流现场:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//将 trapframe 恢复到时钟中断之前的状态，恢复原本正在执行的程序流</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span>myproc();</span><br><span class="line">  *p-&gt;trapframe=*p-&gt;alarm_trapframe;</span><br><span class="line">  p-&gt;alarm_goingoff=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/</url>
    <content><![CDATA[<p># Memory bound algorithms</p>
<p>获取数据有时比计算的开销更大：</p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240326143153174.png"></p>
<p><strong>带宽和时延</strong></p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240326143333708.png"></p>
<p>什么样的运输受限于访存</p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240326143726613.png"></p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240326144201944.png"></p>
<p>以稠密矩阵的计算为例</p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240326144356103.png"></p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240326144648142.png"></p>
<p>通过计算<span class="math inline">\(B_c\)</span>可以看出优化的潜力，对于本来就memory
bound的类型，可优化的空间就比较小</p>
<h1 id="organization-of-processors-caches-and-memory">Organization of
processors, caches, and memory</h1>
<p>多核：每个核有自己的L1,L2共享一个L3</p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240326145131950.png"></p>
<p>一个node有多个 sockets</p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240326145517449.png"></p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240326150412453.png"></p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240326150815843.png"></p>
<h1 id="other-ways-to-get-more-bandwidth">Other ways to get more
bandwidth</h1>
<p>为什么顺序访问和随机访问在L1的时候性能是一样的。因为比较小的数据一开始warm
up所有的元素都可以在L1上可以找到</p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240402143202082.png"></p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240402143013881.png"></p>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240402144304188.png" alt="image-20240402144304188">
<figcaption aria-hidden="true">image-20240402144304188</figcaption>
</figure>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240402144506731.png"></p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240402145159096.png"></p>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240402150337148.png" alt="image-20240402150337148">
<figcaption aria-hidden="true">image-20240402150337148</figcaption>
</figure>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240402151155327.png"></p>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240402153634304.png" alt="image-20240402153634304">
<figcaption aria-hidden="true">image-20240402153634304</figcaption>
</figure>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240402161616159.png"></p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240402164544151.png"></p>
<p>不write alloc</p>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240409143043063.png" alt="image-20240409143043063">
<figcaption aria-hidden="true">image-20240409143043063</figcaption>
</figure>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240409143703463.png" alt="image-20240409143703463">
<figcaption aria-hidden="true">image-20240409143703463</figcaption>
</figure>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240409144111152.png"></p>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240409145054028.png" alt="image-20240409145054028">
<figcaption aria-hidden="true">image-20240409145054028</figcaption>
</figure>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240409150006161.png" alt="image-20240409150006161">
<figcaption aria-hidden="true">image-20240409150006161</figcaption>
</figure>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240409153020704.png" alt="image-20240409153020704">
<figcaption aria-hidden="true">image-20240409153020704</figcaption>
</figure>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240604000011031.png" alt="image-20240604000011031">
<figcaption aria-hidden="true">image-20240604000011031</figcaption>
</figure>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240409160504941.png"></p>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240604002823280.png" alt="image-20240604002823280">
<figcaption aria-hidden="true">image-20240604002823280</figcaption>
</figure>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240416144406374.png"></p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240416144907598.png"></p>
<p><img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240416145653649.png"></p>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240416150049265.png" alt="image-20240416150049265">
<figcaption aria-hidden="true">image-20240416150049265</figcaption>
</figure>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240416163022123.png" alt="image-20240416163022123">
<figcaption aria-hidden="true">image-20240416163022123</figcaption>
</figure>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240603160342812.png" alt="image-20240603160342812">
<figcaption aria-hidden="true">image-20240603160342812</figcaption>
</figure>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240603192339780.png" alt="image-20240603192339780">
<figcaption aria-hidden="true">image-20240603192339780</figcaption>
</figure>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240603194843237.png" alt="image-20240603194843237">
<figcaption aria-hidden="true">image-20240603194843237</figcaption>
</figure>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240604092834160.png" alt="image-20240604092834160">
<figcaption aria-hidden="true">image-20240604092834160</figcaption>
</figure>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240604093159626.png" alt="image-20240604093159626">
<figcaption aria-hidden="true">image-20240604093159626</figcaption>
</figure>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240604094252125.png" alt="image-20240604094252125">
<figcaption aria-hidden="true">image-20240604094252125</figcaption>
</figure>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240604095524207.png" alt="image-20240604095524207">
<figcaption aria-hidden="true">image-20240604095524207</figcaption>
</figure>
<figure>
<img src="/2024/03/26/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec7/image-20240604101637559.png" alt="image-20240604101637559">
<figcaption aria-hidden="true">image-20240604101637559</figcaption>
</figure>
]]></content>
      <categories>
        <category>并行处理</category>
      </categories>
      <tags>
        <tag>并行处理</tag>
      </tags>
  </entry>
  <entry>
    <title>6.S081-Lab 3 PAGE TABLES实验笔记</title>
    <url>/2024/03/21/MIT6S081/6.S081-Lab3%20page%20tables/</url>
    <content><![CDATA[<h1 id="speed-up-system-calls">Speed up system calls</h1>
<p>一些操作系统 (e.g.,
Linux)通过在只读的区域共享用户空间和内核态空间的数据加速特定的系统调用。这种方法可以减少系统调用需要不断跨越用户态和内核态的需求T.
To help you learn how to insert mappings into a page table, your first
task is to implement this optimization for the <code>getpid()</code>
system call in xv6.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ugetpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">u</span> =</span> (<span class="keyword">struct</span> usyscall *)USYSCALL;<span class="comment">//获得USYSCALL的页把它转为一个结构体指针</span></span><br><span class="line">  <span class="keyword">return</span> u-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当每个process被创建的时候, 在USYSCALL (a VA defined in
<code>memlayout.h</code>)映射一个只读page . 在页的开头, store a
<code>struct usyscall</code> (also defined in <code>memlayout.h</code>),
and initialize it to store the PID of the current process.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>For this lab, <code>ugetpid()</code> has been provided on the
userspace side and will automatically use the USYSCALL mapping.</p>
<p>从上面可以看出应该是TRAPFRAME在TRAMPOLINE下面一页，USYSCALL在TRAPFRAME往下一页的位置</p>
<ul>
<li>You can perform the mapping in <code>proc_pagetable()</code> in
<code>kernel/proc.c</code>.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//给进程分配了一个页表</span></span><br><span class="line"><span class="comment">// An empagetable_t</span></span><br><span class="line">proc_pagetable(<span class="keyword">struct</span> proc *p)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//map the usyscall</span></span><br><span class="line">   <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">//如果失败取消映射并释放页</span></span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从上面的函数中可以看到<code>trampoline code</code>和<code>trapframe</code>的映射过程，我们的目标是通过模仿这两个的过程实现对USYSCALL的映射。</p>
<p>Choose permission bits that allow userspace to only read the
page.也就是说我们要将页的权限设为只读的。权限设置部分是在这里操作的：
<code>if(mappages(pagetable, TRAMPOLINE, PGSIZE,(uint64)trampoline, PTE_R | PTE_X) &lt; 0)</code>其中PTE_R
是read，|PTE_X</p>
<p>是可执行，PTE_W是可写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L <span class="string">&lt;&lt; 4) // 1 -&gt;</span> user can access</span></span><br></pre></td></tr></table></figure>
<ul>
<li>You may find that <code>mappages()</code> is a useful utility.</li>
</ul>
<p>mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa,
int
perm)其中，va是起始地址的虚拟地址对应的物理页的启示地址是pa。其中va和size可能不是页对齐的。如果通过walk函数不能分配所需要的页表就返回-1否则返回0</p>
<ul>
<li>Don't forget to allocate and initialize the page in
<code>allocproc()</code></li>
</ul>
<p>如下所示我们需要在allocproc这个是分配进程的函数，里面涉及到页的分配，函数里面对模仿<code>Allocate a trapframe page</code>
对usyscall也分配页</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">allocproc(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line">  p-&gt;state = USED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//allocate an usyscall page</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;usyscall-&gt;pid=p-&gt;pid;</span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Make sure to free the page in <code>freeproc()</code>.</li>
</ul>
<p>释放进程的时候同样涉及对页表的释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proc_freepagetable(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="print-a-page-table">Print a page table</h1>
<p>定义一个名叫 <code>vmprint()</code>的函数. 这个函数输入参数是
<code>pagetable_t</code>, and print that pagetable in the format
described below.</p>
<p><img src="/2024/03/21/MIT6S081/6.S081-Lab3%20page%20tables/image-20240325160239779.png"></p>
<p>Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in
exec.c just before the <code>return argc</code>, to print the first
process's page table.</p>
<p>Now when you start xv6 it should print output like this, describing
the page table of the first process at the point when it has just
finished <code>exec()</code>ing <code>init</code>。如上图所示。</p>
<p>第一行displays 传给vmprint的参数. After that there is a line for each
PTE, including PTEs that refer to page-table pages deeper in the tree.
用" .."` 表示树的深度，第一级两个点，第二级四个，第三级六个.</p>
<p><img src="/2024/03/21/MIT6S081/6.S081-Lab3%20page%20tables/image-20240325161747935.png"></p>
<p>Each PTE line 显示了the PTE index in its page-table page, the pte
bits, and the physical address extracted from the PTE. Don't print PTEs
that are not valid.</p>
<p>在上面的例子中，如上图所示，顶级的页表映射了第0项和第255项。下一个层级0映射了0，0项又映射了0，1，2项。</p>
<ul>
<li><p>You can put <code>vmprint()</code> in <code>kernel/vm.c</code>.
首先在vm.c里面定义vmprint</p></li>
<li><p>The function <code>freewalk</code> may be
inspirational.可以参考freewalk函数进行设计</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable,uint64 depth)</span>&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">if</span>(depth&gt;<span class="number">2</span>)</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(depth==<span class="number">0</span>)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="type">char</span> *buf = prefix[depth];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s%d: pte %p pa %p\n&quot;</span>, buf, i, pte, PTE2PA(pte));</span><br><span class="line">      vmprint((<span class="type">pagetable_t</span>) child, depth + <span class="number">1</span>);<span class="comment">//使用广度优先搜索的思想</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="detecting-which-pages-have-been-accessed">Detecting which pages
have been accessed</h1>
<p>对于一些垃圾回收机制 (a form of automatic memory management)
，知道那些也是被访问过accessed (read or write)的是十分有用的. add a new
feature to xv6 that detects and reports this information to userspace by
inspecting the access bits in the RISC-V page table. 当遇到TLB
miss的时候 RISC-V 硬件会自动标记 PTE里的这些位.</p>
<p>目标L:实现<code>pgaccess()</code>, a system call that reports which
pages have been accessed.</p>
<p>The system call takes three arguments.：</p>
<ul>
<li>First, it takes the starting virtual address of the first user page
to check.</li>
<li>Second, it takes the number of pages to check.</li>
<li>Finally, it takes a user address to a buffer to store the results
into a bitmask (一个数据结构that uses one bit per page and where the
first page corresponds to the least significant bit).</li>
</ul>
<p><img src="/2024/03/21/MIT6S081/6.S081-Lab3%20page%20tables/image-20240325174625718.png"></p>
<ul>
<li><p>Start by implementing <code>sys_pgaccess()</code> in
<code>kernel/sysproc.c</code>.
实现sysproc.c文件里面的sys_pgaccess()函数</p></li>
<li><p>You'll need to parse arguments using <code>argaddr()</code> and
<code>argint()</code>.因为是系统调用，需要上述两个函数获取入参</p></li>
<li><p>For the output bitmask, it's easier to store a temporary buffer
in the kernel and copy it to the user (via <code>copyout()</code>) after
filling it with the right bits.
输出的bitmask需要通过copyout来将其从内核空间拷贝到用户空间</p></li>
<li><p><code>walk()</code> in <code>kernel/vm.c</code> is very useful
for finding the right PTEs.可以参考walkaddr()和walk函数</p></li>
<li><p>You'll need to define <code>PTE_A</code>, the access bit, in
<code>kernel/riscv.h</code>. Consult the RISC-V manual to determine its
value.</p></li>
</ul>
<p><img src="/2024/03/21/MIT6S081/6.S081-Lab3%20page%20tables/image-20240325180521405.png"></p>
<p>从手册上看，RISC-V处理器会自动置位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L <span class="string">&lt;&lt; 4) // 1 -&gt;</span> user can access</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A  (1L&lt;&lt;6)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sys_pgaccess(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">    uint64 addr;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> bitmask;</span><br><span class="line">    <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">2</span>, &amp;bitmask) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">32</span> || len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="type">int</span> va = addr + i * PGSIZE;</span><br><span class="line">        <span class="type">int</span> abit = vm_pgaccess(p-&gt;pagetable, va);</span><br><span class="line">        res = res | abit &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, bitmask, (<span class="type">char</span>*)&amp;res, <span class="keyword">sizeof</span>(res)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vm_pgaccess</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span>&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_A)!=<span class="number">0</span>)&#123;</span><br><span class="line">      *pte=*pte&amp;(~PTE_A);<span class="comment">//clear pteA flag</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/21/MIT6S081/6.S081-Lab3%20page%20tables/image-20240327103354126.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU15445P0实验笔记:实现基于copy on write tree的k-v存储引擎</title>
    <url>/2024/03/15/CMU15445/P0%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>写在前面： 因为对C++
17的特性不太了解，写的很痛苦,感觉对C++的智能指针，模板等新特性有了更深入的了解，收获颇多。</p>
<p><a href="https://15445.courses.cs.cmu.edu/spring2023/project0/">实验官网链接</a></p>
<h1 id="task1copy-on-write-trie">task1：Copy-On-Write Trie</h1>
<p>一开始的树节结构是一个前缀树的结构（详见数据结构与算法前缀树的笔记）</p>
<p>修改 <code>trie.h</code> 和 <code>trie.cpp</code>来实现copy-on-write
trie. 什么是 copy-on-write
trie？对树的操作不需要直接修改原来的树节点，而是创建新的节点并返回新的root节点。例如插入：<code>("ad", 2)</code>
，先创建一个新的节点： <code>Node2</code>
，NODE2会重用原来树的孩子节点，返回新的根节点</p>
<p><img src="/2024/03/15/CMU15445/P0%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240312094244170.png"></p>
<p>插入 <code>("a", "abc")</code> 并且移除<code>("ab", 1)</code>：</p>
<p><img src="/2024/03/15/CMU15445/P0%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240312094918327.png"></p>
<p>尝试完成三种操作</p>
<ul>
<li><p><code>Get(key)</code>: 获取key对应的value值</p></li>
<li><p><code>Put(key, value)</code>:
设置key对应的value值.如果key值已经存在则覆盖. Note that the type of the
value might be non-copyable (i.e.,
<code>std::unique_ptr&lt;int&gt;</code>). This method returns a new
trie.</p>
<p>在 C++
中，有一些类型是不允许直接进行复制的，而是通过移动或者转移所有权的方式来操作。<code>std::unique_ptr</code>
就是这样的一个例子。它表示一个独占所有权的指针，意味着同一时刻只有一个指针可以拥有它所指向的资源。由于其独占性质，它不允许直接进行复制，而是通过移动（move）操作来传递所有权。</p></li>
<li><p><code>Delete(key)</code>: Delete the value for the key. This
method returns a new trie.</p></li>
</ul>
<p>创建新的node节点,应该使用 <code>TrieNode</code>
class里面的<code>Clone</code> 函数. To reuse an existing node in the new
trie, you can copy <code>std::shared_ptr&lt;TrieNode&gt;</code>: copying
a shared pointer doesn’t copy the underlying data.</p>
<p>不能通过new和delete人工的分配内存 <code>std::shared_ptr</code> will
deallocate the object when no one has a reference to the underlying
object.</p>
<h2 id="实现过程中的学习笔记">实现过程中的学习笔记</h2>
<p>tree
class中根节点的定义：<code>std::shared_ptr&lt;const TrieNode&gt; root_&#123;nullptr&#125;;</code></p>
<p>这行代码是在 C++ 中声明了一个类成员变量 <code>root_</code>，它是一个
<code>std::shared_ptr</code> 智能指针，指向 <code>const TrieNode</code>
类型的对象，初始值为 <code>nullptr</code>。</p>
<ol type="1">
<li><strong><code>std::shared_ptr</code></strong>：<code>std::shared_ptr</code>
是 C++
标准库提供的一个智能指针类，用于管理动态分配的内存。它提供了自动内存管理，可以确保在不再需要时正确释放内存，以避免内存泄漏。<code>std::shared_ptr</code>
允许多个指针共享对同一对象的所有权，并且会在所有指向对象的
<code>std::shared_ptr</code> 都被销毁时自动释放内存。</li>
<li><strong><code>root_&#123;nullptr&#125;</code></strong>：这是成员变量
<code>root_</code> 的初始化方式，使用了 C++11
中的成员初始化列表。<code>nullptr</code> 表示空指针，即初始时
<code>root_</code> 不指向任何有效对象。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new trie with the given root.</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Trie</span><span class="params">(std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; root)</span> : root_(std::move(root)) &#123;</span>&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p><strong><code>explicit Trie(std::shared_ptr&lt;const TrieNode&gt; root)</code></strong>：这是一个类
<code>Trie</code> 的构造函数的声明。它接受一个
<code>std::shared_ptr&lt;const TrieNode&gt;</code> 类型的参数
<code>root</code>。构造函数前面的 <code>explicit</code>
关键字指示该构造函数是显式的，即不允许隐式转换调用。</p>
<p><code>explicit</code>
这个关键字用来说明这个类的构造不支持隐式类型转换。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CPP</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">const</span> std::string &amp;name_)</span> : name(name_) &#123;</span>&#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age_) : <span class="built_in">age</span>(age_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person a = <span class="number">22</span>; <span class="comment">// 隐式构造，存在这样的构造函数</span></span><br><span class="line"><span class="comment">// Person b = std::string(&quot;ceyewan&quot;); wrong，明确了不能使用隐式构造</span></span><br><span class="line"><span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;ceyewan&quot;</span>)</span></span>; <span class="comment">// 只能这样构造</span></span><br><span class="line">std::cout &lt;&lt; a.age &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; b.name &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>同样，这样初始化不仅代码风格简单，而且可以避免性能浪费，如果不这样的话，<code>“ceyewan“</code>（<code>const char*</code>
类型）会调用 <code>string</code> 的构造函数得到
<code>name_</code>，然后再次调用 <code>string</code> 的构造函数得到
<code>name</code>。</p></li>
<li><p><strong><code>: root_(std::move(root))</code></strong>：这是成员初始化列表，用于初始化
<code>Trie</code> 类的成员变量
<code>root_</code>。在这里，<code>std::move(root)</code> 使用了 C++11
中的 <code>std::move</code> 函数，将参数 <code>root</code>
转移（move）为右值引用，以便进行移动构造。移动构造可以避免不必要的内存拷贝，提高效率。</p>
<p>移动构造函数：C++的移动构造函数是一种特殊的构造函数，用于将资源从一个对象转移到另一个对象而不进行深拷贝。移动构造函数通常用于支持移动语义，以提高代码的效率和性能。</p></li>
</ol>
<h3 id="move">move</h3>
<p><a href="https://www.cnblogs.com/shadow-lr/p/Introduce_Std-move.html">参考博客连接</a></p>
<p><strong>左值和右值</strong></p>
<p>首先区分左值和右值</p>
<p>左值是表达式结束后依然存在的持久对象(代表一个在内存中占有确定位置的对象)</p>
<p>右值是表达式结束时不再存在的临时对象(不在内存中占有确定位置的表达式）</p>
<p>便携方法：对表达式取地址，如果能，则为左值，否则为右值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> val;</span><br><span class="line">val = <span class="number">4</span>; <span class="comment">// 正确 ①</span></span><br><span class="line"><span class="number">4</span> = val; <span class="comment">// 错误 ②</span></span><br></pre></td></tr></table></figure>
<p>上述例子中，由于在之前已经对变量val进行了定义，故在栈上会给val分配内存地址，运算符=要求等号左边是可修改的左值，4是临时参与运算的值，一般在寄存器上暂存，运算结束后在寄存器上移除该值，故①是对的，②是错的</p>
<ul>
<li>std::move作用主要可以将一个左值转换成右值引用，从而可以调用C++11右值引用的拷贝构造函数</li>
</ul>
<h3 id="智能指针的使用">智能指针的使用</h3>
<p>智能指针可以像普通指针那样使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义智能指针</span></span><br><span class="line"><span class="function">auto_ptr&lt;Test&gt; <span class="title">test</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;test-&gt;debug：&quot;</span> &lt;&lt; test-&gt;<span class="built_in">getDebug</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(*test).debug：&quot;</span> &lt;&lt; (*test).<span class="built_in">getDebug</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>智能指针的常用函数：</p>
<p>get() 获取智能指针托管的指针地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;Test&gt; <span class="title">test</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line"></span><br><span class="line">Test *tmp = test.<span class="built_in">get</span>();		<span class="comment">// 获取指针返回</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;tmp-&gt;debug：&quot;</span> &lt;&lt; tmp-&gt;<span class="built_in">getDebug</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>但我们一般不会这样使用，因为都可以直接使用智能指针去操作，除非有一些特殊情况。</p>
<h3 id="shared_ptr和unique_ptr">shared_ptr和unique_ptr</h3>
<p><code>std::auto_ptr</code> 是 C++98
中引入的智能指针，用于管理动态分配的内存，但它已经在 C++11
中被标记为废弃（deprecated），并且在 C++17 中被完全移除。</p>
<p><code>std::shared_ptr</code> 和 <code>std::unique_ptr</code> 是 C++11
引入的两种智能指针，它们都位于 <code>&lt;memory&gt;</code>
头文件中，用于管理动态分配的内存。虽然它们都提供了自动内存管理，但它们之间有一些关键的区别。</p>
<h3 id="stdshared_ptr">std::shared_ptr：</h3>
<ul>
<li><code>std::shared_ptr</code>
允许多个指针共享对同一对象的所有权。它会维护一个引用计数，记录指向对象的共享指针数量，直到所有的
<code>std::shared_ptr</code> 都被销毁时才会释放对象。</li>
<li>可以通过 <code>std::make_shared</code> 来创建
<code>std::shared_ptr</code>，这会将对象和引用计数放在同一个分配的内存块中，提高效率。</li>
<li><code>std::shared_ptr</code>
的拷贝构造和拷贝赋值是线程安全的，因为引用计数的增减是原子操作。</li>
<li>使用 <code>std::shared_ptr</code>
时要小心循环引用的问题，即两个或多个 <code>std::shared_ptr</code>
相互持有对方的指针，导致引用计数无法降为零，造成内存泄漏。</li>
</ul>
<h3 id="stdunique_ptr">std::unique_ptr：</h3>
<ul>
<li><code>std::unique_ptr</code>
代表对唯一对象的所有权，即同一时刻只有一个 <code>std::unique_ptr</code>
可以拥有一个对象。它提供了移动语义，支持转移所有权而不需要拷贝。</li>
<li>由于它的独占性质，<code>std::unique_ptr</code>
没有引用计数的开销，因此更加轻量级，且无需担心循环引用问题。</li>
<li>不能直接拷贝构造或拷贝赋值
<code>std::unique_ptr</code>，但可以通过移动构造和移动赋值来转移所有权。</li>
<li>可以使用 <code>std::make_unique</code> 来创建
<code>std::unique_ptr</code>。</li>
</ul>
<p>if you want to convert <code>unique_ptr</code> into
<code>shared_ptr</code>, you can use
<code>std::shared_ptr&lt;T&gt;(std::move(ptr))</code></p>
<h3 id="stdstring_view">std::string_view</h3>
<p>C++17中我们可以使用std::string_view来获取一个字符串的视图，字符串视图并不真正的创建或者拷贝字符串，而只是拥有一个字符串的查看功能。std::string_view比std::string的性能要高很多，因为每个std::string都独自拥有一份字符串的拷贝，而std::string_view只是记录了自己对应的字符串的指针和偏移位置。当我们在只是查看字符串的函数中可以直接使用std::string_view来代替std::string。</p>
<p>创建过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* cstr = <span class="string">&quot;yangxunwu&quot;</span>;</span><br><span class="line">    <span class="function">std::string_view <span class="title">stringView1</span><span class="params">(cstr)</span></span>;</span><br><span class="line">    <span class="function">std::string_view <span class="title">stringView2</span><span class="params">(cstr, <span class="number">4</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stringView1: &quot;</span> &lt;&lt; stringView1 &lt;&lt; <span class="string">&quot;, stringView2: &quot;</span> &lt;&lt; stringView2 &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    std::string str = <span class="string">&quot;yangxunwu&quot;</span>;</span><br><span class="line">    <span class="function">std::string_view <span class="title">stringView3</span><span class="params">(str.c_str())</span></span>;</span><br><span class="line">    <span class="function">std::string_view <span class="title">stringView4</span><span class="params">(str.c_str(), <span class="number">4</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stringView3: &quot;</span> &lt;&lt; stringView1 &lt;&lt; <span class="string">&quot;, stringView4: &quot;</span> &lt;&lt; stringView2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/15/CMU15445/P0%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/717692-20201122130119748-831461214.png"></p>
<h3 id="分析一下tree.h里面的各种类">分析一下tree.h里面的各种类</h3>
<p><img src="/2024/03/15/CMU15445/P0%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240317233737992.png"></p>
<h2 id="模板函数">模板函数</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Get</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> T *</span>;</span><br></pre></td></tr></table></figure>
<p>这行代码定义了一个模板成员函数 <code>Get</code>，它接受一个
<code>std::string_view</code> 类型的参数
<code>key</code>，并返回一个指向类型 <code>T</code> 的常量指针。</p>
<ol type="1">
<li><strong><code>template &lt;class T&gt;</code></strong>：这是一个模板声明，声明了一个模板函数，其中
<code>&lt;class T&gt;</code> 表示 <code>T</code>
是一个模板参数，可以在函数内部作为一种类型来使用。</li>
<li><strong><code>auto Get(std::string_view key) const -&gt; const T \*;</code></strong>：这是函数的声明部分。
<ul>
<li><code>auto</code>：返回类型的占位符类型，表示编译器将根据函数体中的返回语句的表达式推断返回类型。</li>
<li><code>Get</code>：函数名。</li>
<li><code>(std::string_view key)</code>：函数参数列表，接受一个类型为
<code>std::string_view</code> 的参数
<code>key</code>，它是一个轻量级的字符串视图，用于传递字符串的引用和长度。</li>
<li><code>const</code>：表示该函数是一个常量成员函数，即在函数内部不能修改对象的成员变量。</li>
<li><code>-&gt; const T *</code>：箭头符号 <code>-&gt;</code>
用于指定函数的返回类型，这里返回一个指向类型 <code>T</code>
的常量指针。</li>
</ul></li>
</ol>
<h2 id="get">get</h2>
<p>如果trie为空，则直接返回nullptr。</p>
<p>如果key为空，先找根节点，如果根节点是一个存储value的节点，则返回value。</p>
<p>如果key不为空，让cur指向根节点。遍历key的字符，如果当前字符在cur的子节点map中，则让cur等于当前字符在cur的子节点中的映射节点继续遍历；否则不存在该key，直接返回nullptr即可。最后把找到的value指针返回。</p>
<p><code>auto pointer= dynamic_cast&lt;const bustub::TrieNodeWithValue&lt;T&gt; *&gt;(root_.get());</code></p>
<p>沿着字符串找到最后的值节点。然后使用dynamic_cast转换。dynamic_cast允许指针安全地向下转换（即由基类转为派生类指针），失败则返回
nullptr 。但这里的问题是智能指针不支持这个转换，故我们使用智能指针的
get( ) 方法取得裸指针，然后再进行转换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//B是A的派生类</span></span><br><span class="line"><span class="comment">//b是B类型的对象</span></span><br><span class="line">std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;(b);</span><br></pre></td></tr></table></figure>
<p>make_shared不会保留多态性质生成一个指向b的基类指针。make_shared会先截断b，只留下A部分的值，然后生成指针。在本题中就是TrieNodeWithValue会被截断为TrieNode。
正确做法是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;B&gt;(b);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Get</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> T * </span>&#123;</span><br><span class="line">  <span class="comment">//throw NotImplementedException(&quot;Trie::Get is not implemented.&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// You should walk through the trie to find the node corresponding to the key. If the node doesn&#x27;t exist, return</span></span><br><span class="line">  <span class="comment">// nullptr. After you find the node, you should use `dynamic_cast` to cast it to `const TrieNodeWithValue&lt;T&gt; *`. If</span></span><br><span class="line">  <span class="comment">// dynamic_cast returns `nullptr`, it means the type of the value is mismatched, and you should return nullptr.</span></span><br><span class="line">  <span class="comment">// Otherwise, return the value.</span></span><br><span class="line">  <span class="comment">//如果树为空则返回空</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;root_==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果key为空pointerpointer</span></span><br><span class="line">  <span class="keyword">if</span>(key.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="comment">//判断根节点是否为value节点</span></span><br><span class="line">    <span class="keyword">if</span>(root_-&gt;is_value_node_)&#123;</span><br><span class="line">      <span class="comment">//转为子类指针</span></span><br><span class="line">      <span class="keyword">auto</span> pointer= <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> bustub::TrieNodeWithValue&lt;T&gt; *&gt;(root_.<span class="built_in">get</span>());</span><br><span class="line">      <span class="keyword">return</span>  pointer==<span class="literal">nullptr</span>?<span class="literal">nullptr</span>:pointer-&gt;value_.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root_-&gt;is_value_node_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    std:: shared_ptr&lt;<span class="type">const</span> bustub :: TrieNode&gt; cur=<span class="keyword">this</span>-&gt;root_;</span><br><span class="line">    <span class="comment">//遍历字符串</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">char</span> ch: key)&#123;</span><br><span class="line">       <span class="comment">//使用map映射找到字符串对应的节点</span></span><br><span class="line">       <span class="keyword">auto</span> node=cur-&gt;children_.<span class="built_in">find</span>(ch);</span><br><span class="line">       <span class="comment">//没找到</span></span><br><span class="line">       <span class="keyword">if</span>(node==cur-&gt;children_.<span class="built_in">end</span>())&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       cur=node-&gt;second;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;is_value_node_)&#123;</span><br><span class="line">          std::shared_ptr&lt;<span class="type">const</span> bustub::TrieNodeWithValue&lt;T&gt;&gt; pointer =std::dynamic_pointer_cast&lt;<span class="type">const</span> bustub::TrieNodeWithValue&lt;T&gt;&gt;(cur); <span class="comment">// 父类智能指针转子类    </span></span><br><span class="line">         <span class="keyword">return</span>  pointer==<span class="literal">nullptr</span>?<span class="literal">nullptr</span>:pointer-&gt;value_.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="put">put</h2>
<p>设置键对应的值。如果键已经存在，则覆盖现有值。注意，值的类型可能是不可复制的（即，
<code>std::unique_ptr&lt;int&gt;</code>
因此需要使用移动语义）。这个方法返回一个新的trie，也就是说，实现写时拷贝</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SubPut</span><span class="params">(std::shared_ptr&lt;bustub::TrieNode&gt; &amp;root,std::shared_ptr&lt;T&gt;&amp; valptr,std::string_view key)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch=key.<span class="built_in">at</span>(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">auto</span> it = root-&gt;children_.<span class="built_in">find</span>(ch);</span><br><span class="line">    <span class="keyword">if</span> (it != root-&gt;children_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="comment">//找到了</span></span><br><span class="line">        <span class="comment">//判断是否为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(key.<span class="built_in">size</span>()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="comment">//覆盖原来的数据</span></span><br><span class="line">          it-&gt;second=std::make_shared&lt;bustub::TrieNodeWithValue&lt;T&gt;&gt;(it-&gt;second-&gt;children_,valptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则复制该节点，并复用下面的节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">         std::shared_ptr&lt;bustub::TrieNode&gt; newnode=it-&gt;second-&gt;<span class="built_in">Clone</span>();</span><br><span class="line">         <span class="comment">//递归写入</span></span><br><span class="line">         <span class="built_in">SubPut</span>(newnode,valptr,key.<span class="built_in">substr</span>(<span class="number">1</span>,key.<span class="built_in">size</span>()<span class="number">-1</span>));</span><br><span class="line">         it-&gt;second=std::<span class="built_in">move</span>(newnode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//没找到</span></span><br><span class="line">       <span class="type">char</span> ch=key.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">//新建节点</span></span><br><span class="line">       <span class="keyword">if</span>(key.<span class="built_in">size</span>()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">         root-&gt;children_.<span class="built_in">insert</span>(&#123;ch,std::make_shared&lt;bustub::TrieNodeWithValue&lt;T&gt;&gt;(valptr)&#125;) ;   </span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">        std::shared_ptr tmpptr=std::<span class="built_in">make_shared</span>&lt;bustub::TrieNode&gt;();</span><br><span class="line">        <span class="comment">//递归插入</span></span><br><span class="line">        <span class="built_in">SubPut</span>(tmpptr,valptr,key.<span class="built_in">substr</span>(<span class="number">1</span>,key.<span class="built_in">size</span>()<span class="number">-1</span>));</span><br><span class="line">        root-&gt;children_.<span class="built_in">insert</span>(&#123;ch,std::<span class="built_in">move</span>(tmpptr)&#125;);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Put</span><span class="params">(std::string_view key, T value)</span> <span class="type">const</span> -&gt; Trie </span>&#123;</span><br><span class="line">  <span class="comment">// Note that `T` might be a non-copyable type. Always use `std::move` when creating `shared_ptr` on that value.</span></span><br><span class="line">  <span class="comment">//throw NotImplementedException(&quot;Trie::Put is not implemented.&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// You should walk through the trie and create new nodes if necessary. If the node corresponding to the key already</span></span><br><span class="line">  <span class="comment">// exists, you should create a new `TrieNodeWithValue`.</span></span><br><span class="line">  <span class="comment">//key为空在根节点插入</span></span><br><span class="line">  std::shared_ptr&lt;T&gt; val_ptr=std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">  <span class="keyword">if</span>(key.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    std::shared_ptr&lt;bustub::TrieNodeWithValue&lt;T&gt;&gt; newroot=<span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//如果根节点没有孩子直接插入</span></span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;root_-&gt;children_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    newroot=std::make_shared&lt;bustub::TrieNodeWithValue&lt;T&gt;&gt;(val_ptr);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果根节点有孩子复制完再插入</span></span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">    newroot=std::make_shared&lt;bustub::TrieNodeWithValue&lt;T&gt;&gt;(<span class="keyword">this</span>-&gt;root_-&gt;children_,std::<span class="built_in">move</span>(val_ptr));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//返回树</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Trie</span>(newroot);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//key不为空，首先复制树然后递归插入</span></span><br><span class="line">  std::shared_ptr&lt;bustub::TrieNode&gt; newroot=<span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;root_!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">     newroot=<span class="keyword">this</span>-&gt;root_-&gt;<span class="built_in">Clone</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    newroot=std::<span class="built_in">make_shared</span>&lt;TrieNode&gt;(<span class="built_in">TrieNode</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//递归插入</span></span><br><span class="line">  <span class="built_in">SubPut</span>(newroot,val_ptr,key);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Trie</span>(newroot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="remove">remove</h2>
<p>Delete the value for the key. This method returns a new trie</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">subremove</span><span class="params">(std::shared_ptr&lt;TrieNode&gt; &amp;root,std::string_view key)</span>-&gt;<span class="type">bool</span></span>&#123;</span><br><span class="line">     <span class="type">char</span> ch=key.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">auto</span> it =root-&gt;children_.<span class="built_in">find</span>(ch);</span><br><span class="line">     <span class="keyword">if</span>(it!=root-&gt;children_.<span class="built_in">end</span>())&#123;</span><br><span class="line">      <span class="comment">//找到了</span></span><br><span class="line">      <span class="comment">//是否为最后一个节点</span></span><br><span class="line">      <span class="keyword">if</span>(key.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!it-&gt;second-&gt;is_value_node_)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second-&gt;children_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                root-&gt;children_.<span class="built_in">erase</span>(it-&gt;first);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                it-&gt;second=std::<span class="built_in">make_shared</span>&lt;TrieNode&gt;(<span class="built_in">TrieNode</span>(it-&gt;second-&gt;children_));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        std::shared_ptr ptr=it-&gt;second-&gt;<span class="built_in">Clone</span>();<span class="comment">//克隆，因为原来是常量指针</span></span><br><span class="line">        <span class="type">bool</span> ret=<span class="built_in">subremove</span>(ptr,key.<span class="built_in">substr</span>(<span class="number">1</span>,key.<span class="built_in">size</span>()<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span>(!ret)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;children_.<span class="built_in">empty</span>()&amp;&amp;!ptr-&gt;is_value_node_)&#123;</span><br><span class="line">          root-&gt;children_.<span class="built_in">erase</span>(it-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//转为常量指针</span></span><br><span class="line">            it-&gt;second=std::<span class="built_in">shared_ptr</span>&lt;<span class="type">const</span> TrieNode&gt;(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">//没找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Remove</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; Trie </span>&#123;</span><br><span class="line">  <span class="comment">//throw NotImplementedException(&quot;Trie::Remove is not implemented.&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// You should walk through the trie and remove nodes if necessary. If the node doesn&#x27;t contain a value any more,</span></span><br><span class="line">  <span class="comment">// you should convert it to `TrieNode`. If a node doesn&#x27;t have children any more, you should remove it.</span></span><br><span class="line">  <span class="keyword">if</span>(key.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="comment">//如果根节点没有孩子</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;root_-&gt;children_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">          std::shared_ptr&lt;TrieNode&gt; newroot=std::<span class="built_in">make_shared</span>&lt;TrieNode&gt;(<span class="built_in">TrieNode</span>(<span class="keyword">this</span>-&gt;root_-&gt;children_));</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Trie</span>(newroot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">        std::shared_ptr newroot=<span class="keyword">this</span>-&gt;root_-&gt;<span class="built_in">Clone</span>();<span class="comment">//拷贝转为非常量</span></span><br><span class="line">        <span class="type">bool</span> flag=<span class="built_in">subremove</span>(newroot,key);</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断根节点是否需要删除</span></span><br><span class="line">        <span class="keyword">if</span>(newroot-&gt;children_.<span class="built_in">empty</span>()&amp;&amp;!newroot-&gt;is_value_node_)&#123;</span><br><span class="line">           newroot=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Trie</span>(newroot);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过本地测试：</p>
<p><img src="/2024/03/15/CMU15445/P0%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240320155327510.png"></p>
<h2 id="bugs">bugs</h2>
<h3 id="bug1">bug1</h3>
<p><code>auto it = root-&gt;children_.find(ch);</code>
这句会发生错误。</p>
<p>错误发生在 <code>std::_Rb_tree</code> 的内部，具体是在
<code>std::_Rb_tree::_M_begin()</code>
函数内部，这个函数是红黑树（<code>std::map</code>）的成员函数，用于获取树的起始位置迭代器报错信息中指出错误发生在读取内存地址的操作（READ
memory access），并且地址指向未知的地址（unknown
address），提示地址指向了零页（zero page）。发现主要是指针没初始化</p>
<p>父类智能指针转换为子类智能指针：</p>
<p><code>std::shared_ptr&lt;const bustub::TrieNodeWithValue&lt;T&gt;&gt; pointer =std::dynamic_pointer_cast&lt;const bustub::TrieNodeWithValue&lt;T&gt;&gt;(cur); // 父类智能指针转子类</code></p>
<h3 id="bug2">bug2</h3>
<p>没法通过CopyOnWriteTest1</p>
<p>定位主要是在这一句出问题：</p>
<p><img src="/2024/03/15/CMU15445/P0%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240320152245658.png"></p>
<p>初步判断原因是<code>ASSERT_EQ(*trie3.Get&lt;uint32_t&gt;("test"), 2333);</code>
在删除test的时候把est节点都删掉了导致的问题</p>
<p>定位到错误：<code>if(ptr-&gt;children_.empty()&amp;&amp;ptr-&gt;is_value_node_)</code>应该是<code>if(ptr-&gt;children_.empty()&amp;&amp;!ptr-&gt;is_value_node_)</code></p>
<h1 id="task2concurrent-key-value-store">Task2：Concurrent Key-Value
Store</h1>
<p>完成copy-on-write trie 后，这个树可以在单一线程的环境使用,
这个实验是implement a concurrent key-value store for a multithreaded
environment. 修改 <code>trie_store.h</code>和
<code>trie_store.cpp</code>完成实验</p>
<p>对于传统的 Trie class, 每次我们修改trie的时候, we need to get the new
root to access the new content.但是对于现在的 key-value store来说, the
<code>put</code> and <code>delete</code> methods 不需要返回值. This
requires you to use concurrency primitives（并发原语） to synchronize
（同步）reads and writes so that no data is lost through the
process.</p>
<p>需求： concurrent key-value store可以并发的服务多个读和单个写。
也就是说, when someone is modifying the trie, reads can still be
performed on the old root. When someone is reading, writes can still be
performed without waiting for reads.</p>
<p>如果我们要获得一个树节点的引用值,我们应该无论是否现在正在修改这个节点我们都能得到他。
get函数只返回一个指针。如果存储此值的trie节点已被删除，则指针将悬空。因此，在TrieStore中，我们返回一个ValueGuard，它存储对该值的引用和与trie结构的根对应的TrieNode，以便在存储ValueGuard时可以访问该值。</p>
<h2 id="get-1">get</h2>
<p>对于Get操作，先获取访问控制锁，防止此时其他写进程修改trie。得到当前时间节点的trie并释放访问控制锁。</p>
<p>由于实现了写时拷贝，因此只需要加锁得到了当前时刻的trie，之后就不需要管写进程了。</p>
<h1 id="vscodegdb-debug">VSCODE+gdb debug</h1>
<p>同时按住 shift + Ctrl + p 出现搜索框，在搜索框中输入 C/C++，选择
“编辑配置文件(JSON)” 下面也有对应的英文版的显示。按下图设置：</p>
<p><img src="/2024/03/15/CMU15445/P0%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240319092535961.png"></p>
<p>配置gdb调试文件：</p>
<p><img src="/2024/03/15/CMU15445/P0%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240319093030543.png"></p>
<p><img src="/2024/03/15/CMU15445/P0%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240319093122540.png"></p>
<p>配置要调试的文件后就可以开始断点调试了</p>
<p><img src="/2024/03/15/CMU15445/P0%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240319093214306.png"></p>
<p><img src="/2024/03/15/CMU15445/P0%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240319094007913.png"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>CMU15445</category>
      </categories>
      <tags>
        <tag>c++,数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>cpu逼近硬件浮点性能峰值</title>
    <url>/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/</url>
    <content><![CDATA[<h1 id="simd">SIMD</h1>
<p>SIMD Processing (<strong>Single instruction, multiple data
(SIMD)</strong>)</p>
<p>它描述了具有多个处理元素(multiple processing
elements)的计算机，可以在多个数据点(data
points)上同时(simultaneously)完成相同的操作。</p>
<p>不是所有的算法都可以容易地被向量化.</p>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240315105937082.png"></p>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240315110026285.png"></p>
<h1 id="硬件架构">硬件架构</h1>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/850px-skylake_server_block_diagram.svg.webp"></p>
<p>一个cycle有两个FMA单元，一个store单元</p>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318102837627.png"></p>
<h1 id="努力使flops接近峰值">努力使FLOPS接近峰值</h1>
<p>峰值计算公式： <img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318124041897.png"></p>
<p>实验1：</p>
<p>计算很简单，但测量时间的部分很重要是linux特有的</p>
<p>**__rdtsc()**：</p>
<ul>
<li><code>__rdtsc()</code>
是一个内联汇编函数，用于获取当前处理器的时间戳计数（RDTSC）的值。</li>
<li>RDTSC 是一条 x86 指令，用于读取 CPU 时钟计数器的当前值，它是一个 64
位的计数器，记录了从 CPU 启动开始到现在的 CPU 时钟周期数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">rdtsc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __rdtsc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>perf_event_open to get CPU clocks</p>
<p><a href="https://www.man7.org/linux/man-pages/man2/perf_event_open.2.html">perf_event_open(2)
- Linux manual page (man7.org)</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">perf_event_open</span><span class="params">(<span class="keyword">struct</span> perf_event_attr *hw_event, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">pid_t</span> pid, <span class="type">int</span> cpu, <span class="type">int</span> group_fd, <span class="type">unsigned</span> <span class="type">long</span> flags)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  ret = <span class="built_in">syscall</span>(SYS_perf_event_open, hw_event, pid, cpu,</span><br><span class="line">                group_fd, flags);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码执行L*n个fma，几乎没有其他操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __AVX512F__</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> vwidth = <span class="number">64</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __AVX__</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> vwidth = <span class="number">32</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __SSE__ </span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> vwidth = <span class="number">16</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> valign = <span class="built_in">sizeof</span>(<span class="type">float</span>);</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">float</span> floatv __attribute__((<span class="built_in">vector_size</span>(vwidth), <span class="built_in">aligned</span>(valign)));</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> L = <span class="built_in">sizeof</span>(floatv) / <span class="built_in">sizeof</span>(<span class="type">float</span>);</span><br><span class="line">...</span><br><span class="line">      <span class="comment">//time</span></span><br><span class="line">  <span class="built_in">clock_gettime</span>(CLOCK_MONOTONIC_RAW, &amp;start);</span><br><span class="line">  <span class="comment">//cpu ref clocks</span></span><br><span class="line">  start_cycle = <span class="built_in">rdtsc</span>();</span><br><span class="line">  <span class="comment">//cpu core clocks</span></span><br><span class="line">  <span class="built_in">ioctl</span>(fd, PERF_EVENT_IOC_RESET, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">ioctl</span>(fd, PERF_EVENT_IOC_ENABLE, <span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;#simd: ax+c loop begin&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    x = a * x + c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;#simd: ax+c loop end&quot;</span>)</span></span>;</span><br><span class="line">  <span class="built_in">ioctl</span>(fd, PERF_EVENT_IOC_DISABLE, <span class="number">0</span>);</span><br><span class="line">  end_cycle = <span class="built_in">rdtsc</span>();</span><br><span class="line">  <span class="built_in">clock_gettime</span>(CLOCK_MONOTONIC_RAW, &amp;end);</span><br><span class="line">  <span class="type">double</span> used_time = <span class="built_in">get_time</span>(&amp;start, &amp;end);</span><br><span class="line">  <span class="type">uint64_t</span> used_cycles = end_cycle - start_cycle;</span><br><span class="line">  <span class="type">double</span> flops = <span class="number">2.0</span> * L * n;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">read</span>(fd, &amp;cpu_clocks, <span class="built_in">sizeof</span>(cpu_clocks)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;read cpu clocks error&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p><strong><code>const int valign = sizeof(float);</code></strong>：</p>
<ul>
<li>这一行定义了一个常量 <code>valign</code>，其值等于
<code>float</code>
类型的大小。这个值通常用于向量类型的对齐，以确保向量在内存中按正确的边界对齐。</li>
</ul></li>
<li><p><strong><code>typedef float floatv __attribute__((vector_size(vwidth), aligned(valign)));</code></strong>：</p>
<ul>
<li><p>这是一个 <code>typedef</code> 语句，用于定义一个名为
<code>floatv</code> 的新类型，它代表着一个向量类型。</p></li>
<li><p><code>float</code> 表示向量中的元素类型。</p></li>
<li><p>``` <strong>attribute</strong>((vector_size(vwidth),
aligned(valign))) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      是 GNU C 扩展语法，用于指定向量的大小和对齐方式。</span><br><span class="line"></span><br><span class="line">     - `vector_size(vwidth)` 表示向量的大小为 `vwidth`，即指定了向量的宽度。</span><br><span class="line">     - `aligned(valign)` 表示向量的对齐方式为 `valign`，即指定了向量在内存中的对齐方式</span><br><span class="line"></span><br><span class="line">理论上，Cascade Lake支持AVx-512，一个cycle有两个FMA部件，理论峰值性能为：</span><br><span class="line"></span><br><span class="line">![](./并行处理笔记lec2/image-20240318132045266.png)</span><br><span class="line"></span><br><span class="line">这里的频率使用的是cycle为单位，而不是秒为单位，因为一般电脑的负载在变换，每个cycle的时间是变化的</span><br><span class="line"></span><br><span class="line">所以这里采用的是reference clocks：</span><br><span class="line"></span><br><span class="line">![](./并行处理笔记lec2/image-20240318134759456.png)</span><br><span class="line"></span><br><span class="line">编译：</span><br><span class="line"></span><br><span class="line">`g++ -D __AVX512F__ -march=native -O3 example1.cpp`</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">![](./并行处理笔记lec2/image-20240318134549327.png)</span><br><span class="line"></span><br><span class="line">性能达到了大概8 flops/core cycle，1/8 of the single core peak 64 flops/cycle</span><br><span class="line"></span><br><span class="line">## 探究为什么没有到达峰值性能</span><br><span class="line"></span><br><span class="line">**首先在程序中放入汇编指令方便定位到循环的位置**</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">asm volatile (&quot;#simd: ax+c loop begin&quot;);</span><br><span class="line">floatv a, x, c;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">x = a * x + c;</span><br><span class="line">&#125;</span><br><span class="line">asm volatile (&quot;#simd: ax+c loop end&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ol>
<p><strong>将其编译成汇编语言</strong></p>
<p><code>g++ -D __AVX512F__ -march=native -O3 -S example1.cpp</code></p>
<p>See example1.s in your editor:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 90 &quot;example1.cpp&quot; 1</span><br><span class="line">	#simd: ax+c loop begin</span><br><span class="line"># 0 &quot;&quot; 2</span><br><span class="line">#NO_APP</span><br><span class="line">	vmovaps	-432(%rbp), %zmm1</span><br><span class="line">	movl	$1000000, %eax</span><br><span class="line">	.p2align 4,,10</span><br><span class="line">	.p2align 3</span><br><span class="line">.L13:</span><br><span class="line">	vmovaps	-304(%rbp), %zmm4</span><br><span class="line">	vfmadd132ps	-368(%rbp), %zmm4, %zmm1</span><br><span class="line">	decl	%eax</span><br><span class="line">	jne	.L13</span><br><span class="line">	vmovaps	%zmm1, -304(%rbp)</span><br><span class="line">#APP</span><br><span class="line"># 94 &quot;example1.cpp&quot; 1</span><br><span class="line">	#simd: ax+c loop end</span><br><span class="line"># 0 &quot;&quot; 2</span><br></pre></td></tr></table></figure>
<p><strong>分析是否是循环造成的开销</strong></p>
<p>进行8次循环展开：</p>
<p>外部循环，用于控制 SIMD 计算的次数。每次循环处理 8 个元素（因为 n /
8）。</p>
<p><code>#pragma GCC unroll 8</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;# axpy simd begin&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">8</span>; i++) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> unroll 8</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">      x = a * x + c;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;# axpy simd end&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.L13:</span><br><span class="line">	vmovaps	-304(%rbp), %zmm4</span><br><span class="line">	vfmadd132ps	-368(%rbp), %zmm4, %zmm1</span><br><span class="line">	vfmadd132ps	-368(%rbp), %zmm4, %zmm1</span><br><span class="line">	vfmadd132ps	-368(%rbp), %zmm4, %zmm1</span><br><span class="line">	vfmadd132ps	-368(%rbp), %zmm4, %zmm1</span><br><span class="line">	vfmadd132ps	-368(%rbp), %zmm4, %zmm1</span><br><span class="line">	vfmadd132ps	-368(%rbp), %zmm4, %zmm1</span><br><span class="line">	vfmadd132ps	-368(%rbp), %zmm4, %zmm1</span><br><span class="line">	vfmadd132ps	-368(%rbp), %zmm4, %zmm1</span><br><span class="line">	decl	%eax</span><br><span class="line">	jne	.L13</span><br><span class="line">	vmovaps	%zmm1, -304(%rbp)</span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318155157099.png"></p>
<p>可以看出flops per cycle没有增加，说明不是循环的开销造成的</p>
<p>Cascade Lake内核每个周期可以执行两条vfmadd132ps指令</p>
<p>但是这并不意味着当前行vfmadd132ps的结果在下一个周期中可用于下一行的vfmadd132ps</p>
<p>每个周期两个vfmadd132ps表示吞吐量。每个指令有一个特定的延迟(&gt;1个周期)</p>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318161047875.png"></p>
<p>上面的指令之间存在相关性会造成阻塞。在我们的代码中，vfmadd使用前面的vfmadd的结果</p>
<p>软件优化策略： http://www.agner.org/optimize/</p>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318161739250.png"></p>
<h3 id="如何克服延迟">如何克服延迟</h3>
<ul>
<li><p>增加并行性(没有其他方法)</p></li>
<li><p>你不能让串行计算链运行得更快(如果你想改变算法)，您只能通过运行多个独立链来提高吞吐量</p></li>
</ul>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318162541925.png"></p>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318162745525.png"></p>
<p>可以看出case2比case1快了一倍</p>
<p>之前我们分析过性能是理想性能的1/8所以，这里使用8个独立链条就能逼近峰值浮点性能</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">uint32_t</span> nv&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">axpy_simd</span><span class="params">(floatv *X, floatv a, floatv c)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unroll nv</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint32_t</span> j = <span class="number">0</span>; j &lt; nv; j++) &#123;</span><br><span class="line">      X[j] = a * X[j] + c;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318163537064.png"></p>
<p>可以看出逼近了理想的峰值性能</p>
<p>链条数对flops/cycle的影响：</p>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318163653715.png"></p>
<h2 id="超标量处理器上的性能">超标量处理器上的性能</h2>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318164816119.png"></p>
<p><strong>依赖关系（ dependency)</strong></p>
<p>依赖关系限制了计算进行的速度，即使存在无限数量的执行资源.</p>
<p>增加独立计算的数量会增加吞吐量，直到达到执行资源的限制</p>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318164920583.png"></p>
<h2 id="分析吞吐量">分析吞吐量</h2>
<h3 id="当独立的链条数值是一个变量会发生什么">当独立的链条数值是一个变量会发生什么</h3>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318165426134.png"></p>
<p>对比两个程序的汇编代码：</p>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318185204470.png"></p>
<p>多了 vmovaps操作，也就是说：代码现在涉及加载/存储的问题</p>
<p>由于执行资源的原因，所有指令都有自己的吞吐量限制(就像FMA一样)</p>
<p>吞吐量=可以按周期执行的指令的数量，“每个周期两个vfmadds”只是其中的一个例子</p>
<h3 id="dispatch-ports"><strong>Dispatch ports</strong></h3>
<p>each instruction(u-op)通过分派端口分派到特定的执行单元</p>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318190318876.png"></p>
<p>吞吐量的限制</p>
<p>2个fma /cycle意味着有2个端口可以处理fused
fma,一条指令的吞吐量受能处理它的端口数量的限制</p>
<p>Buckets effect</p>
<p>吞吐量 may be bounded by one type instruction:例如</p>
<p>▪ Bounded by FMA, good, peak performance</p>
<p>▪ Bounded by others, e.g., store, may limit the performance</p>
<p>一个好用的分析throughput的工具：Intel® Architecture Code Analyzer</p>
<h3 id="how-to-overcome-the-throughput-limit">How to overcome the
throughput limit</h3>
<p>我们的目标是实现 two iterations/cycle (throughput limit of
FMA)（达到FMA的throughput）</p>
<p>当前的瓶颈是：the bottleneck is a store instruction (1/cycle)</p>
<p>首先要避免在每一个单独的fmadd操作时进行loading/storing data的工作</p>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318192154625.png"></p>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318192312211.png"></p>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318192344901.png"></p>
<p>第一种方案是加载一个内层变量然后执行外层循环，执行完一遍再加载下一个内层变量，这样的问题是没有充分利用独立链条，程序收到latency的限制，解决方案是strategy1
，一次多加载几个内层变量。</p>
<p>第二种解决方案是一次加载全部的内层变量然后再执行外层循环。这样的限制是访存端的throughoutput</p>
<p>解决方案是strategy2</p>
<p><strong>实现strategy1</strong></p>
<p>我们希望它通过第i循环(第2行)只加载/存储每个变量一次!。这种编码依赖于编译器的聪明程度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> <span class="type">int</span> jb&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">axpy_simd</span><span class="params">(floatv *X, floatv a, floatv c, <span class="type">long</span> </span></span></span><br><span class="line"><span class="params"><span class="function">m)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint32_t</span> j = <span class="number">0</span>; j &lt; m; j += jb) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unroll jb</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint32_t</span> jj = j; jj &lt; j + jb; jj++) &#123;</span><br><span class="line">X[jj] = a * X[jj] + c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318195303969.png"></p>
<p>我们帮助编译器进行优化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> <span class="type">int</span> jb&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">axpy_simd_register</span><span class="params">(floatv *X, floatv a, floatv c, <span class="type">long</span> m)</span></span>&#123;</span><br><span class="line">__m512 tmp[jb];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint32_t</span> j = <span class="number">0</span>; j &lt; m; j += jb) &#123;</span><br><span class="line"><span class="comment">//load into register</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unroll jb</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint32_t</span> jj = <span class="number">0</span>; jj &lt; jb; jj++) &#123;</span><br><span class="line">tmp[jj] = X[jj + j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//compute</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unroll jb</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint32_t</span> jj = <span class="number">0</span>; jj &lt; jb; jj++) &#123;</span><br><span class="line">tmp[jj] = a * tmp[jj] + c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//write back</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint32_t</span> jj = <span class="number">0</span>; jj &lt; jb; jj++) &#123;</span><br><span class="line">X[jj + j] = tmp[jj];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318200013605.png"></p>
<p><strong>Implementing strategy 2</strong></p>
<p><img src="/2024/03/15/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0lec2/image-20240318200838390.png"></p>
]]></content>
      <categories>
        <category>并行处理</category>
      </categories>
      <tags>
        <tag>并行处理</tag>
      </tags>
  </entry>
  <entry>
    <title>6.S081-Lab 2 system calls实验笔记</title>
    <url>/2024/03/12/MIT6S081/6.S081-Lab%202%20system%20calls%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="trace">trace</h1>
<p>在 usys.pl 中，有用户态到内核态的跳板函数：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment"># user/usys.pl</span></span><br><span class="line"></span><br><span class="line">entry(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mknod&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);  <span class="comment"># HERE</span></span><br></pre></td></tr></table></figure>
<p>这个脚本在运行后会生成 usys.S 汇编文件，里面定义了每个 system call
的用户态跳板函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trace:		# 定义用户态跳板函数</span><br><span class="line"> li a7, SYS_trace	# 将系统调用 id 存入 a7 寄存器</span><br><span class="line"> ecall				# ecall，调用 system call ，跳到内核态的统一系统调用处理函数 syscall()  (syscall.c)</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>
<p>项目代码中系统调用流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user/user.h:		用户态程序调用跳板函数 trace()</span><br><span class="line">user/usys.S:		跳板函数 trace() 使用 CPU 提供的 ecall 指令，调用到内核态</span><br><span class="line">kernel/syscall.c	到达内核态统一系统调用处理函数 syscall()，所有系统调用都会跳到这里来处理。</span><br><span class="line">kernel/syscall.c	syscall() 根据跳板传进来的系统调用编号，查询 syscalls[] 表，找到对应的内核函数并调用。</span><br><span class="line">kernel/sysproc.c	到达 sys_trace() 函数，执行具体内核操作</span><br></pre></td></tr></table></figure>
<p>系统调用实现函数都是不带参数的，实际上系统调用传入的参数会被放在当前的寄存器中，通过<code>kernel/syscall.c</code>文件中的<code>argint</code>,<code>argaddr</code>,<code>argstr</code>等函数能够获取到</p>
<blockquote>
<p>bug2：
测试<code>trace 2147483647 grep hello README</code>的时候不显示trace的系统调用</p>
</blockquote>
<p>主要的问题出在，调用trace的时候执行到打印的时候可以看出mask没有传进来比较滞后还是0。<img src="/2024/03/12/MIT6S081/6.S081-Lab%202%20system%20calls%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/image-20240314151347862.png"></p>
<p>继续dbug发现其实trace是执行了的也就是说应该是改了mask以后才执行到系统调用这段来：</p>
<p><img src="/2024/03/12/MIT6S081/6.S081-Lab%202%20system%20calls%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/image-20240314153734462.png"></p>
<p>然后发现：</p>
<p><code>p-&gt;trapframe-&gt;a0 = syscalls[num]();</code>这句话一定要放在<code>uint64 trace_mask= p-&gt;trace_mask;</code>的前面就可以修复</p>
<p>主要原因：每一个系统调用有一个返回值，这个返回值保存在<code>trapframe-&gt;a0</code>中，如果系统调用号未知，就保存<code>-1</code></p>
<p>最后systemcall：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123; </span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    uint64 trace_mask= p-&gt;trace_mask;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &amp; (trace_mask&gt;&gt;num)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="sysinfo">Sysinfo</h1>
<p>实现功能：添加 <code>sysinfo</code>系统调用,
用于收集系统运行时候的信息.系统调用的入参是一个结构体指针：
<code>struct sysinfo</code> (see <code>kernel/sysinfo.h</code>).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> &#123;</span></span><br><span class="line">  uint64 freemem;   <span class="comment">// amount of free memory (bytes)</span></span><br><span class="line">  uint64 nproc;     <span class="comment">// number of process</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>内核程序负责填写这个结构体： <code>freemem</code>
字段被设置成内存空闲的比特数， <code>nproc</code>字段被设置成 the number
of processes whose <code>state</code> is not <code>UNUSED</code></p>
<p>首先先在内核实现这个系统中断（流程和上一个trace实现过程一致）</p>
<p>sysinfo需要负责将struct sysinfo结构体复制回用户空间;
这一过程的实现可以参考<code>sys_fstat()</code>
(<code>kernel/sysfile.c</code>) 和<code>filestat()</code>
(<code>kernel/file.c</code>) 中的实现过程，主要通过调用
<code>copyout()</code>实现。如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  uint64 st; <span class="comment">// user pointer to struct stat</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span> || argaddr(<span class="number">1</span>, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> filestat(f, st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get metadata about file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address, pointing to a struct stat.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先模仿上面接收传入的结构体指针<code>argaddr(1, &amp;st)</code>.</p>
<p>首先获取用户传递给系统调用的参数放入<code>addr</code>中(用户地址空间地址)，然后在<strong>内核空间</strong>中申请一个<code>struct sysinfo</code>，分别调用<code>getfreemem()</code>和<code>getnproc()</code>函数填充该结构体相应字段之后，调用<code>copyout()</code>将<strong>内核空间的内存复制到用户空间的地址</strong>中</p>
<p>注意包含头文件：<code>#include "sysinfo.h"</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  info.freemem = getfreemem();  <span class="comment">// 获取系统空闲内存(在kernel/kalloc.c中实现)</span></span><br><span class="line">  info.nproc = getnproc();      <span class="comment">// 获取系统当前的进程数量(在kernel/proc.c中实现)</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>To collect the amount of free memory, add a function to
<code>kernel/kalloc.c</code></li>
</ul>
<p>我们看一下kalloc.c的代码</p>
<p>空闲内存是使用一个链表来维护的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>
<p>为了获取系统空闲内存字节数，需要遍历空闲内存链表，参考kalloc函数：我们可以看出<code>memset((char*)r, 5, PGSIZE);</code>中，一个链表指针指向的空闲内存的单位是PGSIZE:</p>
<p><img src="/2024/03/12/MIT6S081/6.S081-Lab%202%20system%20calls%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/image-20240314114147964.png"></p>
<p>所以我们想得到空闲内存的比特数要乘4096。每遍历一个节点就增加一个<code>PGSIZE</code>字节：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">getfreemem</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  uint64 freeret=<span class="number">0</span>;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(r)&#123;</span><br><span class="line">    freeret++;</span><br><span class="line">    r=r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  freeret*=PGSIZE;<span class="comment">//memset((char*)r, 5, PGSIZE); // fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> freeret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>To collect the number of processes, add a function to
<code>kernel/proc.c</code></li>
</ul>
<p>实现getnproc()可以参考 <code>kernel/proc.c</code></p>
<p>参考这个函数的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">allocproc(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，遍历进程池，通过<code>p-&gt;state == UNUSED</code>来判断进程是否空闲</p>
<p>程序实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">getnproc</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(p=proc;p&lt;&amp;proc[NPROC];p++)&#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state!=UNUSED)&#123;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/12/MIT6S081/6.S081-Lab%202%20system%20calls%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/image-20240314193506197.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>利用多线程和智能指针手写数据库连接池</title>
    <url>/2024/02/06/C++projects/%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="项目背景">项目背景</h1>
<p>为了提高MySQL数据库（基于客户端服务端模型）的访问瓶颈</p>
<p>策略一：减小磁盘的IO。</p>
<ul>
<li><p>在服务器端增加缓存服务器缓存常用的数据（例如redis）</p></li>
<li><p>可以增加连接池，来提高MySQL Server的访问效率。</p>
<p>在高并发情况下，大量的TCP三次握手、MySQL Server连接认证、MySQL
Server关闭连接回收资源和TCP四次挥手所耗费的性能时间也是很明显的，增加连接池就是为了减少这一部分的性能损耗。</p></li>
</ul>
<p>本项目就是为了在C/C++项目中，提高MySQL
Server的访问效率，实现基于C++代码的数据库连接池模块。</p>
<h1 id="什么是连接池">什么是连接池</h1>
<p>数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。</p>
<p>连接池一般包含了数据库连接所用的ip地址、port端口号、用户名和密码以及其它的性能参数，例如初始连接量，最大连接量，最大空闲时间、连接超时时间等。</p>
<p><strong>初始连接量（initSize）</strong>：表示连接池事先会和MySQL
Server创建initSize个数的connection连接，当应用发起MySQL访问时，不用再创建和MySQL
Server新的连接，直接从连接池中获取一个可用的连接就可以，使用完成后，并不去释放connection，而是把当前connection再归还到连接池当中。</p>
<p><strong>最大连接量（maxSize）</strong>：当并发访问MySQL
Server的请求增多时，初始连接量已经不够使用了，此时会根据新的请求数量去创建更多的连接给应用去使用，但是新创建的连接数量上限是maxSize，不能无限制的创建连接，因为每一个连接都会占用一个socket资源，一般连接池和服务器程序是部署在一台主机上的，如果连接池占用过多的socket资源，那么服务器就不能接收太多的客户端请求了。当这些连接使用完成后，再次归还到连接池当中来维护。</p>
<p><strong>最大空闲时间（maxIdleTime）</strong>：当访问MySQL的并发请求多了以后，连接池里面的连接数量会动态增加，上限是maxSize个，当这些连接用完再次归还到连接池当中。如果在指定的maxIdleTime里面，这些新增加的连接都没有被再次使用过，那么新增加的这些连接资源就要被回收掉，只需要保持初始连接量initSize个连接就可以了。</p>
<p><strong>连接超时时间（connectionTimeout）</strong>：当MySQL的并发请求量过大，连接池中的连接数量已经到达maxSize了，而此时没有空闲的连接可供使用，那么此时应用从连接池获取连接无法成功，它通过阻塞的方式获取连接的时间如果超过connectionTimeout时间，那么获取连接失败，无法访问数据库。该项目主要实现上述的连接池四大功能。</p>
<h1 id="mysql部分的连接实现">MYSQL部分的连接实现</h1>
<p>MySQL数据库C++代码封装</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="comment">// 数据库操作类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQL</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 初始化数据库连接</span></span><br><span class="line"><span class="built_in">MySQL</span>()</span><br><span class="line">&#123;</span><br><span class="line">_conn = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放数据库连接资源</span></span><br><span class="line">~<span class="built_in">MySQL</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_conn != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">mysql_close</span>(_conn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port, string user, string password,</span></span></span><br><span class="line"><span class="params"><span class="function">string dbname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MYSQL *p = <span class="built_in">mysql_real_connect</span>(_conn, ip.<span class="built_in">c_str</span>(), user.<span class="built_in">c_str</span>(),</span><br><span class="line">password.<span class="built_in">c_str</span>(), dbname.<span class="built_in">c_str</span>(), port, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> p != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新操作 insert、delete、update</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">update</span><span class="params">(string sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">LOG</span>(<span class="string">&quot;更新失败:&quot;</span> + sql);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询操作 select</span></span><br><span class="line"><span class="function">MYSQL_RES* <span class="title">query</span><span class="params">(string sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">LOG</span>(<span class="string">&quot;查询失败:&quot;</span> + sql);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">mysql_use_result</span>(_conn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">MYSQL *_conn; <span class="comment">// 表示和MySQL Server的一条连接</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在官方提供的基础上进行功能增加：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 初始化数据库连接</span></span><br><span class="line">	<span class="built_in">Connection</span>();</span><br><span class="line">	<span class="comment">// 释放数据库连接资源</span></span><br><span class="line">	~<span class="built_in">Connection</span>();</span><br><span class="line">	<span class="comment">// 连接数据库</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">(string ip, </span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">unsigned</span> <span class="type">short</span> port, </span></span></span><br><span class="line"><span class="params"><span class="function">		string user, </span></span></span><br><span class="line"><span class="params"><span class="function">		string password,</span></span></span><br><span class="line"><span class="params"><span class="function">		string dbname)</span></span>;</span><br><span class="line">	<span class="comment">// 更新操作 insert、delete、update</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">update</span><span class="params">(string sql)</span></span>;</span><br><span class="line">	<span class="comment">// 查询操作 select</span></span><br><span class="line">	<span class="function">MYSQL_RES* <span class="title">query</span><span class="params">(string sql)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 刷新一下连接的起始的空闲时间点</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">refreshAliveTime</span><span class="params">()</span> </span>&#123; _alivetime = <span class="built_in">clock</span>(); &#125;</span><br><span class="line">	<span class="comment">// 返回存活的时间</span></span><br><span class="line">	<span class="function"><span class="type">clock_t</span> <span class="title">getAliveeTime</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">clock</span>() - _alivetime; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	MYSQL *_conn; <span class="comment">// 表示和MySQL Server的一条连接</span></span><br><span class="line">	<span class="type">clock_t</span> _alivetime; <span class="comment">// 记录进入空闲状态后的起始存活时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="连接池实现">连接池实现</h1>
<figure>
<img src="/2024/02/06/C++projects/%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/image-20240206174324136.png" alt="原理">
<figcaption aria-hidden="true">原理</figcaption>
</figure>
<ol type="1">
<li><p>连接池只需要一个实例，所以ConnectionPool以单例模式进行设计</p></li>
<li><p>从ConnectionPool中可以获取和MySQL的连接Connection</p></li>
<li><p><code>空闲连接Connection</code>全部维护在一个线程安全的<code>Connection队列</code>中，使用线程<code>互斥锁</code>保证队列的线程安全</p></li>
<li><p>如果Connection队列为空，还需要再获取连接，此时需要动态创建连接，上限数量是maxSize.因此这里是一个生产者线程，生产连接。</p></li>
<li><p>队列中空闲连接时间超过maxIdleTime的就要被释放掉，只保留初始的initSize个连接就可以了。也就是说需要一个定时线程清理队列多余的空闲连接</p></li>
<li><p>如果Connection队列为空，而此时连接的数量已达上限maxSize，那么等待connectionTimeout时间如果还获取不到空闲的连接，那么获取连接失败，此处从Connection队列获取空闲连接，可以使用带超时时间的mutex互斥锁来实现连接超时时间</p></li>
<li><p>用户获取的连接用shared_ptr智能指针来管理，用lambda表达式定制连接释放的功能（不真正释放连接，而是把连接归还到连接池中）</p></li>
<li><p>连接的生产和连接的消费采用生产者-消费者线程模型来设计，使用了线程间的同步通信机制条件变量和互斥锁</p></li>
</ol>
<h2 id="线程安全的单例">线程安全的单例</h2>
<p>这里采用的是线程安全的懒汉式单例模式。</p>
<blockquote>
<p>什么是懒汉模式：在程序运行到需要用到该类的实例化时，instance()方法才去判断单例指针p，进而实例化单例指针p，让人它有一种懒惰，不到最后关头不实例化的感觉。</p>
</blockquote>
<p>首先，将类的构造函数进行私有化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 单例#1 构造函数私有化</span></span><br><span class="line">	<span class="built_in">ConnectionPool</span>();</span><br></pre></td></tr></table></figure>
<p>为了实现线程安全的懒汉式单例模式，可以采用锁，也可以利用静态区。这里采用的是后者。使用在静态数据区实现类的实现的方法，<strong>因为分配在静态区中所以无论获取实例的函数被调用多少次，所得的都是同一份实例</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 获取连接池对象实例</span></span><br><span class="line">	<span class="function"><span class="type">static</span> ConnectionPool* <span class="title">getConnectionPool</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="根据配置文件配置参数">根据配置文件配置参数</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从配置文件中加载配置项</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ConnectionPool::loadConfigFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">	FILE *pf = <span class="built_in">fopen</span>(<span class="string">&quot;mysql.ini&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pf == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//处理文件没打开的情况</span></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//逐行读文件</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">feof</span>(pf))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> line[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="built_in">fgets</span>(line, <span class="number">1024</span>, pf);</span><br><span class="line">		string str = line;</span><br><span class="line">		<span class="type">int</span> idx = str.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (idx == <span class="number">-1</span>) <span class="comment">// 无效的配置项</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> endidx = str.<span class="built_in">find</span>(<span class="string">&#x27;\n&#x27;</span>, idx);</span><br><span class="line">		string key = str.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">		string value = str.<span class="built_in">substr</span>(idx + <span class="number">1</span>, endidx - idx - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (key == <span class="string">&quot;ip&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			_ip = value;</span><br><span class="line">		&#125;</span><br><span class="line">		...<span class="comment">//依次匹配设置其它参数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="构造函数">构造函数</h2>
<p>构造函数只执行一次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line">ConnectionPool::<span class="built_in">ConnectionPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 加载配置项</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">loadConfigFile</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建初始数量的连接，此时是系统启动过程中的所以不用考虑线程安全</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _initSize; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Connection *p = <span class="keyword">new</span> <span class="built_in">Connection</span>();<span class="comment">//创建连接</span></span><br><span class="line">		p-&gt;<span class="built_in">connect</span>(_ip, _port, _username, _password, _dbname);</span><br><span class="line">		p-&gt;<span class="built_in">refreshAliveTime</span>(); <span class="comment">// 刷新一下开始空闲的起始时间</span></span><br><span class="line">		_connectionQue.<span class="built_in">push</span>(p); <span class="comment">//包含到队列中去</span></span><br><span class="line">		_connectionCnt++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动一个新的线程，作为连接的生产者 linux thread =&gt; pthread_create</span></span><br><span class="line">	<span class="function">thread <span class="title">produce</span><span class="params">(std::bind(&amp;ConnectionPool::produceConnectionTask, <span class="keyword">this</span>))</span></span>;</span><br><span class="line">	produce.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动一个新的定时线程，扫描超过maxIdleTime时间的空闲连接，进行对于的连接回收</span></span><br><span class="line">	<span class="function">thread <span class="title">scanner</span><span class="params">(std::bind(&amp;ConnectionPool::scannerConnectionTask, <span class="keyword">this</span>))</span></span>;</span><br><span class="line">	scanner.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分解释：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">produce</span><span class="params">(std::bind(&amp;ConnectionPool::produceConnectionTask, <span class="keyword">this</span>))</span></span>;</span><br><span class="line"><span class="comment">//需要使用bind绑定对象this不然没法访问成员变量</span></span><br><span class="line">produce.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure>
<p>这行代码创建了一个名为 <code>produce</code> 的线程对象。它使用
<code>std::bind</code> 函数将
<code>ConnectionPool::produceConnectionTask</code>
成员函数绑定到当前对象实例 (<code>this</code>) 上，然后传递给
<code>std::thread</code> 构造函数。这样，线程 <code>produce</code>
将执行 <code>ConnectionPool</code> 类<code>produceConnectionTask</code>
成员函数。</p>
<p>调用 <code>detach</code> 函数，将线程 <code>produce</code>
从主线程中分离。这意味着一旦主线程结束，不再等待 <code>produce</code>
线程的完成。线程的生命周期将独立于主线程，允许它在后台继续执行。通常，<code>detach</code>
被用于在主线程退出时，确保所有线程都能完成它们的任务。</p>
<h2 id="生产者线程连接生产者">生产者线程：连接生产者</h2>
<p>首先这个线程一直在查看并创建连接，因此应该在一个死循环里面</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionPool::produceConnectionTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置条件变量作为成员变量，用于连接生产线程和连接消费线程的通信</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">condition_variable cv; </span><br></pre></td></tr></table></figure>
<p>核心逻辑：如果队列不空，则生产者线程等待暂不生产，否则，当连接数量没有达到上限的时候生产新的连接，生产完后通知消费者</p>
<p>使用互斥锁维护队列之间的线程安全：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mutex _queueMutex; <span class="comment">// 维护连接队列的线程安全互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>std::mutex</code> 是 C++11
标准引入的互斥量类，用于实现线程同步。互斥量用于保护共享资源，确保同一时间只有一个线程可以访问它。</p>
<p>这行代码的含义是创建一个 <code>std::unique_lock</code> 对象
<code>lock</code>，该对象对 <code>_queueMutex</code>
进行独占性的锁定。在 <code>lock</code>
对象的生命周期内，<code>_queueMutex</code> 将一直被锁定，直到
<code>lock</code> 被销毁（通常是离开作用域时）或显式调用
<code>unlock</code>
方法来释放锁。这样做的目的是确保在互斥量保护的临界区内，只有一个线程能够执行，防止多个线程同时访问共享资源导致竞态条件。</p>
<p>这里生产者加锁后，消费者就拿不到这把锁了</p>
<h3 id="线程安全队列">线程安全队列</h3>
<p><code>std::queue</code> 是 C++
标准模板库（STL）中的队列容器，但它本身并不提供线程安全性。在多线程环境中，多个线程可能会同时访问和修改队列，这可能导致竞态条件（race
condition）和数据不一致性。</p>
<p>以下是一些导致 <code>std::queue</code>
不适用于多线程环境的主要原因：</p>
<ol type="1">
<li><p><strong>缺乏同步机制：</strong> <code>std::queue</code>
不包含内建的同步机制，比如互斥量或锁。在多线程环境下，当多个线程同时尝试访问或修改队列时，没有适当的同步措施可能导致数据竞争。</p></li>
<li><p><strong>不提供原子操作：</strong> <code>std::queue</code>
不提供原子操作，即使是简单的 <code>push</code> 和 <code>pop</code>
操作，也不能在多线程环境中保证原子性。多个线程可能同时执行这些操作，而没有合适的同步机制，可能导致不一致的队列状态。</p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionPool::produceConnectionTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;<span class="comment">//通过互斥锁实现线程安全队列</span></span><br><span class="line">        <span class="comment">// lock 在此离开作用域时，会自动释放互斥量</span></span><br><span class="line">		<span class="keyword">while</span> (!_connectionQue.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			cv.<span class="built_in">wait</span>(lock); <span class="comment">// 队列不空，此处生产线程进入等待状态</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 连接数量没有到达上限，继续创建新的连接</span></span><br><span class="line">		<span class="keyword">if</span> (_connectionCnt &lt; _maxSize)</span><br><span class="line">		&#123;</span><br><span class="line">			Connection *p = <span class="keyword">new</span> <span class="built_in">Connection</span>();</span><br><span class="line">			p-&gt;<span class="built_in">connect</span>(_ip, _port, _username, _password, _dbname);</span><br><span class="line">			p-&gt;<span class="built_in">refreshAliveTime</span>(); <span class="comment">// 刷新一下开始空闲的起始时间</span></span><br><span class="line">			_connectionQue.<span class="built_in">push</span>(p);</span><br><span class="line">			_connectionCnt++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通知消费者线程，可以消费连接了</span></span><br><span class="line">		cv.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="消费者线程">消费者线程</h2>
<ul>
<li><p><code>cv.wait_for(lock, std::chrono::milliseconds(_connectionTimeout))</code>
是等待条件变为真或超时的操作。它会在等待的过程中释放锁，允许其他线程在这段时间内访问共享资源。等待的时间由
<code>_connectionTimeout</code> 指定，单位是毫秒。</p>
<p>整个 <code>if</code>
语句检查条件变量的等待状态是否是超时状态。如果等待超时，表示在指定的时间内条件变为真的情况未发生。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cv_status::timeout == cv.<span class="built_in">wait_for</span>(lock, chrono::<span class="built_in">milliseconds</span>(_connectionTimeout)))</span><br></pre></td></tr></table></figure>
<p>这里如果写成下面的语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cv.<span class="built_in">wait_for</span>(lock, chrono::<span class="built_in">milliseconds</span>(_connectionTimeout)))</span><br></pre></td></tr></table></figure>
<p>又可能出现并不是超时唤醒，而是被其它的进程唤醒了的问题。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给外部提供接口，从连接池中获取一个可用的空闲连接</span></span><br><span class="line"><span class="function">shared_ptr&lt;Connection&gt; <span class="title">ConnectionPool::getConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;<span class="comment">//涉及到操作队列，需要保证线程安全，所以需要上锁</span></span><br><span class="line">	<span class="keyword">while</span> (_connectionQue.<span class="built_in">empty</span>())<span class="comment">//如果连接池空了，需要</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// sleep</span></span><br><span class="line">        <span class="comment">//如果在超时时间内仍没有获取到，获取失败</span></span><br><span class="line">		<span class="keyword">if</span> (cv_status::timeout == cv.<span class="built_in">wait_for</span>(lock, chrono::<span class="built_in">milliseconds</span>(_connectionTimeout)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (_connectionQue.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">LOG</span>(<span class="string">&quot;获取空闲连接超时了...获取连接失败!&quot;</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	shared_ptr智能指针析构时，会把connection资源直接delete掉，相当于</span></span><br><span class="line"><span class="comment">	调用connection的析构函数，connection就被close掉了。</span></span><br><span class="line"><span class="comment">	这里需要自定义shared_ptr的释放资源的方式，把connection直接归还到queue当中</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Connection&gt; <span class="title">sp</span><span class="params">(_connectionQue.front(), </span></span></span><br><span class="line"><span class="params"><span class="function">		[&amp;](Connection *pcon) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="comment">// 这里是在服务器应用线程中调用的，所以一定要考虑队列的线程安全操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">		unique_lock&lt;mutex&gt; lock(_queueMutex);</span></span></span><br><span class="line"><span class="params"><span class="function">		pcon-&gt;refreshAliveTime(); <span class="comment">// 刷新一下开始空闲的起始时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">		_connectionQue.push(pcon);</span></span></span><br><span class="line"><span class="params"><span class="function">	&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	_connectionQue.<span class="built_in">pop</span>();</span><br><span class="line">	cv.<span class="built_in">notify_all</span>();  <span class="comment">// 消费完连接以后，通知生产者线程检查一下，如果队列为空了，赶紧生产连接</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用智能指针实现给外部提供接口">利用智能指针实现给外部提供接口</h2>
<p>如果是给外界返回一个指针，还得实现一个把连接归还给连接池的过程比较复杂。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Conection* <span class="title">getConnection</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以返回一个智能指针，智能指针出作用域后会自动析构，我们可以重定义一些删除器让其在析构的时候把连接归还给连接池</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function">shared_ptr&lt;Connection&gt; <span class="title">getConnection</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Connection&gt; <span class="title">sp</span><span class="params">(_connectionQue.front(), </span></span></span><br><span class="line"><span class="params"><span class="function">	[&amp;](Connection *pcon) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="comment">// 这里是在服务器应用线程中调用的，所以一定要考虑队列的线程安全操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">	unique_lock&lt;mutex&gt; lock(_queueMutex);</span></span></span><br><span class="line"><span class="params"><span class="function">	pcon-&gt;refreshAliveTime(); <span class="comment">// 刷新一下开始空闲的起始时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_connectionQue.push(pcon);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>std::shared_ptr&lt;Connection&gt;</code>
是一个智能指针，用于管理 <code>Connection</code> 类型的对象。这里使用
<code>_connectionQue.front()</code> 获取队列头部的
<code>Connection</code> 指针作为被 <code>shared_ptr</code>
所管理的对象。</p></li>
<li><p>第二个参数是一个自定义的删除器，使用了 lambda 表达式
<code>([&amp;](Connection *pcon) &#123;...&#125;)</code>。这个删除器会在
<code>shared_ptr</code>
管理的对象引用计数变为零时被调用，用于自定义对象的销毁行为。</p>
<ul>
<li>在这个例子中，当 <code>shared_ptr</code>
的引用计数变为零时（没有任何 <code>shared_ptr</code>
持有这个对象时），lambda 表达式会被调用。</li>
<li>在 lambda 表达式内部，首先通过互斥量 <code>_queueMutex</code>
对队列进行锁定（<code>std::unique_lock&lt;std::mutex&gt;lock(_queueMutex);</code>）。这是因为涉及到队列的操作，需要考虑线程安全。</li>
<li>然后调用 <code>pcon-&gt;refreshAliveTime()</code> 刷新
<code>Connection</code> 对象的空闲时间。</li>
<li>最后，将 <code>pcon</code> 重新放入队列中
<code>_connectionQue.push(pcon)</code>。</li>
</ul></li>
</ul>
<p>这样，通过自定义删除器，你可以在 <code>Connection</code>
对象被释放时执行一些额外的操作。在这个例子中，是刷新空闲时间并将连接重新放入队列。这通常用于对象的资源管理和回收。</p>
<ul>
<li><p>lambda表达式部分解释</p>
<ul>
<li><code>[&amp;]</code>: 这是 lambda 表达式的捕获列表（capture
list），用于指定在 lambda 函数体内可访问的外部变量。<code>[&amp;]</code>
表示以引用方式捕获所有外部变量，即在 lambda 函数体内，可以访问包含这个
lambda 的函数作用域内的所有变量，并且可以修改这些变量的值。</li>
<li><code>(Connection *pcon)</code>: 这是 lambda 表达式的参数列表，表示
lambda 函数接受一个名为 <code>pcon</code>，类型为
<code>Connection*</code> 的参数。</li>
<li><code>&#123; /* ... */ &#125;</code>: 这是 lambda 表达式的函数体，包含了
lambda 函数要执行的代码块。</li>
</ul>
<p>综合起来，<code>[&amp;](Connection *pcon) &#123; /* ... */ &#125;</code> 这个
lambda 表达式表示一个接受一个 <code>Connection*</code> 类型的参数
<code>pcon</code>
的函数，它以引用方式捕获了包含它的作用域内的所有变量，并在函数体内执行一些操作。</p></li>
</ul>
<h2 id="最大空闲时间回收连接扫描线程">最大空闲时间回收连接扫描线程</h2>
<h3 id="时间的记录">时间的记录</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// 刷新一下连接的起始的空闲时间点</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">refreshAliveTime</span><span class="params">()</span> </span>&#123; _alivetime = <span class="built_in">clock</span>(); &#125; <span class="comment">//在每次的队列push的操作时，要刷新一下空闲的起始时间</span></span><br><span class="line">	<span class="comment">// 返回存活的时间</span></span><br><span class="line">     <span class="comment">//const: 这里的 const 表示这是一个常量成员函数。在常量成员函数内部，不能修改该对象的任何非 mutable 成员变量。</span></span><br><span class="line">	<span class="function"><span class="type">clock_t</span> <span class="title">getAliveeTime</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">clock</span>() - _alivetime; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	MYSQL *_conn; <span class="comment">// 表示和MySQL Server的一条连接</span></span><br><span class="line">	<span class="type">clock_t</span> _alivetime; <span class="comment">// 记录进入空闲状态后的起始存活时间</span></span><br></pre></td></tr></table></figure>
<h3 id="定时线程">定时线程</h3>
<p>在构造函数里面进行线程的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动一个新的定时线程，扫描超过maxIdleTime时间的空闲连接，进行对于的连接回收</span></span><br><span class="line"><span class="function">thread <span class="title">scanner</span><span class="params">(std::bind(&amp;ConnectionPool::scannerConnectionTask, <span class="keyword">this</span>))</span></span>;</span><br><span class="line">scanner.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure>
<p><strong>scannerConnectionTask</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扫描超过maxIdleTime时间的空闲连接，进行对于的连接回收</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionPool::scannerConnectionTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 通过sleep模拟定时效果</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(_maxIdleTime));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 扫描整个队列，释放多余的连接</span></span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (_connectionCnt &gt; _initSize)</span><br><span class="line">            <span class="comment">//当当前的连接数量大于初始化最大队列大小的时候才进行检测，有点像缓冲区的设计思想。</span></span><br><span class="line">		&#123;</span><br><span class="line">			Connection *p = _connectionQue.<span class="built_in">front</span>();</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;<span class="built_in">getAliveeTime</span>() &gt;= (_maxIdleTime * <span class="number">1000</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				_connectionQue.<span class="built_in">pop</span>();</span><br><span class="line">				_connectionCnt--;</span><br><span class="line">				<span class="keyword">delete</span> p; <span class="comment">// 调用~Connection()释放连接</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>; <span class="comment">// 队头的连接没有超过_maxIdleTime，其它连接肯定没有</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>projects</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>智能指针，c++</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 0.11内存管理</title>
    <url>/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="linux-0.11内存管理">linux 0.11内存管理</h1>
<h2 id="线性地址空间的格局">线性地址空间的格局</h2>
<p>每个线程的虚拟地址空间并不重叠，每个进程不跨越自己的空间。如何防止进程跨越64M的空间进行非法访问？</p>
<p>非法跨越进程边界有两种情况：</p>
<ul>
<li><p>一个进程非法跨越到内核</p></li>
<li><p>一个进程非法跨越到另一个进程</p></li>
</ul>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231216204104687.png" alt="示意图">
<figcaption aria-hidden="true">示意图</figcaption>
</figure>
<h2 id="非法跨越问题">非法跨越问题</h2>
<h3 id="如何防止进程跨越到内核的非法访问">如何防止进程跨越到内核的非法访问</h3>
<p>通过cpu硬件禁止从3特权级跳转到0特权级。通过设置LDT,GDT设定了特权级。进程能否自己修改LDT,GDT?不能，因为这两个都在内核数据段，是0特权级，进程无法访问。那进程能不能自己建一个LDT,GDT狸猫换太子？也不能，因为运行的时候CPU只将GDTR和LDTR寄存器指向的数据结构认定为LDT,GDT，进程自己没法伪造。而LDTR和GDTR是0特权级的进程没法把自己伪造的挂上去。</p>
<p>在寻址过程中我们会对这一内容做一个总结。详见下面的寻址章节。</p>
<h3 id="进程怎么合理的跨越特权级">进程怎么合理的跨越特权级</h3>
<p>涉及进程通信和中断门，TSS进程切换</p>
<h2 id="分页管理">分页管理</h2>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231217152531971.png" alt="页面地址映射">
<figcaption aria-hidden="true">页面地址映射</figcaption>
</figure>
<p>重要寄存器：</p>
<p>CR3:指向页目录表的地址。CR3里面存放的是物理地址</p>
<p>CR0寄存器： <img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231217153206961.png" alt="CR0"></p>
<h3 id="内核分页机制">内核分页机制</h3>
<p>建立过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.org 0x1000</span><br><span class="line">pg0:</span><br><span class="line">.org 0x2000</span><br><span class="line">pg1:</span><br><span class="line">.org 0x3000</span><br><span class="line">pg2:</span><br><span class="line">.org 0x4000</span><br><span class="line">pg3:</span><br><span class="line">.org 0x5000</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   movl $pg0+7,_pg_dir		/* set present bit/user r/w */</span><br><span class="line">movl $pg1+7,_pg_dir+4		/*  --------- &quot; &quot; --------- */</span><br><span class="line">movl $pg2+7,_pg_dir+8		/*  --------- &quot; &quot; --------- */</span><br><span class="line">movl $pg3+7,_pg_dir+12		/*  --------- &quot; &quot; --------- */</span><br><span class="line">	/*在这段汇编代码中，_pg_dir 是一个地址，_pg_dir+4 是将 _pg_dir 的地址值增加 4 个字节，</span><br><span class="line">以访问 _pg_dir 中的下一个 4 字节的位置。这种情况通常出现在处理数组或数据结构的情况下，</span><br><span class="line">需要按字节访问连续的内存位置。</span><br><span class="line">在汇编语言中，符号$通常用于表示立即数（immediate value），而不是地址偏移。$pg2+7 </span><br><span class="line">中的7是一个立即数，而不是偏移量。这个7代表了一个具体的数值，而不是表示字节或二进制值。 */</span><br></pre></td></tr></table></figure>
<p>上面的7代表111，这三位分别代表用户u，读写rw，存在p。如果是000代表内核，只读，不存在页。加7就是把后12位用于存权限问题。<code>movl $pg0+7,_pg_dir</code>
这行汇编指令的含义是将地址 <code>pg0</code> 加上 7 存储到
<code>_pg_dir</code>
地址处。因此上面这一段代码的意义就是让页目录表指向每个页表项，同时第一个地方指向页目录自己，每次递增4个字节即32位地址。也就是如下图所示,这里的_pg_dir就是head的起始地址，这里是在一边执行head.s的代码一边覆盖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	movl $pg3+4092,%edi/*一个页表的最后一项在页表中的位置是1023*4=4092（一共1024项，第1024项的开始地址） */</span><br><span class="line">	movl $0xfff007,%eax		/*  16Mb - 4096 + 7 (r/w user,p) 一个页面4k=4096，16M是整个页面管理的空间，所以这里是最后一个页面的地址*/</span><br><span class="line">	std/*方向位置位，edi递减 */</span><br><span class="line">1:	stosl			/* fill pages backwards - more efficient :-) */</span><br><span class="line">	subl $0x1000,%eax  /*每写好一项物理地址递减0x1000 ，16^3=2^12=4k */</span><br><span class="line">	jge 1b/*如果小于0说明全填好了 */</span><br></pre></td></tr></table></figure>
<p>edi指向了第一个页面，eax指向了最后一个页面</p>
<p>其中进程0用的是内核的页表。</p>
<p>地址32位4字节，一共页表4k，可以保存1k个线性地址间接指向下一级页表<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231217170102227.png" alt="页表映射关系"></p>
<h3 id="页面管理">页面管理</h3>
<p>内核通过mem_map管理1M以上的内存空间。</p>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231217185638982.png" alt="mem_map">
<figcaption aria-hidden="true">mem_map</figcaption>
</figure>
<p>目录项或页表项P位为1的时候说明已经和某页面建立了映射，如果为0说明没有建立映射机制。此时如果使用该页表项的页面会发送缺页中断。</p>
<p><strong>进程管理自己的页</strong></p>
<p>进程的页目录表是通过内核代码调用得到的，处于内核数据段。因此进程自己是没有权限修改自己的页目录表的，是由内核全权代理。</p>
<h3 id="父子进程共享页面">父子进程共享页面</h3>
<p>copy pagetable：</p>
<p>进入copy_page_tables函数后，先为新的页表申请一个空闲页面，并把进程0中第一个页表里的前160个页表项复制到这个页面中（1个页表项控制一个页面4KB内存空间，160个页表项可以控制640KB内存空间）。进程0和进程1的页表暂时度指向了相同的页面，意味着进程1也可以操作进程0的页面。之后对进程1的页目录表进行设置。最后，用重置CR3的方法刷新页面变换高速缓存。进程1的页表和页目录表设置完毕。进程1此时是一个空架子，还没有对应的程序，它的页表又是从进程0的页表复制过来的，它们管理的页面完全一致，也就是它暂时和进程0共享一套页面管理结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//from 父进程的段基地址，to子进程的段基地址</span></span><br><span class="line"><span class="comment">/*分页实现的是从线性地址到物理地址的转换，因此函数的输入一定是线性地址，</span></span><br><span class="line"><span class="comment">  为了方便遍历，把单位换算为M,此处硬件MMU要求页目录项的地址4M对齐*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_page_tables</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> from,<span class="type">unsigned</span> <span class="type">long</span> to,<span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> * from_page_table;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> * to_page_table;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> this_page;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> * from_dir, * to_dir;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr;</span><br><span class="line">	<span class="comment">//0x3fffff 是4M，是一个页表的管辖范围，22位from和to必须是4MB的整数倍，一个页表对应的4MB连续的线性地址空间必须是从0开始的4MB的整数倍数</span></span><br><span class="line">    <span class="comment">//4M一个页表的覆盖范围，如果4M没有对齐则panic，cpu的要求，cpu分页要对齐，页目录表项要4M对齐</span></span><br><span class="line">	<span class="keyword">if</span> ((from&amp;<span class="number">0x3fffff</span>) || (to&amp;<span class="number">0x3fffff</span>)) <span class="comment">//必须满足后面22位都是0才能不panic</span></span><br><span class="line">		panic(<span class="string">&quot;copy_page_tables called with wrong alignment&quot;</span>);</span><br><span class="line">	<span class="comment">//父进程页目录表项的位置，一个线性地址空间对应一个页目录表</span></span><br><span class="line">	<span class="comment">//from右移20位：以MB为单位，例如0010 0000 0000 0000 0000 000》0010就是2M</span></span><br><span class="line">    <span class="comment">//确保from_dir是4M的倍数</span></span><br><span class="line">	from_dir = (<span class="type">unsigned</span> <span class="type">long</span> *) ((from&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>); <span class="comment">/* _pg_dir = 0 */</span><span class="comment">//地址数由字节数变成M，c：1100，ffc肯定是4的倍数，因此是4M的倍数,</span></span><br><span class="line">	<span class="comment">//有ff是因为32位地址，右移20，还剩12位，ffc，十二位</span></span><br><span class="line">	<span class="comment">//确保to_dir是4M的倍数</span></span><br><span class="line">	to_dir = (<span class="type">unsigned</span> <span class="type">long</span> *) ((to&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>);</span><br><span class="line">	<span class="comment">//22 4MB，这里是不足4M强行等于一个4M</span></span><br><span class="line">	size = ((<span class="type">unsigned</span>) (size+<span class="number">0x3fffff</span>)) &gt;&gt; <span class="number">22</span>;</span><br><span class="line">	<span class="comment">//基地址的低第一位：是P位，指示页表是否存在</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    以进程0创建进程1为例：</span></span><br><span class="line"><span class="comment">    此时from：0</span></span><br><span class="line"><span class="comment">       to :0x4000000(64M)</span></span><br><span class="line"><span class="comment">       SIZE:段限长：0x9f（0xa0)160*4k=640k</span></span><br><span class="line"><span class="comment">       进行单位换算以后就变成了：from 0M TO 64 M size=1M ,如下所示的from和to两个指针进行拷贝操作</span></span><br><span class="line"><span class="comment">       ---------</span></span><br><span class="line"><span class="comment">       ^(0M from_dir)</span></span><br><span class="line"><span class="comment">       ----...----</span></span><br><span class="line"><span class="comment">              ^(64M to_dir)</span></span><br><span class="line"><span class="comment">       两层循环：</span></span><br><span class="line"><span class="comment">       for 父进程的遍历页目录项对应的每一个页表</span></span><br><span class="line"><span class="comment">           if子进程页目录项存在报错</span></span><br><span class="line"><span class="comment">           if 父进程页目录项不存在则跳过，继续便历下一项</span></span><br><span class="line"><span class="comment">                    为子进程的页表分配页面</span></span><br><span class="line"><span class="comment">         for 遍历该页目录项指向的页表对应的页面</span></span><br><span class="line"><span class="comment">             if（父进程该页表不存在，则跳过，继续遍历下一个页表）</span></span><br><span class="line"><span class="comment">             (用nr来记录要遍历的页面的数量，如果from是0M也就是进程0，则要遍历的页面长度是段限长640K.这是因为进程0比较特殊，与内核公用了一个页表，进程0的东西不能都被拷贝给子进程，否则就有问题了.比如进程0的页目录由16	M后两页的内容，后两页有子进程1的task_struct 和页表项，这俩子进程应该无权访问，否则子进程就可以修改自己的页面映射关系了显然不大对。)</span></span><br><span class="line"><span class="comment">             注意：1M以内的页面不参与用户分页管理</span></span><br><span class="line"><span class="comment">             1.设置页面的权限，因为子进程共享了父进程的页面，因此应该把子进程的权限设置位只读，否则两个进程如果存在同时写的情况就会出错。子进程如果需要修改页面，则会引出后面要讲的copy on write</span></span><br><span class="line"><span class="comment">             2.将页面填到子进程的页表（页框frame）里面，完成映射关系</span></span><br><span class="line"><span class="comment">             3.修改mem_map里面的引用计数，表面该页面被新增的进程占用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">for</span>( ; size--&gt;<span class="number">0</span> ; from_dir++,to_dir++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> &amp; *to_dir)<span class="comment">//1:p位。</span></span><br><span class="line">			panic(<span class="string">&quot;copy_page_tables: already exist&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (!(<span class="number">1</span> &amp; *from_dir)) <span class="comment">//from的页表不存在，则没必要进行下去了</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//0xfffff000 低12位清零，from_dir是页目录项的地址，高20位是页表的地址</span></span><br><span class="line">		from_page_table = (<span class="type">unsigned</span> <span class="type">long</span> *) (<span class="number">0xfffff000</span> &amp; *from_dir);</span><br><span class="line">		<span class="keyword">if</span> (!(to_page_table = (<span class="type">unsigned</span> <span class="type">long</span> *) get_free_page()))<span class="comment">//获得空页面。上次调用是在找一个空页面放         task_struct</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">/* Out of memory, see freeing */</span></span><br><span class="line">		*to_dir = ((<span class="type">unsigned</span> <span class="type">long</span>) to_page_table) | <span class="number">7</span>;<span class="comment">//这次是给子进程的基地址段分配页面</span></span><br><span class="line">		nr = (from==<span class="number">0</span>)?<span class="number">0xA0</span>:<span class="number">1024</span>; <span class="comment">//0xa0：0x9f 可以查看init task里面的ldt的断限长计算，把父进程的160个页表项640KB空间的内容复制给子进程</span></span><br><span class="line">		<span class="keyword">for</span> ( ; nr-- &gt; <span class="number">0</span> ; from_page_table++,to_page_table++) &#123;</span><br><span class="line">			this_page = *from_page_table;</span><br><span class="line">			<span class="keyword">if</span> (!(<span class="number">1</span> &amp; this_page)) </span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			this_page &amp;= ~<span class="number">2</span>;<span class="comment">//设置页表属性~2:101 用户，只读，存在</span></span><br><span class="line">			*to_page_table = this_page;</span><br><span class="line">			<span class="keyword">if</span> (this_page &gt; LOW_MEM) &#123;<span class="comment">//1MB以内的内核区域不参与用户分页管理</span></span><br><span class="line">				*from_page_table = this_page;</span><br><span class="line">				this_page -= LOW_MEM;</span><br><span class="line">				this_page &gt;&gt;= <span class="number">12</span>; <span class="comment">//</span></span><br><span class="line">				mem_map[this_page]++; <span class="comment">//增加引用计数，说明这个页被这个进程占用了</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	invalidate();<span class="comment">//重置CR3为0，刷新页变换高速缓存</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/copypagetable.png" alt="copypagetable">
<figcaption aria-hidden="true">copypagetable</figcaption>
</figure>
<h3 id="页面双指针管理">页面双指针管理</h3>
<p>分配给进程的页面除了进程通过建立页表项的映射，内核本身也在管理</p>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231217194700032.png" alt="双指针">
<figcaption aria-hidden="true">双指针</figcaption>
</figure>
<h2 id="寻址">寻址</h2>
<h3 id="寻址过程">寻址过程</h3>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231006095735771.png" alt="寻址机制">
<figcaption aria-hidden="true">寻址机制</figcaption>
</figure>
<h4 id="逻辑地址-线性地址">逻辑地址-&gt;线性地址</h4>
<p>一个==逻辑地址==由一个 16 位的段选择子和一个 32 位的偏移组成</p>
<p>例如<code>jmpi 0，8</code>，0是偏移，8是段选择子：==1000==</p>
<p><strong>段选择子</strong>格式：</p>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231006181323379.png" alt="段选择子格式">
<figcaption aria-hidden="true">段选择子格式</figcaption>
</figure>
<p>1000：</p>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231217105146944.png" alt="解释图">
<figcaption aria-hidden="true">解释图</figcaption>
</figure>
<p>转换关系：</p>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231006101019220.png" alt="转换关系">
<figcaption aria-hidden="true">转换关系</figcaption>
</figure>
<h4 id="线性地址-物理地址">线性地址-&gt;物理地址</h4>
<p>32位地址：CPU 在看到我们给出的内存地址后，首先把线性地址被拆分成</p>
<p>高 10 位：中间 10 位：后 12 位。</p>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231006092145578.png" alt="线性地址">
<figcaption aria-hidden="true">线性地址</figcaption>
</figure>
<p><span class="math inline">\(2^{10}\)</span>=1K,一个页目录表有1k个页表，一个页表包含1k个页表项，一个页表指向一个页面(4k)。</p>
<p>因此一个页表对应了4M的物理空间。这里一共建立了4个页表：16M空间，理论上可以更大。由于硬件中cpu是4k对齐的</p>
<p>因此低12位会是零，所以可以用高20位来表示4KB对齐的页表和页，因此可以用后12位设置权限。</p>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231006092929709.png" alt="线性地址">
<figcaption aria-hidden="true">线性地址</figcaption>
</figure>
<p><strong>代码示例</strong>：</p>
<p>以如下代码为例展示从线性地址转换到物理地址的过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_verify</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> page;</span><br><span class="line">    <span class="comment">// 判断指定地址所对应页目录项的页表是否存在(P)，若不存在(P=0)则返回。4M对齐</span></span><br><span class="line">	<span class="keyword">if</span> (!( (page = *((<span class="type">unsigned</span> <span class="type">long</span> *) ((address&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>)) )&amp;<span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 取页表的地址，加上指定地址的页面在页表中的页表项偏移值，得对应物理页面的页表项指针。</span></span><br><span class="line">	page &amp;= <span class="number">0xfffff000</span>;<span class="comment">//4k对齐</span></span><br><span class="line">	page += ((address&gt;&gt;<span class="number">10</span>) &amp; <span class="number">0xffc</span>);<span class="comment">//（ffc，置0了除了11~2位的所有位）高10位置零，低十位置零只留了中间十位，后两位置零了起到乘4的效果，因为每一个偏移量是以4字节（32位）为单位的，避免后面取到了index再乘4的操作</span></span><br><span class="line">	<span class="comment">// 如果该页面不可写(标志 R/W 没有置位)，则执行共享检验和复制页面操作（写时复制）。</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="number">3</span> &amp; *(<span class="type">unsigned</span> <span class="type">long</span> *) page) == <span class="number">1</span>)  <span class="comment">/* non-writeable, present */</span></span><br><span class="line">		un_wp_page((<span class="type">unsigned</span> <span class="type">long</span> *) page);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>page = *((unsigned long *) ((address&gt;&gt;20) &amp; 0xffc))</code></p>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231217201708437.png" alt="地址转换">
<figcaption aria-hidden="true">地址转换</figcaption>
</figure>
<h3 id="ia-32-特权级保护">IA-32 特权级保护</h3>
<p>linux 0.11的特权级保护是基于==段==的。</p>
<p>访问控制是针对==内存==的访问控制，是以字节为单位的。</p>
<p>首先，程序发生跳转指令的时候会有非法访问的嫌疑。短跳转不会涉及段的变化，不会非法访问。而长跳转例如
jmpi 0，8</p>
<p>怎么确保不会从低特权级跳到高特权级？</p>
<h4 id="访问数据段">访问数据段</h4>
<p>高特权级的代码段可以访问第特权级的数据段，低特权不允许访问高特权的数据</p>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231217131946111.png" alt="访问数据段的时候的特权检查">
<figcaption aria-hidden="true">访问数据段的时候的特权检查</figcaption>
</figure>
<p><img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231217133450858.png" alt="举个例子" style="zoom:80%;"></p>
<h4 id="堆栈">堆栈</h4>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231217134055231.png" alt="SS寄存器加载">
<figcaption aria-hidden="true">SS寄存器加载</figcaption>
</figure>
<h4 id="访问代码段">访问代码段</h4>
<p>程序控制从一个代码段转换到另一个代码段时，必须把目标代码段的段选择子装
入 CS
寄存器。在装载过程中，处理器会检查目标代码段的段描述符，对段界限、类型
及特权级进行检验。进程控制转移是用
JMP、CALL、RET、SYEENTER、SYSEXIT、INT n 和 IRET
指令或者异常和中断机制来实现的。</p>
<p>目标代码段描述符的一致性（C）标志（段描述符类型域），这个标志确定一个段是一个一致性代
码段（标志为 1）还是非一致性代码段（标志为 0）。</p>
<p><strong>访问非一致性代码段</strong></p>
<p>当访问非一致性代码段时，调用例程的 CPL 必须与目标代码段的 DPL
相等，否则 处理器会产生一个一般保护异常（#GP）。</p>
<p><img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231217135134825.png" alt="访问非一致性代码段" style="zoom:80%;"></p>
<p><strong>访问一致性代码段</strong></p>
<p>当访问一致性代码段时，调用例程的 CPL
可以在数值上等于或小于（较低特权级）目标代码段的 DPL。仅当 CPL 大于 DPL
的时候，处理器产生一个一般保护异常（#GP）。
（当目标代码段是一致性代码段时，不用检验目标代码段的 RPL。）</p>
<p><strong>门调用</strong></p>
<p><img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231217151900014.png" alt="门调用" style="zoom: 67%;"></p>
<h3 id="gdt的变迁">GDT的变迁</h3>
<p>==详见：第一章和第二章笔记==</p>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/gdt的变迁.png" alt="GDT的变迁">
<figcaption aria-hidden="true">GDT的变迁</figcaption>
</figure>
<h2 id="段描述符结构">段描述符结构</h2>
<p><strong>段描述符</strong>：写在gdt表里面的那个内容也是段描述符。段描述符是
GDT 或 LDT 中的一个数据结构，它为处理器提供诸如段基地址、段大
小、访问权限及状态等信息。</p>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231006182614416.png" alt="段描述符结构">
<figcaption aria-hidden="true">段描述符结构</figcaption>
</figure>
<p>G表示粒度：</p>
<ul>
<li><p>如果粒度标志位为 0，则段大小可以从 <strong>1 字节到 1M</strong>
字节，段长 增量单位为字节。</p></li>
<li><p>如果粒度标志位为 1，则段大小可以从 <strong>4K 字节到 4G</strong>
字节，段长 增量单位为 4K 字节。</p></li>
</ul>
<p><strong>D/B（默认操 作数大小/默认 栈指针大小和/
或上限）标志</strong></p>
<p>根据段描述符所指的是可执行代码段、向下扩展的数据段还是堆栈
段，这个标志有不同的功能。（对 32 位的代码和数据段，这个标志 总是被置为
1，而 16 位的代码和数据段，这个标志总是被置为 0。）</p>
<p><strong>P（段存在） 标志</strong></p>
<p>指明段当前是否在内存中（1 表示在内存中，0 表示不在）。当指向
段描述符的段选择子被装进段寄存器时，如果这个标志为 0，处理器
会产生段不存在异常（#NP）。内存管理软件可以通过这个标志，来
控制在某个特定时间有哪些段是真正的被载入物理内存的。这是除
分页之外的另一个虚拟内存控制机制。 图 3-9 演示了段存在标志置 0
时段描述符的格式。当这个标志置 0
时，操作系统或者管理软件就可以随意去使用标明为“可用”的地
方（段描述符里）来存贮自己的数据，比如有关已消失段的所在位
置的信息。</p>
<p><strong>DPL（描述符 特权级）域</strong></p>
<p>指明段的特权级。特权级从 0 到 3，0 为最高特权级。DPL 用来控制
对段的访问。DPL:访问该段的权限设置</p>
<p><strong>S（描述符类 型）标志</strong></p>
<p>确定段描述符是系统描述符（S 标记为 0）或者代码、数据段描述符 （S
标记为 1）</p>
<p><strong>类型域</strong>
指明段或者门的类型，确定段的访问权限和增长方向。如何解释这
个域，取决于该描述符是应用程序描述符（代码或数据）还是系统
描述符。代码段、数据段和系统段对类型域有不同的编码</p>
<figure>
<img src="/2023/12/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20231006185241375.png" alt="类型域">
<figcaption aria-hidden="true">类型域</figcaption>
</figure>
<h2 id="section"></h2>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>LINUX011内核学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux0.11缓冲区设计解读</title>
    <url>/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="linux0.11缓冲区设计解读">linux0.11缓冲区设计解读</h1>
<p>在之前的笔记中，我们已经零散的介绍了缓冲区的相关设计。这里我们系统的总结linux0.11关于缓冲区的相关设计</p>
<p>缓冲区：高速缓冲区位于内核代码块和主内存区之间</p>
<figure>
<img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231115095947238.png" alt="高速缓存">
<figcaption aria-hidden="true">高速缓存</figcaption>
</figure>
<h2 id="缓冲区的作用与设计原则">缓冲区的作用与设计原则</h2>
<p>首先，我们需要考虑，我们为什么需要缓冲区，在什么情况下缓冲区可以没有。</p>
<p>缓冲区：开一块内存，磁盘内容先读到缓冲区，在缓冲区读到内存</p>
<figure>
<img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231204000645279.png" alt="缓冲区示意图">
<figcaption aria-hidden="true">缓冲区示意图</figcaption>
</figure>
<blockquote>
<p>缓冲区的优势：</p>
<p>1.块设备的统一集散地，使得操作系统设计更方便，更灵活</p>
<p>2.对块设备的文件操作运行效率更高</p>
</blockquote>
<p>前提：从内存读比从磁盘读快200倍</p>
<p><img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231115093737912.png" alt="image-20231115093737912" style="zoom:55%;"></p>
<p><strong>怎么设计缓冲区才能重复使用。 </strong></p>
<blockquote>
<p>为啥使用缓冲区快：存在重复读写的时候变快，有点像catche</p>
<p>怎么设计缓冲区才能满足重复使用，使得读写变快？</p>
<p><strong>思路：缓冲区的数据一旦进了缓冲区就尽可能呆在缓冲区时间长：怎么设计</strong></p>
<p>如果counter=0且没有新的请求或者缓冲区没满，那么这个conuter的buffer
head还得在缓冲区里面放着，满足在缓冲区时间长</p>
<p>如果缓冲区满了，有新的请求，则把counter=0的挪出去，把新的加进来</p>
<p>如果缓冲区满了，没有counter=0的，有新的请求，则新的请求等待。</p>
</blockquote>
<h2 id="缓冲区数据结构">缓冲区数据结构</h2>
<p>缓冲区涉及的操作主要是buffer
head和request，也就是缓冲区部分和块设备部分</p>
<figure>
<img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231204001805864.png" alt="主要操作">
<figcaption aria-hidden="true">主要操作</figcaption>
</figure>
<h3 id="缓冲区双向环链表和hash">缓冲区双向环链表和hash</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> * b_data;	<span class="comment">// 指向数据块的指针（数据块为 1024 字节）	/* pointer to data block (1024 bytes) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> b_blocknr;	<span class="comment">// 块号//块号/* block number */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> b_dev;	<span class="comment">// 数据源的设备号（0 表示未用）。	/* device (0 = free) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_uptodate; <span class="comment">// 更新标志：表示数据是否已更新。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_dirt;	<span class="comment">// 修改标志：0-未修改，1-已修改。	/* 0-clean,1-dirty */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_count;		<span class="comment">// 使用该数据块的用户数。 /* users using this block */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_lock;	<span class="comment">// 缓冲区是否被锁定，0-未锁；1-已锁定。	/* 0 - ok, 1 -locked */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">b_wait</span>;</span><span class="comment">// 指向等待该缓冲区解锁的任务。 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev</span>;</span> <span class="comment">// 前一块（这四个指针用于缓冲区的管理）。 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next</span>;</span>  <span class="comment">// 下一块。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev_free</span>;</span> <span class="comment">// 前一空闲块。 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next_free</span>;</span> <span class="comment">// 下一空闲块。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中 ==b_blocknr== ==unsigned short
b_dev==，是缓冲区接受多进程文件和设计的基础</p>
<p><strong>如何保证缓冲块的唯一性：</strong>、</p>
<p>每个缓冲块有唯一的bufffer_head,内核通过b_dev和b_blocknr设备号块号把缓冲块和磁盘数据块绑定保证了关系的唯一性</p>
<p>buffer_head 被链接成一个空闲缓冲块双向链表结构。</p>
<figure>
<img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231115101114916.png" alt="双向环链表">
<figcaption aria-hidden="true">双向环链表</figcaption>
</figure>
<p>为了能够快速地在缓冲区中寻找请求的数据块是否已经被读入到缓冲区中，buffer.c
程序使用了具有307 个 buffer_head 指针项的==hash 表结构==。上图中
buffer_head 结构的指针 b_prev、b_next 就是用于
hash表中散列在同一项上多个缓冲块之间的双向连接。Hash
表所使用的散列函数由==设备号和逻辑块号组合而成==。程序中使用的具体函数是：==(设备号^逻辑块号)
Mod 307==。</p>
<figure>
<img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231115101151894.png" alt="hash结构">
<figcaption aria-hidden="true">hash结构</figcaption>
</figure>
<p><img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231115104420577.png" alt="image-20231115104420577" style="zoom:80%;"></p>
<p><strong>request 数据结构</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> dev;		<span class="comment">/* -1 if no request */</span> <span class="comment">//使用的设备号</span></span><br><span class="line">	<span class="type">int</span> cmd;		<span class="comment">/* READ or WRITE */</span></span><br><span class="line">	<span class="type">int</span> errors;<span class="comment">//操作时产生的错误次数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sector;<span class="comment">//起始扇区</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_sectors;<span class="comment">//读写扇区数</span></span><br><span class="line">	<span class="type">char</span> * buffer;<span class="comment">//数据缓冲区</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">waiting</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span><span class="comment">//缓冲区头指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">next</span>;</span><span class="comment">//指向下一个请求项</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>request是一个数组，被用到的request挂载dev_hd这个数组结构下面形成一条链表</p>
<figure>
<img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/缓冲绘图2.png" alt="缓冲绘图">
<figcaption aria-hidden="true">缓冲绘图</figcaption>
</figure>
<h2 id="linux0.11做的缓冲区相关初始化操作">linux0.11做的缓冲区相关初始化操作</h2>
<p>进程与缓冲区交互以块为单位，内核支持缓冲区与磁盘交互通过request交互。块是操作系统的概念，磁盘只有扇区的概念。（request相当于一个翻译官）</p>
<h3 id="buffer">buffer</h3>
<p><code>buffer_init(buffer_memory_end);</code></p>
<p><code>struct buffer_head * start_buffer = (struct buffer_head *) &amp;end;</code></p>
<p>这里的end就是内核代码末端的地址，设计者较难事先预估在内核模块链接期间设置end值，在这里使用</p>
<p>buffer.c里面的buffer_init:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">buffer_init</span><span class="params">(<span class="type">long</span> buffer_end)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">h</span> =</span> start_buffer;</span><br><span class="line">	<span class="type">void</span> * b;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"> <span class="comment">// 如果缓冲区高端等于 1Mb，则由于从 640KB-1MB 被显示内存和 BIOS 占用，因此实际可用缓冲区内存 </span></span><br><span class="line"> <span class="comment">// 高端应该是 640KB。否则内存高端一定大于 1MB。 </span></span><br><span class="line">	<span class="keyword">if</span> (buffer_end == <span class="number">1</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">		b = (<span class="type">void</span> *) (<span class="number">640</span>*<span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		b = (<span class="type">void</span> *) buffer_end;</span><br><span class="line"><span class="comment">// 这段代码用于初始化缓冲区，建立空闲缓冲区环链表，并获取系统中缓冲块的数目。 </span></span><br><span class="line"> <span class="comment">// 操作的过程是从缓冲区高端开始划分 1K 大小的缓冲块，与此同时在缓冲区低端建立描述该缓冲块 </span></span><br><span class="line"> <span class="comment">// 的结构 buffer_head，并将这些 buffer_head 组成双向链表。 </span></span><br><span class="line"> <span class="comment">// h 是指向缓冲头结构的指针，而 h+1 是指向内存地址连续的下一个缓冲头地址，也可以说是指向 h </span></span><br><span class="line"> <span class="comment">// 缓冲头的末端外。为了保证有足够长度的内存来存储一个缓冲头结构，需要 b 所指向的内存块 </span></span><br><span class="line"> <span class="comment">// 地址 &gt;= h 缓冲头的末端，也即要&gt;=h+1。 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> ( (b -= BLOCK_SIZE) &gt;= ((<span class="type">void</span> *) (h+<span class="number">1</span>)) ) &#123;</span><br><span class="line">		h-&gt;b_dev = <span class="number">0</span>; <span class="comment">// 使用该缓冲区的设备号。 </span></span><br><span class="line">		h-&gt;b_dirt = <span class="number">0</span>; <span class="comment">// 脏标志，也即缓冲区修改标志。</span></span><br><span class="line">		h-&gt;b_count = <span class="number">0</span>;<span class="comment">// 该缓冲区引用计数。</span></span><br><span class="line">		h-&gt;b_lock = <span class="number">0</span>;<span class="comment">// 缓冲区锁定标志</span></span><br><span class="line">		h-&gt;b_uptodate = <span class="number">0</span>;<span class="comment">// 缓冲区更新标志（或称数据有效标志）。</span></span><br><span class="line">		h-&gt;b_wait = <span class="literal">NULL</span>;<span class="comment">// 指向等待该缓冲区解锁的进程。 </span></span><br><span class="line">		h-&gt;b_next = <span class="literal">NULL</span>; <span class="comment">// 指向具有相同 hash 值的下一个缓冲头。</span></span><br><span class="line">		h-&gt;b_prev = <span class="literal">NULL</span>;<span class="comment">// 指向具有相同 hash 值的前一个缓冲头。 </span></span><br><span class="line">		h-&gt;b_data = (<span class="type">char</span> *) b;<span class="comment">// 指向对应缓冲区数据块（1024 字节）。 </span></span><br><span class="line">		h-&gt;b_prev_free = h<span class="number">-1</span>;<span class="comment">// 指向链表中前一项。 </span></span><br><span class="line">		h-&gt;b_next_free = h+<span class="number">1</span>;<span class="comment">// 指向链表中下一项。 </span></span><br><span class="line">		h++;<span class="comment">// h 指向下一新缓冲头位置</span></span><br><span class="line">		NR_BUFFERS++;<span class="comment">// 缓冲区块数累加。</span></span><br><span class="line">		<span class="keyword">if</span> (b == (<span class="type">void</span> *) <span class="number">0x100000</span>)<span class="comment">// 如果地址 b 递减到等于 1MB，则跳过 384KB， </span></span><br><span class="line">			b = (<span class="type">void</span> *) <span class="number">0xA0000</span>;<span class="comment">// 让 b 指向地址 0xA0000(640KB)处。</span></span><br><span class="line">	&#125;</span><br><span class="line">	h--;<span class="comment">// 让 h 指向最后一个有效缓冲头。 </span></span><br><span class="line">	free_list = start_buffer;<span class="comment">// 让空闲链表头指向头一个缓冲区头。</span></span><br><span class="line">	free_list-&gt;b_prev_free = h;<span class="comment">// 链表头的 b_prev_free 指向前一项（即最后一项）。</span></span><br><span class="line">	h-&gt;b_next_free = free_list;<span class="comment">// h 的下一项指针指向第一项，形成一个环链。</span></span><br><span class="line">	<span class="comment">// 初始化 hash 表（哈希表、散列表），置表中所有的指针为 NULL。</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;NR_HASH;i++)</span><br><span class="line">		hash_table[i]=<span class="literal">NULL</span>;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/缓冲初始化.png" alt="缓冲初始化">
<figcaption aria-hidden="true">缓冲初始化</figcaption>
</figure>
<h3 id="blk_dev">blk_dev</h3>
<p>blk.h：</p>
<p><code>\#define NR_BLK_DEV  7</code></p>
<p>系统管理外设的重要数据结构：对于各种块设备，内核使用了一张块设备表
blk_dev[]来进行管理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> &#123;</span> </span><br><span class="line"> <span class="type">void</span> (*request_fn)(<span class="type">void</span>); <span class="comment">// 请求项操作的函数指针。 </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">current_request</span>;</span> <span class="comment">// 当前请求项指针。 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> <span class="title">blk_dev</span>[<span class="title">NR_BLK_DEV</span>] =</span> &#123;</span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* no_dev */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev mem */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev fd */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev hd */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev ttyx */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev tty */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;		<span class="comment">/* dev lp */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231120112732685.png" alt="主设备号">
<figcaption aria-hidden="true">主设备号</figcaption>
</figure>
<p>blk_dev[major].request
在hd_init里面做了初始化，挂载了请求项函数：do_hd_request，
current_request指向null</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_REQUEST do_hd_request</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hd_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231204103021783.png" alt="blk_dev">
<figcaption aria-hidden="true">blk_dev</figcaption>
</figure>
<h3 id="request">request</h3>
<p><code>struct request request[NR_REQUEST];</code>//32</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blk_dev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//NR_REQUEST是请求项的数量=32</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_REQUEST ; i++) &#123;</span><br><span class="line">		request[i].dev = <span class="number">-1</span>;<span class="comment">//设为空闲，说明这个请求项还没有聚体对应那个设备，用于判断请求项当前设备是否空闲</span></span><br><span class="line">		request[i].next = <span class="literal">NULL</span>;<span class="comment">//互不挂接，说明还没形成请求队列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个是七个blk_dev的一个是32个的request(是一个数组链表)</p>
<figure>
<img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231204103333791.png" alt="request">
<figcaption aria-hidden="true">request</figcaption>
</figure>
<h2 id="获取缓冲块缓冲块与进程磁盘设备绑定">获取缓冲块，缓冲块与进程，磁盘设备绑定</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">bread</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> block)</span><span class="comment">//读指定的dev，block，第一块dev是0x300   block：0</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">    <span class="comment">//先到缓冲区里面找有没有相同的块</span></span><br><span class="line">	<span class="comment">//dev设备号block 块号</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh=getblk(dev,block))) <span class="comment">//在缓冲区找与dev，block相符合的缓冲块</span></span><br><span class="line">		panic(<span class="string">&quot;bread: getblk returned NULL\n&quot;</span>); <span class="comment">//因为现在是进程一第一次使用缓冲区不可能没有空闲块</span></span><br><span class="line">    <span class="comment">/*找到缓冲块与请求项挂载*/</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_uptodate) <span class="comment">//如果在缓冲区找到了相符合的块，如果该缓冲区中的数据是有效的（已更新的），否则可能内存还没向缓冲区完成写</span></span><br><span class="line">		<span class="keyword">return</span> bh;   <span class="comment">//返回块</span></span><br><span class="line">	<span class="comment">// 否则调用 ll_rw_block()函数，产生读设备块请求。并等待缓冲区解锁。</span></span><br><span class="line">	ll_rw_block(READ,bh); </span><br><span class="line">	wait_on_buffer(bh);<span class="comment">//之前调用了读盘的操作，数据还没用从硬盘中读完，因此等待</span></span><br><span class="line">	<span class="comment">// 如果该缓冲区已更新，则返回缓冲区头指针，退出。</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_uptodate)</span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line">	<span class="comment">// 否则表明读设备操作失败，释放该缓冲区，返回 NULL 指针，退出。 </span></span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get_hash_table">get_hash_table</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">get_hash_table</span><span class="params">(<span class="type">int</span> dev, <span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(bh=find_buffer(dev,block)))<span class="comment">//在hash的链表中找相同设备号块号的缓冲区</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		bh-&gt;b_count++;<span class="comment">//增加缓冲块的引用计数</span></span><br><span class="line">		wait_on_buffer(bh);<span class="comment">//等待缓冲块，因为之前的进程不一定用完了，如果是lock的该进程sleep</span></span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_dev == dev &amp;&amp; bh-&gt;b_blocknr == block)</span><br><span class="line">			<span class="keyword">return</span> bh;</span><br><span class="line">		bh-&gt;b_count--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231204125344146.png" alt="gethashtable">
<figcaption aria-hidden="true">gethashtable</figcaption>
</figure>
<h3 id="find_buffer">find_buffer</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> hash(dev,block) hash_table[_hashfn(dev,block)]</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buffer_head * <span class="title function_">find_buffer</span><span class="params">(<span class="type">int</span> dev, <span class="type">int</span> block)</span></span><br><span class="line">&#123;		</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (tmp = hash(dev,block) ; tmp != <span class="literal">NULL</span> ; tmp = tmp-&gt;b_next)</span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;b_dev==dev &amp;&amp; tmp-&gt;b_blocknr==block)</span><br><span class="line">			<span class="keyword">return</span> tmp;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231204124000143.png" alt="find—buffer">
<figcaption aria-hidden="true">find—buffer</figcaption>
</figure>
<h3 id="getblk">getblk</h3>
<p>缓冲块搜索函数 getblk()，以获取适合的缓冲块。该函数首先 调用
get_hash_table()函数，在 hash
表队列中搜索指定设备号和逻辑块号的缓冲块是否已经存在。如果存在就立刻返回对应缓冲头结构的指针；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">getblk</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">tmp</span>, * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">	<span class="keyword">if</span> (bh = get_hash_table(dev,block))</span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231204130401382.png"></p>
<p>如果不存在现成的，则从空闲链表头开始，对空闲链表进行扫描，寻找
一个空闲缓冲块。在寻找过程中还要对找到的空闲缓冲块作比较，根据赋予修改标志和锁定标志组合而成的权值，比较哪个空闲块最适合。若找到的空闲块既没有被修改也没有被锁定，就不用继续寻找了。</p>
<p>这里的dirt指的是进程方向的，dirt=1指的是进程修改了缓冲块，还没有写到硬盘中，而update是硬盘方向的，update=1指的是硬盘刷新过的缓冲块，数据已经读入内存。dirt和lock的区别体现在，lock是指缓冲块正在同步（正在写入硬盘），而dirt还不知道什么时候写，所以相比之下，dirt位比lock位更加的不好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BADNESS(bh) (((bh)-&gt;b_dirt<span class="string">&lt;&lt;1)+(bh)-&gt;</span>b_lock)</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">free_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">getblk</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	tmp = free_list;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">//如果被人用了就接着往下遍历</span></span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;b_count)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//BADNESS：dirt&lt;&lt;2+lock</span></span><br><span class="line">			<span class="comment">//一读一写才有竞争，生产者消费者模型，谁是自动化的，谁是主动的进程可以干预的，所以要锁住内存到缓冲区的路径</span></span><br><span class="line">			<span class="comment">//因此一加锁说明缓冲区到磁盘正在自动化操作</span></span><br><span class="line">			<span class="comment">//dirt说明缓冲区被进程写过，还没开始自动化的过程</span></span><br><span class="line">			<span class="comment">//因此dirt和lock选一个，选lock，因为lock干的时间短</span></span><br><span class="line">			<span class="comment">//dirt左移说明加了权重了</span></span><br><span class="line">			<span class="comment">//要从11 10 01 00 里面找最小的一个</span></span><br><span class="line">		<span class="keyword">if</span> (!bh || BADNESS(tmp)&lt;BADNESS(bh)) &#123;</span><br><span class="line">			bh = tmp;</span><br><span class="line">			<span class="keyword">if</span> (!BADNESS(tmp))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/* and repeat until we find something good */</span></span><br><span class="line">	&#125; <span class="keyword">while</span> ((tmp = tmp-&gt;b_next_free) != free_list);</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		sleep_on(&amp;buffer_wait);</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231204132338271.png" alt="getblk1">
<figcaption aria-hidden="true">getblk1</figcaption>
</figure>
<p>若没有找到空闲块，则让当前进程进入睡眠状态，待继续执行时再次寻找。若该空闲块被锁定，则进程也需进入睡眠，等待其它进程解锁。若在睡眠等待的过程中，该缓冲块又被其它进程占用，那么只要再
重头开始搜索缓冲块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait_on_buffer(bh);<span class="comment">//等待写完缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_count)<span class="comment">//不空闲则重复上面的操作//在buffer_init里面初始化的时候设置成0</span></span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br></pre></td></tr></table></figure>
<p>否则判断该缓冲块是否已被修改过，若是，则将该块写盘，并等待该块解锁。此
时如果该缓冲块又被别的进程占用，那么又一次全功尽弃，只好再重头开始执行
getblk()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//脏位置一，说明缓冲块被写了，当前正等待用户写</span></span><br><span class="line">	<span class="keyword">while</span> (bh-&gt;b_dirt) &#123;</span><br><span class="line">		sync_dev(bh-&gt;b_dev);</span><br><span class="line">		wait_on_buffer(bh);</span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_count)</span><br><span class="line">			<span class="keyword">goto</span> repeat;<span class="comment">//又被其它进程小贼抢占了，只能继续从头再来</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在经历了以上
折腾后，此时有可能出现另外一个意外情况，也就是在我们睡眠时，可能其它进程已经将我们所需要的
缓冲块加进了 hash 队列中，因此这里需要最后一次搜索一下 hash
队列。如果真的在 hash 队列中找到了
我们所需要的缓冲块，那么我们又得对找到的缓冲块进行以上判断处理，因此，又一次需要重头开始执
行
getblk()。最后，我们才算找到了一块没有被进程使用、没有被上锁，而且是干净（修改标志未置位）
的空闲缓冲块。于是我们就将该块的引用次数置
1，并复位其它几个标志，然后从空闲表中移出该块的
缓冲头结构。在设置了该缓冲块所属的设备号和相应的逻辑号后，在将其放入
hash 表对应表项的第一个
和空闲队列的末尾处。最终，返回该缓冲块头的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">getblk</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">//终于申请到能用的缓冲块了，发现有好兄弟进程先自己一步找到了缓冲块并且加入了hash表里面，自己有白忙活了，只能去等好兄弟用完用他的缓冲块了。</span></span><br><span class="line"><span class="keyword">if</span> (find_buffer(dev,block))</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="comment">/* OK, FINALLY we know that this buffer is the only one of it&#x27;s kind, */</span></span><br><span class="line"><span class="comment">/* and that it&#x27;s unused (b_count=0), unlocked (b_lock=0), and clean */</span></span><br><span class="line">	bh-&gt;b_count=<span class="number">1</span>;<span class="comment">//占用该缓冲块</span></span><br><span class="line">	bh-&gt;b_dirt=<span class="number">0</span>;<span class="comment">//还没有读盘dirt不置1</span></span><br><span class="line">	bh-&gt;b_uptodate=<span class="number">0</span>;</span><br><span class="line">	remove_from_queues(bh);<span class="comment">//假设都满了就会在叉子上面摘下来，放到其他的设备号块号上面</span></span><br><span class="line">	bh-&gt;b_dev=dev;<span class="comment">//更换设备号块号</span></span><br><span class="line">	bh-&gt;b_blocknr=block;</span><br><span class="line">	<span class="comment">//要把缓冲块叉在hash上面才算纳入了缓冲区的管理范围</span></span><br><span class="line">	insert_into_queues(bh);<span class="comment">//重新插到合适的位置</span></span><br><span class="line">	<span class="keyword">return</span> bh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>占用缓冲块：</p>
<figure>
<img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/getblk3.png" alt="getblk2">
<figcaption aria-hidden="true">getblk2</figcaption>
</figure>
<h3 id="remove_from_queues">remove_from_queues</h3>
<p><img src="/2023/12/27/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux0.11%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB/image-20231115104420577.png" alt="image-20231115104420577" style="zoom:100%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 从 hash 队列中移除缓冲块 */</span> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">remove_from_queues</span><span class="params">(<span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* remove from hash-queue */</span></span><br><span class="line"><span class="comment">//hash队列链表上删除结点，但是始终都在双向环链表上面</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_next)</span><br><span class="line">		bh-&gt;b_next-&gt;b_prev = bh-&gt;b_prev;</span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_prev)</span><br><span class="line">		bh-&gt;b_prev-&gt;b_next = bh-&gt;b_next;</span><br><span class="line"><span class="comment">// 如果该缓冲区是该队列的头一个块，则让 hash 表的对应项指向本队列中的下一个缓冲区。</span></span><br><span class="line">	<span class="keyword">if</span> (hash(bh-&gt;b_dev,bh-&gt;b_blocknr) == bh)</span><br><span class="line">		hash(bh-&gt;b_dev,bh-&gt;b_blocknr) = bh-&gt;b_next;</span><br><span class="line"><span class="comment">/* remove from free list */</span></span><br><span class="line"><span class="comment">/* 从空闲缓冲区的双向环链表中移除缓冲块 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh-&gt;b_prev_free) || !(bh-&gt;b_next_free))</span><br><span class="line">		panic(<span class="string">&quot;Free block list corrupted&quot;</span>);</span><br><span class="line">	bh-&gt;b_prev_free-&gt;b_next_free = bh-&gt;b_next_free;</span><br><span class="line">	bh-&gt;b_next_free-&gt;b_prev_free = bh-&gt;b_prev_free;</span><br><span class="line">	<span class="keyword">if</span> (free_list == bh)</span><br><span class="line">		free_list = bh-&gt;b_next_free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="insert_into_queues">insert_into_queues</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// 将指定缓冲区插入空闲链表尾并放入 hash 队列中。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">insert_into_queues</span><span class="params">(<span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* put at end of free list */</span></span><br><span class="line"><span class="comment">/* 放在空闲链表末尾处 */</span> </span><br><span class="line">	bh-&gt;b_next_free = free_list;</span><br><span class="line">	bh-&gt;b_prev_free = free_list-&gt;b_prev_free;</span><br><span class="line">	free_list-&gt;b_prev_free-&gt;b_next_free = bh;</span><br><span class="line">	free_list-&gt;b_prev_free = bh;</span><br><span class="line"><span class="comment">/* put the buffer in new hash-queue if it has a device */</span></span><br><span class="line"><span class="comment">/* 如果该缓冲块对应一个设备，则将其插入新 hash 队列中，头插入 */</span></span><br><span class="line">	bh-&gt;b_prev = <span class="literal">NULL</span>;</span><br><span class="line">	bh-&gt;b_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!bh-&gt;b_dev)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	bh-&gt;b_next = hash(bh-&gt;b_dev,bh-&gt;b_blocknr);</span><br><span class="line">	hash(bh-&gt;b_dev,bh-&gt;b_blocknr) = bh;</span><br><span class="line">	bh-&gt;b_next-&gt;b_prev = bh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bread">bread</h3>
<h2 id="进程与缓冲块">进程与缓冲块</h2>
<p>内核通过文件操作指针计算出文件数据所在的设备号块号，进程方面延申到缓冲块位置，执行<code>bread</code>后就不在与硬盘数据块直接打交道了</p>
<p>写文件同样延申到bread为止</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>LINUX011内核学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 0.11中断机制解读</title>
    <url>/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="linux-0.11中断机制解读">Linux 0.11中断机制解读</h1>
<p>在bios启动的时候首先使用的是bios自带的中断服务函数，int 0x13和int
0x19。</p>
<p>在setup.s里面关中断：将EFLAGS置为0。setup将head.s和内核代码搬运到0x0000开始的地址处，覆盖了原BIOS的中断函数部分，废除了BIOS的中断函数机制。故事就从这里开始。</p>
<p>与中断相关的标志位：<strong>iF 中断许可（第 9 位）</strong></p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E8%A7%A3%E8%AF%BB/image-20231008171319133.png" alt="Eflags">
<figcaption aria-hidden="true">Eflags</figcaption>
</figure>
<h2 id="中断服务函数挂接">中断服务函数挂接</h2>
<p>外部中断、软件中断和异常是通过中断描述符表（IDT）处理的。 IDT
中包含访问中断和异常处理程序的门描述符的集合。像 GDT 一样，IDT
不是一个段， IDT 的线性基地址包含在 IDT 寄存器中（IDTR）。</p>
<h3 id="异常处理类中断服务函数">异常处理类中断服务函数</h3>
<p>trap_init();函数把中断异常处理服务程序与IDT进行挂接</p>
<p>将异常处理函数插入IDT的表项是由set_trap_gate（）和set_system_gate（）函数来完成的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//这里是在维护中断描述符表的内容，idt的架子在head.s里面给了</span></span><br><span class="line">	set_trap_gate(<span class="number">0</span>,&amp;divide_error);<span class="comment">//这里的0，1，2...是中断描述符表项//除零错误</span></span><br><span class="line">	set_trap_gate(<span class="number">1</span>,&amp;debug);<span class="comment">//单步调试//两个参数：表的索引+中断服务函数</span></span><br><span class="line">	set_trap_gate(<span class="number">2</span>,&amp;nmi);<span class="comment">//不可屏蔽中断</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_trap_gate(n,addr) \</span></span><br><span class="line"><span class="meta">	_set_gate(&amp;idt[n],15,0,addr)!0对应dpl，15对应类型（查手册）:1111</span></span><br><span class="line"><span class="comment">//idt是中断描述符表的起始地址。idt[n]是中断描 述符表中中断号n对应项的偏移值。中断描述符的类型是15，特权级是0.意思是只能由内核处理，如果dpl特权级别=3则可以由3特权级（用户）来处理与陷阱门不同，系统陷阱门的特权级是3，即系统陷阱门设置的中断处理过程能够被所有进程调用（如单步调试、溢出出错和超出边界出错等）</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E8%A7%A3%E8%AF%BB/image-20231007212008081.png" alt="参数对应图">
<figcaption aria-hidden="true">参数对应图</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _set_gate(gate_addr,type,dpl,addr) \</span></span><br><span class="line"><span class="meta">__asm__ (<span class="string">&quot;movw %%dx,%%ax\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="string">&quot;movw %0,%%dx\n\t&quot;</span> \<span class="comment">//%0对应i</span></span></span><br><span class="line">	<span class="string">&quot;movl %%eax,%1\n\t&quot;</span> \<span class="comment">//%1对应第二行的o，将eax寄存器的值放到idt表项里面，即&amp;idt【0】，也就是gate_addr</span></span><br><span class="line">	<span class="string">&quot;movl %%edx,%2&quot;</span> \<span class="comment">//%2对应第三行的 放到gateaddr的后四个字节</span></span><br><span class="line">	: \</span><br><span class="line">	: <span class="string">&quot;i&quot;</span> ((<span class="type">short</span>) (<span class="number">0x8000</span>+(dpl&lt;&lt;<span class="number">13</span>)+(type&lt;&lt;<span class="number">8</span>))), \ <span class="comment">//i:立即数</span></span><br><span class="line">	<span class="string">&quot;o&quot;</span> (*((<span class="type">char</span> *) (gate_addr))), \ <span class="comment">//中断描述符前四个字节地址，o是偏移的意思</span></span><br><span class="line">	<span class="string">&quot;o&quot;</span> (*(<span class="number">4</span>+(<span class="type">char</span> *) (gate_addr))), \<span class="comment">//中断描述符后四个字节地址</span></span><br><span class="line">	<span class="string">&quot;d&quot;</span> ((<span class="type">char</span> *) (addr)),<span class="string">&quot;a&quot;</span> (<span class="number">0x00080000</span>))<span class="comment">//d对应edx，a对应eax，这说明了为啥edx是&amp;divide0地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面的偏移地址，就是段偏移再加上gdt里面的段基址就得到了真正的线性地址
这里本来edx里面有着完整的中断服务程序段偏移地址：<code>"d" ((char *) (addr))</code>，为了配合中断描述符，强行把低字部分给了eax(<code>movw %%dx,%%ax\n\t</code>)。
注意，前两条汇编这部分代码一直是在对寄存器进行操作，还没有放到内存里面，后面再添到&amp;idt[0]里面</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E8%A7%A3%E8%AF%BB/image-20231008154231967.png" alt="解释图">
<figcaption aria-hidden="true">解释图</figcaption>
</figure>
<p><strong>中断描述符</strong></p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E8%A7%A3%E8%AF%BB/image-20231008154407166.png" alt="中断描述符">
<figcaption aria-hidden="true">中断描述符</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;i&quot;</span> ((<span class="type">short</span>) (<span class="number">0x8000</span>+(dpl&lt;&lt;<span class="number">13</span>)+(type&lt;&lt;<span class="number">8</span>)))</span><br></pre></td></tr></table></figure>
<p><code>movw %%dx,%%ax\n\t</code>将edx的低字赋值给eax，也就是&amp;divide_error的低字，使得中断服务程序偏移地址符合上述中断描述符</p>
<p>系统描述符：，这里的1111即<code>_set_gate(gate_addr,type,dpl,addr)</code>里面的type，属于系统描述符，从下面这张表中可以看出这里15是32位的陷阱门。</p>
<p>例如这个输入的是14就是32位中断门</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_intr_gate(n,addr) \</span></span><br><span class="line"><span class="meta">	_set_gate(&amp;idt[n],14,0,addr)</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E8%A7%A3%E8%AF%BB/image-20231008172751154.png" alt="系统段和门描述符">
<figcaption aria-hidden="true">系统段和门描述符</figcaption>
</figure>
<h2 id="idt的变迁">IDT的变迁</h2>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E8%A7%A3%E8%AF%BB/image-20231218004726474.png" alt="LDT的变迁">
<figcaption aria-hidden="true">LDT的变迁</figcaption>
</figure>
<h2 id="系统调用">系统调用</h2>
<p>system_call路径：</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E8%A7%A3%E8%AF%BB/image-20231218090434707.png" alt="系统调用">
<figcaption aria-hidden="true">系统调用</figcaption>
</figure>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>LINUX011内核学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 0.11 文件系统总结</title>
    <url>/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="linux-0.11-文件系统总结">linux 0.11 文件系统总结</h1>
<h2 id="文件系统">文件系统</h2>
<p>详见：操作系统文件系统。</p>
<p>操作系统中的文件系统可以分为两部分：操作系统内核中或者在硬盘软盘虚拟盘中。一个物理设备可以分为多个逻辑设备，比如一个物理硬盘可以分为多个逻辑硬盘。而一个逻辑设备只有一个文件系统，一个文件系统只包含一个i结点的树结构。一个逻辑设备只能有一个根i结点。</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203234247319.png" alt="image-20231203234247319">
<figcaption aria-hidden="true">image-20231203234247319</figcaption>
</figure>
<p>未安装文件系统的磁盘称之为生磁盘，生磁盘也可以作为文件读写，linux中一切皆文件。</p>
<p>生磁盘可以被分区，分区中可以安装文件系统，常见的文件系统有fat32、ext2、ext4等。</p>
<p>MINIX 文件系统与标准 UNIX 的文件系统基本相同。它由 6
个部分组成。分区内可以安装指定文件系统，同一磁盘多个分区文件系统不要求相同。MINIX文件系统布局如下：(下述部分是在磁盘上的)</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203233251707.png" alt="MINIX文件系统布局">
<figcaption aria-hidden="true">MINIX文件系统布局</figcaption>
</figure>
<ul>
<li><p>引导块：若作为引导分区，将存放<strong>操作系统的引导程序代码</strong>，否则空置。</p></li>
<li><p>超级块：用于存放磁盘设备上<strong>文件系统结构的信息</strong>，说明各部分的大小。</p></li>
<li><p>i节点位图：标记i节点数据元素是否被使用</p></li>
<li><p>逻辑块位图：标记磁盘数据块是否被使用</p></li>
<li><p>i节点区：用于存放inode节点数据，一个文件对应一个inode节点，inode节点存储文件属性数据。</p></li>
<li><p>数据区：以固定大小盘块（1k）为单位进行动态分配和回收，用于存储数据，类似内存分页。</p>
<p>位图：一个比特对应一个逻辑块，0，1代表是否被占用</p>
<p>删除文件：清理数据块关系清掉，对应逻辑块位图清0，清理i结点和i结点对应位图。</p>
<p>如果一个物理块有多个逻辑块，上述就罗列着摆放：</p>
<p><img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211195002220.png" alt="image-20231211195002220" style="zoom:67%;"></p>
<p><strong>超级块结构：</strong></p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_ninodes;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_nzones;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_imap_blocks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_zmap_blocks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_firstdatazone;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_log_zone_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_max_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_magic;</span><br><span class="line"><span class="comment">/* These are only in memory */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_imap</span>[8];</span><span class="comment">//位图信息存到了缓冲块里面</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_zmap</span>[8];</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_isup</span>;</span><span class="comment">//文件系统的根i结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_imount</span>;</span><span class="comment">//文件系统挂载到的结点</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_time;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">s_wait</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> s_lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> s_rd_only;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> s_dirt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205203527644.png" alt="超级块结构">
<figcaption aria-hidden="true">超级块结构</figcaption>
</figure>
<p><strong>inode结构</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_uid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_mtime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_gid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_nlinks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_zone[<span class="number">9</span>];</span><br><span class="line"><span class="comment">/* these are in memory also */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">i_wait</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_atime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_ctime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_dev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_num;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_dirt;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_pipe;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_mount;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_seek;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_update;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205203724496.png" alt="inode结构">
<figcaption aria-hidden="true">inode结构</figcaption>
</figure>
<p><strong>i_zone数组</strong></p>
<p><code>unsigned short i_zone[9];</code></p>
<p>i_zone数组包含直接盘块号、一次间接盘块号和二次间接盘块号。一次盘块号可视为单级页表，一次间接盘块号可视为二级页表、二次间接盘块号可视为三级页表。</p>
<p>这种处理方式的好处在于，对于小文件，通过直接块号可快速定位数据块；对于中等类型的文件，一次间接块可以维护较多数据块的同时，具有较快的访问速度；对于大型文件，二次间接盘块号可以维护大量磁盘块，但访问速度较慢。</p>
<p>内存多级页表与i_zone直接区别：不同进程具有固定大小的虚地址空间，并且对其整个虚地址空间的内存，都有可能访问到，因此使用多级页表。文件系统内存在很多大小不一的文件，综合考虑对不同大小文件的特点，使用1-3级磁盘块表可以分别处理小、中、大文件。</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205204603044.png" alt="izone">
<figcaption aria-hidden="true">izone</figcaption>
</figure>
<h3 id="文件系统树形结构">文件系统树形结构</h3>
<p>所有文件的i结点最终会挂成一个树形结构，树根i结点就是文件系统的根i结点，</p>
<p>加载文件系统就是把一个文件系统的根i结点挂接在另一个文件系统的i结点上，按照这个设计，一个文件系统必须要挂在另一个文件系统上面，最后最根部那个文件系统就是根文件系统</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203234309406.png" alt="加载根文件系统">
<figcaption aria-hidden="true">加载根文件系统</figcaption>
</figure>
<p>根文件系统挂在super_block[8]上。超级块：有一个超级块数组super_block[8]里面每一个元素是一个超级块，只要一个文件系统加载到内核了这个文件系统的根i结点会依次加载到这个数组里面。最多加载8个文件系统</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203234655944.png" alt="总体效果图">
<figcaption aria-hidden="true">总体效果图</figcaption>
</figure>
<p>文件系统用i结点来管理，一个i结点管理一个文件，目录文件也是文件，也有i结点来管理。</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203232737245.png" alt="文件系统与i结点">
<figcaption aria-hidden="true">文件系统与i结点</figcaption>
</figure>
<h3 id="加载文件过程举例"><strong>加载文件过程举例</strong>：</h3>
<p>通过文件inode节点，可以定位文件数据块，那如何通过文件路径定位到具体文件？</p>
<p>文件系统主要包含文件和目录两种文件，目录是一种特殊的文件，其文件内容存储其目录下文件名-&gt;inode节点号的映射信息。文件查找开始于根目录，根目录号固定为0，不需要查找即可直接打开。</p>
<p>举例说明文件查找过程，给定存在路径<code>/name1/name2/name3</code>查找具体文件过程：</p>
<p>1）通过根节点inode号，打开根目录，读取其文件内容，即目录下文件名-&gt;inode节点号映射表，找到name1目录inode节点号n1</p>
<p>2）通过name1的inode号n1，打开name1目录，读取其文件内容，即目录下文件名-&gt;inode节点号映射表，找到name1目录inode节点号n2</p>
<p>3）通过name2的inode号n2，打开name2目录，读取其文件内容，即目录下文件名-&gt;inode节点号映射表，找到name3目录inode节点号n3</p>
<p>4）通过name3的inode号n3，打开name3文件</p>
<p>怎么打开文件：</p>
<p>通过文件查找找到文件inode节点号，然后打开文件，即读取inode至内存。</p>
<p>定位数据块：通过文件inode节点，访问其i_zone数组，进一步可以定位具体的数据所在磁盘块号。</p>
<p><img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205210257879.png"></p>
<h3 id="以c语言open和close返回的是什么解释文件系统">以c语言open和close返回的是什么解释文件系统</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file_table</span>[<span class="title">NR_FILE</span>];</span><span class="comment">//20</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> <span class="title">super_block</span>[<span class="title">NR_SUPER</span>];</span><span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">f_inode</span>;</span></span><br><span class="line">	<span class="type">off_t</span> f_pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>操作系统只有一个super_blocks数组，每个数组元素是一个超级块，一个超级块管理一个逻辑设备，因此最多挂载8个逻辑设备，其中只有一个根设备。</p></li>
<li><p>inode_table[32]每一个元素就是一个i结点，是在操作系统中所有打开的i结点</p></li>
<li><p>file_table
里面装了file结构体，<code>struct super_block super_block[NR_SUPER]</code></p></li>
</ul>
<p>​ f_inode指针指向inode_table里面的元素</p>
<ul>
<li>task struct里面的filp <code>struct file * filp[NR_OPEN];/</code>：
指针数组，每个元素都是file类型的指针</li>
</ul>
<p>linux
0.11一个进程最多只能打开20个文件（文件是可以重复打开的）可以同一个文件占多个file_table的表项</p>
<p>filp归进程管。进程打开一个文件，首先在filp里面找空闲项，
将这个空闲的位置指向file_table其中的一项，这一项里面的f_inode指针指向inode_table。
c语言里面打开文件返回的句柄就是这个指向的inode_table位置对应的下标索引，例如下图就是0.打开文件就是建立这个指针链接的过程，对应的close文件就是把这个关系链断掉。</p>
<p>file对应的是用户的需求，inode对应的是内核管理</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/文件系统.png" alt="文件系统">
<figcaption aria-hidden="true">文件系统</figcaption>
</figure>
<p>打开同一个文件，指向的inode_table是一个，file_table新开了一个</p>
<p>==file_table【64】是整个kernel只有一个，file_table[32]也是整个操作系统只有一个，每个元素是一个file对象==</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205214503609.png" alt="打开同一个文件">
<figcaption aria-hidden="true">打开同一个文件</figcaption>
</figure>
<p>目录跟结点也要放到inode——table，当路径找完了就把结点pop了</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205200445043.png" alt="image-20231205200445043">
<figcaption aria-hidden="true">image-20231205200445043</figcaption>
</figure>
<h3 id="i结点是如何管理文件的">i结点是如何管理文件的</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_zone[<span class="number">9</span>];</span><br><span class="line">     ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215101438019.png" alt="izone">
<figcaption aria-hidden="true">izone</figcaption>
</figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215101527658.png" alt="izone">
<figcaption aria-hidden="true">izone</figcaption>
</figure>
<p>izone数组是unsigned
short类型，两个字节。前7个是直接的指向7个块。一级间接块大小1k个字节，包含了1k/2
个unsigned short索引</p>
<p>可以指向512个块，二级索引同理。有512*512个数据块。</p>
<p>因此一个inode管理的极限是：（7+512+512*512）KB</p>
<h2 id="根文件系统">根文件系统</h2>
<h3 id="更换根设备进程1格式化虚拟盘并更换跟设备为虚拟盘">更换根设备（进程1格式化虚拟盘并更换跟设备为虚拟盘）</h3>
<p>之前第二章设置了虚拟盘并初始化，但是当时没有进行格式化还不能作为块设备使用。格式化的信息存在boot操作系统的软盘上</p>
<p>进程1调用<code>rd_load();</code>函数格式化虚拟盘调用</p>
<p>rd_load()是虚拟盘根文件加载函数。在系统初始化阶段，该函数被用于尝试从启动引导盘
上指定的磁盘块位置开始处把一个根文件系统加载到虚拟盘中。在函数中，这个起始磁盘块位置被定为256。当然你也可以根据自己的具体要求修改这个值，只要保证这个值所规定的磁盘容量能容纳内核映象
文件即可。这样一个由内核引导映象文件（Bootimage）加上根文件系统映象文件（Rootiamge）组合而
成的“二合一”磁盘，就可以象启动 DOS 系统盘那样来启动 Linux
系统。在进行正常的根文件系统加载之前，系统会首先执行
rd_load()函数，试图从磁盘的第 257 块中读取
根文件系统超级块。若成功，就把该根文件映象文件读到内存虚拟盘中，并把根文件系统设备标志</p>
<p>ROOT_DEV 设置为虚拟盘设备（0x0101），否则退出
rd_load()，系统继续从别的设备上执行根文件加载 操作。
之前根设备是软盘：bootsect.s里面指定的</p>
<p>==把虚拟盘指定为根设备，读硬盘是有中断的。软盘因为比较快就在内存里。所以读软盘不用中断读软盘要用do_rd_request==</p>
<p>==rd虚拟盘，虚拟的是软盘==，相当于把软盘的内容映射过来，然后把虚拟盘替软盘成为根设备</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rd_load</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>	<span class="title">s</span>;</span></span><br><span class="line">	<span class="type">int</span>		block = <span class="number">256</span>;	<span class="comment">/* Start at block 256 */</span></span><br><span class="line">	<span class="type">int</span>		i = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span>		nblocks;</span><br><span class="line">	<span class="type">char</span>		*cp;		<span class="comment">/* Move pointer */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!rd_length)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	printk(<span class="string">&quot;Ram disk: %d bytes, starting at 0x%x\n&quot;</span>, rd_length,</span><br><span class="line">		(<span class="type">int</span>) rd_start);</span><br><span class="line">	<span class="keyword">if</span> (MAJOR(ROOT_DEV) != <span class="number">2</span>)<span class="comment">//判断是不是软盘</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//block：引导块，block+1超级块//见上面文件系统的格式图</span></span><br><span class="line">	bh = breada(ROOT_DEV,block+<span class="number">1</span>,block,block+<span class="number">2</span>,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Disk error while looking for ramdisk!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*((<span class="keyword">struct</span> d_super_block *) &amp;s) = *((<span class="keyword">struct</span> d_super_block *) bh-&gt;b_data);</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="comment">//判断文件系统是不是minux文件系统</span></span><br><span class="line">	<span class="keyword">if</span> (s.s_magic != SUPER_MAGIC)</span><br><span class="line">		<span class="comment">/* No ram disk image present, assume normal floppy boot */</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	nblocks = s.s_nzones &lt;&lt; s.s_log_zone_size;</span><br><span class="line">	<span class="keyword">if</span> (nblocks &gt; (rd_length &gt;&gt; BLOCK_SIZE_BITS)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Ram disk image too big!  (%d blocks, %d avail)\n&quot;</span>, </span><br><span class="line">			nblocks, rd_length &gt;&gt; BLOCK_SIZE_BITS);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;Loading %d bytes into ram disk... 0000k&quot;</span>, </span><br><span class="line">		nblocks &lt;&lt; BLOCK_SIZE_BITS);</span><br><span class="line">	cp = rd_start;</span><br><span class="line">	<span class="keyword">while</span> (nblocks) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nblocks &gt; <span class="number">2</span>) </span><br><span class="line">			bh = breada(ROOT_DEV, block, block+<span class="number">1</span>, block+<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			bh = bread(ROOT_DEV, block);</span><br><span class="line">		<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">			printk(<span class="string">&quot;I/O error on block %d, aborting load\n&quot;</span>, </span><br><span class="line">				block);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		(<span class="type">void</span>) <span class="built_in">memcpy</span>(cp, bh-&gt;b_data, BLOCK_SIZE);</span><br><span class="line">		brelse(bh);</span><br><span class="line">		printk(<span class="string">&quot;\010\010\010\010\010%4dk&quot;</span>,i);</span><br><span class="line">		cp += BLOCK_SIZE;</span><br><span class="line">		block++;</span><br><span class="line">		nblocks--;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;\010\010\010\010\010done \n&quot;</span>);</span><br><span class="line">	ROOT_DEV=<span class="number">0x0101</span>;<span class="comment">//主设备号换为100:虚拟盘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加载根文件系统">加载根文件系统</h3>
<p>进程1调用mount_root在根设备虚拟盘上加载根文件系统</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_isup</span>;</span><span class="comment">//文件系统的根i结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_imount</span>;</span><span class="comment">//文件系统挂载到的结点</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205221522997.png" alt="文件系统加载结点">
<figcaption aria-hidden="true">文件系统加载结点</figcaption>
</figure>
<h3 id="首先挂载super_block数组和file_table数组">首先挂载super_block数组和file_table数组</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,<span class="built_in">free</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">mi</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">32</span> != <span class="keyword">sizeof</span> (<span class="keyword">struct</span> d_inode))</span><br><span class="line">		panic(<span class="string">&quot;bad i-node size&quot;</span>);</span><br><span class="line">	<span class="comment">//file_table初始化引用计数清0</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NR_FILE;i++)</span><br><span class="line">		file_table[i].f_count=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//判断是否为软盘</span></span><br><span class="line">	<span class="keyword">if</span> (MAJOR(ROOT_DEV) == <span class="number">2</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Insert root floppy and press ENTER&quot;</span>);</span><br><span class="line">		wait_for_keypress();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化super_block</span></span><br><span class="line">	<span class="keyword">for</span>(p = &amp;super_block[<span class="number">0</span>] ; p &lt; &amp;super_block[NR_SUPER] ; p++) &#123;</span><br><span class="line">		p-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">		p-&gt;s_lock = <span class="number">0</span>;</span><br><span class="line">		p-&gt;s_wait = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211092132558.png" alt="image-20231211092132558">
<figcaption aria-hidden="true">image-20231211092132558</figcaption>
</figure>
<h3 id="read_super加载文件系统超级块">read_super加载文件系统超级块</h3>
<p>整体流程图：</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/readsuper.png" alt="readsuper">
<figcaption aria-hidden="true">readsuper</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (!(p=read_super(ROOT_DEV)))</span><br><span class="line">		panic(<span class="string">&quot;Unable to mount root&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>read_super()用于把指定设备的文件系统的==超级块==读入到==缓冲区==中，并登记到超级块数组中，同时也
把文件系统的 i
节点位图和逻辑块位图读入内存超级块结构的相应数组中。最后并返回该超级块结构的
指针。</p>
<p>首先检查这个要读的超级块是不是已经在super_block[8]中，如果有直接使用不用在加载一次了（和缓冲区看有没有现成的一个意思）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">s</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">int</span> i,block;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	check_disk_change(dev);<span class="comment">//检查是否换过盘</span></span><br><span class="line">	<span class="keyword">if</span> (s = get_super(dev))</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="get_super">get_super</h4>
<p>查这个要读的超级块是不是已经在super_block[8]中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> super_block * <span class="title function_">get_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	s = <span class="number">0</span>+super_block;</span><br><span class="line">	<span class="keyword">while</span> (s &lt; NR_SUPER+super_block)</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;s_dev == dev) &#123;</span><br><span class="line">			wait_on_super(s);</span><br><span class="line">			<span class="keyword">if</span> (s-&gt;s_dev == dev)</span><br><span class="line">				<span class="keyword">return</span> s;</span><br><span class="line">			s = <span class="number">0</span>+super_block;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			s++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超级块上锁等待（别的进程加载了这个文件系统）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wait_on_super</span><span class="params">(<span class="keyword">struct</span> super_block * sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	cli();</span><br><span class="line">	<span class="keyword">while</span> (sb-&gt;s_lock)</span><br><span class="line">		sleep_on(&amp;(sb-&gt;s_wait));</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="在super_block里面找到空项">在super_block里面找到空项</h4>
<p>在super_block中找到一项空的并加锁。这里加载根文件系统，第一项就是空的所以是选了第一个</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> (s = <span class="number">0</span>+super_block ;; s++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s &gt;= NR_SUPER+super_block)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (!s-&gt;s_dev)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;s_dev = dev;</span><br><span class="line">	s-&gt;s_isup = <span class="literal">NULL</span>;</span><br><span class="line">	s-&gt;s_imount = <span class="literal">NULL</span>;</span><br><span class="line">	s-&gt;s_time = <span class="number">0</span>;</span><br><span class="line">	s-&gt;s_rd_only = <span class="number">0</span>;</span><br><span class="line">	s-&gt;s_dirt = <span class="number">0</span>;</span><br><span class="line">	lock_super(s);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211095203241.png" alt="image-20231211095203241">
<figcaption aria-hidden="true">image-20231211095203241</figcaption>
</figure>
<h4 id="把超级块加载到缓冲区再加载到super-block">把超级块加载到缓冲区，再加载到super
block</h4>
<p>调用bread读取超级块，这里的设备是rd虚拟盘。块号是1.因此在do
request的时候是do_rd_request.虚拟盘虽然是内存模拟的盘，但是读取的操作完全模仿了外设，但是他毕竟是内存不是外设，因此和读硬盘不同的是：不会发生类似硬盘中断的情况</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (!(bh = bread(dev,<span class="number">1</span>))) &#123;</span><br><span class="line">		s-&gt;s_dev=<span class="number">0</span>;</span><br><span class="line">		free_super(s);<span class="comment">//释放超级块</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//将缓冲区的超级块复制到刚才找到的super_block【0】中</span></span><br><span class="line">	*((<span class="keyword">struct</span> d_super_block *) s) =</span><br><span class="line">		*((<span class="keyword">struct</span> d_super_block *) bh-&gt;b_data);</span><br><span class="line">	brelse(bh);<span class="comment">//释放缓冲块</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;s_magic != SUPER_MAGIC) &#123;</span><br><span class="line">		s-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">		free_super(s);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211100257070.png" alt="image-20231211100257070">
<figcaption aria-hidden="true">image-20231211100257070</figcaption>
</figure>
<h4 id="完善super-blok中i结点位图逻辑位图">完善super
blok中i结点位图逻辑位图</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">//首先初始化imap和zmap</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;I_MAP_SLOTS;i++)</span><br><span class="line">		s-&gt;s_imap[i] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;Z_MAP_SLOTS;i++)</span><br><span class="line">		s-&gt;s_zmap[i] = <span class="literal">NULL</span>;</span><br><span class="line">	block=<span class="number">2</span>;<span class="comment">//虚拟盘的第一块是超级块，第二块开始是i结点位图和逻辑块位图所以这里是2</span></span><br><span class="line">    <span class="comment">//把虚拟盘上的逻辑位图加载到缓冲区中，并都挂载到s_imap上</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; s-&gt;s_imap_blocks ; i++)</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;s_imap[i]=bread(dev,block))</span><br><span class="line">			block++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//挂完i结点的位图挂载逻辑块位图</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; s-&gt;s_zmap_blocks ; i++)</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;s_zmap[i]=bread(dev,block))</span><br><span class="line">			block++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//如果块数量不对说明操作系统出问题了释放之前的缓冲块和超级块</span></span><br><span class="line">	<span class="keyword">if</span> (block != <span class="number">2</span>+s-&gt;s_imap_blocks+s-&gt;s_zmap_blocks) &#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;I_MAP_SLOTS;i++)</span><br><span class="line">			brelse(s-&gt;s_imap[i]);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Z_MAP_SLOTS;i++)</span><br><span class="line">			brelse(s-&gt;s_zmap[i]);</span><br><span class="line">		s-&gt;s_dev=<span class="number">0</span>;</span><br><span class="line">		free_super(s);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//牺牲第一个i结点，防止查找算法返回0</span></span><br><span class="line">	s-&gt;s_imap[<span class="number">0</span>]-&gt;b_data[<span class="number">0</span>] |= <span class="number">1</span>;</span><br><span class="line">	s-&gt;s_zmap[<span class="number">0</span>]-&gt;b_data[<span class="number">0</span>] |= <span class="number">1</span>;</span><br><span class="line">	free_super(s);<span class="comment">//解锁超级块</span></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_super</span><span class="params">(<span class="keyword">struct</span> super_block * sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	cli();</span><br><span class="line">	sb-&gt;s_lock = <span class="number">0</span>;</span><br><span class="line">	wake_up(&amp;(sb-&gt;s_wait));</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211102021214.png" alt="image-20231211102021214">
<figcaption aria-hidden="true">image-20231211102021214</figcaption>
</figure>
<h3 id="将根设备的根i结点挂载super-block上">将根设备的根i结点挂载super
block上</h3>
<p>调用iget从虚拟盘上读取i结点。有了i结点，可以通过根i结点找到文件系统中的任意指定i结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">	<span class="comment">//i number ：i结点位图的序号，iget：给定结点，给定设备，这里在找虚拟盘的根i结点</span></span><br><span class="line">	<span class="keyword">if</span> (!(mi=iget(ROOT_DEV,ROOT_INO)))</span><br><span class="line">		panic(<span class="string">&quot;Unable to read root i-node&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h4 id="igetget_empty_inode">iget:get_empty_inode</h4>
<p>首先在记载所有打开的i结点的数组中申请一个空闲的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">iget</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>, * <span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		panic(<span class="string">&quot;iget with dev==0&quot;</span>);</span><br><span class="line">	empty = get_empty_inode();<span class="comment">//从inode_table[32]中申请一个空闲的i结点</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">get_empty_inode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">last_inode</span> =</span> inode_table; <span class="comment">// last_inode 指向 i 节点表第一项</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 扫描 i 节点表。 </span></span><br><span class="line">		inode = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = NR_INODE; i ; i--) &#123;</span><br><span class="line">            <span class="comment">// 如果 last_inode 已经指向 i 节点表的最后 1 项之后，则让其重新指向 i 节点表开始处。</span></span><br><span class="line">			<span class="keyword">if</span> (++last_inode &gt;= inode_table + NR_INODE)</span><br><span class="line">				last_inode = inode_table;</span><br><span class="line">            <span class="comment">// 如果 last_inode 所指向的 i 节点的计数值为 0，则说明可能找到空闲 i 节点项。让 inode 指向 </span></span><br><span class="line">           <span class="comment">// 该 i 节点。如果该 i 节点的已修改标志和锁定标志均为 0，则我们可以使用该 i 节点，于是退出循环。 </span></span><br><span class="line">			<span class="keyword">if</span> (!last_inode-&gt;i_count) &#123;</span><br><span class="line">				inode = last_inode;</span><br><span class="line">				<span class="keyword">if</span> (!inode-&gt;i_dirt &amp;&amp; !inode-&gt;i_lock)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 如果没有找到空闲 i 节点(inode=NULL)，则将整个 i 节点表打印出来供调试使用，并死机。</span></span><br><span class="line">		<span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_INODE ; i++)</span><br><span class="line">				printk(<span class="string">&quot;%04x: %6d\t&quot;</span>,inode_table[i].i_dev,</span><br><span class="line">					inode_table[i].i_num);</span><br><span class="line">			panic(<span class="string">&quot;No free inodes in mem&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 等待该 i 节点解锁（如果又被上锁的话）。 </span></span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">        <span class="comment">// 如果该 i 节点已修改标志被置位的话，则将该 i 节点刷新，并等待该 i 节点解锁。</span></span><br><span class="line">		<span class="keyword">while</span> (inode-&gt;i_dirt) &#123;</span><br><span class="line">			write_inode(inode);</span><br><span class="line">			wait_on_inode(inode);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (inode-&gt;i_count);<span class="comment">//// 如果 i 节点又被其它占用的话，则重新寻找空闲 i 节点。</span></span><br><span class="line">    <span class="comment">// 已找到空闲 i 节点项。则将该 i 节点项内容清零，并置引用标志为 1，返回该 i 节点指针。</span></span><br><span class="line">	<span class="built_in">memset</span>(inode,<span class="number">0</span>,<span class="keyword">sizeof</span>(*inode));</span><br><span class="line">	inode-&gt;i_count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="iget">iget</h4>
<p>inode_table 初始化的时候:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> <span class="title">inode_table</span>[<span class="title">NR_INODE</span>]=</span>&#123;&#123;<span class="number">0</span>,&#125;,&#125;; <span class="comment">// 内存中 i 节点表（NR_INODE=32 项）。</span></span><br></pre></td></tr></table></figure>
<p>这是对数组进行初始化的语法。它使用了一个嵌套的大括号，将数组中的每个元素初始化为
<code>&#123;0,&#125;</code>，这将初始化结构体中的所有成员为零（或NULL，具体取决于结构体的定义）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">iget</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">     <span class="comment">// 扫描 i 节点表。寻找指定节点号的 i 节点。并递增该节点的引用次数。</span></span><br><span class="line">	inode = inode_table;</span><br><span class="line">	<span class="keyword">while</span> (inode &lt; NR_INODE+inode_table) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_dev != dev || inode-&gt;i_num != nr) &#123;</span><br><span class="line">			inode++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">        <span class="comment">// 如果当前扫描的 i 节点的设备号不等于指定的设备号或者节点号不等于指定的节点号，则继续扫描。</span></span><br><span class="line">        <span class="comment">//MOUNT ROOT调用的时候if (!(mi=iget(ROOT_DEV,ROOT_INO)))。dev=0.nr=1)</span></span><br><span class="line">        <span class="comment">//所以刚初始化完的都是0，找不到所以会跳完这个while</span></span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_dev != dev || inode-&gt;i_num != nr) &#123;</span><br><span class="line">			inode = inode_table;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		inode-&gt;i_count++;</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_mount) &#123;</span><br><span class="line">			<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span> ; i&lt;NR_SUPER ; i++)</span><br><span class="line">				<span class="keyword">if</span> (super_block[i].s_imount==inode)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (i &gt;= NR_SUPER) &#123;</span><br><span class="line">				printk(<span class="string">&quot;Mounted inode hasn&#x27;t got sb\n&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (empty)</span><br><span class="line">					iput(empty);</span><br><span class="line">				<span class="keyword">return</span> inode;</span><br><span class="line">			&#125;</span><br><span class="line">			iput(inode);</span><br><span class="line">			dev = super_block[i].s_dev;</span><br><span class="line">			nr = ROOT_INO;</span><br><span class="line">			inode = inode_table;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (empty)</span><br><span class="line">			iput(empty);</span><br><span class="line">		<span class="keyword">return</span> inode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!empty)</span><br><span class="line">		<span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//第一次初始化的话会跳到这个地方执行，而不会在上面的循环中return 因为有continue</span></span><br><span class="line">    <span class="comment">//将当前的跟设备和块号赋值给找出来的inode table里面空闲的inode</span></span><br><span class="line">	inode=empty;</span><br><span class="line">	inode-&gt;i_dev = dev;</span><br><span class="line">	inode-&gt;i_num = nr;</span><br><span class="line">    </span><br><span class="line">	read_inode(inode);<span class="comment">//从虚拟盘上读出i结点</span></span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="read_inode">read_inode</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_inode</span><span class="params">(<span class="keyword">struct</span> m_inode * inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">int</span> block;</span><br><span class="line"></span><br><span class="line">	lock_inode(inode);<span class="comment">//首先对这个选出来的结点加锁，在解锁之前这个结点都不会被其它进程占用</span></span><br><span class="line">	<span class="keyword">if</span> (!(sb=get_super(inode-&gt;i_dev)))<span class="comment">//获得该节点所在设备的超级块</span></span><br><span class="line">		panic(<span class="string">&quot;trying to read inode without dev&quot;</span>);</span><br><span class="line">  <span class="comment">// 该 i 节点所在的逻辑块号 = (启动块+超级块) + i 节点位图占用的块数 + 逻辑块位图占用的块数 + </span></span><br><span class="line"> <span class="comment">// (i 节点号-1)/每块含有的 i 节点数。</span></span><br><span class="line">	block = <span class="number">2</span> + sb-&gt;s_imap_blocks + sb-&gt;s_zmap_blocks +</span><br><span class="line">		(inode-&gt;i_num<span class="number">-1</span>)/INODES_PER_BLOCK;</span><br><span class="line">    <span class="comment">//将inode的块读到缓冲中                                                               </span></span><br><span class="line">	<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,block)))</span><br><span class="line">		panic(<span class="string">&quot;unable to read i-node block&quot;</span>);</span><br><span class="line">    <span class="comment">//将读入的数据从缓冲块赋值给inode</span></span><br><span class="line">	*(<span class="keyword">struct</span> d_inode *)inode =</span><br><span class="line">		((<span class="keyword">struct</span> d_inode *)bh-&gt;b_data)</span><br><span class="line">			[(inode-&gt;i_num<span class="number">-1</span>)%INODES_PER_BLOCK];</span><br><span class="line">	brelse(bh);<span class="comment">//释放缓冲块</span></span><br><span class="line">	unlock_inode(inode);<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211131847124.png" alt="image-20231211131847124">
<figcaption aria-hidden="true">image-20231211131847124</figcaption>
</figure>
<h3 id="将根文件系统与进程1关联设置root和pwd">将根文件系统与进程1关联，设置root和pwd</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">    <span class="keyword">if</span> (!(mi=iget(ROOT_DEV,ROOT_INO)))</span><br><span class="line">		panic(<span class="string">&quot;Unable to read root i-node&quot;</span>);</span><br><span class="line">    <span class="comment">/* 该 i 节点引用次数递增 3 次。因为下面 </span></span><br><span class="line"><span class="comment">    p-&gt;s_isup = p-&gt;s_imount = mi;</span></span><br><span class="line"><span class="comment">    p-&gt;s_isup = p-&gt;s_imount = mi;</span></span><br><span class="line"><span class="comment">	current-&gt;pwd = mi;</span></span><br><span class="line"><span class="comment">    也引用了该 i 节点。*/</span></span><br><span class="line">    mi-&gt;i_count += <span class="number">3</span> ;	<span class="comment">/* NOTE! it is logically used 4 times, not 1 */</span></span><br><span class="line">	p-&gt;s_isup = p-&gt;s_imount = mi;<span class="comment">//他是最根的i结点。自己挂自己，这句话加载了跟设备的根文件系统，非常重要</span></span><br><span class="line">	current-&gt;pwd = mi;<span class="comment">//当前进程的工作目录（当前进程是进程1）进程1的工作目录是根文件系统的根i结点，从进程1开始才有文件系统</span></span><br><span class="line">	<span class="comment">//进程0没有，绝对路径：从根文件系统往下撸和相对路径，根据pwd往下撸</span></span><br><span class="line">	current-&gt;root = mi; <span class="comment">//后面由于父子进程创建遗传机制，后面的进程也会继承这个特征</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算虚拟盘空闲块信息">计算虚拟盘空闲块信息</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     ... </span><br><span class="line">    <span class="comment">// 统计该设备上空闲块数。首先令 i 等于超级块中表明的设备逻辑块总数。 </span></span><br><span class="line">    <span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">	i=p-&gt;s_nzones;</span><br><span class="line"><span class="comment">// 然后根据逻辑块位图中相应比特位的占用情况统计出空闲块数。这里宏函数 set_bit()只是在测试 </span></span><br><span class="line"> <span class="comment">// 比特位，而非设置比特位。&quot;i&amp;8191&quot;用于取得 i 节点号在当前块中的偏移值。&quot;i&gt;&gt;13&quot;是将 i 除以 </span></span><br><span class="line"> <span class="comment">// 8192，也即除一个磁盘块包含的比特位数。 </span></span><br><span class="line">	<span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_zmap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line">			<span class="built_in">free</span>++;</span><br><span class="line">	printk(<span class="string">&quot;%d/%d free blocks\n\r&quot;</span>,<span class="built_in">free</span>,p-&gt;s_nzones);</span><br><span class="line"><span class="comment">// 统计设备上空闲 i 节点数。首先令 i 等于超级块中表明的设备上 i 节点总数+1。加 1 是将 0 节点 </span></span><br><span class="line"> <span class="comment">// 也统计进去。</span></span><br><span class="line">	<span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">	i=p-&gt;s_ninodes+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 然后根据 i 节点位图中相应比特位的占用情况计算出空闲 i 节点数</span></span><br><span class="line">	<span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_imap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line">			<span class="built_in">free</span>++;</span><br><span class="line">    <span class="comment">// 显示设备上可用的空闲 i 节点数/i 节点总数。</span></span><br><span class="line">	printk(<span class="string">&quot;%d/%d free inodes\n\r&quot;</span>,<span class="built_in">free</span>,p-&gt;s_ninodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此mount_root执行完，同时返回后sys_setip函数也执行完了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_setup</span><span class="params">(<span class="type">void</span> * BIOS)</span> <span class="comment">//首先解决硬盘的驱动器问题</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    rd_load();</span><br><span class="line">	mount_root();</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回到之前调用system_call的地方，一路返回到一开始的init函数。</p>
<h2 id="更通用的安装文件系统">更通用的安装文件系统</h2>
<p>安装文件系统分为三步：</p>
<ol type="1">
<li>把超级块读出来挂载到super block[8]上</li>
<li>将作为挂载结点的虚拟盘上的i结点挂在inode_table上</li>
<li>将硬盘上的需要被挂载的超级块挂在inode table上</li>
</ol>
<p>在shell下输入 <code>mount /dev/hd1  /mnt</code>
的命令可以安装文件系统：将设备hd1的文件系统挂载到mnt目录文件下。此时shell会创建一个新的进程调用mount函数最终映射到sys_mount系统调用函数执行加载文件系统的过程</p>
<h3 id="sys_mount">sys_mount</h3>
<p>挂载流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数 dev_name 是设备文件名，dir_name 是安装到的目录名，rw_flag 被安装文件的读写标志。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_mount</span><span class="params">(<span class="type">char</span> * dev_name, <span class="type">char</span> * dir_name, <span class="type">int</span> rw_flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dev_i</span>, * <span class="title">dir_i</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="type">int</span> dev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(dev_i=namei(dev_name)))<span class="comment">//获取设备i结点，通过设备名获取</span></span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">    <span class="comment">// 对于块特殊设备文件，设备号在 i 节点的 i_zone[0]中。</span></span><br><span class="line">	dev = dev_i-&gt;i_zone[<span class="number">0</span>];<span class="comment">//通过i结点获取设备号</span></span><br><span class="line">    <span class="comment">//根据mode判断结点类型，如果不是块设备类型的结点则释放</span></span><br><span class="line">	<span class="keyword">if</span> (!S_ISBLK(dev_i-&gt;i_mode)) &#123;</span><br><span class="line">		iput(dev_i);<span class="comment">//释放</span></span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	iput(dev_i);<span class="comment">//因为dev i结点的挂载的目的就是获得设备号，已经得到了，没有留着的用了就释放掉这个i结点</span></span><br><span class="line">	<span class="keyword">if</span> (!(dir_i=namei(dir_name)))<span class="comment">//找要挂接的目录的i结点</span></span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="comment">//判断目录i结点是不是根结点</span></span><br><span class="line">	<span class="comment">//inum是inode在位图里面的下标，第一个i结点：根i结点</span></span><br><span class="line">	<span class="comment">//// 如果该 i 节点的引用计数不为 1（仅在这里引用），或者该 i 节点的节点号是根文件系统的节点 </span></span><br><span class="line">    <span class="comment">// 号 1，则释放该 i 节点，返回出错码。不能挂载在根结点上面</span></span><br><span class="line">	<span class="keyword">if</span> (dir_i-&gt;i_count != <span class="number">1</span> || dir_i-&gt;i_num == ROOT_INO) &#123;</span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果该节点不是一个目录文件节点，则也释放该 i 节点，返回出错码。 </span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (!S_ISDIR(dir_i-&gt;i_mode)) &#123;</span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 读取将安装文件系统的超级块，如果失败则也释放该 i 节点，返回出错码。根据设备号就可以加载超级块</span></span><br><span class="line">	<span class="keyword">if</span> (!(sb=read_super(dev))) &#123;</span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果将要被安装的文件系统已经安装在其它地方，则释放该 i 节点，返回出错码</span></span><br><span class="line">    <span class="comment">//s_imount 是挂载的inode指针</span></span><br><span class="line">	<span class="keyword">if</span> (sb-&gt;s_imount) &#123;</span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果将要安装到的 i 节点已经安装了文件系统(安装标志已经置位)，则释放该 i 节点，返回出错码。</span></span><br><span class="line">	<span class="keyword">if</span> (dir_i-&gt;i_mount) &#123;</span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	sb-&gt;s_imount=dir_i;</span><br><span class="line">    <span class="comment">//dir inode 已经安装了文件系统。i_dirt置1 说明i结点已经被修改</span></span><br><span class="line">	dir_i-&gt;i_mount=<span class="number">1</span>;</span><br><span class="line">	dir_i-&gt;i_dirt=<span class="number">1</span>;		<span class="comment">/* NOTE! we don&#x27;t iput(dir_i) */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;			<span class="comment">/* we do that in umount */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/文件系统加载示意图.png" alt="文件系统加载结点">
<figcaption aria-hidden="true">文件系统加载结点</figcaption>
</figure>
<pre><code>//看imode区分inode类型，判断是不是目录文件。设备文件i结点找到设备号，第一个就是根i结点
//read super ：先找有没有现成的
//simap 8个缓冲块，每个缓冲块1k，一字节8bit：64kbit，有64ki结点
//64M文件
//超级块里面有两个8个的指针数组。每个指向一个块，</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="comment">/* These are only in memory */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_imap</span>[8];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_zmap</span>[8];</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>超级块在内存的信息里面用于存放i结点位图用的buffer head
*类型的数组。一个buffer head 1k
8个8k字节。一字节8位，所以对应了64K个inode。一个inode对应一个文件一个文件系统最多可以有64k个文件。同理一共64k个逻辑块，注意逻辑块也是块大小是1k，所以一共逻辑系统最多有64M大小的文件。</p>
<h2 id="打开文件">打开文件</h2>
<p>打开文件的本质就是建立*filep【20】，file_table【64】
和inode_table【32】之间的联系</p>
<p>taskstruct 里面有：<code>struct file * filp[NR_OPEN];</code>
每个进程都有一个filep，而file_table和inode_table是内核持有的，只有一个。</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211225204563.png" alt="image-20231211225204563">
<figcaption aria-hidden="true">image-20231211225204563</figcaption>
</figure>
<p>打开文件建立连接的过程：使用open函数打开文件，最终映射到系统调用sys_open</p>
<h3 id="sys_open">sys_open</h3>
<p>总导图：</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/open文件流程.png" alt="open文件流程">
<figcaption aria-hidden="true">open文件流程</figcaption>
</figure>
<h3 id="将进程的filp和file_table挂接">将进程的*filp和file_table挂接</h3>
<p>分别找filp和file_table里面的空闲项，并建立他俩的连接关系：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">int</span> flag,<span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">f</span>;</span></span><br><span class="line">	<span class="type">int</span> i,fd;</span><br><span class="line"></span><br><span class="line">	mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line">	<span class="comment">//打开文件的进程是当前进程，在filep里面找一个空闲项</span></span><br><span class="line">	<span class="keyword">for</span>(fd=<span class="number">0</span> ; fd&lt;NR_OPEN ; fd++) <span class="comment">// #define NR_OPEN 20</span></span><br><span class="line">		<span class="keyword">if</span> (!current-&gt;filp[fd])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span> (fd&gt;=NR_OPEN)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	current-&gt;close_on_exec &amp;= ~(<span class="number">1</span>&lt;&lt;fd);</span><br><span class="line">	f=<span class="number">0</span>+file_table;</span><br><span class="line">	<span class="comment">//找完找file table，引用计数为0的空闲项</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_FILE ; i++,f++)<span class="comment">//#define NR_FILE 64</span></span><br><span class="line">		<span class="keyword">if</span> (!f-&gt;f_count) <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span> (i&gt;=NR_FILE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	(current-&gt;filp[fd]=f)-&gt;f_count++;<span class="comment">//当前进程的空闲的filep的哪一项指向空闲的file table里面的项，引用计数++</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取文件的i结点opennamei">获取文件的i结点：opennamei</h3>
<p>例如要打开的文件路径是：<code>/mnt/user/user1/user2/hellow.txt</code>如何找到hellow.txt文件的i结点？</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/default.jpg" alt="寻找过程">
<figcaption aria-hidden="true">寻找过程</figcaption>
</figure>
<p>主要有目录文件结点和最终的文件结点。通过目录文件结点可以找到目录文件，里面的目录项指向了下一级的结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">int</span> flag,<span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">//读i结点，filename：sysopen的参数const char*类型，返回给inode</span></span><br><span class="line">	<span class="comment">//如果open_namei成功返回0，失败返回1</span></span><br><span class="line">	<span class="keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">		f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">        ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了open_namei实现上述的寻找过程：</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211233150934.png" alt="流程图">
<figcaption aria-hidden="true">流程图</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_namei</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname, <span class="type">int</span> flag, <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> m_inode ** res_inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * basename;</span><br><span class="line">	<span class="type">int</span> inr,dev,namelen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>, *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span><span class="comment">//目录项的数据结构，目录文件里面的目录项可多可少</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((flag &amp; O_TRUNC) &amp;&amp; !(flag &amp; O_ACCMODE))</span><br><span class="line">		flag |= O_WRONLY;</span><br><span class="line">	mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line">	mode |= I_REGULAR;</span><br><span class="line">	<span class="comment">//返回枝梢i结点</span></span><br><span class="line">	<span class="keyword">if</span> (!(dir = dir_namei(pathname,&amp;namelen,&amp;basename)))</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先找到枝梢结点，也就是例子里面的user2目录文件inode结点</p>
<h4 id="dir_namei">dir_namei</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> m_inode * <span class="title function_">dir_namei</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> * namelen, <span class="type">const</span> <span class="type">char</span> ** name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * basename;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(dir = get_dir(pathname)))<span class="comment">//分析路径，获取i节点的执行函数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	basename = pathname;</span><br><span class="line">	<span class="comment">//一个一个解析paathname，一次过一个字符串常量字符</span></span><br><span class="line">	<span class="keyword">while</span> (c=get_fs_byte(pathname++))</span><br><span class="line">		<span class="keyword">if</span> (c==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">			basename=pathname;</span><br><span class="line">	*namelen = pathname-basename<span class="number">-1</span>;</span><br><span class="line">	*name = basename;</span><br><span class="line">	<span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="get_dir">get_dir</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> m_inode * <span class="title function_">get_dir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * thisname;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">int</span> namelen,inr,idev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!current-&gt;root || !current-&gt;root-&gt;i_count)</span><br><span class="line">		panic(<span class="string">&quot;No root inode&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!current-&gt;pwd || !current-&gt;pwd-&gt;i_count)</span><br><span class="line">		panic(<span class="string">&quot;No cwd inode&quot;</span>);</span><br><span class="line">	<span class="comment">//如果第一个是/：绝对路径，如果第一个不是/也不是空：相对路径</span></span><br><span class="line">	<span class="keyword">if</span> ((c=get_fs_byte(pathname))==<span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">		inode = current-&gt;root;</span><br><span class="line">		pathname++;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c)</span><br><span class="line">		inode = current-&gt;pwd;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;	<span class="comment">/* empty name is bad */</span></span><br><span class="line">	inode-&gt;i_count++;<span class="comment">//该i节点的引用计数+1</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;<span class="comment">//寻找枝梢 结点</span></span><br><span class="line">		thisname = pathname;<span class="comment">//后面pathname++遍历，thisname没变</span></span><br><span class="line">		<span class="keyword">if</span> (!S_ISDIR(inode-&gt;i_mode) || !permission(inode,MAY_EXEC)) &#123;</span><br><span class="line">			iput(inode);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//不为空“\0&quot;且没遇到/</span></span><br><span class="line">		<span class="keyword">for</span>(namelen=<span class="number">0</span>;(c=get_fs_byte(pathname++))&amp;&amp;(c!=<span class="string">&#x27;/&#x27;</span>);namelen++)</span><br><span class="line">			<span class="comment">/* nothing */</span> ;</span><br><span class="line">		<span class="keyword">if</span> (!c)</span><br><span class="line">			<span class="keyword">return</span> inode;<span class="comment">//返回前一个inode，正常的情况下是在这里结束的，返回枝末梢i结点</span></span><br><span class="line">        <span class="comment">//c不为空，说明还没到末梢，是目录项结点，在目录项文件中寻找包含目录项的块</span></span><br><span class="line">        <span class="comment">//pathname动，this name不动</span></span><br><span class="line">		<span class="keyword">if</span> (!(bh = find_entry(&amp;inode,thisname,namelen,&amp;de))) &#123;<span class="comment">//找到含有目录项的块</span></span><br><span class="line">			iput(inode);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		inr = de-&gt;inode;<span class="comment">//从目录项中提取i结点号 inumber</span></span><br><span class="line">		idev = inode-&gt;i_dev;<span class="comment">//从i结点中提取设备号</span></span><br><span class="line">		brelse(bh);</span><br><span class="line">		iput(inode);</span><br><span class="line">		<span class="keyword">if</span> (!(inode = iget(idev,inr)))<span class="comment">//获取下一级的inode</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="find_entry">find_entry</h5>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/findentry.png" alt="findentry">
<figcaption aria-hidden="true">findentry</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> inode;<span class="comment">//下一级的inode结点在硬盘上，没有指针。用的是位图的index。i节点位图的偏移，inode number</span></span><br><span class="line">	<span class="type">char</span> name[NAME_LEN];<span class="comment">//这一段的目录文件名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buffer_head * <span class="title function_">find_entry</span><span class="params">(<span class="keyword">struct</span> m_inode ** dir,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">char</span> * name, <span class="type">int</span> namelen, <span class="keyword">struct</span> dir_entry ** res_dir)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> entries;</span><br><span class="line">	<span class="type">int</span> block,i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NO_TRUNCATE</span></span><br><span class="line">	<span class="keyword">if</span> (namelen &gt; NAME_LEN)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">if</span> (namelen &gt; NAME_LEN)</span><br><span class="line">		namelen = NAME_LEN;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	entries = (*dir)-&gt;i_size / (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> dir_entry));<span class="comment">//目录项文件大小/每个目录项的大小-&gt;获得目录项的数目</span></span><br><span class="line">	*res_dir = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!namelen)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* check for &#x27;..&#x27;, as we might have to do some &quot;magic&quot; for it */</span></span><br><span class="line">	<span class="keyword">if</span> (namelen==<span class="number">2</span> &amp;&amp; get_fs_byte(name)==<span class="string">&#x27;.&#x27;</span> &amp;&amp; get_fs_byte(name+<span class="number">1</span>)==<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">/* &#x27;..&#x27; in a pseudo-root results in a faked &#x27;.&#x27; (just change namelen) */</span></span><br><span class="line">		<span class="keyword">if</span> ((*dir) == current-&gt;root)</span><br><span class="line">			namelen=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((*dir)-&gt;i_num == ROOT_INO) &#123;</span><br><span class="line"><span class="comment">/* &#x27;..&#x27; over a mount-point results in &#x27;dir&#x27; being exchanged for the mounted</span></span><br><span class="line"><span class="comment">   directory-inode. NOTE! We set mounted, so that we can iput the new dir */</span></span><br><span class="line">			sb=get_super((*dir)-&gt;i_dev);</span><br><span class="line">			<span class="keyword">if</span> (sb-&gt;s_imount) &#123;</span><br><span class="line">				iput(*dir);</span><br><span class="line">				(*dir)=sb-&gt;s_imount;</span><br><span class="line">				(*dir)-&gt;i_count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//目录文件第一个块不能是逻辑块0，不能为空</span></span><br><span class="line">	<span class="keyword">if</span> (!(block = (*dir)-&gt;i_zone[<span class="number">0</span>]))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//不空的话把这个block读入缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh = bread((*dir)-&gt;i_dev,block)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	de = (<span class="keyword">struct</span> dir_entry *) bh-&gt;b_data;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; entries) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="type">char</span> *)de &gt;= BLOCK_SIZE+bh-&gt;b_data) &#123;</span><br><span class="line">			<span class="comment">//如果一个缓冲区全部搜索完还没找到指定的目录项</span></span><br><span class="line">			brelse(bh);</span><br><span class="line">			bh = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span> (!(block = bmap(*dir,i/DIR_ENTRIES_PER_BLOCK)) ||</span><br><span class="line">			    !(bh = bread((*dir)-&gt;i_dev,block))) &#123;</span><br><span class="line">				i += DIR_ENTRIES_PER_BLOCK;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			de = (<span class="keyword">struct</span> dir_entry *) bh-&gt;b_data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (match(namelen,name,de)) &#123;</span><br><span class="line">			*res_dir = de;</span><br><span class="line">			<span class="keyword">return</span> bh;</span><br><span class="line">		&#125;</span><br><span class="line">		de++;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="iget-1">iget</h5>
<p>iget根据目录项中提供的设备号i结点号获取i结点。</p>
<p>首先在inode_table里面看有没有现成的，如果找不到再加载</p>
<p>整体流程图：</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/iget.png" alt="iget">
<figcaption aria-hidden="true">iget</figcaption>
</figure>
<h5 id="返回dir_namei">返回dir_namei</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> m_inode * <span class="title function_">dir_namei</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> * namelen, <span class="type">const</span> <span class="type">char</span> ** name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * basename;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(dir = get_dir(pathname)))<span class="comment">//分析路径，获取i节点的执行函数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	basename = pathname;</span><br><span class="line">	<span class="comment">//一个一个解析paathname，一次过一个字符串常量字符</span></span><br><span class="line">	<span class="keyword">while</span> (c=get_fs_byte(pathname++))</span><br><span class="line">		<span class="keyword">if</span> (c==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">			basename=pathname;</span><br><span class="line">	*namelen = pathname-basename<span class="number">-1</span>;</span><br><span class="line">	*name = basename;</span><br><span class="line">	<span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231212095622262.png" alt="image-20231212095622262" style="zoom:80%;"></p>
<h4 id="opennamei获取目标文件i节点">opennamei:获取目标文件i节点</h4>
<p>上文已经讲述了获得枝梢结点的过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_namei</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname, <span class="type">int</span> flag, <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> m_inode ** res_inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//返回枝梢i结点</span></span><br><span class="line">	<span class="keyword">if</span> (!(dir = dir_namei(pathname,&amp;namelen,&amp;basename)))</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">    <span class="comment">//如果目标文件名字长度为0</span></span><br><span class="line">	<span class="keyword">if</span> (!namelen) &#123;			<span class="comment">/* special case: &#x27;/usr/&#x27; etc */</span></span><br><span class="line">		<span class="keyword">if</span> (!(flag &amp; (O_ACCMODE|O_CREAT|O_TRUNC))) &#123;</span><br><span class="line">			*res_inode=dir;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		iput(dir);</span><br><span class="line">		<span class="keyword">return</span> -EISDIR;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//根据末梢结点和文件名，寻找目标文件再目录项块中的块</span></span><br><span class="line">    bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(flag &amp; O_CREAT)) &#123;</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOENT;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//检查用户权限</span></span><br><span class="line">		<span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">		inode = new_inode(dir-&gt;i_dev);</span><br><span class="line">		<span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">		&#125;</span><br><span class="line">		inode-&gt;i_uid = current-&gt;euid;</span><br><span class="line">		inode-&gt;i_mode = mode;</span><br><span class="line">		inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">		bh = add_entry(dir,basename,namelen,&amp;de);</span><br><span class="line">		<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">			inode-&gt;i_nlinks--;</span><br><span class="line">			iput(inode);</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">		&#125;</span><br><span class="line">		de-&gt;inode = inode-&gt;i_num;</span><br><span class="line">		bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">		brelse(bh);</span><br><span class="line">		iput(dir);</span><br><span class="line">		*res_inode = inode;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	inr = de-&gt;inode;<span class="comment">//i number，这个是双向找的。得到i结点号</span></span><br><span class="line">	dev = dir-&gt;i_dev;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	iput(dir);</span><br><span class="line">	<span class="keyword">if</span> (flag &amp; O_EXCL)</span><br><span class="line">		<span class="keyword">return</span> -EEXIST;</span><br><span class="line">	<span class="keyword">if</span> (!(inode=iget(dev,inr)))</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	<span class="keyword">if</span> ((S_ISDIR(inode-&gt;i_mode) &amp;&amp; (flag &amp; O_ACCMODE)) ||</span><br><span class="line">	    !permission(inode,ACC_MODE(flag))) &#123;</span><br><span class="line">		iput(inode);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_atime = CURRENT_TIME;</span><br><span class="line">	<span class="keyword">if</span> (flag &amp; O_TRUNC)</span><br><span class="line">		truncate(inode);</span><br><span class="line">	*res_inode = inode;<span class="comment">//最终的inode，将inode传回sys_open</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="将文件i结点与file_table64挂接">将文件i结点与file_table[64]挂接</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">int</span> flag,<span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">    <span class="keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">		f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* ttys are somewhat special (ttyxx major==4, tty major==5) */</span></span><br><span class="line">	<span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))<span class="comment">//如果是字符设备文件</span></span><br><span class="line">		<span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">4</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				current-&gt;tty = MINOR(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">				tty_table[current-&gt;tty].pgrp = current-&gt;pgrp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">5</span>)</span><br><span class="line">			<span class="keyword">if</span> (current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				iput(inode);</span><br><span class="line">				current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">				f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> -EPERM;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">/* Likewise with block-devices: check for floppy_change */</span></span><br><span class="line">	<span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))<span class="comment">//如果是块设备文件</span></span><br><span class="line">		check_disk_change(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//设置文件属性，与file_table[64] 挂接</span></span><br><span class="line">	f-&gt;f_mode = inode-&gt;i_mode;</span><br><span class="line">	f-&gt;f_flags = flag;</span><br><span class="line">	f-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">	f-&gt;f_inode = inode;</span><br><span class="line">	f-&gt;f_pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="namei">namei</h3>
<p>将给定的文件路径名映射 到其 i 节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">namei</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * basename;</span><br><span class="line">	<span class="type">int</span> inr,dev,namelen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(dir = dir_namei(pathname,&amp;namelen,&amp;basename)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!namelen)			<span class="comment">/* special case: &#x27;/usr/&#x27; etc */</span></span><br><span class="line">		<span class="keyword">return</span> dir;</span><br><span class="line">	bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	inr = de-&gt;inode;</span><br><span class="line">	dev = dir-&gt;i_dev;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	iput(dir);</span><br><span class="line">	dir=iget(dev,inr);</span><br><span class="line">	<span class="keyword">if</span> (dir) &#123;</span><br><span class="line">		dir-&gt;i_atime=CURRENT_TIME;</span><br><span class="line">		dir-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>izone ：；一个块1k。一个号unsigned short
2字节，一个块：512个号-》512k</p>
<p>inode_table里面的inode只有一个，但是允许别人重复打开，因此有conunt引用计数</p>
<h2 id="读文件">读文件</h2>
<h3 id="sys_read">sys_read</h3>
<p>读文件由用户调用read完成</p>
<p>read函数最终映射到sys_read()系统调用执行</p>
<p>读文件的offset在file结构体里面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd,<span class="type">char</span> * buf,<span class="type">int</span> count)</span><span class="comment">//count是要读取的字节数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//偏置等信息在file结构体里面，可以通过fd找filep里面的指针找到file_table里面的file</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">     <span class="comment">//检查fd和conunt的范围是否合理</span></span><br><span class="line">	<span class="keyword">if</span> (fd&gt;=NR_OPEN || count&lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (!count)<span class="comment">//读取字符为0直接返回</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	verify_area(buf,count);<span class="comment">//对buf所在页面的属性进行验证。如果页面是只读的则复制该页面</span></span><br><span class="line">	inode = file-&gt;f_inode;</span><br><span class="line">    <span class="comment">//针对不同文件类型读</span></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_pipe)</span><br><span class="line">		<span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">1</span>)?read_pipe(inode,buf,count):-EIO;</span><br><span class="line">	<span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))</span><br><span class="line">		<span class="keyword">return</span> rw_char(READ,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line">	<span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line">		<span class="keyword">return</span> block_read(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line">    <span class="comment">//目录文件</span></span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (count+file-&gt;f_pos &gt; inode-&gt;i_size)</span><br><span class="line">			count = inode-&gt;i_size - file-&gt;f_pos;</span><br><span class="line">		<span class="keyword">if</span> (count&lt;=<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> file_read(inode,file,buf,count);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;(Read)inode-&gt;i_mode=%06o\n\r&quot;</span>,inode-&gt;i_mode);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">verify_area</span><span class="params">(<span class="type">void</span> * addr,<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start;</span><br><span class="line"></span><br><span class="line">	start = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line">	size += start &amp; <span class="number">0xfff</span>;</span><br><span class="line">	start &amp;= <span class="number">0xfffff000</span>;</span><br><span class="line">	start += get_base(current-&gt;ldt[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">while</span> (size&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		size -= <span class="number">4096</span>;</span><br><span class="line">		write_verify(start);</span><br><span class="line">		start += <span class="number">4096</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_verify</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> page;</span><br><span class="line">    <span class="comment">// 判断指定地址所对应页目录项的页表是否存在(P)，若不存在(P=0)则返回。4M对齐</span></span><br><span class="line">	<span class="keyword">if</span> (!( (page = *((<span class="type">unsigned</span> <span class="type">long</span> *) ((address&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>)) )&amp;<span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 取页表的地址，加上指定地址的页面在页表中的页表项偏移值，得对应物理页面的页表项指针。</span></span><br><span class="line">	page &amp;= <span class="number">0xfffff000</span>;</span><br><span class="line">	page += ((address&gt;&gt;<span class="number">10</span>) &amp; <span class="number">0xffc</span>);<span class="comment">//高10位置零，低十位置零只留了中间十位，后两位置零了起到乘4的效果，因为每一个偏移量是以4k为单位的，避免后面取到了index再乘4的操作</span></span><br><span class="line">	<span class="comment">// 如果该页面不可写(标志 R/W 没有置位)，则执行共享检验和复制页面操作（写时复制）。</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="number">3</span> &amp; *(<span class="type">unsigned</span> <span class="type">long</span> *) page) == <span class="number">1</span>)  <span class="comment">/* non-writeable, present */</span></span><br><span class="line">		un_wp_page((<span class="type">unsigned</span> <span class="type">long</span> *) page);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="file_read">file_read</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_read</span><span class="params">(<span class="keyword">struct</span> m_inode * inode, <span class="keyword">struct</span> file * filp, <span class="type">char</span> * buf, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> left,chars,nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((left=count)&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (left) &#123;</span><br><span class="line">		<span class="comment">//每次按块读，每次读一个块</span></span><br><span class="line">		<span class="keyword">if</span> (nr = bmap(inode,(filp-&gt;f_pos)/BLOCK_SIZE)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,nr)))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			bh = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="comment">// 计算文件读写指针在数据块中的偏移值 nr，则该块中可读字节数为(BLOCK_SIZE-nr)，然后与还需 </span></span><br><span class="line">     <span class="comment">// 读取的字节数 left 作比较，其中小值即为本次需读的字节数 chars。若(BLOCK_SIZE-nr)大则说明 </span></span><br><span class="line">     <span class="comment">// 该块是需要读取的最后一块数据，反之则还需要读取一块数据。</span></span><br><span class="line">		nr = filp-&gt;f_pos % BLOCK_SIZE;</span><br><span class="line">		chars = MIN( BLOCK_SIZE-nr , left );</span><br><span class="line">     <span class="comment">// 调整读写文件指针。指针前移此次将读取的字节数 chars。剩余字节计数相应减去 chars。</span></span><br><span class="line">		filp-&gt;f_pos += chars;</span><br><span class="line">		left -= chars;</span><br><span class="line">		<span class="keyword">if</span> (bh) &#123;</span><br><span class="line">			<span class="type">char</span> * p = nr + bh-&gt;b_data;</span><br><span class="line">			<span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)</span><br><span class="line">				put_fs_byte(*(p++),buf++);<span class="comment">//从缓冲区往用户拷贝</span></span><br><span class="line">			brelse(bh);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)</span><br><span class="line">				put_fs_byte(<span class="number">0</span>,buf++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_atime = CURRENT_TIME;</span><br><span class="line">	<span class="keyword">return</span> (count-left)?(count-left):-ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bmap">_bmap</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> m_inode * inode,<span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _bmap(inode,block,<span class="number">0</span>);<span class="comment">//注意这里写死了一个0，0表示用已有的，1表示没有就创建一个（izone有块没有就补一下）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="新建文件">新建文件</h2>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/新建文件inode.png" alt="示意图">
<figcaption aria-hidden="true">示意图</figcaption>
</figure>
<p>creat函数，最终映射到sys_create函数，调用sys_open新建文件，和之前打开文件调用open不一样，这回opennamei没有这个i结点会返回空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">int</span> flag,<span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">		f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_namei</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname, <span class="type">int</span> flag, <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> m_inode ** res_inode)</span></span><br><span class="line">&#123;   </span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> (!(dir = dir_namei(pathname,&amp;namelen,&amp;basename)))</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buffer_head * <span class="title function_">find_entry</span><span class="params">(<span class="keyword">struct</span> m_inode ** dir,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">char</span> * name, <span class="type">int</span> namelen, <span class="keyword">struct</span> dir_entry ** res_dir)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">while</span> (i &lt; entries) &#123;</span><br><span class="line">         ...</span><br><span class="line">		<span class="keyword">if</span> (match(namelen,name,de)) &#123;<span class="comment">//匹配当前的名字和目录项里面的名字</span></span><br><span class="line">			*res_dir = de;</span><br><span class="line">			<span class="keyword">return</span> bh;</span><br><span class="line">		&#125;</span><br><span class="line">		de++;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终find_entry会返回null</p>
<p>因此opennamei执行：if (!bh) 里面的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_namei</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname, <span class="type">int</span> flag, <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> m_inode ** res_inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">        <span class="comment">//没有找到文件不一定是要新建文件，可能是用户输错了名字</span></span><br><span class="line">        <span class="comment">//检查flag的O_CREAT标志位是否置位。如果置位了，说明确实是要新建文件</span></span><br><span class="line">		<span class="keyword">if</span> (!(flag &amp; O_CREAT)) &#123;</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOENT;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//检查用户再该目录是否有写权限</span></span><br><span class="line">		<span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//新建inode</span></span><br><span class="line">		inode = new_inode(dir-&gt;i_dev);</span><br><span class="line">		<span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">		&#125;</span><br><span class="line">		inode-&gt;i_uid = current-&gt;euid;</span><br><span class="line">		inode-&gt;i_mode = mode;</span><br><span class="line">		inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">		bh = add_entry(dir,basename,namelen,&amp;de);<span class="comment">//新建目录项</span></span><br><span class="line">		<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">			inode-&gt;i_nlinks--;</span><br><span class="line">			iput(inode);</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">		&#125;</span><br><span class="line">		de-&gt;inode = inode-&gt;i_num;</span><br><span class="line">		bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">		brelse(bh);</span><br><span class="line">		iput(dir);</span><br><span class="line">		*res_inode = inode;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="new_inode">new_inode</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">new_inode</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">    <span class="comment">//在inode_tale里面寻找空闲i结点</span></span><br><span class="line">	<span class="keyword">if</span> (!(inode=get_empty_inode()))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//获取设备超级块</span></span><br><span class="line">	<span class="keyword">if</span> (!(sb = get_super(dev)))</span><br><span class="line">		panic(<span class="string">&quot;new_inode with unknown device&quot;</span>);</span><br><span class="line">	j = <span class="number">8192</span>;<span class="comment">//根据超级块里面的i结点位图信息设置i结点位图</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;<span class="number">8</span> ; i++)</span><br><span class="line">		<span class="keyword">if</span> (bh=sb-&gt;s_imap[i])</span><br><span class="line">			<span class="keyword">if</span> ((j=find_first_zero(bh-&gt;b_data))&lt;<span class="number">8192</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span> (!bh || j &gt;= <span class="number">8192</span> || j+i*<span class="number">8192</span> &gt; sb-&gt;s_ninodes) &#123;</span><br><span class="line">		iput(inode);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (set_bit(j,bh-&gt;b_data))</span><br><span class="line">		panic(<span class="string">&quot;new_inode: bit already set&quot;</span>);</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_count=<span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_nlinks=<span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_dev=dev;</span><br><span class="line">	inode-&gt;i_uid=current-&gt;euid;</span><br><span class="line">	inode-&gt;i_gid=current-&gt;egid;</span><br><span class="line">	inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_num = j + i*<span class="number">8192</span>;</span><br><span class="line">	inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="add_entry">add_entry</h3>
<p>如果在目录文件中找到空闲项，则在此处加载</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215154349111.png" alt="目录文件示意图">
<figcaption aria-hidden="true">目录文件示意图</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buffer_head * <span class="title function_">add_entry</span><span class="params">(<span class="keyword">struct</span> m_inode * dir,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">char</span> * name, <span class="type">int</span> namelen, <span class="keyword">struct</span> dir_entry ** res_dir)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> block,i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">	*res_dir = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NO_TRUNCATE</span></span><br><span class="line">	<span class="keyword">if</span> (namelen &gt; NAME_LEN)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">if</span> (namelen &gt; NAME_LEN)</span><br><span class="line">		namelen = NAME_LEN;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (!namelen)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(block = dir-&gt;i_zone[<span class="number">0</span>]))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(bh = bread(dir-&gt;i_dev,block)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	de = (<span class="keyword">struct</span> dir_entry *) bh-&gt;b_data;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">// 如果当前判别的目录项已经超出当前数据块，则释放该数据块，重新申请一块磁盘块 block。如果 </span></span><br><span class="line">        <span class="comment">// 申请失败，则返回 NULL，退出。</span></span><br><span class="line">		<span class="keyword">if</span> ((<span class="type">char</span> *)de &gt;= BLOCK_SIZE+bh-&gt;b_data) &#123;</span><br><span class="line">            <span class="comment">//整个数据块都没有空闲则加载新的block</span></span><br><span class="line">			brelse(bh);</span><br><span class="line">			bh = <span class="literal">NULL</span>;</span><br><span class="line">			block = create_block(dir,i/DIR_ENTRIES_PER_BLOCK);</span><br><span class="line">			<span class="keyword">if</span> (!block)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span> (!(bh = bread(dir-&gt;i_dev,block))) &#123;</span><br><span class="line">				i += DIR_ENTRIES_PER_BLOCK;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			de = (<span class="keyword">struct</span> dir_entry *) bh-&gt;b_data;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// 如果当前所操作的目录项序号 i*目录结构大小已经超过了该目录所指出的大小 i_size，则说明该第 i </span></span><br><span class="line"> <span class="comment">// 个目录项还未使用，我们可以使用它。于是对该目录项进行设置(置该目录项的 i 节点指针为空)。并 </span></span><br><span class="line"> <span class="comment">// 更新该目录的长度值(加上一个目录项的长度，设置目录的 i 节点已修改标志，再更新该目录的改变</span></span><br><span class="line">时 </span><br><span class="line"> <span class="comment">// 间为当前时间。</span></span><br><span class="line">    <span class="comment">//在末端找到空闲项</span></span><br><span class="line">		<span class="keyword">if</span> (i*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dir_entry) &gt;= dir-&gt;i_size) &#123;</span><br><span class="line">			de-&gt;inode=<span class="number">0</span>;</span><br><span class="line">			dir-&gt;i_size = (i+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dir_entry);</span><br><span class="line">			dir-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">			dir-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//在中间找到空闲项</span></span><br><span class="line">		<span class="keyword">if</span> (!de-&gt;inode) &#123;</span><br><span class="line">			dir-&gt;i_mtime = CURRENT_TIME;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; NAME_LEN ; i++)</span><br><span class="line">				de-&gt;name[i]=(i&lt;namelen)?get_fs_byte(name+i):<span class="number">0</span>;</span><br><span class="line">			bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">			*res_dir = de;</span><br><span class="line">			<span class="keyword">return</span> bh;</span><br><span class="line">		&#125;</span><br><span class="line">		de++;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_block</span><span class="params">(<span class="keyword">struct</span> m_inode * inode, <span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _bmap(inode,block,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bmap-1">_bmap</h3>
<h4 id="直接索引部分-block7">直接索引部分 （block&lt;7)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _bmap(<span class="keyword">struct</span> m_inode * inode,<span class="type">int</span> block,<span class="type">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"><span class="comment">// 如果块号小于 0，则死机。</span></span><br><span class="line">	<span class="keyword">if</span> (block&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;_bmap: block&lt;0&quot;</span>);</span><br><span class="line"><span class="comment">// 如果块号大于直接块数 + 间接块数 + 二次间接块数，超出文件系统表示范围，则死机。		</span></span><br><span class="line">	<span class="keyword">if</span> (block &gt;= <span class="number">7</span>+<span class="number">512</span>+<span class="number">512</span>*<span class="number">512</span>)</span><br><span class="line">		panic(<span class="string">&quot;_bmap: block&gt;big&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (block&lt;<span class="number">7</span>) &#123;</span><br><span class="line"> <span class="comment">// 如果创建标志置位，并且 i 节点中对应该块的逻辑块（区段）字段为 0，则向相应设备申请一磁盘 </span></span><br><span class="line"> <span class="comment">// 块（逻辑块，区块），并将盘上逻辑块号（盘块号）填入逻辑块字段中。然后设置 i 节点修改时间，</span></span><br><span class="line">		<span class="keyword">if</span> (create &amp;&amp; !inode-&gt;i_zone[block])</span><br><span class="line">			<span class="keyword">if</span> (inode-&gt;i_zone[block]=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">				inode-&gt;i_ctime=CURRENT_TIME;</span><br><span class="line">				inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> inode-&gt;i_zone[block];</span><br><span class="line">	&#125;</span><br><span class="line">	block -= <span class="number">7</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/bmap0.png" alt="bmap">
<figcaption aria-hidden="true">bmap</figcaption>
</figure>
<h4 id="一级索引部分">一级索引部分</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _bmap(<span class="keyword">struct</span> m_inode * inode,<span class="type">int</span> block,<span class="type">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (block&lt;<span class="number">512</span>) &#123;</span><br><span class="line"> <span class="comment">// 如果是创建，并且该 i 节点中对应间接块字段为 0，表明文件是首次使用间接块，则需申请 </span></span><br><span class="line"> <span class="comment">// 一磁盘块用于存放间接块信息，并将此实际磁盘块号填入间接块字段中。然后设置 i 节点 </span></span><br><span class="line"> <span class="comment">// 已修改标志和修改时间。</span></span><br><span class="line">		<span class="keyword">if</span> (create &amp;&amp; !inode-&gt;i_zone[<span class="number">7</span>])</span><br><span class="line">			<span class="keyword">if</span> (inode-&gt;i_zone[<span class="number">7</span>]=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">				inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">				inode-&gt;i_ctime=CURRENT_TIME;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (!inode-&gt;i_zone[<span class="number">7</span>])</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!(bh = bread(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">7</span>])))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		i = ((<span class="type">unsigned</span> <span class="type">short</span> *) (bh-&gt;b_data))[block];</span><br><span class="line">		<span class="keyword">if</span> (create &amp;&amp; !i)</span><br><span class="line">			<span class="keyword">if</span> (i=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">				((<span class="type">unsigned</span> <span class="type">short</span> *) (bh-&gt;b_data))[block]=i;</span><br><span class="line">				bh-&gt;b_dirt=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		brelse(bh);</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	block -= <span class="number">512</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/bmap1.png" alt="bmap1">
<figcaption aria-hidden="true">bmap1</figcaption>
</figure>
<h4 id="二级索引部分">二级索引部分</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _bmap(<span class="keyword">struct</span> m_inode * inode,<span class="type">int</span> block,<span class="type">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (create &amp;&amp; !inode-&gt;i_zone[<span class="number">8</span>])</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_zone[<span class="number">8</span>]=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">			inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">			inode-&gt;i_ctime=CURRENT_TIME;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_zone[<span class="number">8</span>])</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">8</span>])))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	i = ((<span class="type">unsigned</span> <span class="type">short</span> *)bh-&gt;b_data)[block&gt;&gt;<span class="number">9</span>];</span><br><span class="line">	<span class="keyword">if</span> (create &amp;&amp; !i)</span><br><span class="line">		<span class="keyword">if</span> (i=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">			((<span class="type">unsigned</span> <span class="type">short</span> *) (bh-&gt;b_data))[block&gt;&gt;<span class="number">9</span>]=i;</span><br><span class="line">			bh-&gt;b_dirt=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">if</span> (!i)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,i)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	i = ((<span class="type">unsigned</span> <span class="type">short</span> *)bh-&gt;b_data)[block&amp;<span class="number">511</span>];</span><br><span class="line">	<span class="keyword">if</span> (create &amp;&amp; !i)</span><br><span class="line">		<span class="keyword">if</span> (i=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">			((<span class="type">unsigned</span> <span class="type">short</span> *) (bh-&gt;b_data))[block&amp;<span class="number">511</span>]=i;</span><br><span class="line">			bh-&gt;b_dirt=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="new-block">new block</h3>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/new_block.png" alt="new block">
<figcaption aria-hidden="true">new block</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">new_block</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(sb = get_super(dev)))</span><br><span class="line">		panic(<span class="string">&quot;trying to get new block from nonexistant device&quot;</span>);</span><br><span class="line">	j = <span class="number">8192</span>;</span><br><span class="line">	<span class="comment">// 扫描逻辑块位图，寻找首个 0 比特位，寻找空闲逻辑块，获取放置该逻辑块的块号。</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;<span class="number">8</span> ; i++)</span><br><span class="line">		<span class="keyword">if</span> (bh=sb-&gt;s_zmap[i])</span><br><span class="line">			<span class="keyword">if</span> ((j=find_first_zero(bh-&gt;b_data))&lt;<span class="number">8192</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"> <span class="comment">// 如果全部扫描完还没找到(i&gt;=8 或 j&gt;=8192)或者位图所在的缓冲块无效(bh=NULL)则 返回 0， </span></span><br><span class="line"> <span class="comment">// 退出（没有空闲逻辑块）。</span></span><br><span class="line">	<span class="keyword">if</span> (i&gt;=<span class="number">8</span> || !bh || j&gt;=<span class="number">8192</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (set_bit(j,bh-&gt;b_data))</span><br><span class="line">		panic(<span class="string">&quot;new_block: bit already set&quot;</span>);</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">	 <span class="comment">// 置对应缓冲区块的已修改标志。如果新逻辑块大于该设备上的总逻辑块数，则说明指定逻辑块在 </span></span><br><span class="line"> <span class="comment">// 对应设备上不存在。申请失败，返回 0，退出。</span></span><br><span class="line">	j += i*<span class="number">8192</span> + sb-&gt;s_firstdatazone<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (j &gt;= sb-&gt;s_nzones)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 读取设备上的该新逻辑块数据（验证）。如果失败则死机。</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh=getblk(dev,j)))</span><br><span class="line">		panic(<span class="string">&quot;new_block: cannot get block&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_count != <span class="number">1</span>)</span><br><span class="line">		panic(<span class="string">&quot;new block: count is != 1&quot;</span>);</span><br><span class="line">		<span class="comment">// 将该新逻辑块清零，并置位更新标志和已修改标志。然后释放对应缓冲区，返回逻辑块号。</span></span><br><span class="line">	clear_block(bh-&gt;b_data);</span><br><span class="line">	bh-&gt;b_uptodate = <span class="number">1</span>;</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="写文件">写文件</h2>
<p>写入文件最终映射到sys_write,sys_write判断要写的文件的类型，对于目录文件调用file_write</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_write</span><span class="params">(<span class="keyword">struct</span> m_inode * inode, <span class="keyword">struct</span> file * filp, <span class="type">char</span> * buf, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">off_t</span> pos;</span><br><span class="line">	<span class="type">int</span> block,c;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">char</span> * p;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ok, append may not work when many processes are writing at the same time</span></span><br><span class="line"><span class="comment"> * but so what. That way leads to madness anyway.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">if</span> (filp-&gt;f_flags &amp; O_APPEND)<span class="comment">//如果设置了文件尾部添加标志，将pos移动到文件末尾</span></span><br><span class="line">		pos = inode-&gt;i_size;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pos = filp-&gt;f_pos;</span><br><span class="line">	<span class="keyword">while</span> (i&lt;count) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(block = create_block(inode,pos/BLOCK_SIZE))) <span class="comment">//创建逻辑块并反回块号</span></span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,block)))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 求出文件读写指针在数据块中的偏移值 c，将 p 指向读出数据块缓冲区中开始读取的位置。置该 </span></span><br><span class="line"> <span class="comment">// 缓冲区已修改标志。</span></span><br><span class="line">		c = pos % BLOCK_SIZE;</span><br><span class="line">		p = c + bh-&gt;b_data;</span><br><span class="line">		bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line"> <span class="comment">// 从开始读写位置到块末共可写入 c=(BLOCK_SIZE-c)个字节。若 c 大于剩余还需写入的字节数 </span></span><br><span class="line"> <span class="comment">// (count-i)，则此次只需再写入 c=(count-i)即可。</span></span><br><span class="line">		c = BLOCK_SIZE-c;</span><br><span class="line">		<span class="keyword">if</span> (c &gt; count-i) c = count-i;</span><br><span class="line">  <span class="comment">// 文件读写指针前移此次需写入的字节数。如果当前文件读写指针位置值超过了文件的大小，则 </span></span><br><span class="line"> <span class="comment">// 修改 i 节点中文件大小字段，并置 i 节点已修改标志。</span></span><br><span class="line">		pos += c;</span><br><span class="line">		<span class="keyword">if</span> (pos &gt; inode-&gt;i_size) &#123;</span><br><span class="line">			inode-&gt;i_size = pos;</span><br><span class="line">			inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// 已写入字节计数累加此次写入的字节数 c。从用户缓冲区 buf 中复制 c 个字节到高速缓冲区中 p </span></span><br><span class="line"> <span class="comment">// 指向开始的位置处。然后释放该缓冲区。</span></span><br><span class="line">		i += c;</span><br><span class="line">		<span class="keyword">while</span> (c--&gt;<span class="number">0</span>)</span><br><span class="line">			*(p++) = get_fs_byte(buf++);</span><br><span class="line">		brelse(bh);</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_mtime = CURRENT_TIME;</span><br><span class="line">    <span class="comment">// 如果此次操作不是在文件尾添加数据，则把文件读写指针调整到当前读写位置，并更改 i 节点修改 </span></span><br><span class="line"> <span class="comment">// 时间为当前时间。</span></span><br><span class="line">	<span class="keyword">if</span> (!(filp-&gt;f_flags &amp; O_APPEND)) &#123;</span><br><span class="line">		filp-&gt;f_pos = pos;</span><br><span class="line">		inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (i?i:<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关闭文件">关闭文件</h2>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215212431360.png" alt="关闭文件">
<figcaption aria-hidden="true">关闭文件</figcaption>
</figure>
<p>注意file_table[64]是所有进程共享的，所以这里是减小引用计数而不是清零。当引用计数为0的时候空闲</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd)</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= NR_OPEN)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	current-&gt;close_on_exec &amp;= ~(<span class="number">1</span>&lt;&lt;fd);</span><br><span class="line">	<span class="keyword">if</span> (!(filp = current-&gt;filp[fd]))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	current-&gt;filp[fd] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (filp-&gt;f_count == <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;Close: file count is 0&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (--filp-&gt;f_count)</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	iput(filp-&gt;f_inode);<span class="comment">//释放文件i结点。减小在inode_table[32]里面的引用计数。当引用计数为0的时候空闲</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除文件">删除文件</h2>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215235324252.png" alt="删除文件">
<figcaption aria-hidden="true">删除文件</figcaption>
</figure>
<h3 id="i_nlinks">i_nlinks</h3>
<p>linux文件可以建立链接。文件没多被链接一次文件的的inode的i_nlinks会加1。也就是多个目录项链接到一个文件inode</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215214155373.png" alt="i_nlinks">
<figcaption aria-hidden="true">i_nlinks</figcaption>
</figure>
<h3 id="sys_unlink">sys_unlink</h3>
<p>检查文件是否能被删除。函数整个流程和打开文件很类似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * basename;</span><br><span class="line">	<span class="type">int</span> namelen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>, * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(dir = dir_namei(name,&amp;namelen,&amp;basename)))</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="keyword">if</span> (!namelen) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(inode = iget(dir-&gt;i_dev, de-&gt;inode))) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		brelse(bh);</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((dir-&gt;i_mode &amp; S_ISVTX) &amp;&amp; !suser() &amp;&amp;</span><br><span class="line">	    current-&gt;euid != inode-&gt;i_uid &amp;&amp;</span><br><span class="line">	    current-&gt;euid != dir-&gt;i_uid) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		iput(inode);</span><br><span class="line">		brelse(bh);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">		iput(inode);<span class="comment">//释放文件结点</span></span><br><span class="line">		iput(dir); <span class="comment">//释放枝梢结点</span></span><br><span class="line">		brelse(bh);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_nlinks) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Deleting nonexistent file (%04x:%d), %d\n&quot;</span>,</span><br><span class="line">			inode-&gt;i_dev,inode-&gt;i_num,inode-&gt;i_nlinks);</span><br><span class="line">		inode-&gt;i_nlinks=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//具体的文件删除操作：</span></span><br><span class="line">	de-&gt;inode = <span class="number">0</span>;</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	inode-&gt;i_nlinks--;<span class="comment">//修改i_nlinks</span></span><br><span class="line">	inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">	iput(inode);<span class="comment">//释放文件结点</span></span><br><span class="line">	iput(dir);<span class="comment">//释放枝梢结点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>### iput</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iput</span><span class="params">(<span class="keyword">struct</span> m_inode * inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!inode)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	wait_on_inode(inode);</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_count)</span><br><span class="line">		panic(<span class="string">&quot;iput: trying to free free inode&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_pipe) &#123;</span><br><span class="line">		wake_up(&amp;inode-&gt;i_wait);</span><br><span class="line">		<span class="keyword">if</span> (--inode-&gt;i_count)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		free_page(inode-&gt;i_size);</span><br><span class="line">		inode-&gt;i_count=<span class="number">0</span>;</span><br><span class="line">		inode-&gt;i_dirt=<span class="number">0</span>;</span><br><span class="line">		inode-&gt;i_pipe=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_dev) &#123;</span><br><span class="line">		inode-&gt;i_count--;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode)) &#123;</span><br><span class="line">		sync_dev(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">	&#125;</span><br><span class="line">repeat:</span><br><span class="line">    <span class="comment">//减少引用计数</span></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_count&gt;<span class="number">1</span>) &#123;</span><br><span class="line">		inode-&gt;i_count--;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//当链接数目等于0的时候，释放逻辑块</span></span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_nlinks) &#123;</span><br><span class="line">		truncate(inode);<span class="comment">//释放文件在硬盘上占据的逻辑块</span></span><br><span class="line">		free_inode(inode);<span class="comment">//将i结点位图对应的位清空，将inode_table里面对应的表现清空</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//将i结点内容同步到外设</span></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_dirt) &#123;</span><br><span class="line">		write_inode(inode);	<span class="comment">/* we can sleep - so do again */</span></span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_count--;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="truncate">truncate</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">truncate</span><span class="params">(<span class="keyword">struct</span> m_inode * inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">     <span class="comment">//如果该文件不是目录文件或者普通文件则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (!(S_ISREG(inode-&gt;i_mode) || S_ISDIR(inode-&gt;i_mode)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_zone[i]) &#123;</span><br><span class="line">			free_block(inode-&gt;i_dev,inode-&gt;i_zone[i]);<span class="comment">//将izone的前7位对应的逻辑块在逻辑位图上对应清零</span></span><br><span class="line">			inode-&gt;i_zone[i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	free_ind(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">7</span>]);<span class="comment">//释放一级</span></span><br><span class="line">	free_dind(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">8</span>]);<span class="comment">//释放二级</span></span><br><span class="line">	inode-&gt;i_zone[<span class="number">7</span>] = inode-&gt;i_zone[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">	inode-&gt;i_size = <span class="number">0</span>;</span><br><span class="line">	inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="free_inode">free_inode</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_inode</span><span class="params">(<span class="keyword">struct</span> m_inode * inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!inode)<span class="comment">//结点为空返回</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//设备号为0</span></span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_dev) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(inode,<span class="number">0</span>,<span class="keyword">sizeof</span>(*inode));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//结点被多次引用</span></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_count&gt;<span class="number">1</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;trying to free inode with count=%d\n&quot;</span>,inode-&gt;i_count);</span><br><span class="line">		panic(<span class="string">&quot;free_inode&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//结点的nlinks不为0</span></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_nlinks)</span><br><span class="line">		panic(<span class="string">&quot;trying to free inode with links&quot;</span>);</span><br><span class="line">    <span class="comment">//超级块不存在</span></span><br><span class="line">	<span class="keyword">if</span> (!(sb = get_super(inode-&gt;i_dev)))</span><br><span class="line">		panic(<span class="string">&quot;trying to free inode on nonexistent device&quot;</span>);</span><br><span class="line">    <span class="comment">//检查i结点号</span></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_num &lt; <span class="number">1</span> || inode-&gt;i_num &gt; sb-&gt;s_ninodes)</span><br><span class="line">		panic(<span class="string">&quot;trying to free inode 0 or nonexistant inode&quot;</span>);</span><br><span class="line">    <span class="comment">//结点i结点位图不存在</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh=sb-&gt;s_imap[inode-&gt;i_num&gt;&gt;<span class="number">13</span>]))</span><br><span class="line">		panic(<span class="string">&quot;nonexistent imap in superblock&quot;</span>);</span><br><span class="line">    <span class="comment">//清空对应的位</span></span><br><span class="line">	<span class="keyword">if</span> (clear_bit(inode-&gt;i_num&amp;<span class="number">8191</span>,bh-&gt;b_data))</span><br><span class="line">		printk(<span class="string">&quot;free_inode: bit already cleared.\n\r&quot;</span>);</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(inode,<span class="number">0</span>,<span class="keyword">sizeof</span>(*inode));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>LINUX011内核学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 0.11 里面的 inline 问题</title>
    <url>/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="linux-0.11-里面的-inline-问题">Linux 0.11 里面的 inline
问题</h1>
<h2 id="问题描述">问题描述</h2>
<p>如下所示linux 0.11中main函数关于fork和pause的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> _syscall0(<span class="type">int</span>,fork) </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> _syscall0(<span class="type">int</span>,pause)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>本篇文章讨论这里的inline是否有存在的必要，如果去掉会引发什么后果</p>
<h2 id="c-程序运行结构分析">c 程序运行结构分析</h2>
<h3 id="函数调用与执行">函数调用与执行</h3>
<p>为了更好的解决该问题，我们首先需要分析一下c程序运行的结构</p>
<p>以如下一段简单的代码为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> m=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> j=<span class="number">5</span>;</span><br><span class="line">m=fun(i,j);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line"><span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">c=a+b;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行时，内存中展示了如下三个区域</p>
<figure>
<img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/image-20231111161501642.png" alt="image-20231111161501642">
<figcaption aria-hidden="true">image-20231111161501642</figcaption>
</figure>
<p>代码区里面装载了要执行的机器指令，静态数据区装载了全局变量m。动态数据区，在程序没执行的时候还什么都没有，只有在函数执行的时候才会进行压栈清栈的操作。</p>
<p>cpu中有三种寄存器，eip，ebp，esp。eip指向要执行的下一条语句，他有两种方式：一个是顺序执行，一个是跳转。</p>
<p>ebp和esp用于管理栈，ebp指向栈底，esp指向栈顶。</p>
<p><img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/image-20231111162313189.png" alt="image-20231111162313189" style="zoom:80%;"></p>
<p>运行初始时，eip指向main函数第一条指令，eip和esp位置由操作系统内核设定。</p>
<figure>
<img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/image-20231111224934607.png" alt="image-20231111224934607">
<figcaption aria-hidden="true">image-20231111224934607</figcaption>
</figure>
<p>此时将ebp当前的位置压栈，保证在函数执行完以后，ebp还能回到原来的位置，esp自动向下移动指向栈顶。、</p>
<p><strong>下面开始构造main函数自己的栈</strong></p>
<p><img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/image-20231111225242643.png" alt="image-20231111225242643" style="zoom:50%;"></p>
<p>因为上面ebp原来的值已经压栈保存了，现在把ebp向下移动，和esp重合。因为此时main函数还没有用到函数自己的栈，函数栈为空。</p>
<p>eip指向下一条指令<code>int i=4;</code></p>
<p>i=4,局部变量用到数据栈，把4压栈，esp向下移动，eip指向下一条指令。</p>
<p><img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/image-20231111225458831.png" alt="image-20231111225458831" style="zoom:75%;"></p>
<p>同理5也被存到栈中。</p>
<p><img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/image-20231111225638383.png" alt="image-20231111225638383" style="zoom:67%;"></p>
<p><strong>调用fun函数</strong></p>
<p>首先执行传参的指令，参数入栈的顺序是从右到左，<strong>此时用的还是mian的栈</strong></p>
<figure>
<img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/image-20231111230409118.png" alt="image-20231111230409118">
<figcaption aria-hidden="true">image-20231111230409118</figcaption>
</figure>
<p>为fun函数返回值开辟空间，（IA32中是用eax寄存器存储返回值，就不用像这里额外开辟空间存储）,接下来把fun函数返回后要继续执行的地址压栈</p>
<figure>
<img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/image-20231111230602690.png" alt="image-20231111230602690">
<figcaption aria-hidden="true">image-20231111230602690</figcaption>
</figure>
<p>fun函数开始执行，准备建立fun函数的栈</p>
<p>首先保存当前ebp的地址，ebp指向esp。</p>
<figure>
<img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/image-20231111230747076.png" alt="image-20231111230747076">
<figcaption aria-hidden="true">image-20231111230747076</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line"><span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">c=a+b;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续执行fun函数，将函数的局部变量压栈：</p>
<p><strong>此时局部变量在fun函数的栈中，参数在main函数（主调函数）的栈中，以ebp作为分界线寻找</strong></p>
<figure>
<img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/image-20231111231045222.png" alt="image-20231111231045222">
<figcaption aria-hidden="true">image-20231111231045222</figcaption>
</figure>
<h3 id="函数返回恢复现场">函数返回恢复现场</h3>
<p>首先需要恢复栈ebp，首先栈顶是ebp要恢复的位置，出栈后移动ebp，esp自动上移</p>
<p><img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/image-20231111231414857.png" alt="image-20231111231414857" style="zoom: 80%;"></p>
<p>接下来执行RET指令，这条指令将fun函数执行后的返回地址给eip使程序跳转到调用函数后的指令，清栈esp上移</p>
<p><img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/image-20231111231525091.png" alt="image-20231111231525091" style="zoom:80%;"></p>
<p>将fun函数返回值传给m，现在栈里面由fun函数传的参数，这些已经没有用了，因此这里就会进行清栈</p>
<p><img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/image-20231111231823242.png" alt="image-20231111231823242" style="zoom:50%;"></p>
<p>main函数返回时的清栈工作和上面是一致的</p>
<h2 id="如果两个inline都去掉是什么情况">如果两个inline都去掉是什么情况</h2>
<h3 id="理论分析">理论分析</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">	<span class="keyword">if</span> (!fork()) &#123;		<span class="comment">/* we count on this going ok */</span></span><br><span class="line">		init(); </span><br><span class="line">		<span class="comment">//进程本来已经走到pause了，</span></span><br><span class="line">	<span class="comment">//	但是因为eip是fork的eip所以返回的时候是从fork这里出来的</span></span><br><span class="line">	<span class="comment">//eax是在tss初始化里面设置为0，所以res=0所以返回值就是0，所以！fork为真，所以进程1就执行到这里面的init里了</span></span><br><span class="line">	<span class="comment">//因此此时属于三特权的进程1的代码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(;;) pause();<span class="comment">//死循环，进程调度开始</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先正常的执行顺序是，进程1执行的时候从进程0的fork的res处返回：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="type">long</span> __res; \</span><br><span class="line">__asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span> \ <span class="comment">//init 0x80是所有系统调用函数的总入口，fork是其中之一        </span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;=a&quot;</span> (__res) \ <span class="comment">//第一个冒号之后是输出部分，将_res赋值给eax</span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;0&quot;</span> (__NR_fork))</span>; \ <span class="comment">//第二个冒号后是输入部分，&quot;0&quot;同上寄存器，即eax ，__NR_fork=2，赋值给eax，紧接着就进行了0</span></span><br><span class="line">    <span class="comment">//x80软中断</span></span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \ <span class="comment">//int 0x80中断返回后，将执行这一句</span></span><br><span class="line">	<span class="keyword">return</span> (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回后执行到语句，因为进程1eax设置了0，从而执行init</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!fork()) &#123;		<span class="comment">/* we count on this going ok */</span></span><br><span class="line">		init(); &#125;</span><br></pre></td></tr></table></figure>
<p>以上是基于inline的情况</p>
<p>那么如果都不inline了会有什么后果？</p>
<p>这里会出现问题，主要原因是进程1从fork里面出来的时候走的并不是完整的函数返回过程，只是将eip进行了切换，fork的函数返回地址都在进程0的fork返回后从进程0的用户栈中被清理了（进程0的esp向高地址移动，此时进程1的esp没变）。如果是inline，他并不是一真正的函数，而是之间插进去了，没有函数的栈所以不会有问题</p>
<p>我们先考虑一个最简单的过程：进程0执行到pause的时候，发生进程调度，进程切换到进程1.</p>
<p>此时如果两个都不是inline</p>
<p>进程0的<strong>用户栈</strong>*里面存的内容：</p>
<p>fork函数返回后的地址已经被清除了，因为pause函数已经调用了，所以有pause函数返回后的地址，在pause执行后面就调用int
0x80了，这些东西就放在进程0的内核栈里面了与用户栈无关，所以这里没有。</p>
<p>切换到进程1以后，因为进程1的esp和ebp和进程0调用fork时是完全一样的（指向用户栈），而且进程1是复制了进程0的页表，他们俩指向的是同一个物理空间。（注：首先copy_process
设置进程1的esp和ss，这两个值和进程0的一致，接着调用copy_mem，对进程1
的ldt进行了重新设置，对应的是进程1
的线性地址空间，在copy_page_table中，将进程0和进程1的线性地址空间指向了同一个物理页面，基于上述过程，当调度到进程1
执行后，进程1的ss查询进程1的ldt[2]得到进程1
的用户数据段基址，映射到的物理地址和进程0的用户数据段对应的物理地址一致）.此时，进程0，进程1，esp，ebp是一样的，物理地址里面的内容也是一样的，可以看成是在进程1开始发生压栈动作（写操作)之前都和进程0共用了一个物理栈.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr,<span class="type">long</span> ebp,<span class="type">long</span> edi,<span class="type">long</span> esi,<span class="type">long</span> gs,<span class="type">long</span> none,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> ebx,<span class="type">long</span> ecx,<span class="type">long</span> edx,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> fs,<span class="type">long</span> es,<span class="type">long</span> ds,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> eip,<span class="type">long</span> cs,<span class="type">long</span> eflags,<span class="type">long</span> esp,<span class="type">long</span> ss)</span><span class="comment">//调用的时候传参是在压栈的时候就干了的所以看上去好像没传参数</span></span><br><span class="line">&#123;</span><br><span class="line">      ...</span><br><span class="line">    p-&gt;tss.esp = esp;</span><br><span class="line">	p-&gt;tss.ebp = ebp;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>并且注意到在复制页表的时候：也就是说进程0比较特殊，他仍具有写权限，==所以进程0在创建进程1以后执行pause的时候不会触发copy
on write的写时复制==，这一点非常关键。所以进程1从fork return
后使用的用户栈就是进程0那个有pause返回地址的栈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_page_tables</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> from,<span class="type">unsigned</span> <span class="type">long</span> to,<span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (this_page &gt; LOW_MEM) &#123;<span class="comment">//1MB以内的内核区域不参与用户分页管理</span></span><br><span class="line">				*from_page_table = this_page;<span class="comment">//一般都是父子进程同时变成只读的，但是因为有LOW——MEM所以进程0还是可读写，进程1变成只读</span></span><br><span class="line">				this_page -= LOW_MEM;</span><br><span class="line">				this_page &gt;&gt;= <span class="number">12</span>; <span class="comment">//</span></span><br><span class="line">				mem_map[this_page]++; <span class="comment">//增加引用计数，说明这个页被这个进程占用了</span></span><br><span class="line">			&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>因为代码不是inline的所以进程1走到<code>return (type) __res; \</code>的时候，发生return引发清栈和恢复现场的操作，此时因为fork的已经清了，返回地址就变长了pause的返回地址，进程1出来就不会走init而是卡死在了pause里面，因为此时eax并不是按照需要等于非0，所以程序跑飞，会出现问题。</p>
<h4 id="小附加有没有可能正好正常">小附加：有没有可能正好正常</h4>
<p>有可能。上面讨论的是进程0规规矩矩的执行到pause以后进程1调度的情况。实际上还有可能存在：</p>
<p>进程0从fork出来且还没有进入pause的时候（为什么不能是执行完copy_process且还没有执行完fork的时候切换：因为在内核态，不允许进程切换）进程0的时间片就没有进程1足了，此时在发生时钟中断，do_timer的时候，就会发生调度，切换到进程1</p>
<p>此时进程0的栈里面已经没有fork了，但是注意清栈的操作是esp向高地址移动，而数据本身并没有从内存中抹去。由于在进程1创建的时候，复制的是进程1有fork的返回值的时候的esp，因此此时的情景是这样的：</p>
<figure>
<img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/用户栈变化.png" alt="用户栈变化">
<figcaption aria-hidden="true">用户栈变化</figcaption>
</figure>
<p>所有尽管进程0已经清栈了，但是此时数据还没有被覆盖。此时进程1的用户栈里面还有fork的返回后地址。在进程1fork
ret返回时可以回到正确的位置，当进程1使用自己的栈的时候，会发生写时复制，进程1和0的栈彻底分成两个。</p>
<p><strong>为啥有的时候行有的时候不行</strong></p>
<p>因为操作系统调度是根据时间片进行的，而不是指令数。时间比较依赖cpu
硬件或虚拟机类型</p>
<h3 id="代码测试">代码测试</h3>
<h2 id="只去掉pause的inline">只去掉pause的inline</h2>
<h3 id="理论分析-1">理论分析</h3>
<p>当去掉pause的inline的时候，当进程0执行到pause的时候切到进程1，执行·fork的返回，此时因为fork是inlie的所以进程1可以正常的执行到if(!fork)的位置，执行init()，此时进程1要为init建立函数栈，要进行写操作，发生copy
on write。</p>
<h3 id="代码测试-1">代码测试</h3>
<h2 id="只去掉fork的inline">只去掉fork的inline</h2>
<h3 id="理论分析-2">理论分析</h3>
<p>去掉fork的inline的时候，当进程0执行到pause的时候切到进程1，因为pause是inline的所以进程0虽然执行了pause但是不会把pause的返回地址压入栈中，所以此时用户栈和下图是一致的，进程1执行的时候可以正常跳到if(!fork（）)继续执行</p>
<figure>
<img src="/2023/12/02/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%20%E9%87%8C%E9%9D%A2%E7%9A%84%20inline%20%E9%97%AE%E9%A2%98/pause_inlie.png" alt="用户栈变化">
<figcaption aria-hidden="true">用户栈变化</figcaption>
</figure>
<h3 id="代码测试-2">代码测试</h3>
<h2 id="小结关键点">小结关键点</h2>
<p>内存：代码区，静态数据区。动态数据区 cpu：eip（指向下一条指令）
ebp（栈底） esp（栈顶指针）
函数调用时，参数入栈顺序，从右向左），函数调用的时候首先将传参压入数据栈中。
然后将函数执行完的返回地址压栈，保存main函数的栈底（压栈），ebp挪到fun函数栈底，运行函数程序
函数局部变量压栈。
函数返回，根据栈中内容恢复现场，函数传参已经没用了，进行清栈。
用的是用户栈，是共用一个栈：理由copy page tables
进程0完全复制给进程1了，因此物理内存是一个物理内存，线性地址空间不一样，但是物理空间一样，所以可以看成共用一个栈，当发生写时复制才变两个栈，因为进程0本来是可读写的所以没导致copy
on write 所以还是共用了一个栈。 注意：进程0的压栈没有导致写时复制
为啥卡在pause？
因为进程0压栈了fork和pause的返回地址，但是fork返回了就清栈了，所以现在栈里面就是pause所以fork跳出来的时候返回到pause里面去了
有没有可能跑对？有可能
为啥有的时候行有的时候不行，因为操作系统调度是根据时间片进行的，而不是指令数。时间比较依赖cpu
硬件或虚拟机类型 当前进程有tss switch to 里面也有一套tss</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>LINUX011内核学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>do_execve与进程34的生前死后</title>
    <url>/2023/11/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="第四章笔记">第四章笔记</h1>
<h2 id="打开终端设备文件及复制文件句柄">打开终端设备文件及复制文件句柄</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> pid,i;</span><br><span class="line"></span><br><span class="line">	setup((<span class="type">void</span> *) &amp;drive_info);</span><br><span class="line">	(<span class="type">void</span>) open(<span class="string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="number">0</span>);<span class="comment">//创建标准输入设备</span></span><br><span class="line">	(<span class="type">void</span>) dup(<span class="number">0</span>);<span class="comment">//创建标准输出设备</span></span><br><span class="line">	(<span class="type">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename, <span class="type">int</span> flag, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="type">int</span> res;</span><br><span class="line">	va_list arg;</span><br><span class="line"></span><br><span class="line">	va_start(arg,flag);</span><br><span class="line">	__asm__(<span class="string">&quot;int $0x80&quot;</span></span><br><span class="line">		:<span class="string">&quot;=a&quot;</span> (res)</span><br><span class="line">		:<span class="string">&quot;0&quot;</span> (__NR_open),<span class="string">&quot;b&quot;</span> (filename),<span class="string">&quot;c&quot;</span> (flag),</span><br><span class="line">		<span class="string">&quot;d&quot;</span> (va_arg(arg,<span class="type">int</span>)));</span><br><span class="line">	<span class="keyword">if</span> (res&gt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	errno = -res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在GCC中的内联汇编中，数值操作数约束（numeric operand
constraints）如<code>"0"</code>用于指定汇编代码的输入和输出寄存器。该数字指的是操作数在操作数列表中的位置。</p>
<p>在这个上下文中，<code>"0"</code>特指第一个操作数约束，也被称为“约束0”（constraint
0）。在x86调用约定中，EAX寄存器通常用于从函数中返回值。通过将<code>"0"</code>指定为输出操作数的约束（<code>"=a" (res)</code>），编译器得知在内联汇编块之后，EAX寄存器中的值应该赋给变量<code>res</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">int</span> flag,<span class="type">int</span> mode)</span> <span class="comment">//filename &quot;/dev/tty0&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">f</span>;</span></span><br><span class="line">	<span class="type">int</span> i,fd;</span><br><span class="line"></span><br><span class="line">	mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line">	<span class="comment">//打开文件的进程是当前进程，在filep里面找一个空闲项</span></span><br><span class="line">	<span class="keyword">for</span>(fd=<span class="number">0</span> ; fd&lt;NR_OPEN ; fd++) <span class="comment">// #define NR_OPEN 20</span></span><br><span class="line">		<span class="keyword">if</span> (!current-&gt;filp[fd])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span> (fd&gt;=NR_OPEN)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	current-&gt;close_on_exec &amp;= ~(<span class="number">1</span>&lt;&lt;fd);</span><br><span class="line">	f=<span class="number">0</span>+file_table;</span><br><span class="line">	<span class="comment">//找完找file table，引用计数为0的空闲项</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_FILE ; i++,f++)<span class="comment">//#define NR_FILE 64</span></span><br><span class="line">		<span class="keyword">if</span> (!f-&gt;f_count) <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span> (i&gt;=NR_FILE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	(current-&gt;filp[fd]=f)-&gt;f_count++;<span class="comment">//当前进程的空闲的filep的哪一项指向空闲的file table里面的项，引用计数++</span></span><br><span class="line">	<span class="comment">//读i结点，filename：sysopen的参数const char*类型，返回给inode</span></span><br><span class="line">	<span class="comment">//如果open_namei成功返回0，失败返回1</span></span><br><span class="line">	<span class="keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">		f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* ttys are somewhat special (ttyxx major==4, tty major==5) */</span></span><br><span class="line">	<span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))<span class="comment">//tty0是设备文件</span></span><br><span class="line">        <span class="comment">//设备文件的设备号放在i_zone[0]里面</span></span><br><span class="line">		<span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">4</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				current-&gt;tty = MINOR(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">				tty_table[current-&gt;tty].pgrp = current-&gt;pgrp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">5</span>)</span><br><span class="line">			<span class="keyword">if</span> (current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				iput(inode);</span><br><span class="line">				current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">				f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> -EPERM;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">/* Likewise with block-devices: check for floppy_change */</span></span><br><span class="line">	<span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line">		check_disk_change(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">	f-&gt;f_mode = inode-&gt;i_mode;</span><br><span class="line">	f-&gt;f_flags = flag;</span><br><span class="line">	f-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">	f-&gt;f_inode = inode;</span><br><span class="line">	f-&gt;f_pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程2">进程2</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d buffers = %d bytes buffer space\n\r&quot;</span>,NR_BUFFERS,</span><br><span class="line">		NR_BUFFERS*BLOCK_SIZE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Free mem: %d bytes\n\r&quot;</span>,memory_end-main_memory_start);</span><br><span class="line">	<span class="keyword">if</span> (!(pid=fork())) &#123;</span><br><span class="line">        <span class="comment">//  进程2：</span></span><br><span class="line">		close(<span class="number">0</span>);<span class="comment">//关闭设备标准输入</span></span><br><span class="line">		<span class="keyword">if</span> (open(<span class="string">&quot;/etc/rc&quot;</span>,O_RDONLY,<span class="number">0</span>))</span><br><span class="line">			_exit(<span class="number">1</span>);</span><br><span class="line">		execve(<span class="string">&quot;/bin/sh&quot;</span>,argv_rc,envp_rc); <span class="comment">//走syscall3，需要打开的执行文件和环境变量</span></span><br><span class="line">		_exit(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pid&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="comment">//进程1等待子进程退出</span></span><br><span class="line">		<span class="keyword">while</span> (pid != wait(&amp;i))</span><br><span class="line">			<span class="comment">/* nothing */</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((pid=fork())&lt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Fork failed in init\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!pid) &#123;</span><br><span class="line">			close(<span class="number">0</span>);close(<span class="number">1</span>);close(<span class="number">2</span>);</span><br><span class="line">			setsid();</span><br><span class="line">			(<span class="type">void</span>) open(<span class="string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">			(<span class="type">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">			(<span class="type">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">			_exit(execve(<span class="string">&quot;/bin/sh&quot;</span>,argv,envp));</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sys_waitpid">sys_waitpid</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_TASK task[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_TASK task[NR_TASKS-1]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_waitpid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">unsigned</span> <span class="type">long</span> * stat_addr, <span class="type">int</span> options)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> flag, code;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	verify_area(stat_addr,<span class="number">4</span>);</span><br><span class="line">repeat:</span><br><span class="line">	flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!*p || *p == current) <span class="comment">// 跳过空项和本进程项。</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> ((*p)-&gt;father != current-&gt;pid)<span class="comment">// 如果不是当前进程的子进程则跳过。 </span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"> <span class="comment">// 此时扫描选择到的进程 p 肯定是当前进程的子进程。 </span></span><br><span class="line"> <span class="comment">// 如果等待的子进程号 pid&gt;0，但与被扫描子进程 p 的 pid 不相等，说明它是当前进程另外的子进程， </span></span><br><span class="line"> <span class="comment">// 于是跳过该进程，接着扫描下一个进程。</span></span><br><span class="line">		<span class="keyword">if</span> (pid&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((*p)-&gt;pid != pid)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 否则，如果指定等待进程的 pid=0，表示正在等待进程组号等于当前进程组号的任何子进程。如果 </span></span><br><span class="line"> <span class="comment">// 此时被扫描进程 p 的进程组号与当前进程的组号不等，则跳过。 </span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pid) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((*p)-&gt;pgrp != current-&gt;pgrp)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 否则，如果指定的 pid&lt;-1，表示正在等待进程组号等于 pid 绝对值的任何子进程。如果此时被扫描 </span></span><br><span class="line"> <span class="comment">// 进程 p 的组号与 pid 的绝对值不等，则跳过。 </span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((*p)-&gt;pgrp != -pid)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// 如果前 3 个对 pid 的判断都不符合，则表示当前进程正在等待其任何子进程，也即 pid=-1 的情况。 </span></span><br><span class="line"> <span class="comment">// 此时所选择到的进程 p 正是所等待的子进程。接下来根据这个子进程 p 所处的状态来处理。</span></span><br><span class="line">		<span class="keyword">switch</span> ((*p)-&gt;state) &#123;</span><br><span class="line"><span class="comment">// 子进程 p 处于停止状态时，如果此时 WUNTRACED 标志没有置位，表示程序无须立刻返回，于是继续 </span></span><br><span class="line"><span class="comment">// 扫描处理其它进程。如果 WUNTRACED 置位，则把状态信息 0x7f 放入*stat_addr，并立刻返回子进程 </span></span><br><span class="line"><span class="comment">// 号 pid。这里 0x7f 表示的返回状态使 WIFSTOPPED()宏为真。参见 include/sys/wait.h，14 行</span></span><br><span class="line">			<span class="keyword">case</span> TASK_STOPPED:<span class="comment">//进程2处于停止状态</span></span><br><span class="line">				<span class="keyword">if</span> (!(options &amp; WUNTRACED))</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				put_fs_long(<span class="number">0x7f</span>,stat_addr);</span><br><span class="line">				<span class="keyword">return</span> (*p)-&gt;pid;</span><br><span class="line"><span class="comment">// 如果子进程 p 处于僵死状态，则首先把它在用户态和内核态运行的时间分别累计到当前进程（父进程） </span></span><br><span class="line"> <span class="comment">// 中，然后取出子进程的 pid 和退出码，并释放该子进程。最后返回子进程的退出码和 pid。</span></span><br><span class="line">			<span class="keyword">case</span> TASK_ZOMBIE:<span class="comment">//进程2属于僵死状态</span></span><br><span class="line">				current-&gt;cutime += (*p)-&gt;utime;</span><br><span class="line">				current-&gt;cstime += (*p)-&gt;stime;</span><br><span class="line">				flag = (*p)-&gt;pid;</span><br><span class="line">				code = (*p)-&gt;exit_code;</span><br><span class="line">				release(*p);</span><br><span class="line">				put_fs_long(code,stat_addr);</span><br><span class="line">				<span class="keyword">return</span> flag;</span><br><span class="line"><span class="comment">// 如果这个子进程 p 的状态既不是停止也不是僵死，那么就置 flag=1。表示找到过一个符合要求的 </span></span><br><span class="line"> <span class="comment">// 子进程，但是它处于运行态或睡眠态。</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 在上面对任务数组扫描结束后，如果 flag 被置位，说明有符合等待要求的子进程并没有处于退出 </span></span><br><span class="line"> <span class="comment">// 或僵死状态。如果此时已设置 WNOHANG 选项（表示若没有子进程处于退出或终止态就立刻返回）， </span></span><br><span class="line"> <span class="comment">// 就立刻返回 0，退出。否则把当前进程置为可中断等待状态并重新执行调度。 	</span></span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		<span class="keyword">if</span> (options &amp; WNOHANG)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		current-&gt;state=TASK_INTERRUPTIBLE;<span class="comment">//// 置当前进程为可中断等待状态。</span></span><br><span class="line">		schedule();<span class="comment">// 重新调度。</span></span><br><span class="line"><span class="comment">// 当又开始执行本进程时，如果本进程没有收到除 SIGCHLD 以外的信号，则还是重复处理。否则， </span></span><br><span class="line"> <span class="comment">// 返回出错码并退出。</span></span><br><span class="line">		<span class="keyword">if</span> (!(current-&gt;signal &amp;= ~(<span class="number">1</span>&lt;&lt;(SIGCHLD<span class="number">-1</span>))))</span><br><span class="line">			<span class="keyword">goto</span> repeat;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> -EINTR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -ECHILD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="启动shell-进程2">启动shell （进程2）</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!(pid=fork())) &#123;</span><br><span class="line">		close(<span class="number">0</span>);<span class="comment">//关闭设备标准输入</span></span><br><span class="line">		<span class="keyword">if</span> (open(<span class="string">&quot;/etc/rc&quot;</span>,O_RDONLY,<span class="number">0</span>))<span class="comment">//用rc文件替换标准输入文件</span></span><br><span class="line">			_exit(<span class="number">1</span>);</span><br><span class="line">		execve(<span class="string">&quot;/bin/sh&quot;</span>,argv_rc,envp_rc); <span class="comment">//走syscall3，需要打开的执行文件和环境变量，加载shell程序</span></span><br><span class="line">        <span class="comment">//argv_rc是参数，envp_rc是环境变量</span></span><br><span class="line">		_exit(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>execve会对应到</p>
<h4 id="sys_execve">_sys_execve</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_sys_execve:</span><br><span class="line">	lea EIP(%esp),%eax #把EIP值所在栈空间的地址值压栈</span><br><span class="line">	pushl %eax</span><br><span class="line">	call _do_execve</span><br><span class="line">	addl $4,%esp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<h4 id="do_execve">do_execve</h4>
<figure>
<img src="/2023/11/28/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231219163930738.png" alt="栈空间与函数传参">
<figcaption aria-hidden="true">栈空间与函数传参</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_execve</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> * eip,<span class="type">long</span> tmp,<span class="type">char</span> * filename,</span></span><br><span class="line"><span class="params">	<span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">exec</span> <span class="title">ex</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> page[MAX_ARG_PAGES];</span><br><span class="line">	<span class="type">int</span> i,argc,envc;</span><br><span class="line">	<span class="type">int</span> e_uid, e_gid;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="type">int</span> sh_bang = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> p=PAGE_SIZE*MAX_ARG_PAGES<span class="number">-4</span>;</span><br><span class="line">    <span class="comment">// eip指向系统调用前的eip，eip[1]则指向cs，判断一下这时候的cs是不是用户的cs</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="number">0xffff</span> &amp; eip[<span class="number">1</span>]) != <span class="number">0x000f</span>)</span><br><span class="line">		panic(<span class="string">&quot;execve called from supervisor mode&quot;</span>);</span><br><span class="line">	<span class="comment">// 初始化参数和环境串空间的页面指针数组（表）。</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;MAX_ARG_PAGES ; i++)	<span class="comment">/* clear page-table */</span></span><br><span class="line">		page[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(inode=namei(filename))) <span class="comment">//获得文件i结点		/* get executables inode */</span></span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="comment">// 计算参数个数和环境变量个数。</span></span><br><span class="line">	argc = count(argv);</span><br><span class="line">	envc = count(envp);</span><br><span class="line"><span class="comment">// 执行文件必须是常规文件。若不是常规文件则置出错返回码，跳转到 exec_error2(第 347 行)。 	</span></span><br><span class="line">restart_interp:</span><br><span class="line">	<span class="keyword">if</span> (!S_ISREG(inode-&gt;i_mode)) &#123;	<span class="comment">/* must be regular file */</span></span><br><span class="line">		retval = -EACCES;</span><br><span class="line">		<span class="keyword">goto</span> exec_error2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以下检查被执行文件的执行权限。根据其属性(对应 i 节点的 uid 和 gid)，看本进程是否有权执行它。 </span></span><br><span class="line">	i = inode-&gt;i_mode;</span><br><span class="line">	e_uid = (i &amp; S_ISUID) ? inode-&gt;i_uid : current-&gt;euid;</span><br><span class="line">	e_gid = (i &amp; S_ISGID) ? inode-&gt;i_gid : current-&gt;egid;</span><br><span class="line">	<span class="keyword">if</span> (current-&gt;euid == inode-&gt;i_uid)</span><br><span class="line">		i &gt;&gt;= <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;egid == inode-&gt;i_gid)</span><br><span class="line">		i &gt;&gt;= <span class="number">3</span>;</span><br><span class="line">	<span class="comment">//检查权限</span></span><br><span class="line">	<span class="keyword">if</span> (!(i &amp; <span class="number">1</span>) &amp;&amp;</span><br><span class="line">	    !((inode-&gt;i_mode &amp; <span class="number">0111</span>) &amp;&amp; suser())) &#123;</span><br><span class="line">		retval = -ENOEXEC;</span><br><span class="line">		<span class="keyword">goto</span> exec_error2;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//拷贝可执行文件的第一块：就是文件头，有可执行文件的详细信息</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh = bread(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">0</span>]))) &#123;</span><br><span class="line">		retval = -EACCES;</span><br><span class="line">		<span class="keyword">goto</span> exec_error2;</span><br><span class="line">	&#125;</span><br><span class="line">	ex = *((<span class="keyword">struct</span> exec *) bh-&gt;b_data);	<span class="comment">/* read exec-header */</span></span><br><span class="line">	  <span class="comment">// 是脚脚本文件，不是编译后的文件,sh_bang控制只会进入一次</span></span><br><span class="line">	<span class="keyword">if</span> ((bh-&gt;b_data[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>) &amp;&amp; (bh-&gt;b_data[<span class="number">1</span>] == <span class="string">&#x27;!&#x27;</span>) &amp;&amp; (!sh_bang)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This section does the #! interpretation.</span></span><br><span class="line"><span class="comment">		 * Sorta complicated, but hopefully it will work.  -TYT</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> buf[<span class="number">1023</span>], *cp, *interp, *i_name, *i_arg;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> old_fs;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">strncpy</span>(buf, bh-&gt;b_data+<span class="number">2</span>, <span class="number">1022</span>);</span><br><span class="line">		brelse(bh);</span><br><span class="line">		iput(inode);</span><br><span class="line">		buf[<span class="number">1022</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (cp = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\n&#x27;</span>)) &#123;</span><br><span class="line">			*cp = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="keyword">for</span> (cp = buf; (*cp == <span class="string">&#x27; &#x27;</span>) || (*cp == <span class="string">&#x27;\t&#x27;</span>); cp++);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!cp || *cp == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">			retval = -ENOEXEC; <span class="comment">/* No interpreter name found */</span></span><br><span class="line">			<span class="keyword">goto</span> exec_error1;</span><br><span class="line">		&#125;</span><br><span class="line">		interp = i_name = cp;</span><br><span class="line">		i_arg = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> ( ; *cp &amp;&amp; (*cp != <span class="string">&#x27; &#x27;</span>) &amp;&amp; (*cp != <span class="string">&#x27;\t&#x27;</span>); cp++) &#123;</span><br><span class="line"> 			<span class="keyword">if</span> (*cp == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">				i_name = cp+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (*cp) &#123;</span><br><span class="line">			*cp++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			i_arg = cp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * OK, we&#x27;ve parsed out the interpreter name and</span></span><br><span class="line"><span class="comment">		 * (optional) argument.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (sh_bang++ == <span class="number">0</span>) &#123;</span><br><span class="line">			p = copy_strings(envc, envp, page, p, <span class="number">0</span>);</span><br><span class="line">			p = copy_strings(--argc, argv+<span class="number">1</span>, page, p, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Splice in (1) the interpreter&#x27;s name for argv[0]</span></span><br><span class="line"><span class="comment">		 *           (2) (optional) argument to interpreter</span></span><br><span class="line"><span class="comment">		 *           (3) filename of shell script</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This is done in reverse order, because of how the</span></span><br><span class="line"><span class="comment">		 * user environment and arguments are stored.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		p = copy_strings(<span class="number">1</span>, &amp;filename, page, p, <span class="number">1</span>);</span><br><span class="line">		argc++;</span><br><span class="line">		<span class="keyword">if</span> (i_arg) &#123;</span><br><span class="line">			p = copy_strings(<span class="number">1</span>, &amp;i_arg, page, p, <span class="number">2</span>);</span><br><span class="line">			argc++;</span><br><span class="line">		&#125;</span><br><span class="line">		p = copy_strings(<span class="number">1</span>, &amp;i_name, page, p, <span class="number">2</span>);</span><br><span class="line">		argc++;</span><br><span class="line">		<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">			retval = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> exec_error1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * OK, now restart the process with the interpreter&#x27;s inode.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		old_fs = get_fs();</span><br><span class="line">		set_fs(get_ds());</span><br><span class="line">		<span class="keyword">if</span> (!(inode=namei(interp))) &#123; <span class="comment">/* get executables inode */</span></span><br><span class="line">			set_fs(old_fs);</span><br><span class="line">			retval = -ENOENT;</span><br><span class="line">			<span class="keyword">goto</span> exec_error1;</span><br><span class="line">		&#125;</span><br><span class="line">		set_fs(old_fs);</span><br><span class="line">		<span class="keyword">goto</span> restart_interp;</span><br><span class="line">	&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="comment">//通过检查文件头信息判断该执行文件是否和要求</span></span><br><span class="line">	<span class="keyword">if</span> (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||</span><br><span class="line">		ex.a_text+ex.a_data+ex.a_bss&gt;<span class="number">0x3000000</span> ||</span><br><span class="line">		inode-&gt;i_size &lt; ex.a_text+ex.a_data+ex.a_syms+N_TXTOFF(ex)) &#123;</span><br><span class="line">		retval = -ENOEXEC;</span><br><span class="line">		<span class="keyword">goto</span> exec_error2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//文件头大小不等于1k也不能执行</span></span><br><span class="line">	<span class="keyword">if</span> (N_TXTOFF(ex) != BLOCK_SIZE) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s: N_TXTOFF != BLOCK_SIZE. See a.out.h.&quot;</span>, filename);</span><br><span class="line">		retval = -ENOEXEC;</span><br><span class="line">		<span class="keyword">goto</span> exec_error2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果不是脚本文件</span></span><br><span class="line">	<span class="keyword">if</span> (!sh_bang) &#123;</span><br><span class="line">		p = copy_strings(envc,envp,page,p,<span class="number">0</span>);<span class="comment">//将环境变量复制到进程空间</span></span><br><span class="line">		p = copy_strings(argc,argv,page,p,<span class="number">0</span>);<span class="comment">//将参数复制到进程空间</span></span><br><span class="line">		<span class="comment">// 如果 p=0，则表示环境变量与参数空间页面已经被占满，容纳不下了。转至出错处理处。 </span></span><br><span class="line">		<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">			retval = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> exec_error2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* OK, This is the point of no return */</span></span><br><span class="line"><span class="comment">// 如果原程序也是一个执行程序，则释放其 i 节点，并让进程 executable 字段指向新程序 i 节点。</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;executable)</span><br><span class="line">		iput(current-&gt;executable);</span><br><span class="line">	current-&gt;executable = inode;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;<span class="number">32</span> ; i++)</span><br><span class="line">		current-&gt;sigaction[i].sa_handler = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_OPEN ; i++)</span><br><span class="line">		<span class="keyword">if</span> ((current-&gt;close_on_exec&gt;&gt;i)&amp;<span class="number">1</span>)</span><br><span class="line">			sys_close(i);</span><br><span class="line">	current-&gt;close_on_exec = <span class="number">0</span>;<span class="comment">//将原来共享的文件脱钩</span></span><br><span class="line">	<span class="comment">// 根据指定的基地址和限长，释放原来进程代码段和数据段所对应的内存页表指定的内存块及页表本身。 </span></span><br><span class="line">   <span class="comment">// 此时被执行程序没有占用主内存区任何页面。在执行时会引起内存管理程序执行缺页处理而为其申请 </span></span><br><span class="line">   <span class="comment">// 内存页面，并把程序读入内存。</span></span><br><span class="line">	<span class="comment">//脱掉的是用户代码，现在运行的是内核的代码</span></span><br><span class="line">	free_page_tables(get_base(current-&gt;ldt[<span class="number">1</span>]),get_limit(<span class="number">0x0f</span>));<span class="comment">//脱钩</span></span><br><span class="line">	free_page_tables(get_base(current-&gt;ldt[<span class="number">2</span>]),get_limit(<span class="number">0x17</span>));</span><br><span class="line">	<span class="comment">// 如果“上次任务使用了协处理器”指向的是当前进程，则将其置空，并复位使用了协处理器的标志。 </span></span><br><span class="line">	<span class="keyword">if</span> (last__used_math == current)</span><br><span class="line">		last__used_math = <span class="literal">NULL</span>;</span><br><span class="line">	current-&gt;used_math = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//重置该进程的ldt</span></span><br><span class="line"><span class="comment">// 根据 a_text 修改局部表中描述符基址和段限长，并将参数和环境空间页面放置在数据段末端。 </span></span><br><span class="line"><span class="comment">// 执行下面语句之后，p 此时是以数据段起始处为原点的偏移值，仍指向参数和环境空间数据开始处， </span></span><br><span class="line"><span class="comment">// 也即转换成为堆栈的指针。</span></span><br><span class="line">	p += change_ldt(ex.a_text,page)-MAX_ARG_PAGES*PAGE_SIZE;</span><br><span class="line"><span class="comment">// create_tables()在新用户堆栈中创建环境和参数变量指针表，并返回该堆栈指针。</span></span><br><span class="line">	p = (<span class="type">unsigned</span> <span class="type">long</span>) create_tables((<span class="type">char</span> *)p,argc,envc);</span><br><span class="line"><span class="comment">// 修改当前进程各字段为新执行程序的信息。令进程代码段尾值字段 end_code = a_text；令进程数据 </span></span><br><span class="line"><span class="comment">// 段尾字段 end_data = a_data + a_text；令进程堆结尾字段 brk = a_text + a_data + a_bss。</span></span><br><span class="line">	current-&gt;brk = ex.a_bss +</span><br><span class="line">		(current-&gt;end_data = ex.a_data +</span><br><span class="line">		(current-&gt;end_code = ex.a_text));</span><br><span class="line"><span class="comment">// 设置进程堆栈开始字段为堆栈指针所在的页面，并重新设置进程的有效用户 id 和有效组 id。 </span></span><br><span class="line">	current-&gt;start_stack = p &amp; <span class="number">0xfffff000</span>;</span><br><span class="line">	current-&gt;euid = e_uid;</span><br><span class="line">	current-&gt;egid = e_gid;</span><br><span class="line">	i = ex.a_text+ex.a_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i&amp;<span class="number">0xfff</span>)</span><br><span class="line">		put_fs_byte(<span class="number">0</span>,(<span class="type">char</span> *) (i++));</span><br><span class="line"><span class="comment">// 将原调用系统中断的程序在堆栈上的代码指针替换为指向新执行程序的入口点，并将堆栈指针替换 </span></span><br><span class="line"><span class="comment">// 为新执行程序的堆栈指针。返回指令将弹出这些堆栈数据并使得 CPU 去执行新的执行程序，因此不会 </span></span><br><span class="line"><span class="comment">// 返回到原调用系统中断的程序中去了。		</span></span><br><span class="line">	eip[<span class="number">0</span>] = ex.a_entry;<span class="comment">//int 80 的返回地址改成了可执行文件的入口地址		/* eip, magic happens :-) */</span></span><br><span class="line">	eip[<span class="number">3</span>] = p;			<span class="comment">/* stack pointer */</span> <span class="comment">//没经过调度一口气就到执行函数的main函数了</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">exec_error2:</span><br><span class="line">	iput(inode);</span><br><span class="line">exec_error1:</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;MAX_ARG_PAGES ; i++)</span><br><span class="line">		free_page(page[i]);</span><br><span class="line">	<span class="keyword">return</span>(retval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="shell执行">shell执行</h2>
<p>shell开始执行后，因为其线性地址空间对应的程序内容没有加载，所以会发生页异常中断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_page_fault:</span><br><span class="line">	xchgl %eax,(%esp)</span><br><span class="line">	pushl %ecx</span><br><span class="line">	pushl %edx</span><br><span class="line">	push %ds</span><br><span class="line">	push %es</span><br><span class="line">	push %fs</span><br><span class="line">	movl $0x10,%edx</span><br><span class="line">	mov %dx,%ds</span><br><span class="line">	mov %dx,%es</span><br><span class="line">	mov %dx,%fs</span><br><span class="line">	movl %cr2,%edx</span><br><span class="line">	pushl %edx</span><br><span class="line">	pushl %eax</span><br><span class="line">	testl $1,%eax</span><br><span class="line">	jne 1f</span><br><span class="line">	call _do_no_page</span><br><span class="line">	jmp 2f</span><br><span class="line">1:	call _do_wp_page</span><br><span class="line">2:	addl $8,%esp</span><br><span class="line">	pop %fs</span><br><span class="line">	pop %es</span><br><span class="line">	pop %ds</span><br><span class="line">	popl %edx</span><br><span class="line">	popl %ecx</span><br><span class="line">	popl %eax</span><br><span class="line">	iret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="do_no_page">do_no_page</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_no_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> error_code,<span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nr[<span class="number">4</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tmp;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> page;</span><br><span class="line">	<span class="type">int</span> block,i;</span><br><span class="line"></span><br><span class="line">	address &amp;= <span class="number">0xfffff000</span>;<span class="comment">//找到页的头</span></span><br><span class="line">	tmp = address - current-&gt;start_code; <span class="comment">//在创建进程的时候，在copy_mem函数里面将 current-&gt;start_code设置为程序的段基址</span></span><br><span class="line">	<span class="keyword">if</span> (!current-&gt;executable || tmp &gt;= current-&gt;end_data) &#123;</span><br><span class="line">		get_empty_page(address);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (share_page(tmp))<span class="comment">//判断是否共享</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(page = get_free_page())) <span class="comment">//申请新的页</span></span><br><span class="line">		oom();</span><br><span class="line"><span class="comment">/* remember that 1 block is used for header */</span></span><br><span class="line">	block = <span class="number">1</span> + tmp/BLOCK_SIZE;<span class="comment">//计算块号，+1是还有文件头</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;<span class="number">4</span> ; block++,i++)<span class="comment">//4是一页对应4块</span></span><br><span class="line">		nr[i] = bmap(current-&gt;executable,block);</span><br><span class="line">	bread_page(page,current-&gt;executable-&gt;i_dev,nr);</span><br><span class="line">	<span class="comment">//对超出部分进行处理</span></span><br><span class="line">	i = tmp + <span class="number">4096</span> - current-&gt;end_data;</span><br><span class="line">	tmp = page + <span class="number">4096</span>;</span><br><span class="line">	<span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		tmp--;</span><br><span class="line">		*(<span class="type">char</span> *)tmp = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (put_page(page,address))<span class="comment">//将物理地址映射到线性地址空间</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	free_page(page);</span><br><span class="line">	oom();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建update-进程3">创建update （进程3）</h3>
<p>shell之前用rc替换了标准输入设备文件tty0</p>
<p>rc:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/update &amp;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/dev/hd1&quot;</span>&gt;/etc/mlab</span><br></pre></td></tr></table></figure>
<p>因此，此时shell会创建进程3：update，并加载，加载过程与创建shell的过程类似</p>
<p>update的功能：将缓冲区的数据同步到外设上，每隔一段时间这个进程就会被唤醒同步一下，再被挂起。</p>
<h3 id="shell退出">shell退出</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">int</span> error_code)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_exit((error_code&amp;<span class="number">0xff</span>)&lt;&lt;<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_exit</span><span class="params">(<span class="type">long</span> code)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//释放进程的代码段和数据段，释放进程</span></span><br><span class="line">	free_page_tables(get_base(current-&gt;ldt[<span class="number">1</span>]),get_limit(<span class="number">0x0f</span>));</span><br><span class="line">	free_page_tables(get_base(current-&gt;ldt[<span class="number">2</span>]),get_limit(<span class="number">0x17</span>));</span><br><span class="line">	<span class="comment">//检查是否有子进程</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_TASKS ; i++)</span><br><span class="line">		<span class="keyword">if</span> (task[i] &amp;&amp; task[i]-&gt;father == current-&gt;pid) &#123;</span><br><span class="line">			<span class="comment">//在退出前将子进程的父进程设为1</span></span><br><span class="line">			task[i]-&gt;father = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (task[i]-&gt;state == TASK_ZOMBIE)</span><br><span class="line">				<span class="comment">/* assumption task[1] is always init */</span></span><br><span class="line">				<span class="comment">//如果子进程处于僵死状态，向父进程发送终止信号</span></span><br><span class="line">				(<span class="type">void</span>) send_sig(SIGCHLD, task[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//接触进程和其它文件的关系</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_OPEN ; i++)</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;filp[i])</span><br><span class="line">			sys_close(i);</span><br><span class="line">	iput(current-&gt;pwd);</span><br><span class="line">	current-&gt;pwd=<span class="literal">NULL</span>;</span><br><span class="line">	iput(current-&gt;root);</span><br><span class="line">	current-&gt;root=<span class="literal">NULL</span>;</span><br><span class="line">	iput(current-&gt;executable);</span><br><span class="line">	current-&gt;executable=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty &gt;= <span class="number">0</span>)</span><br><span class="line">		tty_table[current-&gt;tty].pgrp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">		last_task_used_math = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (current-&gt;leader)</span><br><span class="line">		kill_session();</span><br><span class="line">	current-&gt;state = TASK_ZOMBIE;<span class="comment">//将当前进程设置为僵死状态</span></span><br><span class="line">	current-&gt;exit_code = code;</span><br><span class="line">	tell_father(current-&gt;father);<span class="comment">//给父进程发送信号通知它本进程要退出</span></span><br><span class="line">	schedule();<span class="comment">//进程切换</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">-1</span>);	<span class="comment">/* just to suppress warnings */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程1执行wait-pid">进程1执行wait pid</h3>
<p>之前进程1在等待shell进程2退出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pid&gt;<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">while</span> (pid != wait(&amp;i))</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_waitpid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">unsigned</span> <span class="type">long</span> * stat_addr, <span class="type">int</span> options)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">switch</span> ((*p)-&gt;state) &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//退出的shell进程属于僵死状态</span></span><br><span class="line">			<span class="keyword">case</span> TASK_ZOMBIE:<span class="comment">//进程2属于僵死状态</span></span><br><span class="line">				current-&gt;cutime += (*p)-&gt;utime;</span><br><span class="line">				current-&gt;cstime += (*p)-&gt;stime;</span><br><span class="line">                <span class="comment">//记录shell的进程号</span></span><br><span class="line">				flag = (*p)-&gt;pid;</span><br><span class="line">				code = (*p)-&gt;exit_code;</span><br><span class="line">				release(*p); <span class="comment">//释放shell进程的task struct</span></span><br><span class="line">				put_fs_long(code,stat_addr);</span><br><span class="line">				<span class="keyword">return</span> flag;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> task_struct * p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span> ; i&lt;NR_TASKS ; i++)</span><br><span class="line">		<span class="keyword">if</span> (task[i]==p) &#123;</span><br><span class="line">			task[i]=<span class="literal">NULL</span>;</span><br><span class="line">			free_page((<span class="type">long</span>)p);</span><br><span class="line">			schedule();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	panic(<span class="string">&quot;trying to release non-existent task&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由此可见子进程的task struct资源在退出的时候是由父进程释放的</p>
<p>返回init：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pid&gt;<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">while</span> (pid != wait(&amp;i))</span><br></pre></td></tr></table></figure>
<p>创建完pid2的时候pid=2，wait退出后返回flag=2，所以退出while循环</p>
<h2 id="重建shell进程4">重建shell（进程4）</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((pid=fork())&lt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Fork failed in init\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!pid) &#123;<span class="comment">//重启shell</span></span><br><span class="line">			close(<span class="number">0</span>);close(<span class="number">1</span>);close(<span class="number">2</span>);<span class="comment">//新的shell进程关闭所有打开的文件</span></span><br><span class="line">			setsid();<span class="comment">//创建新的会话</span></span><br><span class="line">			(<span class="type">void</span>) open(<span class="string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="number">0</span>);<span class="comment">//重新打开标准输入设备文件</span></span><br><span class="line">			(<span class="type">void</span>) dup(<span class="number">0</span>);<span class="comment">//重新打开标准输出设备文件</span></span><br><span class="line">			(<span class="type">void</span>) dup(<span class="number">0</span>);<span class="comment">//重新打开标准错误输出设备文件</span></span><br><span class="line">			_exit(execve(<span class="string">&quot;/bin/sh&quot;</span>,argv,envp));<span class="comment">//加载shell进程</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span> (pid == wait(&amp;i))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\rchild %d died with code %04x\n\r&quot;</span>,pid,i);</span><br><span class="line">		sync();</span><br><span class="line">	&#125;</span><br><span class="line">	_exit(<span class="number">0</span>);	<span class="comment">/* NOTE! _exit, not exit() */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前已经启动了update进程并将其变成进程1的子进程，每个一段时间会update一下。</p>
<p>在进入rw_char函数后，shell进程会被设为可中断等待状态，切换到进程0怠速。怠速后用户通过shell进程提供的端口和系统交互，</p>
<p>通过键盘输入信息存储到字符缓冲队列上，该缓冲队列上的内容就是tyy0文件的内容，shell会不断读取缓冲队列的信息。</p>
<p>如果用户没有下达指令，则缓冲队列为0，shell处于可中断等待状态。</p>
<p>如果用户下达指令，发送键盘中断，中断服务程序会将内容输入到缓冲队列，并给shell进程发信号信号将导致shell进程进入就绪状态被唤醒，处理缓冲队列里面的信息，处理完后又会被挂起。</p>
<h2 id="子进程执行可执行文件">子进程执行可执行文件</h2>
<p>要调整线性地址空间</p>
<ol type="1">
<li><p>fork</p></li>
<li><p>把代码和数据拷贝到进程的线性地址空间，通过缺页机制(虚拟拷贝)</p></li>
<li><p>虚拷贝：将硬盘的空间和进程内存的空间同构</p>
<p><code>unsigned long start_code,end_code,end_data,brk,start_stack;</code></p></li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>LINUX011内核学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程1的创建和运行与缓冲区相关操作</title>
    <url>/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="进程1的创建和运行与缓冲区相关操作">进程1的创建和运行与缓冲区相关操作</h1>
<h2 id="进程0创建进程1">进程0创建进程1</h2>
<p>在linux系统中所有进程都是基于父子进程创建机制，由父进程创建的。通过父进程调用fork函数实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> _syscall0(<span class="type">int</span>,fork) <span class="comment">//定义了fork函数</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(!fork())</span><br><span class="line">init();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="syscall0">syscall0</h3>
<p>执行fork函数实际是执行到unistd.h的syscall0（）：</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231021140609566.png" alt="image-20231021140609566">
<figcaption aria-hidden="true">image-20231021140609566</figcaption>
</figure>
<p>**_syscall0** 是一个宏定义，其实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall0(type,name) \</span></span><br><span class="line"><span class="meta">type name(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">long __res; \</span></span><br><span class="line"><span class="meta">__asm__ volatile (<span class="string">&quot;int $0x80&quot;</span> \</span></span><br><span class="line"><span class="meta">	: <span class="string">&quot;=a&quot;</span> (__res) \</span></span><br><span class="line"><span class="meta">	: <span class="string">&quot;0&quot;</span> (__NR_##name)); \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (__res &gt;= 0) \</span></span><br><span class="line"><span class="meta">	return (type) __res; \</span></span><br><span class="line"><span class="meta">errno = -__res; \</span></span><br><span class="line"><span class="meta">return -1; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>因此这里_syscall0(int,fork) 展开后是这样的：.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="type">long</span> __res; \</span><br><span class="line">__asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span> \ <span class="comment">//init 0x80是所有系统调用函数的总入口，fork是其中之一        </span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;=a&quot;</span> (__res) \ <span class="comment">//第一个冒号之后是输出部分，将_res赋值给eax</span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;0&quot;</span> (__NR_fork))</span>; \ <span class="comment">//第二个冒号后是输入部分，&quot;0&quot;同上寄存器，即eax ，__NR_fork=2，赋值给eax，紧接着就进行了0</span></span><br><span class="line">    <span class="comment">//x80软中断</span></span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \ <span class="comment">//int 0x80中断返回后，将执行这一句</span></span><br><span class="line">	<span class="keyword">return</span> (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__NR_fork=2，其实是描述了操作系统专用性的那几个函数，体现了操作系统的确定性。其定义了
<strong>fork</strong> 函数，其通过 <strong>0x80</strong>
中断进入系统调用。</p>
<p>在 Linux
内核中，每个系统调用都具有唯一的一个系统调用功能号。这些功能号定义在文件
include/unistd.h 中第 60 行开始处。例如，fork系统调用的功能号是
2，定义为符号 ___NR_fork 。这些系统调用功能号实际上对应于
include/linux/sys.h 中定义的系统调用处理程序指针数组表 sys_call_table[]
中项的索引值。因此 write() 系统调用的处理程序指针就位于该数组的项 2 处。
sys_call_table:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fn_ptr sys_call_table[] = &#123; sys_setup, sys_exit, sys_fork, sys_read,</span><br><span class="line">sys_write, ...(此处省略）) &#125;;</span><br></pre></td></tr></table></figure>
<p>当应用程序经过库函数向内核发出一个中断调用 int 0x80
时，就开始执行一个系统调用。其中寄存器 eax
中存放着系统调用号，而携带的参数可依次存放在寄存器 ebx、ecx 和 edx
中。因此 Linux 0.11
内核中用户程序能够向内核最多直接传递三个参数，当然也可以不带参数。上面fork就是向内核传了一个参数，处理系统调用中断
int 0x80 的过程是程序 kernel/system_call.s 中的 system_call 。</p>
<p>调用流程：</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231021142821942.png" alt="image-20231021142821942">
<figcaption aria-hidden="true">image-20231021142821942</figcaption>
</figure>
<p>调用int
$0x80cpu从三特权级转到0特权级，硬件对<strong>ss，ESP,EFLAGS,CS,EIP进行压栈</strong>，压栈的EIP指向当前指令的下一行即if(__res&gt;=0)这一行，这就是进程0从fork函数系统调用中断返回后执行的第一条指令位置。跳转到system_call执行：</p>
<h3 id="system_call">system_call</h3>
<p>system_call程序解读如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_system_call:</span><br><span class="line">	cmpl $nr_system_calls-1,%eax #判断是否越界了，系统调用一共72个（sys_call_table),eax 是传入参数，以fork为例传入的eax=2，是_NR_fork</span><br><span class="line">	ja bad_sys_call #如果越界了则跳到越界代码，中断返回，返回eax的值为-1，以fork为例代表创建失败</span><br><span class="line">	push %ds   #下面的6个push都是为了copy_process()的参数</span><br><span class="line">	push %es</span><br><span class="line">	push %fs</span><br><span class="line">	pushl %edx</span><br><span class="line">	pushl %ecx		# push %ebx,%ecx,%edx as parameters</span><br><span class="line">	pushl %ebx		# to the system call</span><br><span class="line">	movl $0x10,%edx		# set up ds,es to kernel space</span><br><span class="line">	mov %dx,%ds</span><br><span class="line">	mov %dx,%es</span><br><span class="line">	movl $0x17,%edx		# fs points to local data space</span><br><span class="line">	mov %dx,%fs</span><br><span class="line">	call _sys_call_table(,%eax,4) #通过查_sys_call_table确定要调用的函数，以fork为例，eax=2，这里就是</span><br><span class="line">	# call ( _sys_call_table+2*4),也就是_sys_fork的入口</span><br><span class="line">	pushl %eax</span><br><span class="line">	movl _current,%eax</span><br><span class="line">	cmpl $0,state(%eax)		# state</span><br><span class="line">	jne reschedule</span><br><span class="line">	cmpl $0,counte</span><br></pre></td></tr></table></figure>
<p>call _sys_call_table(,%eax,4)
#通过查_sys_call_table确定要调用的函数，以fork为例，eax=2，这里就是 call
(
_sys_call_table+2*4),偏移寻址，也就是_sys_fork的入口，因为sys_call_table的每一项都有四个字节，所有就是sys_call_table[2]</p>
<p><strong>注意</strong>：这里system_call函数还没执行完，因此调用sys_call_table会压栈保护现场，这里压栈体现在后面copy_process函数的第六个参数long
none</p>
<h3 id="sys_fork">sys_fork</h3>
<p>sys_fork 函数解析如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_sys_fork:</span><br><span class="line">	call _find_empty_process #调用找到空进程的函数</span><br><span class="line">	testl %eax,%eax #如果返回的是-EAGAIN说明已经有64个进程运行没有空进程 testl 是指令的名称，</span><br><span class="line">	#它用于执行逻辑“与”操作。测试%eax中的值，将结果存储在标志寄存器中，而不更改%eax的值。如果%eax中的值为零</span><br><span class="line">	#那么零标志位（ZF）将被设置为1；否则，ZF将被清除为0。</span><br><span class="line">	js 1f #跳转到ret</span><br><span class="line">	#1f 中的 1 表示标签的唯一标识符或编号。在某些汇编语言中，数字编号用于标识不同的标签，使程序员能够更容易地跟踪和管理它们。</span><br><span class="line">    # f 表示标签的类型。在汇编语言中，f 可能表示 &quot;forward&quot;，</span><br><span class="line">	# 表示这是一个向前跳转的标签。这意味着在程序执行期间，它将在后续的指令中使用，通常用于条件分支或循环的目标。</span><br><span class="line">	push %gs #这5个参数也作为copy_process的参数</span><br><span class="line">	pushl %esi</span><br><span class="line">	pushl %edi</span><br><span class="line">	pushl %ebp</span><br><span class="line">	pushl %eax</span><br><span class="line">	call _copy_process #调用赋值进程函数，这里call没有传参就是因为其实上面压栈的把参数压进去了</span><br><span class="line">	addl $20,%esp</span><br><span class="line">1:	ret</span><br></pre></td></tr></table></figure>
<h3 id="find_empty_process">find_empty_process</h3>
<p><strong>在task[64]中为进程1申请空闲位置并获取进程号</strong></p>
<p>sched_init()函数已经对task[64]除了o以外的项都清空了，这里调用函数得到的就是1，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EAGAIN 11</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_empty_process</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">     <span class="comment">//last_pid 只增不减，起个日志的作用</span></span><br><span class="line">	repeat:</span><br><span class="line">	    <span class="comment">//判断溢出</span></span><br><span class="line">		<span class="keyword">if</span> ((++last_pid)&lt;<span class="number">0</span>) </span><br><span class="line">		   last_pid=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span> ; i&lt;NR_TASKS ; i++)</span><br><span class="line">			<span class="keyword">if</span> (task[i] &amp;&amp; task[i]-&gt;pid == last_pid) </span><br><span class="line">			    <span class="keyword">goto</span> repeat;<span class="comment">//检测有没有进程号撞了</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span> ; i&lt;NR_TASKS ; i++)</span><br><span class="line">		<span class="keyword">if</span> (!task[i])</span><br><span class="line">			<span class="keyword">return</span> i;<span class="comment">//返回空进程</span></span><br><span class="line">	<span class="keyword">return</span> -EAGAIN; <span class="comment">//进程满了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231021194439886.png" alt="image-20231021194439886">
<figcaption aria-hidden="true">image-20231021194439886</figcaption>
</figure>
<h3 id="copy_process">copy_process</h3>
<p>一个函数的参数不是由函数定义的，而是由函数定义以外的程序通过压栈的方式做出来的，是操作系统底层代码与应用层代码的差异之一。</p>
<p><code>call _copy_process #调用赋值进程函数，这里call没有传参就是因为其实上面压栈的把参数压进去了</code></p>
<h4 id="输入参数的分析"><strong>输入参数的分析</strong>:</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc 编译器传参：进栈，在栈里面传参，从右到左压栈</span></span><br><span class="line"> <span class="comment">//none是现场保护，是call_system_table 还没运行完没出栈</span></span><br><span class="line"> <span class="comment">//nr是一，是返回的空闲进程号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr,<span class="type">long</span> ebp,<span class="type">long</span> edi,<span class="type">long</span> esi,<span class="type">long</span> gs,<span class="type">long</span> none,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> ebx,<span class="type">long</span> ecx,<span class="type">long</span> edx,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> fs,<span class="type">long</span> es,<span class="type">long</span> ds,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> eip,<span class="type">long</span> cs,<span class="type">long</span> eflags,<span class="type">long</span> esp,<span class="type">long</span> ss)</span><span class="comment">//调用的时候传参是在压栈的时候就干了的所以看上去好像没传参数</span></span><br></pre></td></tr></table></figure>
<p>gcc 编译器传参：进栈，在栈里面传参，从右到左压栈</p>
<p><code>long eip,long cs,long eflags,long esp,long ss</code>是指发生init
0x80软中断的时候cpu硬件压栈的，EIP指向当前指令的下一行即if(__res&gt;=0)这一行，这就是进程0从fork函数系统调用中断返回后执行的第一条指令位置，cs，是用户的代码段</p>
<p><code>long ebx,long ecx,long edx,long fs,long es,long ds</code>在systemcall里面被压栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   push %ds   #下面的6个push都是为了copy_process()的参数</span><br><span class="line">push %es</span><br><span class="line">push %fs</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ecx		# push %ebx,%ecx,%edx as parameters</span><br><span class="line">pushl %ebx		# to the system call</span><br></pre></td></tr></table></figure>
<p><code>long none</code> 是现场保护，是call_system_table
还没运行完没出栈</p>
<p><code>int nr,long ebp,long edi,long esi,long gs</code>是sys_fork里面的压栈部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   push %gs #这5个参数也作为copy_process的参数</span><br><span class="line">pushl %esi</span><br><span class="line">pushl %edi</span><br><span class="line">pushl %ebp</span><br><span class="line">pushl %eax</span><br></pre></td></tr></table></figure>
<p>eax是空闲进程号，对应nr</p>
<h4 id="为进程1创建task_struct将进程0的task_struct内容复制给1">为进程1创建task_struct,将进程0的task_struct内容复制给1</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr,<span class="type">long</span> ebp,<span class="type">long</span> edi,<span class="type">long</span> esi,<span class="type">long</span> gs,<span class="type">long</span> none,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> ebx,<span class="type">long</span> ecx,<span class="type">long</span> edx,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> fs,<span class="type">long</span> es,<span class="type">long</span> ds,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> eip,<span class="type">long</span> cs,<span class="type">long</span> eflags,<span class="type">long</span> esp,<span class="type">long</span> ss)</span><span class="comment">//调用的时候传参是在压栈的时候就干了的所以看上去好像没传参数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="comment">// 在16MB内存的最高端获取一页，这里强制类型转换的意思就是把这个页当作task_union使用</span></span><br><span class="line">	p = (<span class="keyword">struct</span> task_struct *) get_free_page();<span class="comment">//获得空闲页：mem_map count=0,mem_map的管理单位是页，从高往低找空闲页。和task不一样，task是从低到高</span></span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	task[nr] = p;</span><br><span class="line">   ...</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get_free_page()算法是从主内存地址的高端向低端递进寻找，进程1是开机以来操作系统第一次在主内存申请空闲页面，因此是16M的最末端。</p>
<p>get_free_page()代码分析如下所示：</p>
<h5 id="get_free_page"><strong>get_free_page</strong></h5>
<p>get_free_page()函数用于在主内存区中申请一页空闲内存页，并返回物理内存页的起始地址。它首先
扫描内存页面字节图数组 mem_map[]，寻找值是 0
的字节项（对应空闲页面）。若无则返回 0 结束，表
示物理内存已使用完。若找到值为 0 的字节，则将其置
1，并换算出对应空闲页面的起始地址。然后对
该内存页面作清零操作。最后返回该空闲页面的物理内存起始地址。</p>
<p><code>"std ; repne ; scasb\n\t"</code></p>
<ol type="1">
<li><code>std</code>：这是 "set direction flag"
的缩写，用于设置字符串操作方向。在使用<code>scasb</code>等指令进行字符串操作时，方向标志的设置将影响字符串操作的方向。<code>std</code>
指令设置方向标志，使字符串操作向前（高地址到低地址）进行。通常，<code>std</code>
用于向后搜索或处理字符串。</li>
<li><code>repne</code>：这是 "repeat while not equal"
的缩写，通常与字符串操作指令一起使用，表示重复执行字符串操作，直到特定条件不再满足。在这种情况下，它可能与
<code>scasb</code>
一起使用，以重复执行比较操作，直到找到匹配的字节或直到遍历整个字符串。</li>
<li><code>scasb</code>：这是 "scan string, compare with byte"
的缩写，用于在字符串中扫描并比较字节。它通常与<code>repne</code>结合使用，以在字符串中搜索特定字节值，并在找到匹配值时停止搜索。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_free_page</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//asm(&quot;ax&quot;)：这是内联汇编指令，它告诉编译器将变量 __res 存储在汇编寄存器 &quot;ax&quot; 中。</span></span><br><span class="line"><span class="comment">//这意味着在编译和运行时，变量 __res 将与寄存器 &quot;ax&quot; 相关联。</span></span><br><span class="line"><span class="keyword">register</span> <span class="type">unsigned</span> <span class="type">long</span> __res <span class="title function_">asm</span><span class="params">(<span class="string">&quot;ax&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">__asm__(<span class="string">&quot;std ; repne ; scasb\n\t&quot;</span> <span class="comment">// 反向扫描串（mem map[])//al(0)与di不相等则重复，找引用计数0的页</span></span><br><span class="line">	<span class="string">&quot;jne 1f\n\t&quot;</span>  <span class="comment">//// 如果没有等于 0 的字节，则跳转结束（返回 0）。</span></span><br><span class="line">	<span class="string">&quot;movb $1,1(%%edi)\n\t&quot;</span> <span class="comment">/// 将对应页面的内存映像位置 1。 将1赋值给edi+1的位置，在mem_map【】中</span></span><br><span class="line">	<span class="string">&quot;sall $12,%%ecx\n\t&quot;</span> <span class="comment">//ecx左移12位，页的相对地址， 页面数*4K = 相对页面起始地址。（&quot;c&quot; (PAGING_PAGES)，ecx=页面数） </span></span><br><span class="line">	<span class="string">&quot;addl %2,%%ecx\n\t&quot;</span> <span class="comment">// 再加上低端内存地址，即获得页面实际物理起始地址。LOW_MEM+ecx</span></span><br><span class="line">	<span class="string">&quot;movl %%ecx,%%edx\n\t&quot;</span> <span class="comment">//将页面实际起始地址Îedx 寄存器。</span></span><br><span class="line">	<span class="string">&quot;movl $1024,%%ecx\n\t&quot;</span> <span class="comment">// 寄存器 ecx 置计数值 1024</span></span><br><span class="line">	<span class="string">&quot;leal 4092(%%edx),%%edi\n\t&quot;</span> <span class="comment">// 将 4092+edx 的位置Îedi(该页面的末端)。 </span></span><br><span class="line">	<span class="string">&quot;rep ; stosl\n\t&quot;</span> <span class="comment">// 将 edi 所指内存清零（反方向，也即将该页面清零）。</span></span><br><span class="line">	<span class="string">&quot;movl %%edx,%%eax\n&quot;</span> <span class="comment">// 将页面起始地址Îeax（返回值）。 </span></span><br><span class="line">	<span class="string">&quot;1:&quot;</span></span><br><span class="line">	:<span class="string">&quot;=a&quot;</span> (__res)</span><br><span class="line">	:<span class="string">&quot;0&quot;</span> (<span class="number">0</span>),<span class="string">&quot;i&quot;</span> (LOW_MEM),<span class="string">&quot;c&quot;</span> (PAGING_PAGES),</span><br><span class="line">	<span class="string">&quot;D&quot;</span> (mem_map+PAGING_PAGES<span class="number">-1</span>) <span class="comment">//函数刚开始的时候edi=LOW_MEM低端内存地址，ecx=页数。edx=mem_map+PAGING_PAGES-1，mem_map的高端</span></span><br><span class="line">	:<span class="string">&quot;di&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> __res; <span class="comment">// 返回空闲页面地址（如果无空闲也则返回 0）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译函数返回值一般是eax寄存器 &gt;为啥是从高往低找空闲页？
让线性地址和物理地址之间的映射关系更加难以捉摸
&gt;拿的是线性页还是物理页？ &gt;拿的页是0特权还是三特权
拿的是物理内存的页，16M的最后一个页
&gt;为什么用父进程创建子进程而不是用模版的机制？</p>
<p>引导，子进程先共享父进程的代码 &gt;父进程怎么没倒腾页表？</p>
<p>进程0和内核的代码是在一起的，段是重叠的，进程0用了一部分kernel的代码</p>
<h4 id="子进程tss寄存器等设置">子进程tss寄存器等设置</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr,<span class="type">long</span> ebp,<span class="type">long</span> edi,<span class="type">long</span> esi,<span class="type">long</span> gs,<span class="type">long</span> none,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> ebx,<span class="type">long</span> ecx,<span class="type">long</span> edx,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> fs,<span class="type">long</span> es,<span class="type">long</span> ds,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> eip,<span class="type">long</span> cs,<span class="type">long</span> eflags,<span class="type">long</span> esp,<span class="type">long</span> ss)</span><span class="comment">//调用的时候传参是在压栈的时候就干了的所以看上去好像没传参数</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    task[nr] = p;<span class="comment">//nr是eax传进来的空进程，创建子进程1时nr=1</span></span><br><span class="line">	*p = *current;	<span class="comment">//当前进程是父进程，将进程0的task struct复制给进程1，栈没用复制，只是复制了task struct/* NOTE! this doesn&#x27;t copy the supervisor stack */</span></span><br><span class="line">	p-&gt;state = TASK_UNINTERRUPTIBLE;<span class="comment">//子进程挂起，中断也唤不醒，看看这个是不是真的有效？？</span></span><br><span class="line">	p-&gt;pid = last_pid;<span class="comment">//开始子进程的个性化设置</span></span><br><span class="line">	p-&gt;father = current-&gt;pid;</span><br><span class="line">	p-&gt;counter = p-&gt;priority;</span><br><span class="line">	p-&gt;signal = <span class="number">0</span>;</span><br><span class="line">	p-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">	p-&gt;leader = <span class="number">0</span>;		<span class="comment">/* process leadership doesn&#x27;t inherit */</span></span><br><span class="line">	p-&gt;utime = p-&gt;stime = <span class="number">0</span>;</span><br><span class="line">	p-&gt;cutime = p-&gt;cstime = <span class="number">0</span>;</span><br><span class="line">	p-&gt;start_time = jiffies;</span><br><span class="line">	p-&gt;tss.back_link = <span class="number">0</span>;</span><br><span class="line">	p-&gt;tss.esp0 = PAGE_SIZE + (<span class="type">long</span>) p;</span><br><span class="line">	p-&gt;tss.ss0 = <span class="number">0x10</span>;</span><br><span class="line">	p-&gt;tss.eip = eip;<span class="comment">//为第二次执行fork中的if(__res&gt;=0)埋下伏笔                                      </span></span><br><span class="line">	p-&gt;tss.eflags = eflags;</span><br><span class="line">	p-&gt;tss.eax = <span class="number">0</span>;</span><br><span class="line">	p-&gt;tss.ecx = ecx;</span><br><span class="line">	p-&gt;tss.edx = edx;</span><br><span class="line">	p-&gt;tss.ebx = ebx;</span><br><span class="line">	p-&gt;tss.esp = esp;</span><br><span class="line">	p-&gt;tss.ebp = ebp;</span><br><span class="line">	p-&gt;tss.esi = esi;</span><br><span class="line">	p-&gt;tss.edi = edi;</span><br><span class="line">	p-&gt;tss.es = es &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.cs = cs &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.ss = ss &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.ds = ds &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.fs = fs &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.gs = gs &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.ldt = _LDT(nr);<span class="comment">//挂接子进程的ldt</span></span><br><span class="line">	p-&gt;tss.trace_bitmap = <span class="number">0x80000000</span>;</span><br><span class="line">	<span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">		__asm__(<span class="string">&quot;clts ; fnsave %0&quot;</span>::<span class="string">&quot;m&quot;</span> (p-&gt;tss.i387));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ <img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231024234009247.png" alt="image-20231024234009247"></p>
<h4 id="设置进程1的分页管理">设置进程1的分页管理</h4>
<p>4GB的空间 ,64个进程，4*1024 MB <span class="math inline">\(2^{12}/2^6=64\)</span>
MB，进程段限长：0~0x9f：0xa0. 段限长 <span class="math inline">\(160\times4KB=640KB\)</span></p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231025115927391.png" alt="image-20231025115927391">
<figcaption aria-hidden="true">image-20231025115927391</figcaption>
</figure>
<p>分页机制是基于保护模式的，访问控制是基于段的，不存在没有pe的pg。要设置进程1的分页，首先要设置进程1的分段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr,<span class="type">long</span> ebp,<span class="type">long</span> edi,<span class="type">long</span> esi,<span class="type">long</span> gs,<span class="type">long</span> none,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> ebx,<span class="type">long</span> ecx,<span class="type">long</span> edx,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> fs,<span class="type">long</span> es,<span class="type">long</span> ds,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> eip,<span class="type">long</span> cs,<span class="type">long</span> eflags,<span class="type">long</span> esp,<span class="type">long</span> ss)</span><span class="comment">//调用的时候传参是在压栈的时候就干了的所以看上去好像没传参数</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">		__asm__(<span class="string">&quot;clts ; fnsave %0&quot;</span>::<span class="string">&quot;m&quot;</span> (p-&gt;tss.i387));</span><br><span class="line">	<span class="keyword">if</span> (copy_mem(nr,p)) &#123;</span><br><span class="line">		task[nr] = <span class="literal">NULL</span>;</span><br><span class="line">		free_page((<span class="type">long</span>) p);</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	&#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="copy_mem">copy_mem</h5>
<p>设置子进程的代码段，数据段及创建复制子进程的第一个页表</p>
<p>设置新的进程的代码段基址是nr*64MB，每个进程分配了64MB的线性地址空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_mem</span><span class="params">(<span class="type">int</span> nr,<span class="keyword">struct</span> task_struct * p)</span></span><br><span class="line">    <span class="comment">/*首先要维护线性地址，因此需要得到父进程代码段数据 段的基址和限长，这个基址存在于当前进程的ldt中</span></span><br><span class="line"><span class="comment">     给子进程分配新的代码段和数据段，系统设置给每个进程分配64M的虚拟内存空间，因此第nr个进程代码段和数据段的基址就是nr *         0x4000000（因为linux0.11版本默认的虚拟空间是共用一个虚拟空间互不重叠的，这个在高版本是有所变化的。然后把设置好的基       址填到子进程的ldt中。至此就完成了段-线性地址的设置，下面设置分页。</span></span><br><span class="line"><span class="comment">     这里的策略是拷贝父进程的页表，也就是说子进程和父进程共享相同的页面，完成这个过程需要用到copy_page_tables函数进行操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#123;   <span class="comment">//段基质（两个不一样），段限长（两个一样）</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> old_data_base,new_data_base,data_limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> old_code_base,new_code_base,code_limit;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取父进程的段基址和段限ch</span></span><br><span class="line">	code_limit=get_limit(<span class="number">0x0f</span>);<span class="comment">//0x0f段选择子，得到段限长</span></span><br><span class="line">	data_limit=get_limit(<span class="number">0x17</span>);</span><br><span class="line">	old_code_base = get_base(current-&gt;ldt[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//current 是一个全局的结构体指针定义如下所示，指向当前指向的进程，一开始指向的是进程0</span></span><br><span class="line">    <span class="comment">//struct task_struct *current = &amp;(init_task.task);</span></span><br><span class="line">	old_data_base = get_base(current-&gt;ldt[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//数据段和代码段要对齐</span></span><br><span class="line">	<span class="keyword">if</span> (old_data_base != old_code_base)</span><br><span class="line">		panic(<span class="string">&quot;We don&#x27;t support separate I&amp;D&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (data_limit &lt; code_limit)</span><br><span class="line">		panic(<span class="string">&quot;Bad data_limit&quot;</span>);</span><br><span class="line">	<span class="comment">//新的代码段和数据段对齐，0x4000 000 ：64M</span></span><br><span class="line">	new_data_base = new_code_base = nr * <span class="number">0x4000000</span>;</span><br><span class="line">	p-&gt;start_code = new_code_base;</span><br><span class="line">	set_base(p-&gt;ldt[<span class="number">1</span>],new_code_base);<span class="comment">//设置子进程段基址</span></span><br><span class="line">	set_base(p-&gt;ldt[<span class="number">2</span>],new_data_base);</span><br><span class="line">	<span class="comment">//把子进程的内存的线性地址折腾完了</span></span><br><span class="line">    <span class="comment">//折腾物理地址</span></span><br><span class="line">	<span class="keyword">if</span> (copy_page_tables(old_data_base,new_data_base,data_limit)) &#123;</span><br><span class="line">		free_page_tables(new_data_base,data_limit); <span class="comment">//copy失败，释放新的页表</span></span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>求段基址和段限长</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 取段选择符 segment 指定的描述符中的段限长值。 </span></span><br><span class="line"> <span class="comment">// 指令 lsl 是 Load Segment Limit 缩写。它从指定段描述符中取出分散的限长比特位拼成完整的 </span></span><br><span class="line"> <span class="comment">// 段限长值放入指定寄存器中。所得的段限长是实际字节数减 1，因此这里还需要加 1 后才返回。 </span></span><br><span class="line"> <span class="comment">// %0 - 存放段长值(字节数)；%1 - 段选择符 segment。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_limit(segment) (&#123; \</span></span><br><span class="line"><span class="meta">unsigned long __limit; \</span></span><br><span class="line"><span class="meta">__asm__(<span class="string">&quot;lsll %1,%0\n\tincl %0&quot;</span>:<span class="string">&quot;=r&quot;</span> (__limit):<span class="string">&quot;r&quot;</span> (segment)); \</span></span><br><span class="line"><span class="meta">__limit;&#125;)</span></span><br><span class="line"><span class="comment">//求段基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_base(ldt) _get_base( ((char *)&amp;(ldt)) )</span></span><br><span class="line"><span class="comment">// 从地址 addr 处描述符中取段基地址。功能与_set_base()正好相反。 </span></span><br><span class="line"><span class="comment">// edx - 存放基地址(__base)；%1 - 地址 addr 偏移 2；%2 - 地址 addr 偏移 4；%3 - addr 偏移 7。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _get_base(addr) (&#123;\</span></span><br><span class="line"><span class="meta">unsigned long __base; \</span></span><br><span class="line"><span class="meta">__asm__(<span class="string">&quot;movb %3,%%dh\n\t&quot;</span> \ <span class="comment">// 取[addr+7]处基址高 16 位的高 8 位(位 31-24)-&gt;dh</span></span></span><br><span class="line">	<span class="string">&quot;movb %2,%%dl\n\t&quot;</span> \  <span class="comment">// 取[addr+4]处基址高 16 位的低 8 位(位 23-16)-&gt;dl。</span></span><br><span class="line">	<span class="string">&quot;shll $16,%%edx\n\t&quot;</span> \ <span class="comment">// 基地址高 16 位移到 edx 中高 16 位处。</span></span><br><span class="line">	<span class="string">&quot;movw %1,%%dx&quot;</span> \ <span class="comment">// 取[addr+2]处基址低 16 位(位 15-0)Îdx。</span></span><br><span class="line">	:<span class="string">&quot;=d&quot;</span> (__base) \</span><br><span class="line">	:<span class="string">&quot;m&quot;</span> (*((addr)+<span class="number">2</span>)), \</span><br><span class="line">	 <span class="string">&quot;m&quot;</span> (*((addr)+<span class="number">4</span>)), \</span><br><span class="line">	 <span class="string">&quot;m&quot;</span> (*((addr)+<span class="number">7</span>))); \</span><br><span class="line">__base;&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="copy_page_tables">copy_page_tables</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//from 父进程的段基地址，to子进程的段基地址</span></span><br><span class="line"><span class="comment">/*分页实现的是从线性地址到物理地址的转换，因此函数的输入一定是线性地址，</span></span><br><span class="line"><span class="comment">  为了方便遍历，把单位换算为M,此处硬件MMU要求页目录项的地址4M对齐*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_page_tables</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> from,<span class="type">unsigned</span> <span class="type">long</span> to,<span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> * from_page_table;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> * to_page_table;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> this_page;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> * from_dir, * to_dir;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr;</span><br><span class="line">	<span class="comment">//0x3fffff 是4M，是一个页表的管辖范围，22位from和to必须是4MB的整数倍，一个页表对应的4MB连续的线性地址空间必须是从0开始的4MB的整数倍数</span></span><br><span class="line">    <span class="comment">//4M一个页表的覆盖范围，如果4M没有对齐则panic，cpu的要求，cpu分页要对齐，页目录表项要4M对齐</span></span><br><span class="line">	<span class="keyword">if</span> ((from&amp;<span class="number">0x3fffff</span>) || (to&amp;<span class="number">0x3fffff</span>)) <span class="comment">//必须满足后面22位都是0才能不panic</span></span><br><span class="line">		panic(<span class="string">&quot;copy_page_tables called with wrong alignment&quot;</span>);</span><br><span class="line">	<span class="comment">//父进程页目录表项的位置，一个线性地址空间对应一个页目录表</span></span><br><span class="line">	<span class="comment">//from右移20位：以MB为单位，例如0010 0000 0000 0000 0000 000》0010就是2M</span></span><br><span class="line">    <span class="comment">//确保from_dir是4M的倍数</span></span><br><span class="line">	from_dir = (<span class="type">unsigned</span> <span class="type">long</span> *) ((from&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>); <span class="comment">/* _pg_dir = 0 */</span><span class="comment">//地址数由字节数变成M，c：1100，ffc肯定是4的倍数，因此是4M的倍数,</span></span><br><span class="line">	<span class="comment">//有ff是因为32位地址，右移20，还剩12位，ffc，十二位</span></span><br><span class="line">	<span class="comment">//确保to_dir是4M的倍数</span></span><br><span class="line">	to_dir = (<span class="type">unsigned</span> <span class="type">long</span> *) ((to&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>);</span><br><span class="line">	<span class="comment">//22 4MB，这里是不足4M强行等于一个4M</span></span><br><span class="line">	size = ((<span class="type">unsigned</span>) (size+<span class="number">0x3fffff</span>)) &gt;&gt; <span class="number">22</span>;</span><br><span class="line">	<span class="comment">//基地址的低第一位：是P位，指示页表是否存在</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    以进程0创建进程1为例：</span></span><br><span class="line"><span class="comment">    此时from：0</span></span><br><span class="line"><span class="comment">       to :0x4000000(64M)</span></span><br><span class="line"><span class="comment">       SIZE:段限长：0x9f（0xa0)160*4k=640k</span></span><br><span class="line"><span class="comment">       进行单位换算以后就变成了：from 0M TO 64 M size=1M ,如下所示的from和to两个指针进行拷贝操作</span></span><br><span class="line"><span class="comment">       ---------</span></span><br><span class="line"><span class="comment">       ^(0M from_dir)</span></span><br><span class="line"><span class="comment">       ----...----</span></span><br><span class="line"><span class="comment">              ^(64M to_dir)</span></span><br><span class="line"><span class="comment">       两层循环：</span></span><br><span class="line"><span class="comment">       for 父进程的遍历页目录项对应的每一个页表</span></span><br><span class="line"><span class="comment">           if子进程页目录项存在报错</span></span><br><span class="line"><span class="comment">           if 父进程页目录项不存在则跳过，继续便历下一项</span></span><br><span class="line"><span class="comment">                    为子进程的页表分配页面</span></span><br><span class="line"><span class="comment">         for 遍历该页目录项指向的页表对应的页面</span></span><br><span class="line"><span class="comment">             if（父进程该页表不存在，则跳过，继续遍历下一个页表）</span></span><br><span class="line"><span class="comment">             (用nr来记录要遍历的页面的数量，如果from是0M也就是进程0，则要遍历的页面长度是段限长640K.这是因为进程0比较特殊，与内核公用了一个页表，进程0的东西不能都被拷贝给子进程，否则就有问题了.比如进程0的页目录由16	M后两页的内容，后两页有子进程1的task_struct 和页表项，这俩子进程应该无权访问，否则子进程就可以修改自己的页面映射关系了显然不大对。)</span></span><br><span class="line"><span class="comment">             注意：1M以内的页面不参与用户分页管理</span></span><br><span class="line"><span class="comment">             1.设置页面的权限，因为子进程共享了父进程的页面，因此应该把子进程的权限设置位只读，否则两个进程如果存在同时写的情况就会出错。子进程如果需要修改页面，则会引出后面要讲的copy on write</span></span><br><span class="line"><span class="comment">             2.将页面填到子进程的页表（页框frame）里面，完成映射关系</span></span><br><span class="line"><span class="comment">             3.修改mem_map里面的引用计数，表面该页面被新增的进程占用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">for</span>( ; size--&gt;<span class="number">0</span> ; from_dir++,to_dir++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> &amp; *to_dir)<span class="comment">//1:p位。</span></span><br><span class="line">			panic(<span class="string">&quot;copy_page_tables: already exist&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (!(<span class="number">1</span> &amp; *from_dir)) <span class="comment">//from的页表不存在，则没必要进行下去了</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//0xfffff000 低12位清零，from_dir是页目录项的地址，高20位是页表的地址</span></span><br><span class="line">		from_page_table = (<span class="type">unsigned</span> <span class="type">long</span> *) (<span class="number">0xfffff000</span> &amp; *from_dir);</span><br><span class="line">		<span class="keyword">if</span> (!(to_page_table = (<span class="type">unsigned</span> <span class="type">long</span> *) get_free_page()))<span class="comment">//获得空页面。上次调用是在找一个空页面放         task_struct</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">/* Out of memory, see freeing */</span></span><br><span class="line">		*to_dir = ((<span class="type">unsigned</span> <span class="type">long</span>) to_page_table) | <span class="number">7</span>;<span class="comment">//这次是给子进程的基地址段分配页面</span></span><br><span class="line">		nr = (from==<span class="number">0</span>)?<span class="number">0xA0</span>:<span class="number">1024</span>; <span class="comment">//0xa0：0x9f 可以查看init task里面的ldt的断限长计算，把父进程的160个页表项640KB空间的内容复制给子进程</span></span><br><span class="line">		<span class="keyword">for</span> ( ; nr-- &gt; <span class="number">0</span> ; from_page_table++,to_page_table++) &#123;</span><br><span class="line">			this_page = *from_page_table;</span><br><span class="line">			<span class="keyword">if</span> (!(<span class="number">1</span> &amp; this_page)) </span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			this_page &amp;= ~<span class="number">2</span>;<span class="comment">//设置页表属性~2:101 用户，只读，存在</span></span><br><span class="line">			*to_page_table = this_page;</span><br><span class="line">			<span class="keyword">if</span> (this_page &gt; LOW_MEM) &#123;<span class="comment">//1MB以内的内核区域不参与用户分页管理</span></span><br><span class="line">				*from_page_table = this_page;</span><br><span class="line">				this_page -= LOW_MEM;</span><br><span class="line">				this_page &gt;&gt;= <span class="number">12</span>; <span class="comment">//</span></span><br><span class="line">				mem_map[this_page]++; <span class="comment">//增加引用计数，说明这个页被这个进程占用了</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	invalidate();<span class="comment">//重置CR3为0，刷新页变换高速缓存</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="free_page_tablesfree-tables">free_page_tables/free tables</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// 根据指定的线性地址和限长（页表个数），释放对应内存页表所指定的内存块并置表项空闲。 </span></span><br><span class="line"> <span class="comment">// 页目录位于物理地址 0 开始处，共 1024 项，占 4K 字节。每个目录项指定一个页表。 </span></span><br><span class="line"> <span class="comment">// 页表从物理地址 0x1000 处开始（紧接着目录空间），每个页表有 1024 项，也占 4K 内存。 </span></span><br><span class="line"> <span class="comment">// 每个页表项对应一页物理内存（4K）。目录项和页表项的大小均为 4 个字节。 </span></span><br><span class="line"> <span class="comment">// 参数：from - 起始基地址；size - 释放的长度。 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">free_page_tables</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> from,<span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *pg_table;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> * dir, nr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (from &amp; <span class="number">0x3fffff</span>)</span><br><span class="line">		panic(<span class="string">&quot;free_page_tables called with wrong alignment&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!from)</span><br><span class="line">		panic(<span class="string">&quot;Trying to free up swapper memory space&quot;</span>);</span><br><span class="line">	size = (size + <span class="number">0x3fffff</span>) &gt;&gt; <span class="number">22</span>; <span class="comment">// 计算所占页目录项数(4M 的进位整数倍)，也即所占页表数。整数不足1为1</span></span><br><span class="line">	dir = (<span class="type">unsigned</span> <span class="type">long</span> *) ((from&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>); <span class="comment">/* _pg_dir = 0 */</span></span><br><span class="line">	<span class="keyword">for</span> ( ; size--&gt;<span class="number">0</span> ; dir++) &#123; <span class="comment">// size 现在是需要被释放内存的目录项数。</span></span><br><span class="line">		<span class="keyword">if</span> (!(<span class="number">1</span> &amp; *dir)) <span class="comment">// 如果该目录项无效(P 位=0)，则继续。</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		pg_table = (<span class="type">unsigned</span> <span class="type">long</span> *) (<span class="number">0xfffff000</span> &amp; *dir); <span class="comment">// 取目录项中页表地址。 </span></span><br><span class="line">		<span class="keyword">for</span> (nr=<span class="number">0</span> ; nr&lt;<span class="number">1024</span> ; nr++) &#123; <span class="comment">// 每个页表有 1024 个页项。</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="number">1</span> &amp; *pg_table) <span class="comment">// 若该页表项有效(P 位=1)，则释放对应内存页。</span></span><br><span class="line">				free_page(<span class="number">0xfffff000</span> &amp; *pg_table);</span><br><span class="line">			*pg_table = <span class="number">0</span>; <span class="comment">// 该页表项内容清零。</span></span><br><span class="line">			pg_table++; <span class="comment">// 指向页表中下一项。</span></span><br><span class="line">		&#125;</span><br><span class="line">		free_page(<span class="number">0xfffff000</span> &amp; *dir); <span class="comment">// 释放该页表所占内存页面。但由于页表在 </span></span><br><span class="line">       <span class="comment">// 物理地址 1M 以内，所以这句什么都不做。</span></span><br><span class="line">		*dir = <span class="number">0</span>; <span class="comment">// 对相应页表的目录项清零。 </span></span><br><span class="line">	&#125;</span><br><span class="line">	invalidate();<span class="comment">// 刷新页变换高速缓冲</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (addr &lt; LOW_MEM) <span class="keyword">return</span>;<span class="comment">//1M一下的内核页不操作直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (addr &gt;= HIGH_MEMORY) </span><br><span class="line">		panic(<span class="string">&quot;trying to free nonexistent page&quot;</span>);</span><br><span class="line">	addr -= LOW_MEM;</span><br><span class="line">	addr &gt;&gt;= <span class="number">12</span>;</span><br><span class="line">	<span class="comment">//修改引用计数</span></span><br><span class="line">	<span class="keyword">if</span> (mem_map[addr]--) <span class="keyword">return</span>; </span><br><span class="line">	mem_map[addr]=<span class="number">0</span>;</span><br><span class="line">	panic(<span class="string">&quot;trying to free free page&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="copy_process小结">copy_process小结：</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr,<span class="type">long</span> ebp,<span class="type">long</span> edi,<span class="type">long</span> esi,<span class="type">long</span> gs,<span class="type">long</span> none,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> ebx,<span class="type">long</span> ecx,<span class="type">long</span> edx,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> fs,<span class="type">long</span> es,<span class="type">long</span> ds,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> eip,<span class="type">long</span> cs,<span class="type">long</span> eflags,<span class="type">long</span> esp,<span class="type">long</span> ss)</span><span class="comment">//调用的时候传参是在压栈的时候就干了的所以看上去好像没传参数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span><span class="comment">//子进程的task struct</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">    </span><br><span class="line">	p = (<span class="keyword">struct</span> task_struct *) get_free_page();<span class="comment">//获得空闲页：mem_map count=0,mem_map的管理单位是页，从高往低找空闲页。和task astruct不一样</span></span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	task[nr] = p;<span class="comment">//nr是eax传进来的空进程，创建子进程1时nr=1</span></span><br><span class="line">	*p = *current;	<span class="comment">//当前进程是父进程，将进程0的task struct复制给进程1，栈没用复制，只是复制了task struct/* NOTE! this doesn&#x27;t copy the supervisor stack */</span></span><br><span class="line">	p-&gt;state = TASK_UNINTERRUPTIBLE;<span class="comment">//子进程挂起，中断也唤不醒，看看这个是不是真的有效？？</span></span><br><span class="line">	p-&gt;pid = last_pid;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">		__asm__(<span class="string">&quot;clts ; fnsave %0&quot;</span>::<span class="string">&quot;m&quot;</span> (p-&gt;tss.i387));</span><br><span class="line">	<span class="keyword">if</span> (copy_mem(nr,p)) &#123;</span><br><span class="line">		task[nr] = <span class="literal">NULL</span>;</span><br><span class="line">		free_page((<span class="type">long</span>) p);</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*设置task_struct中与文件相关的成员，包括打开了那些文件p-&gt;filp【20】*/</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NR_OPEN;i++)</span><br><span class="line">		<span class="keyword">if</span> (f=p-&gt;filp[i])</span><br><span class="line">			f-&gt;f_count++;</span><br><span class="line">    <span class="comment">//设置当前工作目录i结点结构</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;pwd)</span><br><span class="line">		current-&gt;pwd-&gt;i_count++;</span><br><span class="line">    <span class="comment">//设置根目录i节点结构</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;root)</span><br><span class="line">		current-&gt;root-&gt;i_count++;</span><br><span class="line">    <span class="comment">//设置执行文件的i结点结构</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;executable)</span><br><span class="line">		current-&gt;executable-&gt;i_count++;</span><br><span class="line">    <span class="comment">//设置子进程的ldt和tss</span></span><br><span class="line">	set_tss_desc(gdt+(nr&lt;&lt;<span class="number">1</span>)+FIRST_TSS_ENTRY,&amp;(p-&gt;tss));</span><br><span class="line">	set_ldt_desc(gdt+(nr&lt;&lt;<span class="number">1</span>)+FIRST_LDT_ENTRY,&amp;(p-&gt;ldt));</span><br><span class="line">    <span class="comment">//改为就绪态</span></span><br><span class="line">	p-&gt;state = TASK_RUNNING;	<span class="comment">/* do this last, just in case */</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">return</span> last_pid;<span class="comment">//last_pid 是在find empty process里面确定的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要创建子进程主要包括以下几个阶段：</p>
<ol type="1">
<li><p>首先要挂号注册，相当于公安局上户口。这一步需要为进程1创建task_struct（其实和PCB的概念一样）。task_struct的内容复制进程0，并对进程1的task_struct,tss做个性化设置。注意，此时数据栈没有复制，这是因为两个进程代码可以是同一份，但是数据不能是同一个。此时用一个空闲页存放task_struct
和内核栈的共用体。</p></li>
<li><p>第二步要建立实体，因为此时虽然登记了，但是没有给子进程分配内存。一个程序要运行要完成取指执行的过程，因此必须要把代码加载到内存中。因此需要建立内存调用的机制，也就是要完善（线性地址和分页）段-&gt;逻辑（线性）地址，和逻辑（线性）地址-&gt;物理地址的映射关系。</p>
<p>这一部分由copy_mem函数完成。首先要维护线性地址，因此需要得到父进程代码段数据
段的基址和限长，这个基址存在于当前进程的ldt中给子进程分配新的代码段和数据段，系统设置给每个进程分配64M的虚拟内存空间，因此第nr个进程代码段和数据段的基址就是nr
*
0x4000000（因为linux0.11版本默认的虚拟空间是共用一个虚拟空间互不重叠的，这个在高版本是有所变化的。然后把设置好的基
址填到子进程的ldt中。至此就完成了段-线性地址的设置，下面设置分页。这里的策略是拷贝父进程的页表，也就是说子进程和父进程共享相同的页面，完成这个过程需要用到copy_page_tables函数进行操作。</p>
<p>copy_page_tables:
==先拷贝页目录表项再拷贝页表项==，这里子进程拥有自己的页表项，这里页表创建以后由于子进程的页面共享了父进程的页面，因此要把父进程的页表项内容复制给子进程的页表项。而页目录项的空间在分页机制建立的时候就已经建好了。这一个函数干的事情就是：填子进程的页目录项，页目录项需要指向的页表就从内存中申请页面把地址填进去，页表指向的页面就是父进程的页面。疑问：既然都是复制，为啥不直接复制父进程的页表（frame
页框)？因为那子进程就完全没有自主性了，也就是说进程的内存共享是页面的共享，但是页表项和页目录项是独立的。这样后面子进程想写入的时候可以copy
on write ，让页表指向新的页面。
这里为啥不用创建页目录表。因为低版本的linux是不同进程共用了一个虚拟空间
，所以是本来就有页目录表的，填进去就可以了，所以里不用创建。</p></li>
<li><p>进程1共享进程0的文件，设置进程1的GDT项</p></li>
<li><p>将进程1设置为就绪态，使得进程可以参与进程间的轮转。</p>
<p><strong>几个小问题</strong>：</p>
<ol type="1">
<li>一个进程线性地址空间：64M，最多页表：<span class="math inline">\(64/4=16个\)</span>
（一个页表管理的空间是4K*1K=4M),那么实际物理内存就16M，可以填满64M的虚拟内存吗？答：可以填满，因为存在共享内存，可以一个物理地址映射到多个线性地址，这实际上就会涉及内存的装入装出问题）</li>
<li>问：为啥head.s设置分页的时候是+7 ，111（user r/w
p）。因为是进程0要用，必须是用户而不是su因此是7不是3</li>
<li>代码哪里体现进程不能访问页表的？</li>
<li>get free page 是物理的地址还是线性的地址？
线性地址。因为恒等映射看上去一样</li>
<li>为什么要用父进程创建子进程，共享了一部分父进程的的代码？因为此时子进程的代码还在磁盘里面，需要利用父进程的机制把子进程的代码加载进来子进程才能运行。</li>
</ol></li>
</ol>
<h3 id="copy_process-后时代">copy_process 后时代</h3>
<h4 id="sys_fork-1">_sys_fork</h4>
<p>执行完copy_process return 返回到sys_fork</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_sys_fork:</span><br><span class="line">	push %gs #这5个参数也作为copy_process的参数</span><br><span class="line">	pushl %esi</span><br><span class="line">	pushl %edi</span><br><span class="line">	pushl %ebp</span><br><span class="line">	pushl %eax</span><br><span class="line">	call _copy_process #调用赋值进程函数，这里call没有传参就是因为其实上面压栈的把参数压进去了</span><br><span class="line">	addl $20,%esp #清栈，把上面push的那五个清理了。因为栈是从高到低生长的，入栈栈顶指针减小，出栈栈顶指针增加。注意：eax是4个字节，gs是两个字节，那为啥是20个字节，因为这里有字节对齐：align 2（2个字（4个字节）对齐））</span><br><span class="line">1:	ret #目前还在0特权级，返回system call</span><br></pre></td></tr></table></figure>
<h4 id="system_call-1">_system_call</h4>
<p>sys_fork
返回则返回到system_call,注意这里的sys_fork是通过<code>call _sys_call_table</code>调用的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reschedule:</span><br><span class="line">	pushl $ret_from_sys_call #先push再jmp其实就是call  _schedule</span><br><span class="line">	jmp _schedule</span><br><span class="line"></span><br><span class="line">_system_call:</span><br><span class="line">	...</span><br><span class="line">	call _sys_call_table(,%eax,4) #通过查_sys_call_table确定要调用的函数，以fork为例，eax=2，这里就是</span><br><span class="line">	# call ( _sys_call_table+2*4),也就是_sys_fork的入口</span><br><span class="line">	pushl %eax  #eax是函数的返回值，也就是sys_fork的返回值：last pid</span><br><span class="line">	movl _current,%eax     #把当前的子进程task_struct 复制给eax</span><br><span class="line">	cmpl $0,state(%eax)		# state 判断当前的子进程状态是不是就绪态0，不是的话可能当前进程时间片到了需要重新调度</span><br><span class="line">	jne reschedule #重新调度</span><br><span class="line">	cmpl $0,counter(%eax)		# counter，检测时间片是否跑完</span><br><span class="line">	je reschedule#如果时间片跑完了重新调度</span><br><span class="line">ret_from_sys_call:</span><br><span class="line">	movl _current,%eax		# task[0] cannot have signals</span><br><span class="line">	cmpl _task,%eax          #将task的首地址（task[0]的地址）和eax做比较，也就是判断当前进程是否为进程0</span><br><span class="line">	je 3f                    #如果是进程0，则直接跳转到下面的3执行</span><br><span class="line">	cmpw $0x0f,CS(%esp)		# was old code segment supervisor ?</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">3:	popl %eax # 将last pid 出栈给cpu的eax#将7个寄存器的值出栈给cpu ，对应前面push进来的七个值</span><br><span class="line">	popl %ebx</span><br><span class="line">	popl %ecx</span><br><span class="line">	popl %edx</span><br><span class="line">	pop %fs</span><br><span class="line">	pop %es</span><br><span class="line">	pop %ds</span><br><span class="line">	iret #中断返回，将cpu硬件在int 80中断压栈的ss esp eflags cs eip的值出栈给cpu对应的寄存器，此时cs：eip指向fork()中int 0x80的下一行 if(__res&gt;=0)处执行</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h4 id="回到原点fork-if__res0">回到原点fork： if(__res&gt;=0)</h4>
<p>绕了一大圈，诸位可能都忘了我们从哪里进来的，进程0创建进程1调用了fork的宏展开，现在我们又回到了fork</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="type">long</span> __res; \</span><br><span class="line">__asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span> \ <span class="comment">//init 0x80是所有系统调用函数的总入口，fork是其中之一        </span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;=a&quot;</span> (__res) \ <span class="comment">//第一个冒号之后是输出部分，将_res赋值给eax</span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;0&quot;</span> (__NR_fork))</span>; \ <span class="comment">//第二个冒号后是输入部分，&quot;0&quot;同上寄存器，即eax ，__NR_fork=2，赋值给eax，紧接着就进行了0</span></span><br><span class="line">    <span class="comment">//x80软中断</span></span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \ <span class="comment">//int 0x80中断返回后，将执行这一句</span></span><br><span class="line">	<span class="keyword">return</span> (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意此处，res代表的就是eax：:<code>"=a" (__res)</code>,因此<code>if (__res &gt;= 0)</code>判断eax是不是大于等于0.此时的eax就是上面popl的eax，也就是last
pid=1（进程1），所以这里是大于等于0的，所以fork返回last pid=1。</p>
<h4 id="回到main">回到main</h4>
<p>fork 返回值是last pid=1，也就是刚创建的子进程pid，这里！last
pid=0,因此跳到pause()函数中执行，这是一个死循环，因为如果不是死循环操作系统就退出了。进入pause就即将开始第一次进程调度过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">   ...</span><br><span class="line">	<span class="keyword">if</span> (!fork()) &#123;		<span class="comment">/* we count on this going ok */</span></span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   NOTE!!   For any other task &#x27;pause()&#x27; would mean we have to get a</span></span><br><span class="line"><span class="comment"> * signal to awaken, but task0 is the sole exception (see &#x27;schedule()&#x27;)</span></span><br><span class="line"><span class="comment"> * as task 0 gets activated at every idle moment (when no other tasks</span></span><br><span class="line"><span class="comment"> * can run). For task0 &#x27;pause()&#x27; just means we go check if some other</span></span><br><span class="line"><span class="comment"> * task can run, and if not we return here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">for</span>(;;) pause();<span class="comment">//死循环，进程调度开始</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结-图解进程0创建进程1全过程">小结
：图解进程0创建进程1全过程</h3>
<h2 id="内核做第一次进程调度">内核做第一次进程调度</h2>
<p>在linux 0.11 进程调度机制中，发生进程切换存在两种情形：</p>
<ul>
<li>时间片用完</li>
<li>进程运行停止（比如等待外设提供数据）</li>
</ul>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231106001422585.png" alt="image-20231106001422585">
<figcaption aria-hidden="true">image-20231106001422585</figcaption>
</figure>
<h3 id="pause">pause</h3>
<p>上一小结说到，fork后，执行到了死循环里面的pause，pause和fork调用一样，也是syscall0的一个宏展开。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//问这里inline去了有区别吗，static只在当前文件有效</span></span><br><span class="line"><span class="comment">//这里的static关键字并不是静态的函数的意思，而是指该函数只在当前文件有效。这里的inline是内联函数，表示</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> _syscall0(<span class="type">int</span>,fork) </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> _syscall0(<span class="type">int</span>,pause)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span> \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="type">long</span> __res; \</span><br><span class="line">__asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span> \ <span class="comment">//init 0x80是所有系统调用函数的总入口，fork是其中之一        </span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;=a&quot;</span> (__res) \ <span class="comment">//第一个冒号之后是输出部分，将_res赋值给eax</span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;0&quot;</span> (__NR_pause))</span>; \ <span class="comment">//第二个冒号后是输入部分，&quot;0&quot;同上寄存器，即eax ，__NR_fork=2，赋值给eax，紧接着就进行了0</span></span><br><span class="line">    <span class="comment">//x80软中断</span></span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \ <span class="comment">//int 0x80中断返回后，将执行这一句</span></span><br><span class="line">	<span class="keyword">return</span> (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们又跳回了熟悉的system_call
,下面的压栈过程和fork的时候如出一辙，只是在<code>call _sys_call_table(,%eax,4)</code>的时候出现差别，这里调用的是<code>sys_pause</code>。因为这里传入的<code>eax</code>是<code>_NR_pause</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_system_call:</span><br><span class="line">	cmpl $nr_system_calls-1,%eax </span><br><span class="line">	ja bad_sys_call #如果越界了则跳到越界代码，中断返回，返回eax的值为-1，以fork为例代表创建失败</span><br><span class="line">	push %ds   #下面的6个push都是为了copy_process()的参数</span><br><span class="line">	...</span><br><span class="line">	call _sys_call_table(,%eax,4) #通过查_sys_call_table确定要调用的函数，以fork为例，eax=2，这里就是</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_pause</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里的TASK_INTERRUPTIBLE，将进程0状态切换到可中断打断状态，注意这里并不是马上就硬件上切换了，要在schedule();才切</span></span><br><span class="line">	<span class="comment">//可中断等待状态：当其它进程发生特定信号才可能将这个进程状态改为就绪态</span></span><br><span class="line">    current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="schedule">schedule</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,next,c;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span><span class="comment">//指针的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span></span><br><span class="line"><span class="comment">/* 检测 alarm（进程的报警定时值），唤醒任何已得到信号的可中断任务 */</span> </span><br><span class="line"><span class="comment">// 从任务数组中最后一个任务开始检测 alarm。</span></span><br><span class="line">	<span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">		<span class="keyword">if</span> (*p) &#123;</span><br><span class="line"><span class="comment">// 如果设置过任务的定时值 alarm，并且已经过期(alarm&lt;jiffies),则在信号位图中置 SIGALRM 信号， </span></span><br><span class="line"><span class="comment">// 即向任务发送 SIGALARM 信号。然后清 alarm。该信号的默认操作是终止进程。 </span></span><br><span class="line"><span class="comment">// jiffies 是系统从开机开始算起的滴答数（10ms/滴答）。定义在 sched.h 第 139 行。</span></span><br><span class="line">			<span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;</span><br><span class="line">					(*p)-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGALRM<span class="number">-1</span>));</span><br><span class="line">					(*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line"><span class="comment">// 如果信号位图中除被阻塞的信号外还有其它信号，并且任务处于可中断状态，则置任务为就绪状态。 </span></span><br><span class="line"><span class="comment">// 其中&#x27;~(_BLOCKABLE &amp; (*p)-&gt;blocked)&#x27;用于忽略被阻塞的信号，但 SIGKILL 和 SIGSTOP 不能被阻塞。</span></span><br><span class="line">			<span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="line">			(*p)-&gt;state==TASK_INTERRUPTIBLE)</span><br><span class="line">				(*p)-&gt;state=TASK_RUNNING;<span class="comment">//置为就绪（可执行）状态。 </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">/* this is the scheduler proper: */</span></span><br><span class="line"><span class="comment">/* 这里是调度程序的主要部分 */</span> </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		c = <span class="number">-1</span>;</span><br><span class="line">		next = <span class="number">0</span>;<span class="comment">//要切换的下一个进程，初始化置0</span></span><br><span class="line">		i = NR_TASKS;<span class="comment">//64</span></span><br><span class="line">		p = &amp;task[NR_TASKS];</span><br><span class="line"><span class="comment">// 这段代码也是从任务数组的最后一个任务开始循环处理，并跳过不含任务的数组槽。比较每个就绪 </span></span><br><span class="line"><span class="comment">// 状态任务的 counter（任务运行时间的递减滴答计数）值，哪一个值大，运行时间还不长，next 就 </span></span><br><span class="line"><span class="comment">// 指向哪个的任务号。</span></span><br><span class="line">		<span class="keyword">while</span> (--i) &#123; <span class="comment">//task数组是从高往低便利的，和find empty process的顺序是不一样的，思考原因：</span></span><br><span class="line">			<span class="keyword">if</span> (!*--p)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//找就绪态度且优先级高的（时间片多）。linux0.11的优先级折成了时间片，把级别折成钱了。时间片越多级别越高</span></span><br><span class="line">			<span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">				c = (*p)-&gt;counter, next = i;</span><br><span class="line">			<span class="comment">// 切换到任务号为 next 的任务运行。next 被初始化为 0。因此若系统中没有任何其它任务 </span></span><br><span class="line">           <span class="comment">// 可运行时，则 next 始终为 0。因此调度函数会在系统空闲时去执行任务 0。此时任务 0 仅执行 </span></span><br><span class="line">          <span class="comment">// pause()系统调用，并又会调用本函数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果比较得出有 counter 值大于 0 的结果，则退出 循环，执行任务切换 </span></span><br><span class="line">		<span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// 否则就根据每个任务的优先权值，更新每一个任务的 counter 值. </span></span><br><span class="line">       <span class="comment">// counter 值的计算方式为 counter = counter /2 + priority。这里计算过程不考虑进程的状态。</span></span><br><span class="line">		<span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">			<span class="keyword">if</span> (*p)</span><br><span class="line">				(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">						(*p)-&gt;priority;</span><br><span class="line">	&#125;</span><br><span class="line">	switch_to(next);<span class="comment">// 切换到任务号为 next 的任务，并运行之。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch_to">switch_to</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> //这段代码属于内核态</span><br><span class="line">#define switch_to(n) &#123;\  </span><br><span class="line">struct &#123;long a,b;&#125; __tmp; \ </span><br><span class="line">__asm__(&quot;cmpl %%ecx,_current\n\t&quot; \ // 任务 n 是当前任务吗?(current ==task[n]?) </span><br><span class="line">	&quot;je 1f\n\t&quot; \ // 如果是当前任务，则什么都不做，退出。</span><br><span class="line">	&quot;movw %%dx,%1\n\t&quot; \  //把edx的里面的tss复制给tmp.b也就是基址，把edx低16位给b，也就是把cs赋值给b</span><br><span class="line">	//这里1%是tmp.b存放tss的段选择子，也就是基址。其中tss任务切换的时候偏移就是0，所以不用给tmp.a赋值，初始化的时候就是0</span><br><span class="line">	&quot;xchgl %%ecx,_current\n\t&quot; \ //交换把目标进程里面tss保存的东西恢复 // current = task[n]；ecx = 被切换出的任务。 </span><br><span class="line">	//上面是进程0的内核态，ljmp以后就跑到了进程1.注意此时进程0还没跑完，还挂着呢，切换以后到res跑到三特权的进程1运行了</span><br><span class="line">	&quot;ljmp %0\n\t&quot; \ // 执行长跳转至*&amp;__tmp，造成任务切换。</span><br><span class="line">	//因此这里偏移是0，不是要跳到tss数据段执行，而是要让tss段东西恢复当前进程状态</span><br><span class="line">    //ljmp以后后面的代码段就不执行了，要看tss里面的eip指向的是哪里就执行哪里，此时task0 的栈没清理</span><br><span class="line">	//这里的ljmp不是一个简单的跳转，是一个进程切换的机制，要参考ＩＡ３2手册。先保存进程0的状态，保存在tss0里面，然后再恢复tss1</span><br><span class="line">	//那后面这几条语句什么时候执行？ 的切回进程0的时候才继续跑。</span><br><span class="line">	//进程1eip跳哪里去了？ 在copy process里面有eip，保存的位置是 init80 压入的syscall0的if（ res__&gt;=0)</span><br><span class="line">	//此时已经走了两次init80 ，一个是fork 一个是pause 这里的init 80 是fork的时候存入的，现在它的res是0，因为copy process里面存的eax=0 所以res=0</span><br><span class="line">	&quot;cmpl %%ecx,_last_task_used_math\n\t&quot; \ // 新任务上次使用过协处理器吗？</span><br><span class="line">	&quot;jne 1f\n\t&quot; \  // 没有则跳转，退出。</span><br><span class="line">	&quot;clts\n&quot; \ // 新任务上次使用过协处理器，则清 cr0 的 TS 标志。</span><br><span class="line">	&quot;1:&quot; \</span><br><span class="line">	::&quot;m&quot; (*&amp;__tmp.a),&quot;m&quot; (*&amp;__tmp.b), \ //一个是段选择子（b是段选择子），一个是偏移（a是偏移），任务门切换只需要跳到新的tss段就可，不需要偏移</span><br><span class="line">	&quot;d&quot; (_TSS(n)),&quot;c&quot; ((long) task[n])); \ //在进程切换走的时候，当前进程的状态保存在了tss（n）里面，edx保存了tss n的索引号 </span><br><span class="line">     //因此在切回来的时候，tss段里面有当前的进程状态。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tss_n:</p>
<p>tss位于gdt中的第四项，其中每项8字节，所以<code>(FIRST_TSS_ENTRY&lt;&lt;3)</code>
,每个进程tss+ldt16个字节，所以第n个进程在gdt表中的相对第0个tss的偏移量：<code>(((unsigned long) n)&lt;&lt;4)</code>
,由于这个段选择子是0特权+gdt后三位是0，不用改，所以段选择子就是长这样了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define FIRST_TSS_ENTRY 4</span><br><span class="line">#define FIRST_LDT_ENTRY (FIRST_TSS_ENTRY+1) </span><br><span class="line">#define _TSS(n) ((((unsigned long) n)&lt;&lt;4)+(FIRST_TSS_ENTRY&lt;&lt;3)) </span><br></pre></td></tr></table></figure>
<h2 id="轮转到进程1执行">轮转到进程1执行</h2>
<p>进程1的eip在tss初始化的时候由进程0进程赋值，因此切换到进程1时，程序跳转到fork结束后的<code>if (__res &gt;= 0)</code>处执行，此时的eax是在父进程创建子进程的时候，copy
process个性化设置tss的时候赋值的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="type">long</span> __res; \</span><br><span class="line">__asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span> \ <span class="comment">//init 0x80是所有系统调用函数的总入口，fork是其中之一        </span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;=a&quot;</span> (__res) \ <span class="comment">//第一个冒号之后是输出部分，将_res赋值给eax</span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;0&quot;</span> (__NR_fork))</span>; \ <span class="comment">//第二个冒号后是输入部分，&quot;0&quot;同上寄存器，即eax ，__NR_fork=2，赋值给eax，紧接着就进行了0</span></span><br><span class="line">    <span class="comment">//x80软中断</span></span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \ <span class="comment">//int 0x80中断返回后，将执行这一句</span></span><br><span class="line">	<span class="keyword">return</span> (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;tss.eax = <span class="number">0</span>;</span><br><span class="line">p-&gt;tss.ecx = ecx;</span><br></pre></td></tr></table></figure>
<p>因此res=0，fork的返回值是0</p>
<p>因此回到main函数中！fork()为真，因此下一步就开始执行init</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>	&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">if</span> (!fork()) &#123;		<span class="comment">/* we count on this going ok */</span></span><br><span class="line">		init(); </span><br><span class="line">		<span class="comment">//进程本来已经走到pause了，</span></span><br><span class="line">	<span class="comment">//	但是因为eip是fork的eip所以返回的时候是从fork这里出来的</span></span><br><span class="line">	<span class="comment">//eax是在tss初始化里面设置为0，所以res=0所以返回值就是0，所以！fork为真，所以进程1就执行到这里面的init里了</span></span><br><span class="line">	<span class="comment">//因此此时属于三特权的进程1的代码</span></span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="init">init</h3>
<h3 id="setup">setup</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> pid,i;</span><br><span class="line"></span><br><span class="line">	setup((<span class="type">void</span> *) &amp;drive_info);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>首先调用setup函数</p>
<p>setup不是通过syscall0而是通过syscall1实现的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> _syscall1(<span class="type">int</span>,setup,<span class="type">void</span> *,BIOS)</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall1(type,name,atype,a) \</span></span><br><span class="line"><span class="meta">type name(atype a) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">long __res; \</span></span><br><span class="line"><span class="meta">__asm__ volatile (<span class="string">&quot;int $0x80&quot;</span> \</span></span><br><span class="line"><span class="meta">	: <span class="string">&quot;=a&quot;</span> (__res) \</span></span><br><span class="line"><span class="meta">	: <span class="string">&quot;0&quot;</span> (__NR_##name),<span class="string">&quot;b&quot;</span> ((long)(a))); \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (__res &gt;= 0) \</span></span><br><span class="line"><span class="meta">	return (type) __res; \</span></span><br><span class="line"><span class="meta">errno = -__res; \</span></span><br><span class="line"><span class="meta">return -1; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>因此这里展开就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setup</span><span class="params">(<span class="type">void</span>* BIOS)</span> \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="type">long</span> __res; \</span><br><span class="line">__asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span> \</span></span><br><span class="line"><span class="params">	: <span class="string">&quot;=a&quot;</span> (__res) \</span></span><br><span class="line"><span class="params">	: <span class="string">&quot;0&quot;</span> (__NR_setup),<span class="string">&quot;b&quot;</span> ((<span class="type">long</span>)(a)))</span>; \</span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \</span><br><span class="line">	<span class="keyword">return</span> (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时依旧会调用init 0x80 ,
__system_call,call_sys_table(,%eax,4),最后调用到sys_setup</p>
<hr>
<p>注意：进程0 pause函数的init
0x80中断还没有返回，而setup又产生了·一个中断</p>
<hr>
<h4 id="进程1设置硬盘的hd_info">进程1设置硬盘的hd_info</h4>
<p>根据机器系统数据中的drive_info 设置内核hd_info</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231111154453412.png" alt="image-20231111154453412">
<figcaption aria-hidden="true">image-20231111154453412</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This may be used only once, enforced by &#x27;static int callable&#x27; */</span></span><br><span class="line"><span class="comment">// 程序从 BIOS 取得的 2 个硬盘的基本参数表(32 字节)。硬盘参数表信息参见下面列表后的说明。 </span></span><br><span class="line"><span class="comment">// 本函数主要功能是读取 CMOS 和硬盘参数表信息，用于设置硬盘分区结构 hd，并加载 RAM 虚拟盘和 </span></span><br><span class="line"><span class="comment">// 根文件系统</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_setup</span><span class="params">(<span class="type">void</span> * BIOS)</span> <span class="comment">//首先解决硬盘的驱动器问题</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> callable = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i,drive;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> cmos_disks;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">partition</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">   <span class="comment">// 初始化时 callable=1，当运行该函数时将其设置为 0，使本函数只能执行一次。</span></span><br><span class="line">	<span class="keyword">if</span> (!callable)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	callable = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果没有在 config.h 中定义硬盘参数，就从 0x90080 处读入</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HD_TYPE</span></span><br><span class="line">	<span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;<span class="number">2</span> ; drive++) &#123;</span><br><span class="line">		hd_info[drive].cyl = *(<span class="type">unsigned</span> <span class="type">short</span> *) BIOS;<span class="comment">// 柱面数。</span></span><br><span class="line">		hd_info[drive].head = *(<span class="type">unsigned</span> <span class="type">char</span> *) (<span class="number">2</span>+BIOS);<span class="comment">// 磁头数。</span></span><br><span class="line">		hd_info[drive].wpcom = *(<span class="type">unsigned</span> <span class="type">short</span> *) (<span class="number">5</span>+BIOS); <span class="comment">// 写前预补偿柱面号。 </span></span><br><span class="line">		hd_info[drive].ctl = *(<span class="type">unsigned</span> <span class="type">char</span> *) (<span class="number">8</span>+BIOS); <span class="comment">// 控制字节。</span></span><br><span class="line">		hd_info[drive].lzone = *(<span class="type">unsigned</span> <span class="type">short</span> *) (<span class="number">12</span>+BIOS); <span class="comment">// 磁头着陆区柱面号。 </span></span><br><span class="line">		hd_info[drive].sect = *(<span class="type">unsigned</span> <span class="type">char</span> *) (<span class="number">14</span>+BIOS); <span class="comment">// 每磁道扇区数。 </span></span><br><span class="line">		BIOS += <span class="number">16</span>; <span class="comment">// 每个硬盘的参数表长 16 字节，这里 BIOS 指向下一个表。</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// setup.s 程序在取 BIOS 中的硬盘参数表信息时，如果只有 1 个硬盘，就会将对应第 2 个硬盘的 </span></span><br><span class="line"> <span class="comment">// 16 字节全部清零。因此这里只要判断第 2 个硬盘柱面数是否为 0 就可以知道有没有第 2 个硬盘了。</span></span><br><span class="line">	<span class="keyword">if</span> (hd_info[<span class="number">1</span>].cyl)</span><br><span class="line">		NR_HD=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		NR_HD=<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 设置每个硬盘的起始扇区号和扇区总数。</span></span><br><span class="line"><span class="comment">//一个物理硬盘最多可以分4个逻辑盘，0是物理盘，1~4是逻辑盘，第一个物理盘·0*5，第二个物理盘1*5</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_HD ; i++) &#123;</span><br><span class="line">		hd[i*<span class="number">5</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">		hd[i*<span class="number">5</span>].nr_sects = hd_info[i].head*</span><br><span class="line">				hd_info[i].sect*hd_info[i].cyl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((cmos_disks = CMOS_READ(<span class="number">0x12</span>)) &amp; <span class="number">0xf0</span>)</span><br><span class="line">		<span class="keyword">if</span> (cmos_disks &amp; <span class="number">0x0f</span>)</span><br><span class="line">			NR_HD = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			NR_HD = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		NR_HD = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = NR_HD ; i &lt; <span class="number">2</span> ; i++) &#123;</span><br><span class="line">		hd[i*<span class="number">5</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">		hd[i*<span class="number">5</span>].nr_sects = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//做根设备的分区表</span></span><br><span class="line">	<span class="comment">//为啥用块？为了碎片整理，当年操作系统比较小，块不标准：1k现在应该是4k</span></span><br><span class="line">	<span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;NR_HD ; drive++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(bh = bread(<span class="number">0x300</span> + drive*<span class="number">5</span>,<span class="number">0</span>))) &#123;</span><br><span class="line">			printk(<span class="string">&quot;Unable to read partition table of drive %d\n\r&quot;</span>,</span><br><span class="line">				drive);</span><br><span class="line">			panic(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读取硬盘的引导块到缓冲区">读取硬盘的引导块到缓冲区</h4>
<p>在linux0.11中，硬盘最基础的信息就是分区表，其它信息都可以从这个信息引导出来，这个信息所在的块就是引导块。一块硬盘只有唯一的一个引导块（0号逻辑盘）。引导块有两个扇区，真正有用的是第一个扇区。bread函数实现读取引导快到缓冲区</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_setup</span><span class="params">(<span class="type">void</span> * BIOS)</span> <span class="comment">//首先解决硬盘的驱动器问题</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;NR_HD ; drive++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(bh = bread(<span class="number">0x300</span> + drive*<span class="number">5</span>,<span class="number">0</span>))) &#123;</span><br><span class="line">			printk(<span class="string">&quot;Unable to read partition table of drive %d\n\r&quot;</span>,</span><br><span class="line">				drive);</span><br><span class="line">			panic(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数量级关系">数量级关系</h4>
<p>一般hash数据结构数组比链表快一个数量级左右所以307个哈希块，每个后面串10个，一共是3000多个buffer块。</p>
<p>为啥是307？缓冲区和硬盘的速度差了两个量级。缓冲区3000多对应请求项32.缓冲区对应缓冲区到用户进程的东西，request负责缓冲区到硬盘，速度差了两个数量级</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NR_HASH 307</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_BUFFERS nr_buffers</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _hashfn(dev,block) (((unsigned)(dev^block))%NR_HASH)<span class="comment">//为啥是307？量级差不多是两个量级。307:10</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hash(dev,block) hash_table[_hashfn(dev,block)]<span class="comment">//有可能不同的设备号块号找到了同一个哈希值</span></span></span><br></pre></td></tr></table></figure>
<h4 id="缓冲区">缓冲区</h4>
<p>初始化在上一章节中做过： <a href="./第二章笔记.md###初始化缓冲区管理结构">缓冲区初始化</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> * b_data;	<span class="comment">// 指向数据块的指针（数据块为 1024 字节）	/* pointer to data block (1024 bytes) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> b_blocknr;	<span class="comment">// 块号//块号/* block number */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> b_dev;	<span class="comment">// 数据源的设备号（0 表示未用）。	/* device (0 = free) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_uptodate; <span class="comment">// 更新标志：表示数据是否已更新。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_dirt;	<span class="comment">// 修改标志：0-未修改，1-已修改。	/* 0-clean,1-dirty */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_count;		<span class="comment">// 使用该数据块的用户数。 /* users using this block */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_lock;	<span class="comment">// 缓冲区是否被锁定，0-未锁；1-已锁定。	/* 0 - ok, 1 -locked */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">b_wait</span>;</span><span class="comment">// 指向等待该缓冲区解锁的任务。 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev</span>;</span> <span class="comment">// 前一块（这四个指针用于缓冲区的管理）。 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next</span>;</span>  <span class="comment">// 下一块。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev_free</span>;</span> <span class="comment">// 前一空闲块。 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next_free</span>;</span> <span class="comment">// 下一空闲块。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>缓冲区：开一块内存，磁盘内容先读到缓冲区，在缓冲区读到内存</p>
</blockquote>
<p>//怎么设计缓冲区才能重复使用。</p>
<blockquote>
<p>为啥使用缓冲区快：存在重复读写的时候变快，有点像catche</p>
<p>怎么设计缓冲区才能满足重复使用，使得读写变快？</p>
<p>思路：缓冲区的数据一旦进了缓冲区就尽可能呆在缓冲区时间长：怎么设计</p>
<p>如果counter=0且没有新的请求或者缓冲区没满，那么这个conuter的buffer
head还得在缓冲区里面放着，满足在缓冲区时间长</p>
<p>如果缓冲区满了，有新的请求，则把counter=0的挪出去，把新的加进来</p>
<p>如果缓冲区满了，没有counter=0的，有新的请求，则新的请求等待。</p>
</blockquote>
<p>前提：从内存读比从磁盘读快200倍</p>
<p><img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115093737912.png" alt="image-20231115093737912" style="zoom:55%;"></p>
<p>缓冲区：高速缓冲区位于内核代码块和主内存区之间</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115095947238.png" alt="image-20231115095947238">
<figcaption aria-hidden="true">image-20231115095947238</figcaption>
</figure>
<p>整个高速缓冲区被划分成 1024
字节大小的缓冲块，正好与块设备上的磁盘逻辑块大小相同。高速缓冲采用 hash
表和空闲缓冲块队列进行操作管理。在缓冲区初始化过程中，从缓冲区的两端开始，同时分别设置缓冲块头结构和划分出对应的缓冲块。缓冲区的高端被划分成一个个
1024 字节的缓冲块，低端则 分别建立起对应各缓冲块的缓冲头结构
buffer_head，用于描述对应缓冲块的
属性和把所有缓冲头连接成链表。直到它们之间已经不能再划分出缓冲块为止。</p>
<p><img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115100227526.png" alt="image-20231115100227526" style="zoom:80%;"></p>
<p>buffer_head 被链接成一个空闲缓冲块双向链表结构。</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115101114916.png" alt="image-20231115101114916">
<figcaption aria-hidden="true">image-20231115101114916</figcaption>
</figure>
<p>为了能够快速地在缓冲区中寻找请求的数据块是否已经被读入到缓冲区中，buffer.c
程序使用了具有307 个 buffer_head 指针项的==hash 表结构==。上图中
buffer_head 结构的指针 b_prev、b_next 就是用于
hash表中散列在同一项上多个缓冲块之间的双向连接。Hash
表所使用的散列函数由==设备号和逻辑块号组合而成==。程序中使用的具体函数是：==(设备号^逻辑块号)
Mod 307==。</p>
<p><a href="https://www.youtube.com/watch?v=CnRR_UENZ2s">什么是哈希表</a></p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115101151894.png" alt="image-20231115101151894">
<figcaption aria-hidden="true">image-20231115101151894</figcaption>
</figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231120095719241.png" alt="image-20231120095719241">
<figcaption aria-hidden="true">image-20231120095719241</figcaption>
</figure>
<h4 id="bread">bread</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">bread</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> block)</span><span class="comment">//读指定的dev，block，第一块dev是0x300   block：0</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">    <span class="comment">//先到缓冲区里面找有没有相同的块</span></span><br><span class="line">	<span class="comment">//dev设备号block 块号</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh=getblk(dev,block))) <span class="comment">//在缓冲区找与dev，block相符合的缓冲块</span></span><br><span class="line">		panic(<span class="string">&quot;bread: getblk returned NULL\n&quot;</span>); <span class="comment">//因为现在是进程一第一次使用缓冲区不可能没有空闲块</span></span><br><span class="line">    <span class="comment">/*找到缓冲块与请求项挂载*/</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_uptodate) <span class="comment">//如果在缓冲区找到了相符合的块，如果该缓冲区中的数据是有效的（已更新的），否则可能内存还没向缓冲区完成写</span></span><br><span class="line">		<span class="keyword">return</span> bh;   <span class="comment">//返回块</span></span><br><span class="line">	<span class="comment">// 否则调用 ll_rw_block()函数，产生读设备块请求。并等待缓冲区解锁。</span></span><br><span class="line">	ll_rw_block(READ,bh); </span><br><span class="line">	wait_on_buffer(bh);<span class="comment">//之前调用了读盘的操作，数据还没用从硬盘中读完，因此等待</span></span><br><span class="line">	<span class="comment">// 如果该缓冲区已更新，则返回缓冲区头指针，退出。</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_uptodate)</span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line">	<span class="comment">// 否则表明读设备操作失败，释放该缓冲区，返回 NULL 指针，退出。 </span></span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="getblk">getblk</h5>
<p><img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115104420577.png" alt="image-20231115104420577" style="zoom:80%;"></p>
<p>缓冲块搜索函数 getblk()，以获取适合的缓冲块。该函数首先 调用
get_hash_table()函数，在 hash
表队列中搜索指定设备号和逻辑块号的缓冲块是否已经存在。如果存在就立刻返回对应缓冲头结构的指针；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">getblk</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">tmp</span>, * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">	<span class="keyword">if</span> (bh = get_hash_table(dev,block))</span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不存在，则从空闲链表头开始，对空闲链表进行扫描，寻找
一个空闲缓冲块。在寻找过程中还要对找到的空闲缓冲块作比较，根据赋予修改标志和锁定标志组合而成的权值，比较哪个空闲块最适合。若找到的空闲块既没有被修改也没有被锁定，就不用继续寻找了。</p>
<p>这里的dirt指的是进程方向的，dirt=1指的是进程修改了缓冲块，还没有写到硬盘中，而update是硬盘方向的，update=1指的是硬盘刷新过的缓冲块，数据已经读入内存。dirt和lock的区别体现在，lock是指缓冲块正在同步（正在写入硬盘），而dirt还不知道什么时候写，所以相比之下，dirt位比lock位更加的不好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BADNESS(bh) (((bh)-&gt;b_dirt<span class="string">&lt;&lt;1)+(bh)-&gt;</span>b_lock)</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">free_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">getblk</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	tmp = free_list;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">//如果被人用了就接着往下遍历</span></span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;b_count)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//BADNESS：dirt&lt;&lt;2+lock</span></span><br><span class="line">			<span class="comment">//一读一写才有竞争，生产者消费者模型，谁是自动化的，谁是主动的进程可以干预的，所以要锁住内存到缓冲区的路径</span></span><br><span class="line">			<span class="comment">//因此一加锁说明缓冲区到磁盘正在自动化操作</span></span><br><span class="line">			<span class="comment">//dirt说明缓冲区被进程写过，还没开始自动化的过程</span></span><br><span class="line">			<span class="comment">//因此dirt和lock选一个，选lock，因为lock干的时间短</span></span><br><span class="line">			<span class="comment">//dirt左移说明加了权重了</span></span><br><span class="line">			<span class="comment">//要从11 10 01 00 里面找最小的一个</span></span><br><span class="line">		<span class="keyword">if</span> (!bh || BADNESS(tmp)&lt;BADNESS(bh)) &#123;</span><br><span class="line">			bh = tmp;</span><br><span class="line">			<span class="keyword">if</span> (!BADNESS(tmp))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/* and repeat until we find something good */</span></span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">while</span> ((tmp = tmp-&gt;b_next_free) != free_list);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		sleep_on(&amp;buffer_wait);</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>若没有找到空闲块，则让当前进程进入睡眠状态，待继续执行时再次寻找。若该空闲块被锁定，则进程也需进入睡眠，等待其它进程解锁。</p>
<p>若在睡眠等待的过程中，该缓冲块又被其它进程占用，那么只要再
重头开始搜索缓冲块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait_on_buffer(bh);<span class="comment">//等待写完缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_count)<span class="comment">//不空闲则重复上面的操作//在buffer_init里面初始化的时候设置成0</span></span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br></pre></td></tr></table></figure>
<p>否则判断该缓冲块是否已被修改过，若是，则将该块写盘，并等待该块解锁。此
时如果该缓冲块又被别的进程占用，那么又一次全功尽弃，只好再重头开始执行
getblk()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//脏位置一，说明缓冲块被写了，当前正等待用户写</span></span><br><span class="line">	<span class="keyword">while</span> (bh-&gt;b_dirt) &#123;</span><br><span class="line">		sync_dev(bh-&gt;b_dev);</span><br><span class="line">		wait_on_buffer(bh);</span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_count)</span><br><span class="line">			<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在经历了以上
折腾后，此时有可能出现另外一个意外情况，也就是在我们睡眠时，可能其它进程已经将我们所需要的
缓冲块加进了 hash 队列中，因此这里需要最后一次搜索一下 hash
队列。如果真的在 hash 队列中找到了
我们所需要的缓冲块，那么我们又得对找到的缓冲块进行以上判断处理，因此，又一次需要重头开始执
行
getblk()。最后，我们才算找到了一块没有被进程使用、没有被上锁，而且是干净（修改标志未置位）
的空闲缓冲块。于是我们就将该块的引用次数置
1，并复位其它几个标志，然后从空闲表中移出该块的
缓冲头结构。在设置了该缓冲块所属的设备号和相应的逻辑号后，在将其放入
hash 表对应表项的第一个
和空闲队列的末尾处。最终，返回该缓冲块头的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">getblk</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (find_buffer(dev,block))</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="comment">/* OK, FINALLY we know that this buffer is the only one of it&#x27;s kind, */</span></span><br><span class="line"><span class="comment">/* and that it&#x27;s unused (b_count=0), unlocked (b_lock=0), and clean */</span></span><br><span class="line">	bh-&gt;b_count=<span class="number">1</span>;<span class="comment">//占用该缓冲块</span></span><br><span class="line">	bh-&gt;b_dirt=<span class="number">0</span>;<span class="comment">//还没有读盘dirt不置1</span></span><br><span class="line">	bh-&gt;b_uptodate=<span class="number">0</span>;</span><br><span class="line">	remove_from_queues(bh);<span class="comment">//假设都满了就会在叉子上面摘下来，放到其他的设备号块号上面</span></span><br><span class="line">	bh-&gt;b_dev=dev;<span class="comment">//更换设备号块号</span></span><br><span class="line">	bh-&gt;b_blocknr=block;</span><br><span class="line">	<span class="comment">//要把缓冲块叉在hash上面才算纳入了缓冲区的管理范围</span></span><br><span class="line">	insert_into_queues(bh);<span class="comment">//重新插到合适的位置</span></span><br><span class="line">	<span class="keyword">return</span> bh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="get_hash_table">get_hash_table</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">get_hash_table</span><span class="params">(<span class="type">int</span> dev, <span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(bh=find_buffer(dev,block)))<span class="comment">//在hash的链表中找相同设备号块号的缓冲区</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		bh-&gt;b_count++;<span class="comment">//增加缓冲块的引用计数</span></span><br><span class="line">		wait_on_buffer(bh);<span class="comment">//等待缓冲块，因为之前的进程不一定用完了，如果是lock的该进程sleep</span></span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_dev == dev &amp;&amp; bh-&gt;b_blocknr == block)</span><br><span class="line">			<span class="keyword">return</span> bh;</span><br><span class="line">		bh-&gt;b_count--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="一些同步加锁等待函数解析">一些同步加锁等待函数解析</h5>
<p>加锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">lock_buffer</span><span class="params">(<span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line">	cli();<span class="comment">//这个地方关中断是置EFLAGS相当于是关了进程的中断，后面虽然进程调度切换出去了</span></span><br><span class="line">	<span class="comment">//没运行sti但是进程切换的时候mtss里面有自己的EFLAGS，就没有中断了所以别的进程是有中断的</span></span><br><span class="line">	<span class="keyword">while</span> (bh-&gt;b_lock)</span><br><span class="line">		sleep_on(&amp;bh-&gt;b_wait);</span><br><span class="line">	bh-&gt;b_lock=<span class="number">1</span>;</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等待缓冲区</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">wait_on_buffer</span><span class="params">(<span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line">	cli();<span class="comment">//关中断，原子操作</span></span><br><span class="line">	<span class="comment">// 如果已被上锁，则进程进入睡眠，等待其解锁。</span></span><br><span class="line">	<span class="keyword">while</span> (bh-&gt;b_lock)<span class="comment">//为啥不是if？说明这个还会循环</span></span><br><span class="line">		sleep_on(&amp;bh-&gt;b_wait);</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系统调用。同步设备和内存高速缓冲中数据。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sync</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	sync_inodes();		<span class="comment">/* write out inodes into buffers */</span><span class="comment">//将 i 节点写入高速缓冲</span></span><br><span class="line">	bh = start_buffer;</span><br><span class="line">	<span class="comment">// 扫描所有高速缓冲区，对于已被修改的缓冲块产生写盘请求，将缓冲中数据与设备中同步。 </span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_BUFFERS ; i++,bh++) &#123;</span><br><span class="line">		wait_on_buffer(bh);</span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_dirt)</span><br><span class="line">			ll_rw_block(WRITE,bh);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="remove_from_queues">remove_from_queues</h5>
<p><img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115104420577.png" alt="image-20231115104420577" style="zoom:100%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 从 hash 队列中移除缓冲块 */</span> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">remove_from_queues</span><span class="params">(<span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* remove from hash-queue */</span></span><br><span class="line"><span class="comment">//hash队列链表上删除结点，但是始终都在双向环链表上面</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_next)</span><br><span class="line">		bh-&gt;b_next-&gt;b_prev = bh-&gt;b_prev;</span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_prev)</span><br><span class="line">		bh-&gt;b_prev-&gt;b_next = bh-&gt;b_next;</span><br><span class="line"><span class="comment">// 如果该缓冲区是该队列的头一个块，则让 hash 表的对应项指向本队列中的下一个缓冲区。</span></span><br><span class="line">	<span class="keyword">if</span> (hash(bh-&gt;b_dev,bh-&gt;b_blocknr) == bh)</span><br><span class="line">		hash(bh-&gt;b_dev,bh-&gt;b_blocknr) = bh-&gt;b_next;</span><br><span class="line"><span class="comment">/* remove from free list */</span></span><br><span class="line"><span class="comment">/* 从空闲缓冲区的双向环链表中移除缓冲块 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh-&gt;b_prev_free) || !(bh-&gt;b_next_free))</span><br><span class="line">		panic(<span class="string">&quot;Free block list corrupted&quot;</span>);</span><br><span class="line">	bh-&gt;b_prev_free-&gt;b_next_free = bh-&gt;b_next_free;</span><br><span class="line">	bh-&gt;b_next_free-&gt;b_prev_free = bh-&gt;b_prev_free;</span><br><span class="line">	<span class="keyword">if</span> (free_list == bh)</span><br><span class="line">		free_list = bh-&gt;b_next_free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="insert_into_queues">insert_into_queues</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// 将指定缓冲区插入空闲链表尾并放入 hash 队列中。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">insert_into_queues</span><span class="params">(<span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* put at end of free list */</span></span><br><span class="line"><span class="comment">/* 放在空闲链表末尾处 */</span> </span><br><span class="line">	bh-&gt;b_next_free = free_list;</span><br><span class="line">	bh-&gt;b_prev_free = free_list-&gt;b_prev_free;</span><br><span class="line">	free_list-&gt;b_prev_free-&gt;b_next_free = bh;</span><br><span class="line">	free_list-&gt;b_prev_free = bh;</span><br><span class="line"><span class="comment">/* put the buffer in new hash-queue if it has a device */</span></span><br><span class="line"><span class="comment">/* 如果该缓冲块对应一个设备，则将其插入新 hash 队列中，头插入 */</span></span><br><span class="line">	bh-&gt;b_prev = <span class="literal">NULL</span>;</span><br><span class="line">	bh-&gt;b_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!bh-&gt;b_dev)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	bh-&gt;b_next = hash(bh-&gt;b_dev,bh-&gt;b_blocknr);</span><br><span class="line">	hash(bh-&gt;b_dev,bh-&gt;b_blocknr) = bh;</span><br><span class="line">	bh-&gt;b_next-&gt;b_prev = bh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ll_rw_block">ll_rw_block</h5>
<p>ll底层的读写块操作</p>
<p>blk.h：</p>
<p><code>\#define NR_BLK_DEV  7</code></p>
<p>系统管理外设的重要数据结构：对于各种块设备，内核使用了一张块设备表
blk_dev[]来进行管理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> &#123;</span> </span><br><span class="line"> <span class="type">void</span> (*request_fn)(<span class="type">void</span>); <span class="comment">// 请求项操作的函数指针。 </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">current_request</span>;</span> <span class="comment">// 当前请求项指针。 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> <span class="title">blk_dev</span>[<span class="title">NR_BLK_DEV</span>] =</span> &#123;</span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* no_dev */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev mem */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev fd */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev hd */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev ttyx */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev tty */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;		<span class="comment">/* dev lp */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231120112732685.png" alt="image-20231120112732685">
<figcaption aria-hidden="true">image-20231120112732685</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ll_rw_block</span><span class="params">(<span class="type">int</span> rw, <span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> major;</span><br><span class="line">    <span class="comment">//NR_BLK_DEV:最开始在blk_dev 操作系统)管理外设的据结构里面见过</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> ((major=MAJOR(bh-&gt;b_dev)) &gt;= NR_BLK_DEV ||!(blk_dev[major].request_fn))</span><br><span class="line">    &#123;<span class="comment">//blk_dev[major].request 在hd_init里面做了初始化</span></span><br><span class="line">		<span class="comment">//printk：只有文件系统起来以后才能用printf，这个地方还不能用printf只能用printk</span></span><br><span class="line">		printk(<span class="string">&quot;Trying to read nonexistent block-device\n\r&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	make_request(major,rw,bh);<span class="comment">//  创建请求项并插入请求队列。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>if ((major=MAJOR(bh-&gt;b_dev)) &gt;= NR_BLK_DEV ||!(blk_dev[major].request_fn))</code></p>
</blockquote>
<p>这段的条件解析：或条件，说明两个满足一个就会报错试图读不存在的块设备</p>
<p><code>(major=MAJOR(bh-&gt;b_dev)) &gt;= NR_BLK_DEV</code></p>
<p><code>#define MAJOR(a) (((unsigned)(a))&gt;&gt;8)</code>右移8位取高字节（主设备号）。</p>
<p>将<code>bh-&gt;b_dev</code>主设备号是0~6，NR_BLK_DEV是7，大于说明不存在。</p>
<blockquote>
<p><code>!(blk_dev[major].request_fn)</code></p>
</blockquote>
<p>blk_dev[major].request
在hd_init里面做了初始化，挂载了请求项函数：do_hd_request</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_REQUEST do_hd_request</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hd_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的判断语句是指如果没有初始化，对应的就是上面表里面的NULL，！null为真，就会报错</p>
<p>挂载的另一个request*也在之前做过初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blk_dev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//NR_REQUEST是请求项的数量=32</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_REQUEST ; i++) &#123;</span><br><span class="line">		request[i].dev = <span class="number">-1</span>;<span class="comment">//设为空闲，说明这个请求项还没有聚体对应那个设备，用于判断请求项当前设备是否空闲</span></span><br><span class="line">		request[i].next = <span class="literal">NULL</span>;<span class="comment">//互不挂接，说明还没形成请求队列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个是七个blk_dev的一个是32个的request(是一个数组链表)</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231122092315542.png" alt="image-20231122092315542">
<figcaption aria-hidden="true">image-20231122092315542</figcaption>
</figure>
<h5 id="make_request">make_request</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bufferd 的时候major=3，rw=READ （0）bh：在缓冲区找到一个空闲的</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">make_request</span><span class="params">(<span class="type">int</span> major,<span class="type">int</span> rw, <span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">req</span>;</span></span><br><span class="line">	<span class="type">int</span> rw_ahead;</span><br><span class="line">	<span class="comment">//预读</span></span><br><span class="line">	<span class="keyword">if</span> (rw_ahead = (rw == READA || rw == WRITEA)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_lock)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (rw == READA)</span><br><span class="line">			rw = READ;                                                                          </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			rw = WRITE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rw!=READ &amp;&amp; rw!=WRITE)</span><br><span class="line">		panic(<span class="string">&quot;Bad block dev command, must be R/W/RA/WA&quot;</span>);</span><br><span class="line">    <span class="comment">//加锁，锁住进程向buffer的方向。</span></span><br><span class="line">	<span class="comment">//竞争：生产者消费者</span></span><br><span class="line">	lock_buffer(bh);</span><br><span class="line">	<span class="comment">//如果是写操作你又不需要写，是读操作又是最新的不需要读，矛盾</span></span><br><span class="line">	<span class="keyword">if</span> ((rw == WRITE &amp;&amp; !bh-&gt;b_dirt) || (rw == READ &amp;&amp; bh-&gt;b_uptodate)) &#123;</span><br><span class="line">		unlock_buffer(bh);<span class="comment">//sleep on 利用内核栈构造了一串等待队列</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">repeat:</span><br><span class="line">    <span class="comment">//读从最后开始，写从2/3开始，从后往前，读比写范围更大</span></span><br><span class="line">	<span class="comment">//why？读比写多？因为读的话用户比较着急，写的话用户已经写到缓冲区了用户不着急了，只要在断电前完成写就可以了。</span></span><br><span class="line">	<span class="keyword">if</span> (rw == READ)</span><br><span class="line">		req = request+NR_REQUEST;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		req = request+((NR_REQUEST*<span class="number">2</span>)/<span class="number">3</span>);</span><br><span class="line"><span class="comment">//-1是没有request 参看 blk_dev_init 数组链表</span></span><br><span class="line">	<span class="keyword">while</span> (--req &gt;= request)</span><br><span class="line">		<span class="keyword">if</span> (req-&gt;dev&lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;	</span><br><span class="line">	<span class="comment">//没找到空闲</span></span><br><span class="line">	<span class="keyword">if</span> (req &lt; request) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rw_ahead) &#123;</span><br><span class="line">			unlock_buffer(bh);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//之前的sleep等具体的buffer解锁，现在等整个请求项</span></span><br><span class="line">		sleep_on(&amp;wait_for_request);</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">	req-&gt;dev = bh-&gt;b_dev;</span><br><span class="line">	req-&gt;cmd = rw;</span><br><span class="line">	req-&gt;errors=<span class="number">0</span>;</span><br><span class="line">	req-&gt;sector = bh-&gt;b_blocknr&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	req-&gt;nr_sectors = <span class="number">2</span>;<span class="comment">//块比较小1k，扇区512，一个块对应2个扇区</span></span><br><span class="line">	req-&gt;buffer = bh-&gt;b_data;</span><br><span class="line">	req-&gt;waiting = <span class="literal">NULL</span>;</span><br><span class="line">	req-&gt;bh = bh;</span><br><span class="line">	req-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//到这里为止，缓冲块做出来了，还没有进入队列</span></span><br><span class="line">	<span class="comment">//物理上是在32个的数组里面做的，但是还没进链表，是按照链上的东西进行同步的</span></span><br><span class="line">	<span class="comment">//第二阶段，缓冲区3000多对应请求项32.缓冲区对应缓冲区到用户进程的东西</span></span><br><span class="line">	<span class="comment">//request负责缓冲区到硬盘，速度差了两个数量级</span></span><br><span class="line">	add_request(major+blk_dev,req);<span class="comment">//本质就是进入链表 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="add_request">add_request</h5>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/缓冲绘图2.png" alt="缓冲绘图">
<figcaption aria-hidden="true">缓冲绘图</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_request</span><span class="params">(<span class="keyword">struct</span> blk_dev_struct * dev, <span class="keyword">struct</span> request * req)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">	req-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	cli(); <span class="comment">//原子操作，思考什么引发了竞争</span></span><br><span class="line">	<span class="keyword">if</span> (req-&gt;bh)<span class="comment">//req不为空，说明make好了一个request</span></span><br><span class="line">		req-&gt;bh-&gt;b_dirt = <span class="number">0</span>;<span class="comment">//清dirt位</span></span><br><span class="line">	<span class="keyword">if</span>(!(tmp=dev-&gt;current_request))&#123;</span><br><span class="line">		dev-&gt;current_request = req; <span class="comment">//blk dev在之前init的时候是null后来request fun设定了但是curent request还是空的,这里相当于做一个链表的头节点</span></span><br><span class="line">		sti();</span><br><span class="line">		(dev-&gt;request_fn)();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;		</span><br><span class="line">	<span class="comment">//使用电梯算法，让磁头移动的距离最小</span></span><br><span class="line">	<span class="keyword">for</span> ( ; tmp-&gt;next ; tmp=tmp-&gt;next)<span class="comment">//当dev blk不为空的时候，相当于头节点不为空了，所以这里进行插入结点</span></span><br><span class="line">		<span class="keyword">if</span> ((IN_ORDER(tmp,req) ||</span><br><span class="line">		    !IN_ORDER(tmp,tmp-&gt;next)) &amp;&amp;</span><br><span class="line">		    IN_ORDER(req,tmp-&gt;next))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	req-&gt;next=tmp-&gt;next;</span><br><span class="line">	tmp-&gt;next=req;</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="dev-request_fn-do_hd_request">(dev-&gt;request_fn)();
do_hd_request</h5>
<p>hd_init的时候挂载了请求项函数：<code>#define DEVICE_REQUEST do_hd_request</code></p>
<p><code>blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;</code></p>
<p>do_hd_request()是硬盘请求项的操作函数。其操作流程如下：</p>
<ul>
<li><p>首先判断当前请求项是否存在，若当前请求项指针为空，则说明目前硬盘块设备已经没有待处理
的请求项，因此立刻退出程序。这是在宏 INIT_REQUEST
中执行的语句。否则就继续处理当前请 求项。</p></li>
<li><p>对当前请求项中指明的设备号和请求的盘起始扇区号的合理性进行验证；</p></li>
<li><p>根据当前请求项提供的信息计算请求数据的磁盘磁道号、磁头号和柱面号；</p></li>
<li><p>如果复位标志（reset）已被设置，则也设置硬盘重新校正标志（recalibrate），并对硬盘执行复位操
作，向控制器重新发送“建立驱动器参数”命令（WIN_SPECIFY）。该命令不会引发硬盘中断；</p></li>
<li><p>如果重新校正标志被置位的话，就向控制器发送硬盘重新校正命令（WIN_RESTORE），并在发送
之前预先设置好该命令引发的中断中需要执行的 C
函数（recal_intr()），并退出。recal_intr()函数的
主要作用是：当控制器执行该命令结束并引发中断时，能重新（继续）执行本函数。</p></li>
<li><p>如果当前请求项指定是写操作，则首先设置硬盘控制器调用的 C 函数为
write_intr()，向控制器发</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_hd_request</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,r;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> block,dev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sec,head,cyl;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nsect;</span><br><span class="line">    <span class="comment">// 检测请求项的合法性，若已没有请求项则退出</span></span><br><span class="line">	INIT_REQUEST;<span class="comment">//repeat在这个宏里面</span></span><br><span class="line">	dev = MINOR(CURRENT-&gt;dev);</span><br><span class="line">	block = CURRENT-&gt;sector;</span><br><span class="line">	<span class="comment">// 如果子设备号不存在或者起始扇区大于该分区扇区数-2，则结束该请求，并跳转到标号 repeat 处 </span></span><br><span class="line">    <span class="comment">// （定义在 INIT_REQUEST 开始处）。因为一次要求读写 2 个扇区（512*2 字节），所以请求的扇区号 </span></span><br><span class="line">    <span class="comment">// 不能大于分区中最后倒数第二个扇区号。</span></span><br><span class="line">	<span class="keyword">if</span> (dev &gt;= <span class="number">5</span>*NR_HD || block+<span class="number">2</span> &gt; hd[dev].nr_sects) &#123;</span><br><span class="line">		end_request(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过加上本分区的起始扇区号，把将所需读写的块对应到整个硬盘的绝对扇区号上</span></span><br><span class="line">	block += hd[dev].start_sect;</span><br><span class="line">	dev /= <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 下面嵌入汇编代码用来从硬盘信息结构中根据起始扇区号和每磁道扇区数计算在磁道中的 </span></span><br><span class="line">    <span class="comment">// 扇区号(sec)、所在柱面号(cyl)和磁头号(head)。</span></span><br><span class="line">	__asm__(<span class="string">&quot;divl %4&quot;</span>:<span class="string">&quot;=a&quot;</span> (block),<span class="string">&quot;=d&quot;</span> (sec):<span class="string">&quot;0&quot;</span> (block),<span class="string">&quot;1&quot;</span> (<span class="number">0</span>),</span><br><span class="line">		<span class="string">&quot;r&quot;</span> (hd_info[dev].sect));</span><br><span class="line">	__asm__(<span class="string">&quot;divl %4&quot;</span>:<span class="string">&quot;=a&quot;</span> (cyl),<span class="string">&quot;=d&quot;</span> (head):<span class="string">&quot;0&quot;</span> (block),<span class="string">&quot;1&quot;</span> (<span class="number">0</span>),</span><br><span class="line">		<span class="string">&quot;r&quot;</span> (hd_info[dev].head));</span><br><span class="line">	sec++;</span><br><span class="line">	nsect = CURRENT-&gt;nr_sectors;</span><br><span class="line">	<span class="comment">// 如果 reset 标志是置位的，则执行复位操作。复位硬盘和控制器，并置需要重新校正标志，返回。</span></span><br><span class="line">	<span class="keyword">if</span> (reset) &#123;</span><br><span class="line">		reset = <span class="number">0</span>;</span><br><span class="line">		recalibrate = <span class="number">1</span>;</span><br><span class="line">		reset_hd(CURRENT_DEV);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果重新校正标志(recalibrate)置位，则首先复位该标志，然后向硬盘控制器发送重新校正命令。 </span></span><br><span class="line">    <span class="comment">// 该命令会执行寻道操作，让处于任何地方的磁头移动到 0 柱面。</span></span><br><span class="line">	<span class="keyword">if</span> (recalibrate) &#123;</span><br><span class="line">		recalibrate = <span class="number">0</span>;</span><br><span class="line">		hd_out(dev,hd_info[CURRENT_DEV].sect,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">			WIN_RESTORE,&amp;recal_intr);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//和驱动挂钩子了</span></span><br><span class="line">	<span class="comment">// 如果当前请求是写扇区操作，则发送写命令，循环读取状态寄存器信息并判断请求服务标志 </span></span><br><span class="line">   <span class="comment">// DRQ_STAT 是否置位。DRQ_STAT 是硬盘状态寄存器的请求服务位，表示驱动器已经准备好在主机和 </span></span><br><span class="line">   <span class="comment">// 数据端口之间传输一个字或一个字节的数据。</span></span><br><span class="line"> 	<span class="keyword">if</span> (CURRENT-&gt;cmd == WRITE) &#123;</span><br><span class="line">		hd_out(dev,nsect,sec,head,cyl,WIN_WRITE,&amp;write_intr);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span> ; i&lt;<span class="number">3000</span> &amp;&amp; !(r=inb_p(HD_STATUS)&amp;DRQ_STAT) ; i++)</span><br><span class="line">			<span class="comment">/* nothing */</span> ;</span><br><span class="line">		<span class="keyword">if</span> (!r) &#123;</span><br><span class="line">			bad_rw_intr();</span><br><span class="line">			<span class="keyword">goto</span> repeat;</span><br><span class="line">		&#125;</span><br><span class="line">		port_write(HD_DATA,CURRENT-&gt;buffer,<span class="number">256</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CURRENT-&gt;cmd == READ) &#123;</span><br><span class="line">		hd_out(dev,nsect,sec,head,cyl,WIN_READ,&amp;read_intr);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		panic(<span class="string">&quot;unknown hd-command&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="hd_out">hd_out</h5>
<p><code>hd_out(dev,nsect,sec,head,cyl,WIN_READ,&amp;read_intr);</code></p>
<p><code>hd_out(dev,nsect,sec,head,cyl,WIN_WRITE,&amp;write_intr);</code></p>
<p>后两个实参<code>read_intr</code>
是读盘对应的中断服务函数，是一个钩子，要提取这个函数的地址准备挂接，读挂接read_intr，写挂接write_intr</p>
<p><code>unsigned int cmd</code>对应接下来要进行的操作</p>
<p>是硬盘控制器操作命令发送函数。该函数带有一个中断过程中调用的 C
函数指针参数，在
向控制器发送命令之前，它首先使用这个参数预置好中断过程中会调用的函数指针（do_hd）</p>
<p>然后它按 照规定的方式依次向硬盘控制器 0x1f0 至 0x1f7
发送命令参数块。：<code>\#define outb_p(value,port)</code></p>
<p>除控制器诊断（WIN_DIAGNOSE）和
建立驱动器参数（WIN_SPECIFY）两个命令以外，硬盘控制器在接收到任何其它命令并执行了命令以后，
都会向 CPU 发出中断请求信号，从而引发系统去执行硬盘中断处理过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hd_out</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> drive,<span class="type">unsigned</span> <span class="type">int</span> nsect,<span class="type">unsigned</span> <span class="type">int</span> sect,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> head,<span class="type">unsigned</span> <span class="type">int</span> cyl,<span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">		<span class="type">void</span> (*intr_addr)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="type">int</span> port <span class="title function_">asm</span><span class="params">(<span class="string">&quot;dx&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (drive&gt;<span class="number">1</span> || head&gt;<span class="number">15</span>)</span><br><span class="line">		panic(<span class="string">&quot;Trying to write bad sector&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!controller_ready())</span><br><span class="line">		panic(<span class="string">&quot;HD controller not ready&quot;</span>);</span><br><span class="line">	do_hd = intr_addr;<span class="comment">//把read intr挂上去//// do_hd 函数指针将在硬盘中断程序中被调用。</span></span><br><span class="line">	<span class="comment">//一次命令是一个块，一个操做两个扇区，一个命令跑两次</span></span><br><span class="line">	outb_p(hd_info[drive].ctl,HD_CMD);<span class="comment">//// 向控制寄存器(0x3f6)输出控制字节。</span></span><br><span class="line">	port=HD_DATA;<span class="comment">//置 dx 为数据寄存器端口(0x1f0)。</span></span><br><span class="line">	outb_p(hd_info[drive].wpcom&gt;&gt;<span class="number">2</span>,++port);<span class="comment">// 参数：写预补偿柱面号(需除 4)。 </span></span><br><span class="line">	outb_p(nsect,++port);<span class="comment">// 参数：读/写扇区总数。</span></span><br><span class="line">	outb_p(sect,++port);<span class="comment">// 参数：起始扇区。</span></span><br><span class="line">	outb_p(cyl,++port);<span class="comment">// 参数：柱面号低 8 位。 </span></span><br><span class="line">	outb_p(cyl&gt;&gt;<span class="number">8</span>,++port);<span class="comment">// 参数：柱面号高 8 位</span></span><br><span class="line">	outb_p(<span class="number">0xA0</span>|(drive&lt;&lt;<span class="number">4</span>)|head,++port);<span class="comment">// 参数：驱动器号+磁头号。 </span></span><br><span class="line">	outb(cmd,++port);<span class="comment">// 命令：硬盘控制命令。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="hd_interrupt">_hd_interrupt:</h4>
<p>do_hd已经挂接了函数，在执行硬盘中断函数的时候会自动执行</p>
<p>_hd_interrupt位于system_call.s</p>
<p>这里中断函数的挂接在hd_init中完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hd_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	set_intr_gate(<span class="number">0x2E</span>,&amp;hd_interrupt);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_hd_interrupt:</span><br><span class="line">	pushl %eax</span><br><span class="line">	pushl %ecx</span><br><span class="line">	pushl %edx</span><br><span class="line">	push %ds</span><br><span class="line">	push %es</span><br><span class="line">	push %fs</span><br><span class="line">	movl $0x10,%eax  ## ds,es 置为内核数据段。</span><br><span class="line">	mov %ax,%ds</span><br><span class="line">	mov %ax,%es</span><br><span class="line">	movl $0x17,%eax  #fs置为调用程序的局部数据段。</span><br><span class="line">	mov %ax,%fs</span><br><span class="line">	# 由于初始化中断控制芯片时没有采用自动 EOI，所以这里需要发指令结束该硬件中断。</span><br><span class="line">	movb $0x20,%al</span><br><span class="line">	outb %al,$0xA0		# EOI to interrupt controller #1</span><br><span class="line">	jmp 1f			# give port chance to breathe</span><br><span class="line">1:	jmp 1f</span><br><span class="line">1:	xorl %edx,%edx #清零</span><br><span class="line">	xchgl _do_hd,%edx # do_hd 定义为一个函数指针，将被赋值 read_intr()或write_intr()函数地址。(kernel/blk_drv/hd.c) </span><br><span class="line">	# 放到 edx 寄存器后就将 do_hd 指针变量置为 NULL。</span><br><span class="line">	testl %edx,%edx # 测试函数指针是否为 Null。</span><br><span class="line">	jne 1f # 若空，则使指针指向 C 函数 unexpected_hd_interrupt()</span><br><span class="line">	movl $_unexpected_hd_interrupt,%edx # 送主 8259A 中断控制器 EOI 指令（结束硬件中断）。</span><br><span class="line">1:	outb %al,$0x20</span><br><span class="line">	call *%edx		# &quot;interesting&quot; way of handling intr.</span><br><span class="line">	pop %fs #上句调用 do_hd 指向的 C 函数</span><br><span class="line">	pop %es</span><br><span class="line">	pop %ds</span><br><span class="line">	popl %edx</span><br><span class="line">	popl %ecx</span><br><span class="line">	popl %eax</span><br><span class="line">	iret</span><br></pre></td></tr></table></figure>
<p>硬盘开始将引导块中的数据不断读入缓存中，同时函数一路返回到bread</p>
<h4 id="读盘还没完成这个过程中进程01的切换">读盘还没完成这个过程中进程0，1的切换</h4>
<p>进入<code>wait_on_buffer(bh);</code></p>
<p>进入<code>sleep_on</code>，此时进程1设置为不可中断等待状态，进入schedule函数</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231127094912326.png" alt="image-20231127094912326">
<figcaption aria-hidden="true">image-20231127094912326</figcaption>
</figure>
<h5 id="sleep_on">sleep_on</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span><span class="comment">//p是指向b_wait的志珍</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (current == &amp;(init_task.task))<span class="comment">//当前进程是不是进程0</span></span><br><span class="line">		panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">	tmp = *p;<span class="comment">//*p就是b_wait，目前是null在初始化的时候是null（buffer init）第一个缓冲块初始化到现在还没动过</span></span><br><span class="line">	*p = current;<span class="comment">//b_wait 指向进程1的task struct。                                                                                            </span></span><br><span class="line">	current-&gt;state = TASK_UNINTERRUPTIBLE;<span class="comment">//进程·0进程1都挂起了</span></span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">if</span> (tmp)</span><br><span class="line">		tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getblk 是先进去再读写数据
可能不同进程用同一个缓冲块。因为进入队列以后没有立刻写数据，getblk找现成的找到了同一个缓冲块，一个进程sleep
on的时候，其他的进程也sleep on 了 目前在内核态，tmp在内核栈里面</p>
<p>buffer head是全局的变量（buffer init） ##### 进程0被强制唤醒</p>
<p>这次遍历task的时候，进程0和进程1都是不可中断等待状态，这时进程0就以不可中断状态的姿态强制执行了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...	</span><br><span class="line"><span class="comment">// 如果比较得出有 counter 值大于 0 的结果，则退出 循环，执行任务切换 </span></span><br><span class="line">		<span class="keyword">if</span> (c) <span class="keyword">break</span>;<span class="comment">//当没有找到进程的时候break，也就是所有的进程都挂起就切回默认的进程0</span></span><br><span class="line">		<span class="comment">// 否则就根据每个任务的优先权值，更新每一个任务的 counter 值. </span></span><br><span class="line">       <span class="comment">// counter 值的计算方式为 counter = counter /2 + priority。这里计算过程不考虑进程的状态。</span></span><br><span class="line">		<span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">			<span class="keyword">if</span> (*p)</span><br><span class="line">				(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>)+ </span><br><span class="line">						(*p)-&gt;priority;</span><br><span class="line">	&#125;</span><br><span class="line">	switch_to(next);<span class="comment">// 切换到任务号为 next 的任务，并运行之。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前进程0被切换到进程1的时候，进程0停在了switch_to函数中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> switch_to(n) &#123;\  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">long</span> a,b;&#125; __tmp; \ </span><br><span class="line">__asm__(<span class="string">&quot;cmpl %%ecx,_current\n\t&quot;</span> \ <span class="comment">// 任务 n 是当前任务吗?(current ==task[n]?) </span></span><br><span class="line">  ...</span><br><span class="line">	<span class="string">&quot;ljmp %0\n\t&quot;</span> \ <span class="comment">// 执行长跳转至*&amp;__tmp，造成任务切换。</span></span><br><span class="line">	<span class="string">&quot;cmpl %%ecx,_last_task_used_math\n\t&quot;</span> \ <span class="comment">// 新任务上次使用过协处理器吗？</span></span><br><span class="line">	<span class="string">&quot;jne 1f\n\t&quot;</span> \  <span class="comment">// 没有则跳转，退出。</span></span><br><span class="line">	<span class="string">&quot;clts\n&quot;</span> \ <span class="comment">// 新任务上次使用过协处理器，则清 cr0 的 TS 标志。</span></span><br><span class="line">	<span class="string">&quot;1:&quot;</span> \</span><br><span class="line">	::<span class="string">&quot;m&quot;</span> (*&amp;__tmp.a),<span class="string">&quot;m&quot;</span> (*&amp;__tmp.b), \ <span class="comment">//一个是段选择子（b是段选择子），一个是偏移（a是偏移），任务门切换只需要跳到新的tss段就可，不需要偏移</span></span><br><span class="line">	<span class="string">&quot;d&quot;</span> (_TSS(n)),<span class="string">&quot;c&quot;</span> ((<span class="type">long</span>) task[n])); \ <span class="comment">//在进程切换走的时候，当前进程的状态保存在了tss（n）里面，edx保存了tss n的索引号 </span></span><br><span class="line">     <span class="comment">//因此在切回来的时候，tss段里面有当前的进程状态。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切到进程1的时候执行了<code>ljmp %0\n\</code>进程切走了，而进程0自己的tss里面保存的要执行的下一条指令的eip：<code>cmpl %%ecx,_last_task_used_math\n\t</code>
是这条指令，因此切回进程0从这条语句开始执行</p>
<p>进程0将处于挂起状态执行：pause(),sys_pause(),schedule(),switch_to(0).进程0起到怠速作用</p>
<p>当过了一段时间，硬盘剩下的数据读完了硬件产生中断，读盘中断服务程序响应中断，进入read_intr判断缓冲区是否读完，这里一共一个块要读两次，两次都读完就读完了</p>
<p>不执行<code>if (--CURRENT-&gt;nr_sectors)</code>里面·的·语句，直接跳到<code>end_request(1)</code>语句执行</p>
<h5 id="read_intr">read_intr</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_intr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (win_result()) &#123;</span><br><span class="line">		bad_rw_intr();</span><br><span class="line">		do_hd_request();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	port_read(HD_DATA,CURRENT-&gt;buffer,<span class="number">256</span>);</span><br><span class="line">	CURRENT-&gt;errors = <span class="number">0</span>;</span><br><span class="line">	CURRENT-&gt;buffer += <span class="number">512</span>;</span><br><span class="line">	CURRENT-&gt;sector++;</span><br><span class="line">	<span class="keyword">if</span> (--CURRENT-&gt;nr_sectors) &#123;</span><br><span class="line">		do_hd = &amp;read_intr;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	end_request(<span class="number">1</span>);</span><br><span class="line">	do_hd_request();<span class="comment">//请求项里面只要有任意一个请求项走到同步操作，</span></span><br><span class="line">	<span class="comment">//就一直走走到走完为止（主设备的那一条链上的request）</span></span><br><span class="line">	<span class="comment">//类似于从中断引发的递归 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203231230513.png" alt="image-20231203231230513">
<figcaption aria-hidden="true">image-20231203231230513</figcaption>
</figure>
<h5 id="end_request">end_request</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CURRENT (blk_dev[MAJOR_NR].current_request) <span class="comment">//CURRENT是当前请求项</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">wait_for_request</span> =</span> <span class="literal">NULL</span>;<span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">end_request</span><span class="params">(<span class="type">int</span> uptodate)</span></span><br><span class="line">&#123;</span><br><span class="line">	DEVICE_OFF(CURRENT-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (CURRENT-&gt;bh) &#123;</span><br><span class="line">		CURRENT-&gt;bh-&gt;b_uptodate = uptodate;</span><br><span class="line">		unlock_buffer(CURRENT-&gt;bh);<span class="comment">//解锁缓冲块</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!uptodate) &#123;</span><br><span class="line">		printk(DEVICE_NAME <span class="string">&quot; I/O error\n\r&quot;</span>);</span><br><span class="line">		printk(<span class="string">&quot;dev %04x, block %d\n\r&quot;</span>,CURRENT-&gt;dev,</span><br><span class="line">			CURRENT-&gt;bh-&gt;b_blocknr);</span><br><span class="line">	&#125;</span><br><span class="line">	wake_up(&amp;CURRENT-&gt;waiting);<span class="comment">//这个没用过</span></span><br><span class="line">	wake_up(&amp;wait_for_request);<span class="comment">//唤醒由于请求项用完了而休眠的进程</span></span><br><span class="line">	CURRENT-&gt;dev = <span class="number">-1</span>;<span class="comment">//反应请求项是否被占用</span></span><br><span class="line">	CURRENT = CURRENT-&gt;next;<span class="comment">//req仍然在数组中，但从链上脱钩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时磁盘已经全部读进来，update=1位置1</p>
<h4 id="进程1唤醒">进程1唤醒</h4>
<h5 id="unlock_buffer">unlock_buffer</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">unlock_buffer</span><span class="params">(<span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!bh-&gt;b_lock)</span><br><span class="line">		printk(DEVICE_NAME <span class="string">&quot;: free buffer being unlocked\n&quot;</span>);</span><br><span class="line">	bh-&gt;b_lock=<span class="number">0</span>;<span class="comment">//解锁，之前给缓冲块向进程（1）之间加锁</span></span><br><span class="line">	wake_up(&amp;bh-&gt;b_wait);<span class="comment">//唤醒进程（1）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="wake_up">wake_up</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//p 指向b_wait的指针</span></span><br><span class="line">    <span class="comment">//*p b_wait</span></span><br><span class="line">	<span class="comment">//**p b_wait指向的东西，task—struct</span></span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; *p) &#123;</span><br><span class="line">		(**p).state=<span class="number">0</span>;</span><br><span class="line">		*p=<span class="literal">NULL</span>;<span class="comment">//tmp </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="这里是null还是tmp的讨论---sleep_on深层逻辑基于内核栈的唤醒队列">这里是null还是tmp的讨论---sleep_on深层逻辑基于内核栈的唤醒队列</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span><span class="comment">//p是指向b_wait的志珍</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (current == &amp;(init_task.task))<span class="comment">//当前进程是不是进程0</span></span><br><span class="line">		panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">	tmp = *p;<span class="comment">//*p就是b_wait，目前是null在初始化的时候是null（buffer init）第一个缓冲块初始化到现在还没动过</span></span><br><span class="line">	*p = current;<span class="comment">//b_wait 指向进程1的task struct。                                                                                            </span></span><br><span class="line">	current-&gt;state = TASK_UNINTERRUPTIBLE;<span class="comment">//进程·0进程1都挂起了</span></span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">if</span> (tmp)</span><br><span class="line">		tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">	*p=tmp;<span class="comment">//加这一句会更好，比较对称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep on 构成的队列分析：</p>
<p>因为sleep_on是在内核态调用的，所以这里的tmp是在内核栈中，b_wait是全局变量。一开始只有进程A申请的时候，最开始的b_wait=null</p>
<p>假设一开始只有进程A，A申请缓冲块，一开始没有现成的的缓冲块，进程A调用<code>getblk</code>,首先在hash表里面找<code>get_hash_table</code></p>
<p>没有现成的，然后沿着free_list在缓冲块的双向环链表上面寻找，顺着链找一块没被别的进程占用（引用计数为0（别的进程已经走了），并且最好是lock或者完全没被用过的，其次才是dirt的），此时假设缓冲区全是新的（和进程1一样），此时A会把该缓冲块插入hash的叉子上，然后进程A需要等待磁盘将内容加载到它选择的这块缓冲块里面，在等待的过程中进程A
sleep。具体而言，在<code>make_request</code>中开始加锁：<code>lock_buffer</code>，进程A在执行到bread的<code>wait_on_buffer(bh);</code>的时候睡眠等待磁盘把缓冲区写完。</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129104547640.png" alt="A stack">
<figcaption aria-hidden="true">A stack</figcaption>
</figure>
<p>此时如果切到新的进程B也要申请和A相同的设备号块号，B在调用getblk的时候：执行<code>if (bh = get_hash_table(dev,block)) return bh</code>的时候，因为A已经把缓冲块放到Hash队列里面了，所以进程B找到了现成的，此时进程A还没有用完，进程B在wait
buffer的时候调用sleep_on。</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129105131834.png" alt="B内核栈">
<figcaption aria-hidden="true">B内核栈</figcaption>
</figure>
<p>同理如果又来了进程C也请求了该缓冲块就变成：形成一个由内核栈构成的等待队列</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129105434871.png" alt="等待队列">
<figcaption aria-hidden="true">等待队列</figcaption>
</figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129101121864.png" alt="该缓冲块插入hash的叉子上">
<figcaption aria-hidden="true">该缓冲块插入hash的叉子上</figcaption>
</figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129095311681.png" alt="image-20231129095311681">
<figcaption aria-hidden="true">image-20231129095311681</figcaption>
</figure>
<p>那么现在回到wake up</p>
<p>当进程A完成磁盘的操作后，唤醒进程的时候是通过b
wait唤醒，如果是null的效果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//p 指向b_wait的指针</span></span><br><span class="line">    <span class="comment">//*p b_wait</span></span><br><span class="line">	<span class="comment">//**p b_wait指向的东西，task—struct</span></span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; *p) &#123;</span><br><span class="line">		(**p).state=<span class="number">0</span>;</span><br><span class="line">		*p=<span class="literal">NULL</span>;<span class="comment">//tmp </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129110807043.png" alt="image-20231129110807043">
<figcaption aria-hidden="true">image-20231129110807043</figcaption>
</figure>
<p>切回来以后进程继续沿着sleep_on执行</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129111725176.png" alt="image-20231129111725176">
<figcaption aria-hidden="true">image-20231129111725176</figcaption>
</figure>
<p>唤醒tmp所指的进程B</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129111811437.png" alt="image-20231129111811437">
<figcaption aria-hidden="true">image-20231129111811437</figcaption>
</figure>
<p>在schedule的时候会用到state，由于此时state已经设为0解锁了，调度的时候就可以切到该进程执行。</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129111130011.png" alt="image-20231129111130011">
<figcaption aria-hidden="true">image-20231129111130011</figcaption>
</figure>
<p>在这个框架下面其他的进程怎么唤醒？由链子上面的上一个进程负责唤醒下一个进程</p>
<h4 id="bread后时代">bread后时代</h4>
<p>回到<code>sys_setup</code>执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_setup</span><span class="params">(<span class="type">void</span> * BIOS)</span> <span class="comment">//首先解决硬盘的驱动器问题</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;NR_HD ; drive++) &#123;</span><br><span class="line">         <span class="comment">//300hd 200fd 100 虚拟盘</span></span><br><span class="line">		<span class="keyword">if</span> (!(bh = bread(<span class="number">0x300</span> + drive*<span class="number">5</span>,<span class="number">0</span>))) &#123;</span><br><span class="line">			printk(<span class="string">&quot;Unable to read partition table of drive %d\n\r&quot;</span>,</span><br><span class="line">				drive);</span><br><span class="line">			panic(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//缓冲块里，装着引导块的内容，如果扇区最后两个字节不是55AA说明扇区数据无效</span></span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_data[<span class="number">510</span>] != <span class="number">0x55</span> || (<span class="type">unsigned</span> <span class="type">char</span>)</span><br><span class="line">		    bh-&gt;b_data[<span class="number">511</span>] != <span class="number">0xAA</span>) &#123;</span><br><span class="line">			printk(<span class="string">&quot;Bad partition table on drive %d\n\r&quot;</span>,drive);</span><br><span class="line">			panic(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		p = <span class="number">0x1BE</span> + (<span class="type">void</span> *)bh-&gt;b_data;<span class="comment">//根据引导块中的信息设置分区hd</span></span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++,p++) &#123;</span><br><span class="line">			hd[i+<span class="number">5</span>*drive].start_sect = p-&gt;start_sect;</span><br><span class="line">			hd[i+<span class="number">5</span>*drive].nr_sects = p-&gt;nr_sects;</span><br><span class="line">		&#125;</span><br><span class="line">		brelse(bh);<span class="comment">//该缓冲块的历史使命已经完成，释放</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (NR_HD)</span><br><span class="line">		printk(<span class="string">&quot;Partition table%s ok.\n\r&quot;</span>,(NR_HD&gt;<span class="number">1</span>)?<span class="string">&quot;s&quot;</span>:<span class="string">&quot;&quot;</span>);</span><br><span class="line">	rd_load();</span><br><span class="line">	mount_root();</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引导块0，超级块1，一个分区一个</p>
<h4 id="文件系统">文件系统</h4>
<h5 id="minix-文件系统">MINIX <strong>文件系统</strong></h5>
<p>详见：操作系统文件系统。</p>
<p>操作系统中的文件系统可以分为两部分：操作系统内核中或者在硬盘软盘虚拟盘中。一个物理设备可以分为多个逻辑设备，比如一个物理硬盘可以分为多个逻辑硬盘。而一个逻辑设备只有一个文件系统，一个文件系统只包含一个i结点的树结构。一个逻辑设备只能有一个根i结点。</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203234247319.png" alt="image-20231203234247319">
<figcaption aria-hidden="true">image-20231203234247319</figcaption>
</figure>
<p>未安装文件系统的磁盘称之为生磁盘，生磁盘也可以作为文件读写，linux中一切皆文件。</p>
<p>生磁盘可以被分区，分区中可以安装文件系统，常见的文件系统有fat32、ext2、ext4等。</p>
<p>MINIX 文件系统与标准 UNIX 的文件系统基本相同。它由 6
个部分组成。分区内可以安装指定文件系统，同一磁盘多个分区文件系统不要求相同。MINIX文件系统布局如下：(下述部分是在磁盘上的)</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203233251707.png" alt="MINIX文件系统布局">
<figcaption aria-hidden="true">MINIX文件系统布局</figcaption>
</figure>
<ul>
<li><p>引导块：若作为引导分区，将存放<strong>操作系统的引导程序代码</strong>，否则空置。</p></li>
<li><p>超级块：用于存放磁盘设备上<strong>文件系统结构的信息</strong>，说明各部分的大小。</p></li>
<li><p>i节点位图：标记i节点数据元素是否被使用</p></li>
<li><p>逻辑块位图：标记磁盘数据块是否被使用</p></li>
<li><p>i节点区：用于存放inode节点数据，一个文件对应一个inode节点，inode节点存储文件属性数据。</p></li>
<li><p>数据区：以固定大小盘块（1k）为单位进行动态分配和回收，用于存储数据，类似内存分页。</p>
<p>位图：一个比特对应一个逻辑块，0，1代表是否被占用</p>
<p>删除文件：清理数据块关系清掉，对应逻辑块位图清0，清理i结点和i结点对应位图。</p>
<p><strong>超级块结构：</strong></p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_ninodes;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_nzones;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_imap_blocks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_zmap_blocks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_firstdatazone;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_log_zone_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_max_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_magic;</span><br><span class="line"><span class="comment">/* These are only in memory */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_imap</span>[8];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_zmap</span>[8];</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_isup</span>;</span><span class="comment">//文件系统的根i结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_imount</span>;</span><span class="comment">//文件系统挂载到的结点</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_time;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">s_wait</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> s_lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> s_rd_only;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> s_dirt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205203527644.png" alt="超级块结构">
<figcaption aria-hidden="true">超级块结构</figcaption>
</figure>
<p><strong>inode结构</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_uid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_mtime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_gid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_nlinks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_zone[<span class="number">9</span>];</span><br><span class="line"><span class="comment">/* these are in memory also */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">i_wait</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_atime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_ctime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_dev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_num;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_dirt;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_pipe;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_mount;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_seek;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_update;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205203724496.png" alt="inode结构">
<figcaption aria-hidden="true">inode结构</figcaption>
</figure>
<p><strong>i_zone数组</strong></p>
<p><code>unsigned short i_zone[9];</code></p>
<p>i_zone数组包含直接盘块号、一次间接盘块号和二次间接盘块号。一次盘块号可视为单级页表，一次间接盘块号可视为二级页表、二次间接盘块号可视为三级页表。</p>
<p>这种处理方式的好处在于，对于小文件，通过直接块号可快速定位数据块；对于中等类型的文件，一次间接块可以维护较多数据块的同时，具有较快的访问速度；对于大型文件，二次间接盘块号可以维护大量磁盘块，但访问速度较慢。</p>
<p>内存多级页表与i_zone直接区别：不同进程具有固定大小的虚地址空间，并且对其整个虚地址空间的内存，都有可能访问到，因此使用多级页表。文件系统内存在很多大小不一的文件，综合考虑对不同大小文件的特点，使用1-3级磁盘块表可以分别处理小、中、大文件。</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205204603044.png" alt="izone">
<figcaption aria-hidden="true">izone</figcaption>
</figure>
<h5 id="文件系统-1">文件系统</h5>
<p>所有文件的i结点最终会挂成一个树形结构，树根i结点就是文件系统的根i结点，</p>
<p>加载文件系统就是把一个文件系统的根i结点挂接在另一个文件系统的i结点上，按照这个设计，一个文件系统必须要挂在另一个文件系统上面，最后最根部那个文件系统就是根文件系统</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203234309406.png" alt="加载根文件系统">
<figcaption aria-hidden="true">加载根文件系统</figcaption>
</figure>
<p>根文件系统挂在super_block[8]上。超级块：有一个超级块数组super_block[8]里面每一个元素是一个超级块，只要一个文件系统加载到内核了这个文件系统的根i结点会依次加载到这个数组里面。最多加载8个文件系统</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203234655944.png" alt="总体效果图">
<figcaption aria-hidden="true">总体效果图</figcaption>
</figure>
<p>文件系统用i结点来管理，一个i结点管理一个文件，目录文件也是文件，也有i结点来管理。</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203232737245.png" alt="文件系统与i结点">
<figcaption aria-hidden="true">文件系统与i结点</figcaption>
</figure>
<p><strong>加载文件过程举例</strong>：</p>
<p>通过文件inode节点，可以定位文件数据块，那如何通过文件路径定位到具体文件？</p>
<p>文件系统主要包含文件和目录两种文件，目录是一种特殊的文件，其文件内容存储其目录下文件名-&gt;inode节点号的映射信息。文件查找开始于根目录，根目录号固定为0，不需要查找即可直接打开。</p>
<p>举例说明文件查找过程，给定存在路径<code>/name1/name2/name3</code>查找具体文件过程：</p>
<p>1）通过根节点inode号，打开根目录，读取其文件内容，即目录下文件名-&gt;inode节点号映射表，找到name1目录inode节点号n1</p>
<p>2）通过name1的inode号n1，打开name1目录，读取其文件内容，即目录下文件名-&gt;inode节点号映射表，找到name1目录inode节点号n2</p>
<p>3）通过name2的inode号n2，打开name2目录，读取其文件内容，即目录下文件名-&gt;inode节点号映射表，找到name3目录inode节点号n3</p>
<p>4）通过name3的inode号n3，打开name3文件</p>
<p>怎么打开文件：</p>
<p>通过文件查找找到文件inode节点号，然后打开文件，即读取inode至内存。</p>
<p>定位数据块：通过文件inode节点，访问其i_zone数组，进一步可以定位具体的数据所在磁盘块号。</p>
<p><img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205210257879.png"></p>
<h5 id="以c语言open和close返回的是什么解释文件系统">以c语言open和close返回的是什么解释文件系统</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file_table</span>[<span class="title">NR_FILE</span>];</span><span class="comment">//20</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> <span class="title">super_block</span>[<span class="title">NR_SUPER</span>];</span><span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">f_inode</span>;</span></span><br><span class="line">	<span class="type">off_t</span> f_pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>操作系统只有一个super_blocks数组，每个数组元素是一个超级块，一个超级块管理一个逻辑设备，因此最多挂载8个逻辑设备，其中只有一个根设备。</p></li>
<li><p>inode_table[32]每一个元素就是一个i结点，是在操作系统中所有打开的i结点</p></li>
<li><p>file_table
里面装了file结构体，<code>struct super_block super_block[NR_SUPER]</code></p></li>
</ul>
<p>​ f_inode指针指向inode_table里面的元素</p>
<ul>
<li>task struct里面的filp <code>struct file * filp[NR_OPEN];/</code>：
指针数组，每个元素都是file类型的指针</li>
</ul>
<p>linux
0.11一个进程最多只能打开20个文件（文件是可以重复打开的）可以同一个文件占多个file_table的表项</p>
<p>filp归进程管。进程打开一个文件，首先在filp里面找空闲项，
将这个空闲的位置指向file_table其中的一项，这一项里面的f_inode指针指向inode_table。
c语言里面打开文件返回的句柄就是这个指向的inode_table位置对应的下标索引，例如下图就是0.打开文件就是建立这个指针链接的过程，对应的close文件就是把这个关系链断掉。</p>
<p>file对应的是用户的需求，inode对应的是内核管理</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/文件系统.png" alt="文件系统">
<figcaption aria-hidden="true">文件系统</figcaption>
</figure>
<p>打开同一个文件，指向的inode_table是一个，file_table新开了一个</p>
<p>file_table【64】是整个kernel只有一个，file_table[32]也是整个操作系统只有一个，每个元素是一个file对象</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205214503609.png" alt="打开同一个文件">
<figcaption aria-hidden="true">打开同一个文件</figcaption>
</figure>
<p>目录跟结点也要放到inode——table，当路径找完了就把结点pop了</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205200445043.png" alt="image-20231205200445043">
<figcaption aria-hidden="true">image-20231205200445043</figcaption>
</figure>
<h4 id="更换根设备进程1格式化虚拟盘并更换跟设备为虚拟盘">更换根设备（进程1格式化虚拟盘并更换跟设备为虚拟盘）</h4>
<p>之前第二章设置了虚拟盘并初始化，但是当时没有进行格式化还不能作为块设备使用。格式化的信息存在boot操作系统的软盘上</p>
<p>进程1调用<code>rd_load();</code>函数格式化虚拟盘调用</p>
<p>rd_load()是虚拟盘根文件加载函数。在系统初始化阶段，该函数被用于尝试从启动引导盘
上指定的磁盘块位置开始处把一个根文件系统加载到虚拟盘中。在函数中，这个起始磁盘块位置被定为256。当然你也可以根据自己的具体要求修改这个值，只要保证这个值所规定的磁盘容量能容纳内核映象
文件即可。这样一个由内核引导映象文件（Bootimage）加上根文件系统映象文件（Rootiamge）组合而
成的“二合一”磁盘，就可以象启动 DOS 系统盘那样来启动 Linux
系统。在进行正常的根文件系统加载之前，系统会首先执行
rd_load()函数，试图从磁盘的第 257 块中读取
根文件系统超级块。若成功，就把该根文件映象文件读到内存虚拟盘中，并把根文件系统设备标志</p>
<p>ROOT_DEV 设置为虚拟盘设备（0x0101），否则退出
rd_load()，系统继续从别的设备上执行根文件加载 操作。
之前根设备是软盘：bootsect.s里面指定的</p>
<p>==把虚拟盘指定为根设备，读硬盘是有中断的。软盘因为比较快就在内存里。所以读软盘不用中断读软盘要用do_rd_request==</p>
<p>==rd虚拟盘，虚拟的是软盘==，相当于把软盘的内容映射过来，然后把虚拟盘替软盘成为根设备</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rd_load</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>	<span class="title">s</span>;</span></span><br><span class="line">	<span class="type">int</span>		block = <span class="number">256</span>;	<span class="comment">/* Start at block 256 */</span></span><br><span class="line">	<span class="type">int</span>		i = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span>		nblocks;</span><br><span class="line">	<span class="type">char</span>		*cp;		<span class="comment">/* Move pointer */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!rd_length)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	printk(<span class="string">&quot;Ram disk: %d bytes, starting at 0x%x\n&quot;</span>, rd_length,</span><br><span class="line">		(<span class="type">int</span>) rd_start);</span><br><span class="line">	<span class="keyword">if</span> (MAJOR(ROOT_DEV) != <span class="number">2</span>)<span class="comment">//判断是不是软盘</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//block：引导块，block+1超级块//见上面文件系统的格式图</span></span><br><span class="line">	bh = breada(ROOT_DEV,block+<span class="number">1</span>,block,block+<span class="number">2</span>,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Disk error while looking for ramdisk!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*((<span class="keyword">struct</span> d_super_block *) &amp;s) = *((<span class="keyword">struct</span> d_super_block *) bh-&gt;b_data);</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="comment">//判断文件系统是不是minux文件系统</span></span><br><span class="line">	<span class="keyword">if</span> (s.s_magic != SUPER_MAGIC)</span><br><span class="line">		<span class="comment">/* No ram disk image present, assume normal floppy boot */</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	nblocks = s.s_nzones &lt;&lt; s.s_log_zone_size;</span><br><span class="line">	<span class="keyword">if</span> (nblocks &gt; (rd_length &gt;&gt; BLOCK_SIZE_BITS)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Ram disk image too big!  (%d blocks, %d avail)\n&quot;</span>, </span><br><span class="line">			nblocks, rd_length &gt;&gt; BLOCK_SIZE_BITS);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;Loading %d bytes into ram disk... 0000k&quot;</span>, </span><br><span class="line">		nblocks &lt;&lt; BLOCK_SIZE_BITS);</span><br><span class="line">	cp = rd_start;</span><br><span class="line">	<span class="keyword">while</span> (nblocks) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nblocks &gt; <span class="number">2</span>) </span><br><span class="line">			bh = breada(ROOT_DEV, block, block+<span class="number">1</span>, block+<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			bh = bread(ROOT_DEV, block);</span><br><span class="line">		<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">			printk(<span class="string">&quot;I/O error on block %d, aborting load\n&quot;</span>, </span><br><span class="line">				block);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		(<span class="type">void</span>) <span class="built_in">memcpy</span>(cp, bh-&gt;b_data, BLOCK_SIZE);</span><br><span class="line">		brelse(bh);</span><br><span class="line">		printk(<span class="string">&quot;\010\010\010\010\010%4dk&quot;</span>,i);</span><br><span class="line">		cp += BLOCK_SIZE;</span><br><span class="line">		block++;</span><br><span class="line">		nblocks--;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;\010\010\010\010\010done \n&quot;</span>);</span><br><span class="line">	ROOT_DEV=<span class="number">0x0101</span>;<span class="comment">//主设备号换为100:虚拟盘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加载根文件系统">加载根文件系统</h4>
<p>进程1调用mount_root在根设备虚拟盘上加载根文件系统</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_isup</span>;</span><span class="comment">//文件系统的根i结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_imount</span>;</span><span class="comment">//文件系统挂载到的结点</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205221522997.png" alt="文件系统加载结点">
<figcaption aria-hidden="true">文件系统加载结点</figcaption>
</figure>
<h5 id="首先挂载super_block数组和file_table数组">首先挂载super_block数组和file_table数组</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,<span class="built_in">free</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">mi</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">32</span> != <span class="keyword">sizeof</span> (<span class="keyword">struct</span> d_inode))</span><br><span class="line">		panic(<span class="string">&quot;bad i-node size&quot;</span>);</span><br><span class="line">	<span class="comment">//file_table初始化引用计数清0</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NR_FILE;i++)</span><br><span class="line">		file_table[i].f_count=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//判断是否为软盘</span></span><br><span class="line">	<span class="keyword">if</span> (MAJOR(ROOT_DEV) == <span class="number">2</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Insert root floppy and press ENTER&quot;</span>);</span><br><span class="line">		wait_for_keypress();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化super_block</span></span><br><span class="line">	<span class="keyword">for</span>(p = &amp;super_block[<span class="number">0</span>] ; p &lt; &amp;super_block[NR_SUPER] ; p++) &#123;</span><br><span class="line">		p-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">		p-&gt;s_lock = <span class="number">0</span>;</span><br><span class="line">		p-&gt;s_wait = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211092132558.png" alt="image-20231211092132558">
<figcaption aria-hidden="true">image-20231211092132558</figcaption>
</figure>
<h5 id="read_super加载文件系统超级块">read_super加载文件系统超级块</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (!(p=read_super(ROOT_DEV)))</span><br><span class="line">		panic(<span class="string">&quot;Unable to mount root&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>read_super()用于把指定设备的文件系统的==超级块==读入到==缓冲区==中，并登记到超级块数组中，同时也
把文件系统的 i
节点位图和逻辑块位图读入内存超级块结构的相应数组中。最后并返回该超级块结构的
指针。</p>
<p>首先检查这个要读的超级块是不是已经在super_block[8]中，如果有直接使用不用在加载一次了（和缓冲区看有没有现成的一个意思）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">s</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">int</span> i,block;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	check_disk_change(dev);<span class="comment">//检查是否换过盘</span></span><br><span class="line">	<span class="keyword">if</span> (s = get_super(dev))</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="get_super">get_super</h6>
<p>查这个要读的超级块是不是已经在super_block[8]中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> super_block * <span class="title function_">get_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	s = <span class="number">0</span>+super_block;</span><br><span class="line">	<span class="keyword">while</span> (s &lt; NR_SUPER+super_block)</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;s_dev == dev) &#123;</span><br><span class="line">			wait_on_super(s);</span><br><span class="line">			<span class="keyword">if</span> (s-&gt;s_dev == dev)</span><br><span class="line">				<span class="keyword">return</span> s;</span><br><span class="line">			s = <span class="number">0</span>+super_block;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			s++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超级块上锁等待（别的进程加载了这个文件系统）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wait_on_super</span><span class="params">(<span class="keyword">struct</span> super_block * sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	cli();</span><br><span class="line">	<span class="keyword">while</span> (sb-&gt;s_lock)</span><br><span class="line">		sleep_on(&amp;(sb-&gt;s_wait));</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="在super_block里面找到空项">在super_block里面找到空项</h6>
<p>在super_block中找到一项空的并加锁。这里加载根文件系统，第一项就是空的所以是选了第一个</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> (s = <span class="number">0</span>+super_block ;; s++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s &gt;= NR_SUPER+super_block)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (!s-&gt;s_dev)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;s_dev = dev;</span><br><span class="line">	s-&gt;s_isup = <span class="literal">NULL</span>;</span><br><span class="line">	s-&gt;s_imount = <span class="literal">NULL</span>;</span><br><span class="line">	s-&gt;s_time = <span class="number">0</span>;</span><br><span class="line">	s-&gt;s_rd_only = <span class="number">0</span>;</span><br><span class="line">	s-&gt;s_dirt = <span class="number">0</span>;</span><br><span class="line">	lock_super(s);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211095203241.png" alt="image-20231211095203241">
<figcaption aria-hidden="true">image-20231211095203241</figcaption>
</figure>
<h6 id="把超级块加载到缓冲区再加载到super-block">把超级块加载到缓冲区，再加载到super
block</h6>
<p>调用bread读取超级块，这里的设备是rd虚拟盘。块号是1.因此在do
request的时候是do_rd_request.虚拟盘虽然是内存模拟的盘，但是读取的操作完全模仿了外设，但是他毕竟是内存不是外设，因此和读硬盘不同的是：不会发生类似硬盘中断的情况</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (!(bh = bread(dev,<span class="number">1</span>))) &#123;</span><br><span class="line">		s-&gt;s_dev=<span class="number">0</span>;</span><br><span class="line">		free_super(s);<span class="comment">//释放超级块</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//将缓冲区的超级块复制到刚才找到的super_block【0】中</span></span><br><span class="line">	*((<span class="keyword">struct</span> d_super_block *) s) =</span><br><span class="line">		*((<span class="keyword">struct</span> d_super_block *) bh-&gt;b_data);</span><br><span class="line">	brelse(bh);<span class="comment">//释放缓冲块</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;s_magic != SUPER_MAGIC) &#123;</span><br><span class="line">		s-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">		free_super(s);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211100257070.png" alt="image-20231211100257070">
<figcaption aria-hidden="true">image-20231211100257070</figcaption>
</figure>
<h6 id="完善super-blok中i结点位图逻辑位图">完善super
blok中i结点位图逻辑位图</h6>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">//首先初始化imap和zmap</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;I_MAP_SLOTS;i++)</span><br><span class="line">		s-&gt;s_imap[i] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;Z_MAP_SLOTS;i++)</span><br><span class="line">		s-&gt;s_zmap[i] = <span class="literal">NULL</span>;</span><br><span class="line">	block=<span class="number">2</span>;<span class="comment">//虚拟盘的第一块是超级块，第二块开始是i结点位图和逻辑块位图所以这里是2</span></span><br><span class="line">    <span class="comment">//把虚拟盘上的逻辑位图加载到缓冲区中，并都挂载到s_imap上</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; s-&gt;s_imap_blocks ; i++)</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;s_imap[i]=bread(dev,block))</span><br><span class="line">			block++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//挂完i结点的位图挂载逻辑块位图</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; s-&gt;s_zmap_blocks ; i++)</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;s_zmap[i]=bread(dev,block))</span><br><span class="line">			block++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//如果块数量不对说明操作系统出问题了释放之前的缓冲块和超级块</span></span><br><span class="line">	<span class="keyword">if</span> (block != <span class="number">2</span>+s-&gt;s_imap_blocks+s-&gt;s_zmap_blocks) &#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;I_MAP_SLOTS;i++)</span><br><span class="line">			brelse(s-&gt;s_imap[i]);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Z_MAP_SLOTS;i++)</span><br><span class="line">			brelse(s-&gt;s_zmap[i]);</span><br><span class="line">		s-&gt;s_dev=<span class="number">0</span>;</span><br><span class="line">		free_super(s);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//牺牲第一个i结点，防止查找算法返回0</span></span><br><span class="line">	s-&gt;s_imap[<span class="number">0</span>]-&gt;b_data[<span class="number">0</span>] |= <span class="number">1</span>;</span><br><span class="line">	s-&gt;s_zmap[<span class="number">0</span>]-&gt;b_data[<span class="number">0</span>] |= <span class="number">1</span>;</span><br><span class="line">	free_super(s);<span class="comment">//解锁超级块</span></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_super</span><span class="params">(<span class="keyword">struct</span> super_block * sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	cli();</span><br><span class="line">	sb-&gt;s_lock = <span class="number">0</span>;</span><br><span class="line">	wake_up(&amp;(sb-&gt;s_wait));</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211102021214.png" alt="image-20231211102021214">
<figcaption aria-hidden="true">image-20231211102021214</figcaption>
</figure>
<h5 id="将根设备的根i结点挂载super-block上">将根设备的根i结点挂载super
block上</h5>
<p>调用iget从虚拟盘上读取i结点。有了i结点，可以通过根i结点找到文件系统中的任意指定i结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">	<span class="comment">//i number ：i结点位图的序号，iget：给定结点，给定设备，这里在找虚拟盘的根i结点</span></span><br><span class="line">	<span class="keyword">if</span> (!(mi=iget(ROOT_DEV,ROOT_INO)))</span><br><span class="line">		panic(<span class="string">&quot;Unable to read root i-node&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h6 id="igetget_empty_inode">iget:get_empty_inode</h6>
<p>首先在记载所有打开的i结点的数组中申请一个空闲的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">iget</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>, * <span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		panic(<span class="string">&quot;iget with dev==0&quot;</span>);</span><br><span class="line">	empty = get_empty_inode();<span class="comment">//从inode_table[32]中申请一个空闲的i结点</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">get_empty_inode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">last_inode</span> =</span> inode_table; <span class="comment">// last_inode 指向 i 节点表第一项</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 扫描 i 节点表。 </span></span><br><span class="line">		inode = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = NR_INODE; i ; i--) &#123;</span><br><span class="line">            <span class="comment">// 如果 last_inode 已经指向 i 节点表的最后 1 项之后，则让其重新指向 i 节点表开始处。</span></span><br><span class="line">			<span class="keyword">if</span> (++last_inode &gt;= inode_table + NR_INODE)</span><br><span class="line">				last_inode = inode_table;</span><br><span class="line">            <span class="comment">// 如果 last_inode 所指向的 i 节点的计数值为 0，则说明可能找到空闲 i 节点项。让 inode 指向 </span></span><br><span class="line">           <span class="comment">// 该 i 节点。如果该 i 节点的已修改标志和锁定标志均为 0，则我们可以使用该 i 节点，于是退出循环。 </span></span><br><span class="line">			<span class="keyword">if</span> (!last_inode-&gt;i_count) &#123;</span><br><span class="line">				inode = last_inode;</span><br><span class="line">				<span class="keyword">if</span> (!inode-&gt;i_dirt &amp;&amp; !inode-&gt;i_lock)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 如果没有找到空闲 i 节点(inode=NULL)，则将整个 i 节点表打印出来供调试使用，并死机。</span></span><br><span class="line">		<span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_INODE ; i++)</span><br><span class="line">				printk(<span class="string">&quot;%04x: %6d\t&quot;</span>,inode_table[i].i_dev,</span><br><span class="line">					inode_table[i].i_num);</span><br><span class="line">			panic(<span class="string">&quot;No free inodes in mem&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 等待该 i 节点解锁（如果又被上锁的话）。 </span></span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">        <span class="comment">// 如果该 i 节点已修改标志被置位的话，则将该 i 节点刷新，并等待该 i 节点解锁。</span></span><br><span class="line">		<span class="keyword">while</span> (inode-&gt;i_dirt) &#123;</span><br><span class="line">			write_inode(inode);</span><br><span class="line">			wait_on_inode(inode);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (inode-&gt;i_count);<span class="comment">//// 如果 i 节点又被其它占用的话，则重新寻找空闲 i 节点。</span></span><br><span class="line">    <span class="comment">// 已找到空闲 i 节点项。则将该 i 节点项内容清零，并置引用标志为 1，返回该 i 节点指针。</span></span><br><span class="line">	<span class="built_in">memset</span>(inode,<span class="number">0</span>,<span class="keyword">sizeof</span>(*inode));</span><br><span class="line">	inode-&gt;i_count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="iget">iget</h6>
<p>inode_table 初始化的时候:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> <span class="title">inode_table</span>[<span class="title">NR_INODE</span>]=</span>&#123;&#123;<span class="number">0</span>,&#125;,&#125;; <span class="comment">// 内存中 i 节点表（NR_INODE=32 项）。</span></span><br></pre></td></tr></table></figure>
<p>这是对数组进行初始化的语法。它使用了一个嵌套的大括号，将数组中的每个元素初始化为
<code>&#123;0,&#125;</code>，这将初始化结构体中的所有成员为零（或NULL，具体取决于结构体的定义）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">iget</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">     <span class="comment">// 扫描 i 节点表。寻找指定节点号的 i 节点。并递增该节点的引用次数。</span></span><br><span class="line">	inode = inode_table;</span><br><span class="line">	<span class="keyword">while</span> (inode &lt; NR_INODE+inode_table) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_dev != dev || inode-&gt;i_num != nr) &#123;</span><br><span class="line">			inode++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">        <span class="comment">// 如果当前扫描的 i 节点的设备号不等于指定的设备号或者节点号不等于指定的节点号，则继续扫描。</span></span><br><span class="line">        <span class="comment">//MOUNT ROOT调用的时候if (!(mi=iget(ROOT_DEV,ROOT_INO)))。dev=0.nr=1)</span></span><br><span class="line">        <span class="comment">//所以刚初始化完的都是0，找不到所以会跳完这个while</span></span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_dev != dev || inode-&gt;i_num != nr) &#123;</span><br><span class="line">			inode = inode_table;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		inode-&gt;i_count++;</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_mount) &#123;</span><br><span class="line">			<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span> ; i&lt;NR_SUPER ; i++)</span><br><span class="line">				<span class="keyword">if</span> (super_block[i].s_imount==inode)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (i &gt;= NR_SUPER) &#123;</span><br><span class="line">				printk(<span class="string">&quot;Mounted inode hasn&#x27;t got sb\n&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (empty)</span><br><span class="line">					iput(empty);</span><br><span class="line">				<span class="keyword">return</span> inode;</span><br><span class="line">			&#125;</span><br><span class="line">			iput(inode);</span><br><span class="line">			dev = super_block[i].s_dev;</span><br><span class="line">			nr = ROOT_INO;</span><br><span class="line">			inode = inode_table;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (empty)</span><br><span class="line">			iput(empty);</span><br><span class="line">		<span class="keyword">return</span> inode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!empty)</span><br><span class="line">		<span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//第一次初始化的话会跳到这个地方执行，而不会在上面的循环中return 因为有continue</span></span><br><span class="line">    <span class="comment">//将当前的跟设备和块号赋值给找出来的inode table里面空闲的inode</span></span><br><span class="line">	inode=empty;</span><br><span class="line">	inode-&gt;i_dev = dev;</span><br><span class="line">	inode-&gt;i_num = nr;</span><br><span class="line">    </span><br><span class="line">	read_inode(inode);<span class="comment">//从虚拟盘上读出i结点</span></span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="read_inode">read_inode</h6>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_inode</span><span class="params">(<span class="keyword">struct</span> m_inode * inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">int</span> block;</span><br><span class="line"></span><br><span class="line">	lock_inode(inode);<span class="comment">//首先对这个选出来的结点加锁，在解锁之前这个结点都不会被其它进程占用</span></span><br><span class="line">	<span class="keyword">if</span> (!(sb=get_super(inode-&gt;i_dev)))<span class="comment">//获得该节点所在设备的超级块</span></span><br><span class="line">		panic(<span class="string">&quot;trying to read inode without dev&quot;</span>);</span><br><span class="line">  <span class="comment">// 该 i 节点所在的逻辑块号 = (启动块+超级块) + i 节点位图占用的块数 + 逻辑块位图占用的块数 + </span></span><br><span class="line"> <span class="comment">// (i 节点号-1)/每块含有的 i 节点数。</span></span><br><span class="line">	block = <span class="number">2</span> + sb-&gt;s_imap_blocks + sb-&gt;s_zmap_blocks +</span><br><span class="line">		(inode-&gt;i_num<span class="number">-1</span>)/INODES_PER_BLOCK;</span><br><span class="line">    <span class="comment">//将inode的块读到缓冲中                                                               </span></span><br><span class="line">	<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,block)))</span><br><span class="line">		panic(<span class="string">&quot;unable to read i-node block&quot;</span>);</span><br><span class="line">    <span class="comment">//将读入的数据从缓冲块赋值给inode</span></span><br><span class="line">	*(<span class="keyword">struct</span> d_inode *)inode =</span><br><span class="line">		((<span class="keyword">struct</span> d_inode *)bh-&gt;b_data)</span><br><span class="line">			[(inode-&gt;i_num<span class="number">-1</span>)%INODES_PER_BLOCK];</span><br><span class="line">	brelse(bh);<span class="comment">//释放缓冲块</span></span><br><span class="line">	unlock_inode(inode);<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211131847124.png" alt="image-20231211131847124">
<figcaption aria-hidden="true">image-20231211131847124</figcaption>
</figure>
<h5 id="将根文件系统与进程1关联设置root和pwd">将根文件系统与进程1关联，设置root和pwd</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">    <span class="keyword">if</span> (!(mi=iget(ROOT_DEV,ROOT_INO)))</span><br><span class="line">		panic(<span class="string">&quot;Unable to read root i-node&quot;</span>);</span><br><span class="line">    <span class="comment">/* 该 i 节点引用次数递增 3 次。因为下面 </span></span><br><span class="line"><span class="comment">    p-&gt;s_isup = p-&gt;s_imount = mi;</span></span><br><span class="line"><span class="comment">    p-&gt;s_isup = p-&gt;s_imount = mi;</span></span><br><span class="line"><span class="comment">	current-&gt;pwd = mi;</span></span><br><span class="line"><span class="comment">    也引用了该 i 节点。*/</span></span><br><span class="line">    mi-&gt;i_count += <span class="number">3</span> ;	<span class="comment">/* NOTE! it is logically used 4 times, not 1 */</span></span><br><span class="line">	p-&gt;s_isup = p-&gt;s_imount = mi;<span class="comment">//他是最根的i结点。自己挂自己，这句话加载了跟设备的根文件系统，非常重要</span></span><br><span class="line">	current-&gt;pwd = mi;<span class="comment">//当前进程的工作目录（当前进程是进程1）进程1的工作目录是根文件系统的根i结点，从进程1开始才有文件系统</span></span><br><span class="line">	<span class="comment">//进程0没有，绝对路径：从根文件系统往下撸和相对路径，根据pwd往下撸</span></span><br><span class="line">	current-&gt;root = mi; <span class="comment">//后面由于父子进程创建遗传机制，后面的进程也会继承这个特征</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计算虚拟盘空闲块信息">计算虚拟盘空闲块信息</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     ... </span><br><span class="line">    <span class="comment">// 统计该设备上空闲块数。首先令 i 等于超级块中表明的设备逻辑块总数。 </span></span><br><span class="line">    <span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">	i=p-&gt;s_nzones;</span><br><span class="line"><span class="comment">// 然后根据逻辑块位图中相应比特位的占用情况统计出空闲块数。这里宏函数 set_bit()只是在测试 </span></span><br><span class="line"> <span class="comment">// 比特位，而非设置比特位。&quot;i&amp;8191&quot;用于取得 i 节点号在当前块中的偏移值。&quot;i&gt;&gt;13&quot;是将 i 除以 </span></span><br><span class="line"> <span class="comment">// 8192，也即除一个磁盘块包含的比特位数。 </span></span><br><span class="line">	<span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_zmap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line">			<span class="built_in">free</span>++;</span><br><span class="line">	printk(<span class="string">&quot;%d/%d free blocks\n\r&quot;</span>,<span class="built_in">free</span>,p-&gt;s_nzones);</span><br><span class="line"><span class="comment">// 统计设备上空闲 i 节点数。首先令 i 等于超级块中表明的设备上 i 节点总数+1。加 1 是将 0 节点 </span></span><br><span class="line"> <span class="comment">// 也统计进去。</span></span><br><span class="line">	<span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">	i=p-&gt;s_ninodes+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 然后根据 i 节点位图中相应比特位的占用情况计算出空闲 i 节点数</span></span><br><span class="line">	<span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_imap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line">			<span class="built_in">free</span>++;</span><br><span class="line">    <span class="comment">// 显示设备上可用的空闲 i 节点数/i 节点总数。</span></span><br><span class="line">	printk(<span class="string">&quot;%d/%d free inodes\n\r&quot;</span>,<span class="built_in">free</span>,p-&gt;s_ninodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此mount_root执行完，同时返回后sys_setip函数也执行完了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_setup</span><span class="params">(<span class="type">void</span> * BIOS)</span> <span class="comment">//首先解决硬盘的驱动器问题</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    rd_load();</span><br><span class="line">	mount_root();</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回到之前调用system_call的地方，一路返回到一开始的init函数。</p>
<p>#### sys_mount</p>
<blockquote>
<p>函数说明：除了根文件系统以外其它一般的文件系统挂载的流程。</p>
</blockquote>
<p>完成挂载： 1.找到要安装的结点 2.找到要挂接的结点 3.连接
拿到设备号一定可以拿到超级块，把超级块加载到super
block数组里面——》安装文件系统 首先在获取设备i结点</p>
<p>此时再看copy_process 可以看出子进程复制了父进程打开的文件
进程0创建进程1的时候因为进程0的pwd和root都是空，因此进程1刚建立的时候还没有pwd和root
进程1是在current-&gt;pad=mi的时候才有的，后面的进程集成了基础1也有==（<em>p=</em>current）==
这个root不一定是根i结点的根
每个硬件设备都有一个引导块，每个逻辑设备都有一个超级块，如果一个物理设备有多个逻辑设备往后复制一下上图
iput 释放在inode_table[32]的结点 wait_on_inode:和 wait buffer 相似
get_super 在super block里面找同样的 iget</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/文件系统加载示意图.png" alt="文件系统加载结点">
<figcaption aria-hidden="true">文件系统加载结点</figcaption>
</figure>
<p>首先获取设备inode，根据设备inode就可以获得设备号（然后这个结点就没有用了，iput释放)</p>
<p>目录文件的i结点指向目录文件。目录文件里面有目录项。根据目录项可以找到下一级目录文件的i结点</p>
<p>最后一个目录文件的i结点叫做枝梢i结点。通过枝梢i结点可以找到硬盘上包含要找的目录项的块，把这个块读到缓冲区，在缓冲区倒腾目录项都有那些内容。然后再把内容放到inode里面。这个结点最终要到inode
table32</p>
<p>还缺少imode ：区分i结点是目录i结点还是文件i结点</p>
<h4 id="dirt-update位分析">dirt ，update位分析</h4>
<p>对缓冲块的共享有两个方向：</p>
<ul>
<li>进程方向：进程能共享哪些缓冲块，不能共享哪些</li>
<li>硬盘方向：哪些缓冲块需要同步到外设，哪些不用同步</li>
</ul>
<p>缓冲块管理结构 buffer_head 的 <code>b_uptodate</code> 和
<code>b_dirt</code> 字段就是为了保证缓冲块和逻辑块数据的正确性</p>
<ul>
<li><code>b_uptodate</code>：针对进程方向。它的作用是告诉内核，只要缓冲块的
b_uptodate 字段被设置为
1，缓冲块的数据已经是最新的，可以放心地支持进程共享缓冲块的数据；反之，如果设置为
0，就提醒内核缓冲块数据并没有更新，不支持进程共享该缓冲块。</li>
</ul>
<p>需要<strong>特别注意</strong>的是，<code>b_uptodate 字段为 1 并不代表缓冲块的数据跟块设备逻辑块上的数据是一致的，它们可以不一样。</code>。</p>
<p>申请逻辑块是一种特殊情况。<code>将 b_uptodate 字段设置为 1 只是表明该缓冲块的数据是最新，进程可以直接读或写，但并不意味着缓冲块的数据跟逻辑块的数据是一致的。</code>设想将
b_uptodate 字段设置为
0，进程以为该缓冲块数据不是最新的，就会从逻辑块将数据读入，而此时逻辑块数据并没有清零，读入的必然是垃圾数据。另外，因为是新建逻辑块，内核不会去读该逻辑块，只会向该逻辑块写数据，所以当该缓冲块的
b_dirt 字段为 1
时，将缓冲块数据同步到该逻辑块自然能够覆盖掉该逻辑块之前的垃圾数据。</p>
<ul>
<li><code>b_dirt</code>：针对硬盘方向。只要缓冲块的 b_dirt 字段被设置为
1，就是告诉内核，这个缓冲块中的内容已经被进程修改过，需要同步到块设备上；反之，如果为
0，不需要同步。b_uptodate 字段设置为 1
后，内核就支持进程共享该缓冲块的数据，读写都可以。读操作不会改变缓冲块的数据；但写操作会改变缓冲块的内容，需要将
b_dirt 字段设置为 1，标志该缓冲块需要同步。</li>
</ul>
<blockquote>
<p>在buffer init的时候会初始化：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">h-&gt;b_dirt = <span class="number">0</span>; <span class="comment">// 脏标志，也即缓冲区修改标志。</span></span><br><span class="line">h-&gt;b_count = <span class="number">0</span>;<span class="comment">// 该缓冲区引用计数。</span></span><br><span class="line">h-&gt;b_lock = <span class="number">0</span>;<span class="comment">// 缓冲区锁定标志</span></span><br><span class="line">h-&gt;b_uptodate = <span class="number">0</span>;<span class="comment">// 缓冲区更新标志（或称数据有效标志）。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在getblk的时候，如果没有找到现成的缓冲块，从空闲区域找到后会对块操作：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bh-&gt;b_dirt=<span class="number">0</span>;<span class="comment">//还没有读盘dirt不置1</span></span><br><span class="line">bh-&gt;b_uptodate=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>缓冲块的同步有两种方法：一种是 update
进程定期同步；另一种是因缓冲区使用达到极限，操作系统强行同步。这两种同步方法最终都会调用
<code>sys_sync</code> 函数</p>
<p>uptodate 创建新文件的时候uptodate直接置1</p>
<h2 id="static-和inline分析">static 和inline分析</h2>
<p><a href="./Linux%200.11%20里面的%20inline%20问题">Linux 0.11 里面的
inline 问题</a></p>
<p>去掉inline行不行？原理是什么？ #### C程序运行结构
内存：代码区，静态数据区。动态数据区 cpu：eip（指向下一条指令）
ebp（栈底） esp（栈顶指针）
函数调用时，参数入栈顺序，从右向左），函数调用的时候首先将传参压入数据栈中。
然后将函数执行完的返回地址压栈，保存main函数的栈底（压栈），ebp挪到fun函数栈底，运行函数程序
函数局部变量压栈。
函数返回，根据栈中内容恢复现场，函数传参已经没用了，进行清栈。
用的是用户栈，是共用一个栈：理由copy page tables
进程0完全复制给进程1了，因此物理内存是一个物理内存，线性地址空间不一样，但是物理空间一样，所以可以看成共用一个栈，当发生写时复制才变两个栈，因为进程0本来是可读写的所以没导致copy
on write 所以还是共用了一个栈。 注意：进程0的压栈没有导致写时复制
为啥卡在pause？
因为进程0压栈了fork和pause的返回地址，但是fork返回了就清栈了，所以现在栈里面就是pause所以fork跳出来的时候返回到pause里面去了
有没有可能跑对？有可能
为啥有的时候行有的时候不行，因为操作系统调度是根据时间片进行的，而不是指令数。时间比较依赖cpu
硬件或虚拟机类型 当前进程有tss switch to 里面也有一套tss ============｜
======== c 运行的程序 | ST 里面 TSS（0） |TSS（1） CS.EiP |cs.eip
进程1第一次运行，他的运行状态记录tss是否存在？存在。是在父进程创建的时候就被创建出来，不然开始运行的时候不知道从哪里开始运行。进程1返回的时候，eip（__res_)在用户态
有两个验证： 1.iret 2.在trap设置里面设置了特权级是用户态。</p>
<p>## 小结 1. 进程0从哪里蹦出来的： move to usermod</p>
<pre><code>2.taskstruct 是共用体前端，和内核栈在一个union ，分配了一个页：4k，task struct一般也就1k，也就是说，内核栈再怎么用页不会超过3k。注意一个进程有两个栈，调用fork的时候跑的是用户栈，copyprocess的一系列操作的时候用的是内核栈。</code></pre>
<ol start="2" type="1">
<li><p>init 80
在用户态执行，fork进程0压栈五个，进的是内核栈还是用户栈？内核栈。进程0用户栈：user
stack 压栈最本质是为了配合iret执行，iret在内核态</p></li>
<li><p>假设有inline在int 80
返回之后有可能出时钟，这个时钟里面也有一堆call这会不会把fork里面的那个返回值搞乱了？不会。do
timer来了以后在内核态，用的是内核栈，fork的返回值在用户栈里</p></li>
<li><p>get free page 获得空闲页不是共享页，get free
page是物理地址上还是线性地址上？获得的是线性地址，但是获得的是物理页。为啥是线性的地址？
cr3时物理的，页目录表里面要指向一个页表，这里也是一个物理地址（20位），页表有1k的页表项里面指向的也是物理地址，</p></li>
<li><p>p=(strict
task_struct*)get_free_page(),这里面得到的页是线性地址，这里的页面有没有挂到页表里面？挂过了，在head.s里面就挂了。挂到页表和用过是不等价的，只有memmap的引用计数可以看出来有没有用过</p></li>
<li><p>进程1能不能访问到自己的task
struct的那个页？。不可以，这个页挂在了进程0的页表上，进程1用不了，进程1的页目录表：64M-128M上没用挂过这个页</p></li>
</ol>
<pre><code>8.是不是所有的get free page用户程序都访问不了？：不一定</code></pre>
<ol start="7" type="1">
<li><p>get free
page是从后往前遍历？这样映射关系就变得不那么线性了，增加安全性，物理地址和线性地址的映射关系就会更复杂一点。</p></li>
<li><p>没有一个脱离进程的绝对的内核，内核是进程的内核态</p></li>
<li><p>时间片在内核态和用户态都在跑，详见do_timer</p></li>
<li><p>in32
里面又的指令是绝对特权的，在0特权级列表里面，还有一些是通过IOPL设定他能不能被用户态度操作的
，在init
task里面的eflags=0的时候设定的，此时IOPL也被清零了。因为存在父子进程创建机制，因此后面所有进程的eflags都等于0</p></li>
<li><p>要用逻辑体系的思维保证滴水不漏</p></li>
<li><p>为啥都从fork出来
main函数代表内核，一般肯定不能走完，结束前肯定有一个死循环：<code>for（；；）pause（）;</code>
这个死循环谁做：进程0</p></li>
<li><p>进程0:进程的祖宗，当其他进程都不动的时候进程0怠速状态idle
由进程0负责让操作系统不熄火。所以说，创建进程在fork，怠速在pause
那其他进程只能从fork出来了，linux的设计思想</p></li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>LINUX011内核学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ldt中断函数挂接以及进程及相关设备初始化</title>
    <url>/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="ldt中断函数挂接以及进程及相关设备初始化">ldt中断函数挂接以及进程及相关设备初始化</h1>
<p>操作系统中心思想：管理所有的硬件资源为软件资源提供服务</p>
<h2 id="main.c">main.c</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//之前把0x9000-0x901F部分用来存储机器系统信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT_MEM_K (*(unsigned short *)0x90002)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVE_INFO (*(struct drive_info *)0x90080)<span class="comment">//90080是硬盘参数表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORIG_ROOT_DEV (*(unsigned short *)0x901FC)<span class="comment">//901fc是跟设备号</span></span></span><br></pre></td></tr></table></figure>
<p><strong>根文件系统设备</strong></p>
<p>Linux0.11要求系统必须存在一个跟文件系统，其他文件系统挂载在上面，这里指的是文件系统格式化设备例如软盘。</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231007004249231.png" alt="image-20231007004249231">
<figcaption aria-hidden="true">image-20231007004249231</figcaption>
</figure>
<h3 id="规划物理内存">规划物理内存</h3>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231005095121645.png" alt="image-20231005095121645">
<figcaption aria-hidden="true">image-20231005095121645</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> 	ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line"> 	drive_info = DRIVE_INFO;</span><br><span class="line">	<span class="comment">//内存大小=1M+扩展内存</span></span><br><span class="line">	memory_end = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="number">10</span>);<span class="comment">//左移20位：1M EXT_MEM_K机器设备信息，0x90002扩展内存kb数 左移10位kb-&gt;mb </span></span><br><span class="line">	<span class="comment">//忽略不到4KB（一页）的内存页</span></span><br><span class="line">	memory_end &amp;= <span class="number">0xfffff000</span>;</span><br><span class="line">	<span class="keyword">if</span> (memory_end &gt; <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">		memory_end = <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">//如果内存大于16M按照16M计算</span></span><br><span class="line">	<span class="keyword">if</span> (memory_end &gt; <span class="number">12</span>*<span class="number">1024</span>*<span class="number">1024</span>) </span><br><span class="line">		buffer_memory_end = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (memory_end &gt; <span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">		buffer_memory_end = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		buffer_memory_end = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">//设置缓冲区</span></span><br><span class="line">	main_memory_start = buffer_memory_end;</span><br><span class="line"><span class="comment">//如果在Makefile里面指定了RAMDISK则建立虚拟盘</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RAMDISK </span></span><br><span class="line">	main_memory_start += rd_init(main_memory_start, RAMDISK*<span class="number">1024</span>);</span><br><span class="line">	<span class="comment">//虚拟盘设置</span></span><br></pre></td></tr></table></figure>
<h3 id="设置虚拟盘块设备">设置虚拟盘(块设备)</h3>
<p>什么是虚拟盘：在内存中开辟一块空间按照盘处理，这个是比较快的。</p>
<p>相对应的虚拟内存是在磁盘中开辟一块空间当作内存处理，这个速度就很慢。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_REQUEST do_rd_request</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">rd_init</span><span class="params">(<span class="type">long</span> mem_start, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>	i;</span><br><span class="line">	<span class="type">char</span>	*cp;</span><br><span class="line"></span><br><span class="line">	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;<span class="comment">//将虚拟盘的请求处理函数与blk_dev【7】的第二项挂接</span></span><br><span class="line">	rd_start = (<span class="type">char</span> *) mem_start;</span><br><span class="line">	rd_length = length;</span><br><span class="line">	cp = rd_start;</span><br><span class="line">    <span class="comment">//虚拟盘所在的内存区域初始化为0</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">		*cp++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span>(length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231007095026059.png" alt="image-20231007095026059">
<figcaption aria-hidden="true">image-20231007095026059</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> <span class="title">blk_dev</span>[<span class="title">NR_BLK_DEV</span>] =</span> &#123;</span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* no_dev */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev mem */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev fd */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev hd */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev ttyx */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev tty */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;		<span class="comment">/* dev lp */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>blk_dev
主要功能是将某一类设备与对应的请求处理项函数挂接。操作系统最多可以管理六类设备。</p>
<h3 id="内存管理结构与mem_map初始化">内存管理结构与mem_map初始化</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mem_init(main_memory_start,memory_end);</span><br></pre></td></tr></table></figure>
<p>系统通过mem_map 对1MB
以上的内存进行分页管理，记录一个页面的使用次数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> mem_map [ PAGING_PAGES ] = &#123;<span class="number">0</span>,&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">(<span class="type">long</span> start_mem, <span class="type">long</span> end_mem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	HIGH_MEMORY = end_mem;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;PAGING_PAGES ; i++)</span><br><span class="line">		mem_map[i] = USED; <span class="comment">//used=100 理论上是不可能出现的，因为进程最大数是64，说明这个地方已经占死了不能给比人用</span></span><br><span class="line">	i = MAP_NR(start_mem);<span class="comment">// 然后计算可使用起始内存的页面号。</span></span><br><span class="line">	end_mem -= start_mem;</span><br><span class="line">	end_mem &gt;&gt;= <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">while</span> (end_mem--&gt;<span class="number">0</span>)</span><br><span class="line">		mem_map[i++]=<span class="number">0</span>;<span class="comment">//mem_map非常重要用于记录分配出了多少内存，这里指的是物理内存，将6M以后的内存占用清零</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231007204235125.png" alt="image-20231007204235125">
<figcaption aria-hidden="true">image-20231007204235125</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	main_memory_start = buffer_memory_end;</span><br><span class="line"><span class="comment">//如果在Makefile里面指定了RAMDISK则建立虚拟盘</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RAMDISK</span></span><br><span class="line">	main_memory_start += rd_init(main_memory_start, RAMDISK*<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>可知在设置缓冲和虚拟盘后main_memory_start就是虚拟盘后面的地址，操作系统对内核和用户采用了不同的管理方法，1M以内是内核的内存区域不允许用户方法，所以used了。缓冲区和虚拟盘也没有分页访问的权限。</p>
<h3 id="中断流程再分析">中断流程再分析</h3>
<p>外部中断、软件中断和异常是通过中断描述符表（IDT）处理的。 IDT
中包含访问中断和异常处理程序的门描述符的集合。像 GDT 一样，IDT
不是一个段， IDT 的线性基地址包含在 IDT 寄存器中（IDTR）。</p>
<p>IDT
中的描述符可以是中断门、陷阱门或任务门。处理器必须先从内部硬件、外部
中断控制器或者通过诸如 INT、INTO、INT 3、BOUND
指令收到一个中断向量（中断号）， 才去访问中断或异常处理程序。中断向量是
IDT 中门描述符的索引。如果选中的门描
述符是中断门或者陷阱门，就如同通过调用门调用过程一样去访问相应的处理程序；
如果是任务门，就通过任务切换访问其处理程序。</p>
<p>与中断相关的标志位：<strong>iF 中断许可（第 9 位）</strong></p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231008171319133.png" alt="image-20231008171319133">
<figcaption aria-hidden="true">image-20231008171319133</figcaption>
</figure>
<p>IDT 中可以包含以下三种门描述符：</p>
<p>z 任务门描述符。</p>
<p>z 中断门描述符。</p>
<p>z 陷阱门描述符</p>
<h4 id="中断描述符表的预初始化"><strong>中断描述符表的预初始化：</strong></h4>
<p>head.s</p>
<p>用256
个指向ignore_int中断门的入口地址填充中断描述符表。它不是真正的初始化idt，等到分页和内核跳转到PAGE_OFFSET处时才真正的进行
初始化。确定所有相关的准备都已就绪之后，中断可以在任何地方发生。</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231008154407166.png" alt="image-20231008154407166">
<figcaption aria-hidden="true">image-20231008154407166</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setup_idt:</span><br><span class="line">	lea ignore_int,%edx #取ignore_int的有效地址到edx寄存器</span><br><span class="line">	movl $0x00080000,%eax  #把内核代码段选择符左移16位，送到eax存器，此时eax的高16位存放选择符。</span><br><span class="line">	movw %dx,%ax		/* selector = 0x0008 = cs */#ignore_int的有效地址存入eax的底16位。此时，eax中含有门描述符底4字节（32位）的值。</span><br><span class="line">	movw $0x8E00,%dx	/* interrupt gate - dpl=0, present */</span><br><span class="line"></span><br><span class="line">	lea _idt,%edi  #取中断描述符表的地址到edi中 </span><br><span class="line">	mov $256,%ecx</span><br><span class="line">rp_sidt:</span><br><span class="line">	movl %eax,(%edi) #将通用的中断描述符存入表中（将ignore_int存入edi所指向的地址中）</span><br><span class="line">	movl %edx,4(%edi)</span><br><span class="line">	addl $8,%edi  #edi指向表中下一项，从上面的图中可以看出idt描述符是8个字节</span><br><span class="line">	dec %ecx</span><br><span class="line">	jne rp_sidt  #条件跳转，使得idt表有256项</span><br><span class="line">	lidt idt_descr </span><br><span class="line">	ret</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">idt_descr:</span><br><span class="line">	.word 256*8-1		# idt contains 256 entries</span><br><span class="line">	.long _idt</span><br><span class="line">_idt:	.fill 256,8,0		# idt is uninitialized</span><br></pre></td></tr></table></figure>
<p>定义了中断处理函数：</p>
<p>Ignore_int()中断处理程序，可以看作是一个空的处理程序，它执行的主要动
作有： 1、在栈中保存一些寄存器的内容。 2、调用printk（）函数打印“Unknown
interrupt”系统消息。 3、 恢复栈中寄存器的内容。
4、执行iret指令，恢复被中断的程序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ignore_int:</span><br><span class="line">	pushl %eax</span><br><span class="line">	pushl %ecx</span><br><span class="line">	pushl %edx</span><br><span class="line">	push %ds</span><br><span class="line">	push %es</span><br><span class="line">	push %fs</span><br><span class="line">	movl $0x10,%eax</span><br><span class="line">	mov %ax,%ds</span><br><span class="line">	mov %ax,%es</span><br><span class="line">	mov %ax,%fs</span><br><span class="line">	pushl $int_msg</span><br><span class="line">	call _printk</span><br><span class="line">	popl %eax</span><br><span class="line">	pop %fs</span><br><span class="line">	pop %es</span><br><span class="line">	pop %ds</span><br><span class="line">	popl %edx</span><br><span class="line">	popl %ecx</span><br><span class="line">	popl %eax</span><br><span class="line">	iret</span><br></pre></td></tr></table></figure>
<h4 id="中断描述符表的第二遍初始化">中断描述符表的第二遍初始化</h4>
<p>在上述预初始化之后后，内核将在
IDT中进行第二遍初始化，用有意义的陷阱和中断处理程序替换空处理程序。第二遍处理过程完成后，针对控制单元产生的每个不同的异常，IDT都有一个专门
的陷阱门或系统门；而对于可编程控制器确认的每一个IRQ，IDT都将包含一个专门的中断门。Trap_init()函数的工作就是将一些处理异常的函数
插入到IDT的非屏蔽中断及异常表项中。</p>
<p>IA-32
系统架构也定义了一套称为门（调用门、中断门、陷阱门和任务门）的特殊
描述符，以提供一种对不同于应用程序特权级的系统过程和处理程序的保护性访问途
经。Trap_init()函数用于设置
中断描述符表开头的陷阱门和系统门。这些中断向量都是CPU保留，用于异常处理的。</p>
<h5 id="异常处理类中断服务程序挂接">异常处理类中断服务程序挂接</h5>
<p>linux
通过int80中断翻特权级，通过iret返回。要通过门的机制来控制低特权级到高特权级的落点</p>
<p>之前head.s虽然建立了idt但是还没有挂接中断服务函数，只是一个空架子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">trap_init();</span><br></pre></td></tr></table></figure>
<p>trap_init();函数把中断异常处理服务程序与IDT进行挂接</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231007210524694.png" alt="image-20231007210524694">
<figcaption aria-hidden="true">image-20231007210524694</figcaption>
</figure>
<p>将异常处理函数插入IDT的表项是由set_trap_gate（）和set_system_gate（）函数来完成的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//这里是在维护中断描述符表的内容，idt的架子在head.s里面给了</span></span><br><span class="line">	set_trap_gate(<span class="number">0</span>,&amp;divide_error);<span class="comment">//这里的0，1，2...是中断描述符表项//除零错误</span></span><br><span class="line">	set_trap_gate(<span class="number">1</span>,&amp;debug);<span class="comment">//单步调试//两个参数：表的索引+中断服务函数</span></span><br><span class="line">	set_trap_gate(<span class="number">2</span>,&amp;nmi);<span class="comment">//不可屏蔽中断</span></span><br><span class="line">	set_system_gate(<span class="number">3</span>,&amp;int3);	<span class="comment">/* int3-5 can be called from all */</span></span><br><span class="line">	set_system_gate(<span class="number">4</span>,&amp;overflow);<span class="comment">//溢出</span></span><br><span class="line">	set_system_gate(<span class="number">5</span>,&amp;bounds);<span class="comment">//边界检查错误</span></span><br><span class="line">	set_trap_gate(<span class="number">6</span>,&amp;invalid_op);<span class="comment">//无效指令</span></span><br><span class="line">	set_trap_gate(<span class="number">7</span>,&amp;device_not_available);<span class="comment">//无效设备</span></span><br><span class="line">	set_trap_gate(<span class="number">8</span>,&amp;double_fault);<span class="comment">//双故障</span></span><br><span class="line">	set_trap_gate(<span class="number">9</span>,&amp;coprocessor_segment_overrun);<span class="comment">//协处理器段越界</span></span><br><span class="line">	set_trap_gate(<span class="number">10</span>,&amp;invalid_TSS);</span><br><span class="line">	set_trap_gate(<span class="number">11</span>,&amp;segment_not_present);<span class="comment">//段不存在</span></span><br><span class="line">	set_trap_gate(<span class="number">12</span>,&amp;stack_segment);<span class="comment">//栈异常</span></span><br><span class="line">	set_trap_gate(<span class="number">13</span>,&amp;general_protection);<span class="comment">//一般保护性异常</span></span><br><span class="line">	set_trap_gate(<span class="number">14</span>,&amp;page_fault);<span class="comment">//缺页</span></span><br><span class="line">	set_trap_gate(<span class="number">15</span>,&amp;reserved);<span class="comment">//保留</span></span><br><span class="line">	set_trap_gate(<span class="number">16</span>,&amp;coprocessor_error);<span class="comment">//协处理器错误</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">17</span>;i&lt;<span class="number">48</span>;i++)</span><br><span class="line">		set_trap_gate(i,&amp;reserved);</span><br><span class="line">	set_trap_gate(<span class="number">45</span>,&amp;irq13);<span class="comment">//协处理器</span></span><br><span class="line">	outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>);</span><br><span class="line">	outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xdf</span>,<span class="number">0xA1</span>);</span><br><span class="line">	set_trap_gate(<span class="number">39</span>,&amp;parallel_interrupt);<span class="comment">//并口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_trap_gate(n,addr) \</span></span><br><span class="line"><span class="meta">	_set_gate(&amp;idt[n],15,0,addr)!0对应dpl，15对应类型（查手册）:1111</span></span><br><span class="line"><span class="comment">//idt是中断描述符表的起始地址。idt[n]是中断描 述符表中中断号n对应项的偏移值。中断描述符的类型是15，特权级是0.意思是只能由内核处理，如果dpl特权级别=3则可以由3特权级（用户）来处理</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231007212008081.png" alt="image-20231007212008081">
<figcaption aria-hidden="true">image-20231007212008081</figcaption>
</figure>
<p>与陷阱门不同，系统陷阱门的特权级是3，即系统陷阱门设置的中断处理过程能够被所有进程调用（如单步调试、溢出出错和超出边界出错等）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _set_gate(gate_addr,type,dpl,addr) \</span></span><br><span class="line"><span class="meta">__asm__ (<span class="string">&quot;movw %%dx,%%ax\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="string">&quot;movw %0,%%dx\n\t&quot;</span> \<span class="comment">//%0对应i</span></span></span><br><span class="line">	<span class="string">&quot;movl %%eax,%1\n\t&quot;</span> \<span class="comment">//%1对应第二行的o，将eax寄存器的值放到idt表项里面，即&amp;idt【0】，也就是gate_addr</span></span><br><span class="line">	<span class="string">&quot;movl %%edx,%2&quot;</span> \<span class="comment">//%2对应第三行的 放到gateaddr的后四个字节</span></span><br><span class="line">	: \</span><br><span class="line">	: <span class="string">&quot;i&quot;</span> ((<span class="type">short</span>) (<span class="number">0x8000</span>+(dpl&lt;&lt;<span class="number">13</span>)+(type&lt;&lt;<span class="number">8</span>))), \ <span class="comment">//i:立即数</span></span><br><span class="line">	<span class="string">&quot;o&quot;</span> (*((<span class="type">char</span> *) (gate_addr))), \ <span class="comment">//中断描述符前四个字节地址，o是偏移的意思</span></span><br><span class="line">	<span class="string">&quot;o&quot;</span> (*(<span class="number">4</span>+(<span class="type">char</span> *) (gate_addr))), \<span class="comment">//中断描述符后四个字节地址</span></span><br><span class="line">	<span class="string">&quot;d&quot;</span> ((<span class="type">char</span> *) (addr)),<span class="string">&quot;a&quot;</span> (<span class="number">0x00080000</span>))<span class="comment">//d对应edx，a对应eax，这说明了为啥edx是&amp;divide0地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>中断描述符结构：
这里面的偏移地址，就是段偏移再加上gdt里面的段基址就得到了真正的线性地址
这里本来edx里面有着完整的中断服务程序段偏移地址，为了配合中断描述符，强行把低字部分给了eax。
注意，前两条汇编这部分代码一直是在对寄存器进行操作，还没有放到内存里面，后面再添到&amp;idt[0]里面</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231008154407166.png" alt="image-20231008154407166">
<figcaption aria-hidden="true">image-20231008154407166</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;i&quot;</span> ((<span class="type">short</span>) (<span class="number">0x8000</span>+(dpl&lt;&lt;<span class="number">13</span>)+(type&lt;&lt;<span class="number">8</span>)))</span><br></pre></td></tr></table></figure>
<p><code>movw %%dx,%%ax\n\t</code>将edx的低字赋值给eax，也就是&amp;divide_error的低字，使得中断服务程序偏移地址符合上述中断描述符</p>
<p>系统描述符：我们之前在总结段描述符的时候有一个代码段和数据段的描述符（<a href="./内存管理机制汇总.md####段描述符">跳转链接</a>），这里的1111即<code>_set_gate(gate_addr,type,dpl,addr)</code>里面的type，属于系统描述符，从下面这张表中可以看出这里15是32位的陷阱门。</p>
<p>例如这个输入的是14就是32位中断门</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_intr_gate(n,addr) \</span></span><br><span class="line"><span class="meta">	_set_gate(&amp;idt[n],14,0,addr)</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231008172751154.png" alt="image-20231008172751154">
<figcaption aria-hidden="true">image-20231008172751154</figcaption>
</figure>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231008154231967.png" alt="image-20231008154231967">
<figcaption aria-hidden="true">image-20231008154231967</figcaption>
</figure>
<h5 id="中断门陷阱门执行流程">中断门陷阱门执行流程</h5>
<p>当执行int
n时，就去IDT表寻找对应的描述符，这个n是几就找到IDT表对应的第n+1个(从0开始)。</p>
<p>获取到段描述符后检查权限，进行段权限检查(没有RPL，只检查CPL)。</p>
<p>权限检查通过后，获取新的段选择子与之对应的gtd表中的段描述符的base，再加上IDT表中的limit作为EIP去跳转。</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231008161635109.png" alt="image-20231008161635109">
<figcaption aria-hidden="true">image-20231008161635109</figcaption>
</figure>
<p><img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231008173918140.png" alt="image-20231008173918140"> ### 初始化块设备请求项结构 linux
将外设分为了两类，一类是块设备，一类是字符设备。</p>
<p>进程与块设备进行沟通的时候需要经过主机内存中的缓冲区。</p>
<p>如何管理缓冲区和块设备逻辑块之间的读写关系：<strong>request
[32]请求项</strong></p>
<p><img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231011184551420.png" alt="image-20231011184551420" style="zoom:80%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> dev;		<span class="comment">/* -1 if no request */</span> <span class="comment">//使用的设备号</span></span><br><span class="line">	<span class="type">int</span> cmd;		<span class="comment">/* READ or WRITE */</span></span><br><span class="line">	<span class="type">int</span> errors;<span class="comment">//操作时产生的错误次数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sector;<span class="comment">//起始扇区</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_sectors;<span class="comment">//读写扇区数</span></span><br><span class="line">	<span class="type">char</span> * buffer;<span class="comment">//数据缓冲区</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">waiting</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span><span class="comment">//缓冲区头指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">next</span>;</span><span class="comment">//指向下一个请求项</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> <span class="title">request</span>[<span class="title">NR_REQUEST</span>];</span><span class="comment">//32个请求项</span></span><br></pre></td></tr></table></figure>
<p>操作系统根据任务的轻重缓急，管理块设备。决定缓冲和块设备之间的读写操作，并把需要操作的缓冲块记录在<strong>请求项</strong>上，得到读写操作指令时只根据请求项决定要处理的逻辑块。隔离了进程和IO设备</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blk_dev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//NR_REQUEST是请求项的数量=32</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_REQUEST ; i++) &#123;</span><br><span class="line">		request[i].dev = <span class="number">-1</span>;<span class="comment">//设为空闲，说明这个请求项还没有聚体对应那个设备，用于判断请求项当前设备是否空闲</span></span><br><span class="line">		request[i].next = <span class="literal">NULL</span>;<span class="comment">//互不挂接，说明还没形成请求队列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231011192529023.png" alt="image-20231011192529023">
<figcaption aria-hidden="true">image-20231011192529023</figcaption>
</figure>
<h3 id="与建立人机交互界面相关的外设的中断服务程序挂接非重点">与建立人机交互界面相关的外设的中断服务程序挂接（非重点）</h3>
<p>这是一个空函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chr_dev_init();<span class="comment">//字符设备，例如标准输出</span></span><br></pre></td></tr></table></figure>
<p>初始化字符设备：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tty_init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// tty 终端初始化函数。 </span></span><br><span class="line"><span class="comment">// 初始化串口终端和控制台终端</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rs_init();<span class="comment">// 初始化串行中断程序和串行接口 1 和 2。</span></span><br><span class="line">	con_init();<span class="comment">// 初始化控制台终端。(console.c, 617) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="串口设置">串口设置</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rs_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	set_intr_gate(<span class="number">0x24</span>,rs1_interrupt);<span class="comment">//设置串口1中断，中断门序号：0x24</span></span><br><span class="line">	set_intr_gate(<span class="number">0x23</span>,rs2_interrupt);</span><br><span class="line">	init(tty_table[<span class="number">1</span>].read_q.data);<span class="comment">//初始化串口1</span></span><br><span class="line">	init(tty_table[<span class="number">2</span>].read_q.data);</span><br><span class="line">	outb(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xE7</span>,<span class="number">0x21</span>);<span class="comment">//允许IRQ3,IRQ4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_intr_gate(n,addr) \</span></span><br><span class="line"><span class="meta">	_set_gate(&amp;idt[n],14,0,addr)</span></span><br></pre></td></tr></table></figure>
<p>这里设置串口用到的是中断门，dpl仍然是内核级。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">	outb_p(<span class="number">0x80</span>,port+<span class="number">3</span>);	<span class="comment">/* set DLAB of line control reg */</span></span><br><span class="line">	outb_p(<span class="number">0x30</span>,port);	<span class="comment">/* LS of divisor (48 -&gt; 2400 bps */</span><span class="comment">/* 发送波特率因子低字节，0x30-&gt;2400bps */</span> </span><br><span class="line">	outb_p(<span class="number">0x00</span>,port+<span class="number">1</span>);	<span class="comment">/* MS of divisor */</span><span class="comment">/* 发送波特率因子高字节，0x00 */</span> </span><br><span class="line">	outb_p(<span class="number">0x03</span>,port+<span class="number">3</span>);	<span class="comment">/* reset DLAB */</span></span><br><span class="line">	outb_p(<span class="number">0x0b</span>,port+<span class="number">4</span>);	<span class="comment">/* set DTR,RTS, OUT_2 */</span><span class="comment">/* 设置 DTR，RTS，辅助用户输出 2 */</span> </span><br><span class="line">	outb_p(<span class="number">0x0d</span>,port+<span class="number">1</span>);	<span class="comment">/* enable all intrs but writes */</span><span class="comment">/* 除了写(写保持空)以外，允许所有中断源中断 */</span> </span><br><span class="line">	(<span class="type">void</span>)inb(port);	<span class="comment">/* read data port to reset things (?) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231011200603640.png" alt="image-20231011200603640">
<figcaption aria-hidden="true">image-20231011200603640</figcaption>
</figure>
<h4 id="设置显示器">设置显示器</h4>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231011201010562.png" alt="image-20231011201010562">
<figcaption aria-hidden="true">image-20231011201010562</figcaption>
</figure>
<h4 id="设置键盘">设置键盘</h4>
<p>将键盘中断服务程序与IDT挂接，取消8259A对键盘的中断屏蔽。</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231011201231132.png" alt="image-20231011201231132">
<figcaption aria-hidden="true">image-20231011201231132</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> con_init()调用：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORIG_X			(*(unsigned char *)0x90000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORIG_Y			(*(unsigned char *)0x90001)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the variables used for scrolling (mostly EGA/VGA)	*/</span></span><br><span class="line">	</span><br><span class="line">	origin	= video_mem_start;</span><br><span class="line">	scr_end	= video_mem_start + video_num_lines * video_size_row;</span><br><span class="line">	top	= <span class="number">0</span>;</span><br><span class="line">	bottom	= video_num_lines;</span><br><span class="line">     gotoxy(ORIG_X,ORIG_Y);<span class="comment">//查看机器系统数据 // 初始化光标位置 x,y 和对应的内存位置 pos。 </span></span><br><span class="line">	set_trap_gate(<span class="number">0x21</span>,&amp;keyboard_interrupt);<span class="comment">// 设置键盘中断陷阱门。</span></span><br><span class="line">	outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfd</span>,<span class="number">0x21</span>);</span><br><span class="line">	a=inb_p(<span class="number">0x61</span>);</span><br><span class="line">	outb_p(a|<span class="number">0x80</span>,<span class="number">0x61</span>);</span><br><span class="line">	outb(a,<span class="number">0x61</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="设置开机启动时间非重点">设置开机启动时间（非重点）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">time_init();</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">time_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time</span>;</span></span><br><span class="line">    <span class="comment">// CMOS 的访问速度很慢。为了减小时间误差，在读取了下面循环中所有数值后，若此时 CMOS 中秒值 </span></span><br><span class="line">   <span class="comment">// 发生了变化，那么就重新读取所有值。这样内核就能把与 CMOS 的时间误差控制在 1 秒之内</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		time.tm_sec = CMOS_READ(<span class="number">0</span>); <span class="comment">// 当前时间秒值（均是 BCD 码值）。 </span></span><br><span class="line">		time.tm_min = CMOS_READ(<span class="number">2</span>);</span><br><span class="line">		time.tm_hour = CMOS_READ(<span class="number">4</span>);</span><br><span class="line">		time.tm_mday = CMOS_READ(<span class="number">7</span>);</span><br><span class="line">		time.tm_mon = CMOS_READ(<span class="number">8</span>);</span><br><span class="line">		time.tm_year = CMOS_READ(<span class="number">9</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (time.tm_sec != CMOS_READ(<span class="number">0</span>));</span><br><span class="line">	BCD_TO_BIN(time.tm_sec); <span class="comment">// 转换成二进制数值。 </span></span><br><span class="line">	BCD_TO_BIN(time.tm_min);</span><br><span class="line">	BCD_TO_BIN(time.tm_hour);</span><br><span class="line">	BCD_TO_BIN(time.tm_mday);</span><br><span class="line">	BCD_TO_BIN(time.tm_mon);</span><br><span class="line">	BCD_TO_BIN(time.tm_year);</span><br><span class="line">	time.tm_mon--;<span class="comment">// tm_mon 中月份范围是 0—11</span></span><br><span class="line">	<span class="comment">// 调用 kernel/mktime.c 中函数，计算从 1970 年 1 月 1 日 0 时起到开机当日经过的秒数，作为开机 </span></span><br><span class="line"> <span class="comment">// 时间。 </span></span><br><span class="line">	startup_time = kernel_mktime(&amp;time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码用设置开机启动时间，后面文件修改时间，访问时间等均需要根据这个进行推算。CMOS是主板上面的一个存储芯片，上面记录了时间数据。这里对这个芯片上记录的时间信息进行采集。</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231011202733967.png" alt="image-20231011202733967">
<figcaption aria-hidden="true">image-20231011202733967</figcaption>
</figure>
<h3 id="初始化进程0">初始化进程0</h3>
<p>程序是一个可执行的文件，而进程（process）是一个执行中的程序实例。利用分时技术，在
Linux</p>
<p>操作系统上同时可以运行多个进程。分时技术的基本原理是把 CPU
的运行时间划分成一个个规定长度的
时间片，让每个进程在一个时间片内运行。当进程的时间片用完时系统就利用调度程序切换到另一个进
程去运行。因此实际上对于具有单个 CPU
的机器来说某一时刻只能运行一个进程。但由于每个进程运行
的时间片很短（例如 15 个系统滴答=150
毫秒），所以表面看来好象所有进程在同时运行着。 对于 Linux 0.11
内核来讲，<strong>系统最多可有 64
个进程同时存在</strong>。除了第一个进程是“手工”建立以外，
其余的都是进程使用系统调用 fork
创建的新进程，被创建的进程称为子进程（child process），创建者，
则称为父进程（parent process）。内核程序使用进程标识号（process
ID，pid）来标识每个进程。进程由
可执行的指令代码、数据和堆栈区组成。进程中的代码和数据部分分别对应一个执行文件中的代码段、
数据段。<strong>每个进程只能执行自己的代码和访问自己的数据及堆栈区</strong>。进程之间相互之间的通信需要通过系统调用来进行。对于只有一个
CPU 的系统，在某一时刻只能有一个进程正在运行。内核通过调度程序
分时调度各个进程运行。 Linux 系统中，一个进程可以在内核态（kernel
mode）或用户态（user
mode）下执行，因此，Linux内核堆栈和用户堆栈是分开的。用户堆栈用于进程在用户态下临时保存调用函数的参数、局部变量等数
据。内核堆栈则含有内核程序执行函数调用时的信息。</p>
<p>操作系统最大共有64个进程</p>
<p>ldt，tss结构体代码如下所示（tss结构体在task结构体里面用到过）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span><span class="comment">// 任务局部描述符表。0-空，1-代码段 cs，2-数据和堆栈段 ds&amp;ss</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//四对esp ss代表了四个段特权级，每个特权级都要配合栈</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> &#123;</span></span><br><span class="line">	<span class="type">long</span>	back_link;	<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	esp0;</span><br><span class="line">	<span class="type">long</span>	ss0;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	esp1;</span><br><span class="line">	<span class="type">long</span>	ss1;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	esp2;</span><br><span class="line">	<span class="type">long</span>	ss2;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	cr3; <span class="comment">//cr3寄存器里面存放的是项目录表基址（物理地址）</span></span><br><span class="line">	<span class="type">long</span>	eip;</span><br><span class="line">	<span class="type">long</span>	eflags;</span><br><span class="line">	<span class="type">long</span>	eax,ecx,edx,ebx;</span><br><span class="line">	<span class="type">long</span>	esp;</span><br><span class="line">	<span class="type">long</span>	ebp;</span><br><span class="line">	<span class="type">long</span>	esi;</span><br><span class="line">	<span class="type">long</span>	edi;</span><br><span class="line">	<span class="comment">//段寄存器</span></span><br><span class="line">	<span class="type">long</span>	es;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	cs;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	ss;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	ds;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	fs;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	gs;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	ldt;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	trace_bitmap;	<span class="comment">/* bits: trace 0, bitmap 16-31 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i387_struct</span> <span class="title">i387</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231011203649878.png" alt="image-20231011203649878">
<figcaption aria-hidden="true">image-20231011203649878</figcaption>
</figure>
<p>LDT0:描述的是进程0的LDT段。是LDT0的基址 LDT的段描述的段是线性地址的段
CR3:一个CR3意味着一个线性地址空间，CR3记录了页目录表的地址，这里面指的是物理地址
LDT：三项，0:空的，1:代码段，2:数据段描述符。一个进程有一个LDT
TSS：有一堆寄存器的值，用于进程切换 esp：栈顶指针，和ss配对
esp0:这里的0是特权级的意思
进程切换除了要存储寄存器还要存储了显示器的状态，文件的状态（但是不一定所有进程都打开了文件）等，任务切换必定要切换TSS
在Ａ进程切换到B的时候，把进程A的cpu状态存到A进程的TSS里面。把B的TSS加载到cppu里面
<strong>设计思想：剥夺进程访问外设，访问内核，访问其他进程</strong>
从cpu的层面，同特权之间的代码段是可以互相访问的，但是从操作系统层面不可以这样。
操作系统怎么做到的：
利用LDT实现了隔离。每一个进程想跳到代码段的时候都是jmpi
1111，写不出来有效的跳转到其他段的跳转指令 EFLAGS
里面的IOPL设置了特权级，因此只有内核可以关中断开中断</p>
<h4 id="设置tssldt">设置TSS,LDT</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;(init_task.task.tss));<span class="comment">//FIRST_TSS_ENTRY=4</span></span><br><span class="line">set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));<span class="comment">//FIRST_LTD_ENTRY=5</span></span><br><span class="line">   </span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> set_tss_desc(n,addr) _set_tssldt_desc(((char *) (n)),addr,<span class="string">&quot;0x89&quot;</span>)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> set_ldt_desc(n,addr) _set_tssldt_desc(((char *) (n)),addr,<span class="string">&quot;0x82&quot;</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述的<code>gdt+FIRST_TSS_ENTRY</code>就是对应图中寻找gdt表中的描述符的过程，gdt是gdt表的基地址，保存在GDTR之中，上述操作在设置TSS0和LDT0在GDT中的段描述符</p>
<p>TSS0的段描述符格式如下所示：</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231011205601753.png" alt="image-20231011205601753">
<figcaption aria-hidden="true">image-20231011205601753</figcaption>
</figure>
<p>这段嵌入式汇编代码就是在凑出上述的段描述符格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _set_tssldt_desc(n,addr,type) \</span></span><br><span class="line"><span class="meta">__asm__ (<span class="string">&quot;movw $104,%1\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="string">&quot;movw %%ax,%2\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="string">&quot;rorl $16,%%eax\n\t&quot;</span> \ <span class="comment">//循环右移16位，高低字节互换</span></span></span><br><span class="line">	<span class="string">&quot;movb %%al,%3\n\t&quot;</span> \ <span class="comment">//将基地址eax高字中低字节移入描述符第 4 字节</span></span><br><span class="line">	<span class="string">&quot;movb $&quot;</span> type <span class="string">&quot;,%4\n\t&quot;</span> \ </span><br><span class="line">	<span class="string">&quot;movb $0x00,%5\n\t&quot;</span> \</span><br><span class="line">	<span class="string">&quot;movb %%ah,%6\n\t&quot;</span> \  <span class="comment">// 将基地址eax高字中高字节移入描述符第 7 字节。</span></span><br><span class="line">	<span class="string">&quot;rorl $16,%%eax&quot;</span> \ <span class="comment">//循环右移16位，高低字节互换</span></span><br><span class="line">	::<span class="string">&quot;a&quot;</span> (addr), <span class="string">&quot;m&quot;</span> (*(n)), <span class="string">&quot;m&quot;</span> (*(n+<span class="number">2</span>)), <span class="string">&quot;m&quot;</span> (*(n+<span class="number">4</span>)), \</span><br><span class="line">	 <span class="string">&quot;m&quot;</span> (*(n+<span class="number">5</span>)), <span class="string">&quot;m&quot;</span> (*(n+<span class="number">6</span>)), <span class="string">&quot;m&quot;</span> (*(n+<span class="number">7</span>)) \</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231011205953927.png" alt="image-20231011205953927">
<figcaption aria-hidden="true">image-20231011205953927</figcaption>
</figure>
<p>描述符表结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> a,b;</span><br><span class="line">&#125; desc_table[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> desc_table idt,gdt;</span><br></pre></td></tr></table></figure>
<ul>
<li>32位系统上，<code>unsigned long</code>通常是4字节，也就是32位。</li>
<li>64位系统上，<code>unsigned long</code>通常是8字节，也就是64位。</li>
</ul>
<p>参数对应关系如下图所示：</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231011210554759.png" alt="image-20231011210554759">
<figcaption aria-hidden="true">image-20231011210554759</figcaption>
</figure>
<p>TSS的基地址就是eax里面的addr。type
0x89,代表页存在，DPL是00内核级，S（描述符类 型）标志**</p>
<p>确定段描述符是系统描述符（S 标记为 0）或者代码、数据段描述符 （S
标记为 1）</p>
<p>这里后面的1001是系统描述符类型：查表可以看出是32位的TSS</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231008172751154.png" alt="image-20231008172751154">
<figcaption aria-hidden="true">image-20231008172751154</figcaption>
</figure>
<p><code>movw $104,%1\n\t</code>
填入段限长，说明段限长是104字节，104=b(1101000),G=0说明粒度是以字节为单位的。LDT一共只有三项，是3*8=24字节，所以是完全够用的。</p>
<h4 id="task_struct-和-init_task">task_struct 和 init_task</h4>
<p>sched_init部分代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;NR_TASKS;i++) &#123;</span><br><span class="line">		task[i] = <span class="literal">NULL</span>;</span><br><span class="line">		p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">		p++;</span><br><span class="line">		p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这里面的task定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">task</span>[<span class="title">NR_TASKS</span>] =</span> &#123;&amp;(init_task.task), &#125;;</span><br></pre></td></tr></table></figure>
<p>task是一个结构体数组，其中第一项由init_task.task初始化，其他项暂时为空。内核程序通过进程表对进程进行管理，每个进程在进程表中占有一项。在
Linux 系统中，进程表项 是一个 task_struct
任务结构指针。任务数据结构定义在头文件 include/linux/sched.h
中。有些书上称其为 进程控制块 PCB（Process Control Block）或进程描述符
PD（Processor Descriptor）。其中保存着用于控
制和管理进程的所有信息。主要包括进程当前运行的状态信息、信号、进程号、父进程号、运行时间累
计值、正在使用的文件和本任务的局部描述符以及任务状态段信息。该结构每个字段的具体含义如下所
示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* these are hardcoded - don&#x27;t touch */</span></span><br><span class="line">	<span class="type">long</span> state;	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped 任务的运行状态（-1 不可运行，0 可运行(就绪)，&gt;0 已停止）*/</span></span><br><span class="line">	<span class="type">long</span> counter;<span class="comment">//任务运行时间计数(递减)（滴答数），运行时间片。</span></span><br><span class="line">	<span class="type">long</span> priority;<span class="comment">//运行优先数。任务开始运行时 counter=priority，越大运行越长。</span></span><br><span class="line">	<span class="type">long</span> signal;<span class="comment">//信号。是位图，每个比特位代表一种信号，信号值=位偏移值+1。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction</span>[32];</span><span class="comment">//信号执行属性结构，对应信号将要执行的操作和标志信息。</span></span><br><span class="line">	<span class="type">long</span> blocked;	<span class="comment">/*进程信号屏蔽码（对应信号位图） bitmap of masked signals */</span></span><br><span class="line"><span class="comment">/* various fields */</span></span><br><span class="line">	<span class="type">int</span> exit_code;<span class="comment">//任务执行停止的退出码，其父进程会取</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_code,end_code,end_data,brk,start_stack;<span class="comment">//代码段地址。代码长度（字节数）。代码长度 + 数据长度（字节数）。总长度（字节数）。堆栈段地址。</span></span><br><span class="line">	<span class="type">long</span> pid,father,pgrp,session,leader;<span class="comment">//进程标识号(进程号)。 父进程号。父进程组号。会话号。 会话首领。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> uid,euid,suid;<span class="comment">//用户标识号（用户 id）。 有效用户 id。 保存的用户 id。 </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> gid,egid,sgid;<span class="comment">//组标识号（组 id）。有效组 id。保存的组 id。</span></span><br><span class="line">	<span class="type">long</span> alarm;<span class="comment">//报警定时值（滴答数）。</span></span><br><span class="line">	<span class="type">long</span> utime,stime,cutime,cstime,start_time;<span class="comment">//用户态运行时间（滴答数）。系统态运行时间（滴答数）。子进程用户态运行时间。子进程系统态运行时间。 进程开始运行时刻。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> used_math;<span class="comment">//标志：是否使用了协处理器。</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line">	<span class="type">int</span> tty;		<span class="comment">/* -1 if no tty, so it must be signed 进程使用 tty 的子设备号。-1 表示没有使用。 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> umask;<span class="comment">// 文件创建属性屏蔽位</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">pwd</span>;</span><span class="comment">//当前工作目录 i 节点结构。 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">root</span>;</span><span class="comment">//根目录 i 节点结构。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">executable</span>;</span><span class="comment">//执行文件 i 节点结构。 </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> close_on_exec;<span class="comment">//执行时关闭文件句柄位图标志。（参见 include/fcntl.h）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>[<span class="title">NR_OPEN</span>];</span><span class="comment">//文件结构指针表，最多 32 项。表项号即是文件描述符的值。</span></span><br><span class="line"><span class="comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span><span class="comment">// 任务局部描述符表。0-空，1-代码段 cs，2-数据和堆栈段 ds&amp;ss。 </span></span><br><span class="line"><span class="comment">/* tss for this task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span><span class="comment">//进程的任务状态段信息结构。 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>task的初始化：，可见这里只有第一个被初始化其它为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">union</span> <span class="title">task_union</span> <span class="title">init_task</span> =</span> &#123;INIT_TASK,&#125;;</span><br></pre></td></tr></table></figure>
<p><code>union</code>
是一种C语言数据结构，它可以存储不同数据类型的成员，但一次只能存储其中的一个成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">task_union</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span></span><br><span class="line">	<span class="type">char</span> <span class="built_in">stack</span>[PAGE_SIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>task union结构图如下所示 <img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231013112118390.png" alt="image-20231013112118390"></p>
<p>INIT_TASK：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  INIT_TASK is used to set up the first task table, touch at</span></span><br><span class="line"><span class="comment"> * your own risk!. Base=0, limit=0x9ffff (=640kB)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//进程0 ：这里只写了一个进程结构，相当于户口本，按照task_struct来的</span></span><br><span class="line"> <span class="comment">//INIT_TASK 用于设置第 1 个任务表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_TASK \</span></span><br><span class="line"><span class="meta"><span class="comment">//时间片设为15</span></span></span><br><span class="line"><span class="comment">/* state etc */</span>	&#123; <span class="number">0</span>,<span class="number">15</span>,<span class="number">15</span>, \ <span class="comment">// state:就绪状态, counter, priority .</span></span><br><span class="line"><span class="comment">/* signals */</span>	<span class="number">0</span>,&#123;&#123;&#125;,&#125;,<span class="number">0</span>, \ <span class="comment">// signal, sigaction[32], blocked</span></span><br><span class="line"><span class="comment">/* ec,brk... */</span>	<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \ <span class="comment">// exit_code,start_code,end_code,end_data,brk,start_stack </span></span><br><span class="line"><span class="comment">/* pid etc.. */</span>	<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \ <span class="comment">// pid, father, pgrp, session, leader </span></span><br><span class="line"><span class="comment">/* uid etc */</span>	<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \ <span class="comment">// uid, euid, suid, gid, egid, sgid </span></span><br><span class="line"><span class="comment">/* alarm */</span>	<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \ <span class="comment">// alarm, utime, stime, cutime, cstime, start_time</span></span><br><span class="line"><span class="comment">/* math */</span>	<span class="number">0</span>, \ <span class="comment">// used_math</span></span><br><span class="line"><span class="comment">/* fs info */</span>	<span class="number">-1</span>,<span class="number">0022</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">0</span>, \ <span class="comment">// tty,umask,pwd,root,executable,close_on_exec </span></span><br><span class="line"><span class="comment">/* filp */</span>	&#123;<span class="literal">NULL</span>,&#125;, \  <span class="comment">// filp[20] </span></span><br><span class="line">	&#123; \                <span class="comment">//ldt[3] 空+cs+ds</span></span><br><span class="line">		     &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, \</span><br><span class="line"><span class="comment">/* ldt */</span>	&#123;<span class="number">0x9f</span>,<span class="number">0xc0fa00</span>&#125;, \ <span class="comment">// 注意这里的地址是从低到高0x9f是低地址,代码长 640K，基址 0x0，G=1，D=1，DPL=3，P=1 TYPE=0x0a </span></span><br><span class="line">		    &#123;<span class="number">0x9f</span>,<span class="number">0xc0f200</span>&#125;, \ <span class="comment">// 数据长 640K，基址 0x0，G=1，D=1，DPL=3，P=1 TYPE=0x02</span></span><br><span class="line">	&#125;, \</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*tss*/</span>	&#123;<span class="number">0</span>,PAGE_SIZE+(<span class="type">long</span>)&amp;init_task,<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,(<span class="type">long</span>)&amp;pg_dir,\</span><br><span class="line">	 <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \</span><br><span class="line">	 <span class="number">0</span>,<span class="number">0</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>, \</span><br><span class="line">	 _LDT(<span class="number">0</span>),<span class="number">0x80000000</span>, \</span><br><span class="line">		&#123;&#125; \</span><br><span class="line">	&#125;, \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>idt 描述符：8个字节：</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231011205601753.png" alt="image-20231011205601753">
<figcaption aria-hidden="true">image-20231011205601753</figcaption>
</figure>
<p>idt设置：第一项为空项{0,0}</p>
<p>0x9f,0xc0fa00：</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231014101301111.png" alt="image-20231014101301111">
<figcaption aria-hidden="true">image-20231014101301111</figcaption>
</figure>
<p>数据段描述符 （S 标记为 1），类型1010代码段，基地址0x00，段限长9f</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231006185241375.png" alt="image-20231006185241375">
<figcaption aria-hidden="true">image-20231006185241375</figcaption>
</figure>
<p>tss0的设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*tss*/</span>	&#123;<span class="number">0</span>,PAGE_SIZE+(<span class="type">long</span>)&amp;init_task,<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,(<span class="type">long</span>)&amp;pg_dir,\</span><br><span class="line">	 <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \</span><br><span class="line">	 <span class="number">0</span>,<span class="number">0</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>, \</span><br><span class="line">	 _LDT(<span class="number">0</span>),<span class="number">0x80000000</span>, \</span><br><span class="line">		&#123;&#125; \</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>结合下述代码进行解读：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> &#123;</span></span><br><span class="line">	<span class="type">long</span>	back_link;	<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	esp0;</span><br><span class="line">	<span class="type">long</span>	ss0;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	esp1;</span><br><span class="line">	<span class="type">long</span>	ss1;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	esp2;</span><br><span class="line">	<span class="type">long</span>	ss2;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	cr3; <span class="comment">//cr3寄存器里面存放的是项目录表基址（物理地址）</span></span><br><span class="line">	<span class="type">long</span>	eip;</span><br><span class="line">	<span class="type">long</span>	eflags;</span><br><span class="line">	<span class="type">long</span>	eax,ecx,edx,ebx;</span><br><span class="line">	<span class="type">long</span>	esp;</span><br><span class="line">	<span class="type">long</span>	ebp;</span><br><span class="line">	<span class="type">long</span>	esi;</span><br><span class="line">	<span class="type">long</span>	edi;</span><br><span class="line">	<span class="comment">//段寄存器</span></span><br><span class="line">	<span class="type">long</span>	es;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	cs;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	ss;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	ds;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	fs;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	gs;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	ldt;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="type">long</span>	trace_bitmap;	<span class="comment">/* bits: trace 0, bitmap 16-31 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i387_struct</span> <span class="title">i387</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里給back_link赋值为0，</p>
<ul>
<li>ESP：栈指针寄存器(extended stack
pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶（下一个压入栈的活动记录的顶部），是栈指针</li>
</ul>
<p>​
内核栈的栈顶指针指向<code>static union task_union init_task = &#123;INIT_TASK,&#125;;</code>即内核栈的尾部，因为init——task是在内核栈的
起始位置，内核栈的大小正好是一页，如下图所示</p>
<p><img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231013112118390.png" alt="image-20231013112118390" style="zoom:80%;"></p>
<ul>
<li>ss0记录的是内核栈的段选择子。0x10:00010000
0特权级，GDT第10项，即内核数据段。</li>
</ul>
<p>​ esp1=0，ss1=0，esp2=0，ss2=0
（因为；inux0.11只用到了0和三特权级）。</p>
<ul>
<li><p>cr3=（long）&amp;pg_dir ，即页目录项物理地址。</p></li>
<li><p><em>EIP</em>（instruction
pointer）：<em>EIP寄存器</em>，用来存储CPU要读取指令的地址，CPU通过<em>EIP寄存器</em>读取即将要执行的指令。</p></li>
</ul>
<p>​ eip=0;因为进程0的代码还没开始执行</p>
<ul>
<li><p>eflags=0；决定了cli这类指令只能在零特权级使用</p></li>
<li><p>一般寄存器:AX、BX、CX、DX
AX:累积暂存器，BX:基底暂存器，CX:计数暂存器，DX:资料暂存器</p></li>
</ul>
<p>​ EAX、ECX、EDX、EBX：為ax,bx,cx,dx的延伸，各為32位元</p>
<ul>
<li><p>esp=0,EBP：基址指针寄存器(extended base
pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。用户栈</p></li>
<li><p>esi，edi=0.寄存器<em>ESI</em>、<em>EDI</em>、<em>SI</em>和<em>DI</em>称为变址寄存器<em>(Index
Register)</em>，它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。变址寄存器不可分割成<em>8</em>位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。
它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。</p></li>
<li><p>0x17是段选择子: 00010111.用户特权级，ldt第三项，即数据段。es=0x17
ES（Extra
Segment）：附加段寄存器。存放当前执行程序中一个辅助数据段的段地址。</p></li>
<li><p>进程的代码段cs，数据段ds栈顶指针ss，标志段寄存器fs，全局段寄存器gs都指向0x17</p>
<p>ldt=_LDT(0)<code>\#define _LDT(n) ((((unsigned long) n)&lt;&lt;4)+(FIRST_LDT_ENTRY&lt;&lt;3))</code>
进程的ldt相对gdt的偏移量</p></li>
<li><p>trace0 的位图 0x80000000</p></li>
</ul>
<h4 id="进程0设置相关代码解读">进程0设置相关代码解读</h4>
<p>main函数：调用进程初始化函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void main(void)&#123;</span><br><span class="line">...</span><br><span class="line">sched_init();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义task和内核栈的共用体</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">task_union</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span></span><br><span class="line">	<span class="type">char</span> <span class="built_in">stack</span>[PAGE_SIZE];<span class="comment">//内核栈，大小是一个页</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//初始化进程0的task_struct</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">union</span> <span class="title">task_union</span> <span class="title">init_task</span> =</span> &#123;INIT_TASK,&#125;;</span><br><span class="line"><span class="comment">//初始化进程槽第一个进程为进程0.让进程0占用task[0]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">task</span>[<span class="title">NR_TASKS</span>] =</span> &#123;&amp;(init_task.task), &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> a,b;</span><br><span class="line">&#125; desc_table[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">extern</span> desc_table idt,gdt;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sched_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> * <span class="title">p</span>;</span><span class="comment">//描述符表结构体指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sigaction) != <span class="number">16</span>)</span><br><span class="line">		panic(<span class="string">&quot;Struct sigaction MUST be 16 bytes&quot;</span>);</span><br><span class="line">	<span class="comment">//这两个和用户进程有关</span></span><br><span class="line">	<span class="comment">//tss task state segment 任务状态段</span></span><br><span class="line">	set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;(init_task.task.tss));<span class="comment">//FIRST_TSS_ENTRY=4</span></span><br><span class="line">	set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));<span class="comment">//FIRST_LTD_ENTRY=5</span></span><br><span class="line">	p = gdt+<span class="number">2</span>+FIRST_TSS_ENTRY;</span><br><span class="line">	<span class="comment">//从GDT第六项（TSS1开始向上全部清零，并将进程槽从1往后的项清空</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;NR_TASKS;i++) &#123;</span><br><span class="line">		task[i] = <span class="literal">NULL</span>;</span><br><span class="line">		p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">		p++;</span><br><span class="line">		p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 清除标志寄存器中的位 NT，这样以后就不会有麻烦 */</span> </span><br><span class="line"> <span class="comment">// NT 标志用于控制程序的递归调用(Nested Task)。当 NT 置位时，那么当前中断任务执行 </span></span><br><span class="line"> <span class="comment">// iret 指令时就会引起任务切换。NT 指出 TSS 中的 back_link 字段是否有效。</span></span><br><span class="line"><span class="comment">/* Clear NT, so that we won&#x27;t have troubles with that later on */</span></span><br><span class="line">	__asm__(<span class="string">&quot;pushfl ; andl $0xffffbfff,(%esp) ; popfl&quot;</span>); <span class="comment">// 复位 NT 标志。 </span></span><br><span class="line">	ltr(<span class="number">0</span>);<span class="comment">//tr寄存器指向当前tss，task 寄存器/ 将任务 0 的 TSS 加载到任务寄存器 tr。</span></span><br><span class="line">	lldt(<span class="number">0</span>);<span class="comment">//load ldt 将局部描述符表加载到局部描述符表寄存器。</span></span><br><span class="line">	outb_p(<span class="number">0x36</span>,<span class="number">0x43</span>);		<span class="comment">/* binary, mode 3, LSB/MSB, ch 0 */</span></span><br><span class="line">	outb_p(LATCH &amp; <span class="number">0xff</span> , <span class="number">0x40</span>);	<span class="comment">/* LSB */</span><span class="comment">// 定时值低字节。，每10ms一次中断</span></span><br><span class="line">	outb(LATCH &gt;&gt; <span class="number">8</span> , <span class="number">0x40</span>);	<span class="comment">/* MSB */</span><span class="comment">// 定时值高字节。</span></span><br><span class="line">	set_intr_gate(<span class="number">0x20</span>,&amp;timer_interrupt);<span class="comment">// 设置时钟中断处理程序句柄（设置时钟中断门）。这是进程调度的基础</span></span><br><span class="line">	outb(inb_p(<span class="number">0x21</span>)&amp;~<span class="number">0x01</span>,<span class="number">0x21</span>);<span class="comment">// 修改中断控制器屏蔽码，允许时钟中断。</span></span><br><span class="line">	set_system_gate(<span class="number">0x80</span>,&amp;system_call);<span class="comment">//设置系统调用 int80 // 设置系统调用中断门。 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述的：</p>
<p>ltr(0);，task register是cpu的寄存器，这里指向了tss0 lldt(0);
这里将当前进程0的ldt挂到cpu的ldtr上 操作系统真正激活了进程0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_TSS_ENTRY 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_LDT_ENTRY (FIRST_TSS_ENTRY+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TSS(n) ((((unsigned long) n)&lt;&lt;4)+(FIRST_TSS_ENTRY&lt;&lt;3))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LDT(n) ((((unsigned long) n)&lt;&lt;4)+(FIRST_LDT_ENTRY&lt;&lt;3))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ltr(n) __asm__(<span class="string">&quot;ltr %%ax&quot;</span>::<span class="string">&quot;a&quot;</span> (_TSS(n)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lldt(n) __asm__(<span class="string">&quot;lldt %%ax&quot;</span>::<span class="string">&quot;a&quot;</span> (_LDT(n)))</span></span><br></pre></td></tr></table></figure>
<p>进程初始化总览： <img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231017143210782.png" alt="image-20231017143210782"></p>
<h3 id="设置时钟中断">设置时钟中断</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">void</span> <span class="title function_">sched_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">       ...</span><br><span class="line">    outb_p(<span class="number">0x36</span>,<span class="number">0x43</span>);		<span class="comment">/* binary, mode 3, LSB/MSB, ch 0 */</span></span><br><span class="line">	outb_p(LATCH &amp; <span class="number">0xff</span> , <span class="number">0x40</span>);	<span class="comment">/* LSB */</span><span class="comment">// 定时值低字节。，每10ms一次中断</span></span><br><span class="line">	outb(LATCH &gt;&gt; <span class="number">8</span> , <span class="number">0x40</span>);	<span class="comment">/* MSB */</span><span class="comment">// 定时值高字节。</span></span><br><span class="line">	set_intr_gate(<span class="number">0x20</span>,&amp;timer_interrupt);<span class="comment">// 设置时钟中断处理程序句柄（设置时钟中断门）。这是进程调度的基础</span></span><br><span class="line">	outb(inb_p(<span class="number">0x21</span>)&amp;~<span class="number">0x01</span>,<span class="number">0x21</span>);<span class="comment">// 修改中断控制器屏蔽码，允许时钟中断。</span></span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中LATCH宏定义<code>：\#define LATCH (1193180/HZ)</code>
即系统每10毫秒发生一次中断</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231017233515389.png" alt="image-20231017233515389">
<figcaption aria-hidden="true">image-20231017233515389</figcaption>
</figure>
<h3 id="系统调用">系统调用</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_system_gate(<span class="number">0x80</span>,&amp;system_call);<span class="comment">//设置系统调用 int80 // 设置系统调用中断门。 </span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231017233811932.png" alt="image-20231017233811932">
<figcaption aria-hidden="true">image-20231017233811932</figcaption>
</figure>
<h3 id="初始化缓冲区管理结构">初始化缓冲区管理结构</h3>
<p>操作系统通过hash_table[NR_HASH],buffer_head双向链表组成的复杂哈希表管理缓冲区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;	</span><br><span class="line">buffer_init(buffer_memory_end);<span class="comment">//块设备缓冲区init，开在内存里面</span></span><br></pre></td></tr></table></figure>
<p>从内核的末端和缓冲区的末端同时开始，方向相对增长，配对的做出buffer_head(低地址端）和缓冲块（高地址端），直到不足一对buffer_head缓冲块</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231017235712928.png" alt="image-20231017235712928">
<figcaption aria-hidden="true">image-20231017235712928</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">start_buffer</span> =</span> (<span class="keyword">struct</span> buffer_head *) &amp;end;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">hash_table</span>[<span class="title">NR_HASH</span>];</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">free_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> * b_data;			<span class="comment">/* pointer to data block (1024 bytes) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> b_blocknr;	<span class="comment">/* block number */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> b_dev;		<span class="comment">/* device (0 = free) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_uptodate;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_dirt;		<span class="comment">/* 0-clean,1-dirty */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_count;		<span class="comment">/* users using this block */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_lock;		<span class="comment">/* 0 - ok, 1 -locked */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">b_wait</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev_free</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next_free</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">buffer_init</span><span class="params">(<span class="type">long</span> buffer_end)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">h</span> =</span> start_buffer;</span><br><span class="line">	<span class="type">void</span> * b;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"> <span class="comment">// 如果缓冲区高端等于 1Mb，则由于从 640KB-1MB 被显示内存和 BIOS 占用，因此实际可用缓冲区内存 </span></span><br><span class="line"> <span class="comment">// 高端应该是 640KB。否则内存高端一定大于 1MB。 </span></span><br><span class="line">	<span class="keyword">if</span> (buffer_end == <span class="number">1</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">		b = (<span class="type">void</span> *) (<span class="number">640</span>*<span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		b = (<span class="type">void</span> *) buffer_end;</span><br><span class="line"><span class="comment">// 这段代码用于初始化缓冲区，建立空闲缓冲区环链表，并获取系统中缓冲块的数目。 </span></span><br><span class="line"> <span class="comment">// 操作的过程是从缓冲区高端开始划分 1K 大小的缓冲块，与此同时在缓冲区低端建立描述该缓冲块 </span></span><br><span class="line"> <span class="comment">// 的结构 buffer_head，并将这些 buffer_head 组成双向链表。 </span></span><br><span class="line"> <span class="comment">// h 是指向缓冲头结构的指针，而 h+1 是指向内存地址连续的下一个缓冲头地址，也可以说是指向 h </span></span><br><span class="line"> <span class="comment">// 缓冲头的末端外。为了保证有足够长度的内存来存储一个缓冲头结构，需要 b 所指向的内存块 </span></span><br><span class="line"> <span class="comment">// 地址 &gt;= h 缓冲头的末端，也即要&gt;=h+1。 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> ( (b -= BLOCK_SIZE) &gt;= ((<span class="type">void</span> *) (h+<span class="number">1</span>)) ) &#123;</span><br><span class="line">		h-&gt;b_dev = <span class="number">0</span>; <span class="comment">// 使用该缓冲区的设备号。 </span></span><br><span class="line">		h-&gt;b_dirt = <span class="number">0</span>; <span class="comment">// 脏标志，也即缓冲区修改标志。</span></span><br><span class="line">		h-&gt;b_count = <span class="number">0</span>;<span class="comment">// 该缓冲区引用计数。</span></span><br><span class="line">		h-&gt;b_lock = <span class="number">0</span>;<span class="comment">// 缓冲区锁定标志</span></span><br><span class="line">		h-&gt;b_uptodate = <span class="number">0</span>;<span class="comment">// 缓冲区更新标志（或称数据有效标志）。</span></span><br><span class="line">		h-&gt;b_wait = <span class="literal">NULL</span>;<span class="comment">// 指向等待该缓冲区解锁的进程。 </span></span><br><span class="line">		h-&gt;b_next = <span class="literal">NULL</span>; <span class="comment">// 指向具有相同 hash 值的下一个缓冲头。</span></span><br><span class="line">		h-&gt;b_prev = <span class="literal">NULL</span>;<span class="comment">// 指向具有相同 hash 值的前一个缓冲头。 </span></span><br><span class="line">		h-&gt;b_data = (<span class="type">char</span> *) b;<span class="comment">// 指向对应缓冲区数据块（1024 字节）。 </span></span><br><span class="line">		h-&gt;b_prev_free = h<span class="number">-1</span>;<span class="comment">// 指向链表中前一项。 </span></span><br><span class="line">		h-&gt;b_next_free = h+<span class="number">1</span>;<span class="comment">// 指向链表中下一项。 </span></span><br><span class="line">		h++;<span class="comment">// h 指向下一新缓冲头位置</span></span><br><span class="line">		NR_BUFFERS++;<span class="comment">// 缓冲区块数累加。</span></span><br><span class="line">		<span class="keyword">if</span> (b == (<span class="type">void</span> *) <span class="number">0x100000</span>)<span class="comment">// 如果地址 b 递减到等于 1MB，则跳过 384KB， </span></span><br><span class="line">			b = (<span class="type">void</span> *) <span class="number">0xA0000</span>;<span class="comment">// 让 b 指向地址 0xA0000(640KB)处。</span></span><br><span class="line">	&#125;</span><br><span class="line">	h--;<span class="comment">// 让 h 指向最后一个有效缓冲头。 </span></span><br><span class="line">	free_list = start_buffer;<span class="comment">// 让空闲链表头指向头一个缓冲区头。</span></span><br><span class="line">	free_list-&gt;b_prev_free = h;<span class="comment">// 链表头的 b_prev_free 指向前一项（即最后一项）。</span></span><br><span class="line">	h-&gt;b_next_free = free_list;<span class="comment">// h 的下一项指针指向第一项，形成一个环链。</span></span><br><span class="line">	<span class="comment">// 初始化 hash 表（哈希表、散列表），置表中所有的指针为 NULL。</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;NR_HASH;i++)</span><br><span class="line">		hash_table[i]=<span class="literal">NULL</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231018001249142.png" alt="image-20231018001249142">
<figcaption aria-hidden="true">image-20231018001249142</figcaption>
</figure>
<p><code>struct buffer_head * start_buffer = (struct buffer_head *) &amp;end;</code></p>
<p>这里的end就是内核代码末端的地址，设计者较难事先预估在内核模块链接期间设置end值，在这里使用。</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231018084734659.png" alt="image-20231018084734659">
<figcaption aria-hidden="true">image-20231018084734659</figcaption>
</figure>
<h3 id="初始化硬盘">初始化硬盘</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hd_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;</span><br><span class="line">	set_intr_gate(<span class="number">0x2E</span>,&amp;hd_interrupt);</span><br><span class="line">	outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>);</span><br><span class="line">	outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xbf</span>,<span class="number">0xA1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将硬盘请求项服务程序do_hd_request与blk_dev控制结构挂接，将中断服务程序与LDT相挂接</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231018084850085.png" alt="image-20231018084850085">
<figcaption aria-hidden="true">image-20231018084850085</figcaption>
</figure>
<h3 id="初始化软盘">初始化软盘</h3>
<p>初始化与软盘相关的中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">floppy_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;</span><br><span class="line">	set_trap_gate(<span class="number">0x26</span>,&amp;floppy_interrupt);</span><br><span class="line">	outb(inb_p(<span class="number">0x21</span>)&amp;~<span class="number">0x40</span>,<span class="number">0x21</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和硬盘初始化的步骤相同</p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231018085045864.png" alt="image-20231018085045864">
<figcaption aria-hidden="true">image-20231018085045864</figcaption>
</figure>
<h3 id="开启中断">开启中断</h3>
<p><code>sti();//开中断，cli关中断在setup.s里面</code></p>
<figure>
<img src="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231018085257981.png" alt="image-20231018085257981">
<figcaption aria-hidden="true">image-20231018085257981</figcaption>
</figure>
<h3 id="进程0特权级翻转成为真正的进程">进程0特权级翻转，成为真正的进程</h3>
<p>除了进程0外，其它所有进程都要由一个已有进程在<strong>3</strong>特权级下创建</p>
<p>此时进程0还在0特权还不算真正的进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">...</span><br><span class="line"> move_to_user_mode();<span class="comment">//特权级从0变到3，开始运行进程0   </span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模仿中断硬件压栈，顺序是ss，esp，eflags，cs，eip</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> move_to_user_mode() \</span></span><br><span class="line"><span class="meta">__asm__ (<span class="string">&quot;movl %%esp,%%eax\n\t&quot;</span> \ <span class="comment">//当前的esp赋值给eax，因为后面模仿压栈后esp会变化</span></span></span><br><span class="line">	<span class="string">&quot;pushl $0x17\n\t&quot;</span> \ <span class="comment">//ss进栈，0x17：00010111（3特权级，LDT,数据段</span></span><br><span class="line">	<span class="string">&quot;pushl %%eax\n\t&quot;</span> \ <span class="comment">//esp进栈。esp即是0特权也是三特权，栈的实际内存空间是一样的，就是特权级不一样，压进来的是esp0，弹出的是esp3，特权级翻转但是物理位置没变	</span></span><br><span class="line">	<span class="string">&quot;pushfl\n\t&quot;</span> \  <span class="comment">//eflags进栈</span></span><br><span class="line">	<span class="string">&quot;pushl $0x0f\n\t&quot;</span> \  <span class="comment">//cs进栈。 1111 三特权级，LDT，代码段</span></span><br><span class="line">	<span class="string">&quot;pushl $1f\n\t&quot;</span> \ <span class="comment">//eip进栈</span></span><br><span class="line">	<span class="string">&quot;iret\n&quot;</span> \  <span class="comment">//出栈恢复现场，特权级翻转，因为上面压栈的都是三特权级的</span></span><br><span class="line">	<span class="string">&quot;1:\tmovl $0x17,%%eax\n\t&quot;</span> \ <span class="comment">//为什么这里指的是进程0:因为ltr和ldtr寄存器指向0进程。</span></span><br><span class="line">	<span class="string">&quot;movw %%ax,%%ds\n\t&quot;</span> \ <span class="comment">//ds，es，fs，gs与ss一致</span></span><br><span class="line">	<span class="string">&quot;movw %%ax,%%es\n\t&quot;</span> \</span><br><span class="line">	<span class="string">&quot;movw %%ax,%%fs\n\t&quot;</span> \</span><br><span class="line">	<span class="string">&quot;movw %%ax,%%gs&quot;</span> \</span><br><span class="line">	:::<span class="string">&quot;ax&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>中段函数与普通函数调用最大的不同是，不知道在哪里调用因此压栈工作是由硬件完成的，cpu硬件会将SS,ESP,EFLAGS,CS,EIP按顺序进栈。iret会引发CPU硬件将栈中的值返还给寄存器</p>
<p>这部分代码是手动模拟了中断压栈的过程</p>
<p>中断期间硬件会完成保护现场恢复现场，以及特权级翻转</p>
<p>CPU响应中断时，根据DPL设置可以实现指定特权级之间的翻转</p>
<p><strong>特权级翻转</strong></p>
<p>3 -&gt;0 :system_call</p>
<p>0-&gt;3 : move_to_user_mode() iret</p>
<h3 id="user_stack-与进程0的栈分析">user_stack 与进程0的栈分析</h3>
<p><a href="第一章节笔记.md###head.s">user_stack在第一章节笔记中的记录</a>
分析共用一个栈：怎么证明：esp一样的对应的ss的段指的位置上一样的
iret之前：0特权栈 iret之后：进程0的用户栈
进程0的内核栈？每一个进程的内核栈不能与其他1进程共用
进程0的内核栈和原来的0特权栈不是一回事
原来的0特权栈没用了，历史使命完成：保护模式打开，分页打开，中断建立完了，中断打开，0进程开始运行了。
进程0的内核栈：task init</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>LINUX011内核学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>哈工大操作系统实验系统调用</title>
    <url>/2023/11/06/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="系统调用实验">系统调用实验</h1>
<h2 id="实验内容">实验内容</h2>
<p>在 Linux 0.11
上添加两个系统调用，并编写两个简单的应用程序测试它们。</p>
<h3 id="iam"><code>iam()</code></h3>
<p>第一个系统调用是 iam()，其原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">iam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name)</span>;</span><br></pre></td></tr></table></figure>
<p>完成的功能是将字符串参数 <code>name</code>
的内容拷贝到内核中保存下来。要求 <code>name</code> 的长度不能超过 23
个字符。返回值是拷贝的字符数。如果 <code>name</code> 的字符个数超过了
<code>23</code>，则返回 “-1”，并置 errno 为 EINVAL。</p>
<p>在 <code>kernal/mywho.c</code> 中实现此系统调用。</p>
<h3 id="whoami"><code>whoami()</code></h3>
<p>第二个系统调用是 whoami()，其原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int whoami(char* name, unsigned int size);</span><br></pre></td></tr></table></figure>
<p>它将内核中由 <code>iam()</code> 保存的名字拷贝到 name
指向的用户地址空间中，同时确保不会对 <code>name</code>
越界访存（<code>name</code> 的大小由 <code>size</code>
说明）。返回值是拷贝的字符数。如果 <code>size</code>
小于需要的空间，则返回“-1”，并置 errno 为 EINVAL。</p>
<p>也是在 <code>kernal/mywho.c</code> 中实现。</p>
<h2 id="模仿">模仿</h2>
<p>操作系统实现系统调用的基本过程是：</p>
<ol type="1">
<li>应用程序调用库函数（API）；</li>
<li>API将系统调用号存入EAX，然后通过中断调用使系统进入内核态；</li>
<li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li>
<li>系统调用完成相应功能，将返回值存入EAX，返回到中断处理函数；</li>
<li>中断处理函数返回到API中；</li>
<li>API将EAX返回给应用程序。</li>
</ol>
<p>而用户模式下的很多工作需要依赖一些系统调用才能完成，因此在内核中实现了这些系统调用的API。我们不妨看看lib/close.c，研究一下<code>close()</code>的API：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">_syscall1(<span class="type">int</span>,close,<span class="type">int</span>,fd)</span><br></pre></td></tr></table></figure>
<p>其中<code>_syscall1</code>是一个宏，在include/unistd.h中定义。将<code>_syscall1(int,close,int,fd)</code>进行宏展开，可以得到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> __res;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=a&quot;</span> (__res)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;0&quot;</span> (__NR_close),<span class="string">&quot;b&quot;</span> ((<span class="type">long</span>)(fd)))</span>;</span><br><span class="line">    <span class="keyword">if</span> (__res &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) __res;</span><br><span class="line">    errno = -__res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是API的定义。它先将宏<code>__NR_close</code>存入<code>EAX</code>，将参数<code>fd</code>存入<code>EBX</code>，然后进行0x80中断调用。调用返回后，从<code>EAX</code>取出返回值，存入<code>__res</code>，再通过对<code>__res</code>的判断决定传给API的调用者什么样的返回值。</p>
<p>其中<code>__NR_close</code>就是系统调用的编号，在include/unistd.h中定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_close    6</span></span><br></pre></td></tr></table></figure>
<h3 id="从int-0x80进入内核函数">从“int 0x80”进入内核函数</h3>
<p><code>int 0x80</code>触发后，接下来就是内核的中断处理了。先了解一下0.11处理0x80号中断的过程。</p>
<p>在内核初始化时，主函数（在init/main.c中，Linux实验环境下是<code>main()</code>，Windows下因编译器兼容性问题被换名为<code>start()</code>）调用了<code>sched_init()</code>初始化函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    time_init();</span><br><span class="line">    sched_init();</span><br><span class="line">    buffer_init(buffer_memory_end);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sched_init()</code>在kernel/sched.c中定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sched_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    set_system_gate(<span class="number">0x80</span>,&amp;system_call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>set_system_gate</code>是个宏，在include/asm/system.h中定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_system_gate(n,addr) \</span></span><br><span class="line"><span class="meta">    _set_gate(&amp;idt[n],15,3,addr)</span></span><br></pre></td></tr></table></figure>
<p>_set_gate的定义是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _set_gate(gate_addr,type,dpl,addr) \</span></span><br><span class="line"><span class="meta">__asm__ (<span class="string">&quot;movw %%dx,%%ax\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;movw %0,%%dx\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;movl %%eax,%1\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;movl %%edx,%2&quot;</span> \</span></span><br><span class="line"><span class="meta">    : \</span></span><br><span class="line"><span class="meta">    : <span class="string">&quot;i&quot;</span> ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;o&quot;</span> (*((char *) (gate_addr))), \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;o&quot;</span> (*(4+(char *) (gate_addr))), \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;d&quot;</span> ((char *) (addr)),<span class="string">&quot;a&quot;</span> (0x00080000))</span></span><br></pre></td></tr></table></figure>
<p>虽然看起来挺麻烦，但实际上很简单，就是填写IDT（中断描述符表），将<code>system_call</code>函数地址写到0x80对应的中断描述符中，也就是在中断0x80发生后，自动调用函数<code>system_call</code>。</p>
<p>增加实验要求的系统调用，需要在这个函数表中增加两个函数引用——<code>sys_myiam</code>和<code>sys_mywhoami</code>。当然该函数在<code>sys_call_table</code>数组中的位置必须和<code>__NR_xxxxxx</code>的值对应上。同时还要仿照此文件中前面各个系统调用的写法，：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_mywhoami</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_myiam</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>==详细解释见：==</p>
<p>每个系统调用都有一个<code>sys_xxxxxx()</code>与之对应，它们都是我们学习和模仿的好对象。比如在fs/open.c中的<code>sys_close(int fd)</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它没有什么特别的，都是实实在在地做<code>close()</code>该做的事情。所以只要自己创建一个文件：kernel/who.c，然后实现两个函数就万事大吉了。</p>
<h3 id="在用户态和核心态之间传递数据">在用户态和核心态之间传递数据</h3>
<p>指针参数传递的是应用程序所在地址空间的逻辑地址，在内核中如果直接访问这个地址，访问到的是内核空间中的数据，不会是用户空间的。所以这里还需要一点儿特殊工作，才能在内核中从用户空间得到数据。</p>
<p>要实现的两个系统调用参数中都有字符串指针，非常像<code>open(char *filename, ……)</code>，所以我们看一下<code>open()</code>系统调用是如何处理的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename, <span class="type">int</span> flag, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    __asm__(<span class="string">&quot;int $0x80&quot;</span></span><br><span class="line">            :<span class="string">&quot;=a&quot;</span> (res)</span><br><span class="line">            :<span class="string">&quot;0&quot;</span> (__NR_open),<span class="string">&quot;b&quot;</span> (filename),<span class="string">&quot;c&quot;</span> (flag),</span><br><span class="line">            <span class="string">&quot;d&quot;</span> (va_arg(arg,<span class="type">int</span>)));</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，系统调用是用eax、ebx、ecx、edx寄存器来传递参数的。其中eax传递了系统调用号，而ebx、ecx、edx是用来传递函数的参数的，其中ebx对应第一个参数，ecx对应第二个参数，依此类推。如open所传递的文件名指针是由ebx传递的，也即进入内核后，通过ebx取出文件名字符串。open的ebx指向的数据在用户空间，而当前执行的是内核空间的代码，如何在用户态和核心态之间传递数据？接下来我们继续看看open的处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename, <span class="type">int</span> flag, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    __asm__(<span class="string">&quot;int $0x80&quot;</span></span><br><span class="line">            :<span class="string">&quot;=a&quot;</span> (res)</span><br><span class="line">            :<span class="string">&quot;0&quot;</span> (__NR_open),<span class="string">&quot;b&quot;</span> (filename),<span class="string">&quot;c&quot;</span> (flag),</span><br><span class="line">            <span class="string">&quot;d&quot;</span> (va_arg(arg,<span class="type">int</span>)));</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，系统调用是用eax、ebx、ecx、edx寄存器来传递参数的。其中eax传递了系统调用号，而ebx、ecx、edx是用来传递函数的参数的，其中ebx对应第一个参数，ecx对应第二个参数，依此类推。如open所传递的文件名指针是由ebx传递的，也即进入内核后，通过ebx取出文件名字符串。open的ebx指向的数据在用户空间，而当前执行的是内核空间的代码，如何在用户态和核心态之间传递数据？接下来我们继续看看open的处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system_call: //所有的系统调用都从system_call开始</span><br><span class="line">    ……</span><br><span class="line">    pushl %edx</span><br><span class="line">    pushl %ecx</span><br><span class="line">    pushl %ebx                # push %ebx,%ecx,%edx，这是传递给系统调用的参数</span><br><span class="line">    movl $0x10,%edx            # 让ds,es指向GDT，指向核心地址空间</span><br><span class="line">    mov %dx,%ds</span><br><span class="line">    mov %dx,%es</span><br><span class="line">    movl $0x17,%edx            # 让fs指向的是LDT，指向用户地址空间</span><br><span class="line">    mov %dx,%fs</span><br><span class="line">    call sys_call_table(,%eax,4)    # 即call sys_open</span><br></pre></td></tr></table></figure>
<p>由上面的代码可以看出，获取用户地址空间（用户数据段）中的数据依靠的就是段寄存器fs，下面该转到sys_open执行了，在fs/open.c文件中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">int</span> flag,<span class="type">int</span> mode)</span>  <span class="comment">//filename这些参数从哪里来？</span></span><br><span class="line"><span class="comment">/*是否记得上面的pushl %edx,    pushl %ecx,    pushl %ebx？</span></span><br><span class="line"><span class="comment">  实际上一个C语言函数调用另一个C语言函数时，编译时就是将要</span></span><br><span class="line"><span class="comment">  传递的参数压入栈中（第一个参数最后压，…），然后call …，</span></span><br><span class="line"><span class="comment">  所以汇编程序调用C函数时，需要自己编写这些参数压栈的代码…*/</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它将参数传给了<code>open_namei()</code>。再沿着<code>open_namei()</code>继续查找，文件名先后又被传给<code>dir_namei()</code>、<code>get_dir()</code>。在<code>get_dir()</code>中可以看到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> m_inode * <span class="title function_">get_dir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname)</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> ((c=get_fs_byte(pathname))==<span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理方法就很显然了：用get_fs_byte()获得一个字节的用户空间中的数据。所以，在实现iam()时，调用get_fs_byte()即可。但如何实现whoami()呢？即如何实现从核心态拷贝数据到用户态内存空间中呢？猜一猜，是否有put_fs_byte()？有！看一看include/asm/segment.h：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">get_fs_byte</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="keyword">register</span> <span class="type">char</span> _v;</span><br><span class="line">    __asm__ (<span class="string">&quot;movb %%fs:%1,%0&quot;</span>:<span class="string">&quot;=r&quot;</span> (_v):<span class="string">&quot;m&quot;</span> (*addr));</span><br><span class="line">    <span class="keyword">return</span> _v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">put_fs_byte</span><span class="params">(<span class="type">char</span> val,<span class="type">char</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__ (<span class="string">&quot;movb %0,%%fs:%1&quot;</span>::<span class="string">&quot;r&quot;</span> (val),<span class="string">&quot;m&quot;</span> (*addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他俩以及所有<code>put_fs_xxx()</code>和<code>get_fs_xxx()</code>都是用户空间和内核空间之间的桥梁，在后面的实验中还要经常用到。</p>
<h2 id="实现">实现</h2>
<h3 id="iam-1">iam()</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">_syscall1(<span class="type">int</span>,myiam,<span class="type">const</span> <span class="type">char</span>*,name)</span><br></pre></td></tr></table></figure>
<p>修改include/unistd.h中定义：</p>
<p>将system_calls的
<code>nr_system_call</code>改了，不然会越界报错，因为这里的<code>nr_system_calls</code>指的是总共有多少个系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_myiam		74</span></span><br></pre></td></tr></table></figure>
<p>sys.h:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fn_ptr sys_call_table[] = &#123; sys_setup, sys_exit, sys_fork, sys_read,</span><br><span class="line">...,sys_myiam,sys_mywhoami &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_mywhoami</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_myiam</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>在mywho.c 实现<code>sys_myiam();</code>函数主体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"><span class="comment">//要求 `name` 的长度不能超过 23 个字符。返回值是拷贝的字符数。如果 `name` 的字符个数超过了 `23`，则返回 “-1”，</span></span><br><span class="line"><span class="comment">//并置 errno 为 EINVAL。</span></span><br><span class="line"><span class="comment">//保存name</span></span><br><span class="line"><span class="type">char</span> global_name[<span class="number">24</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_myiam</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>&#123;</span><br><span class="line"><span class="comment">//name 长度检查：</span></span><br><span class="line">    <span class="type">char</span> str[<span class="number">25</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123; <span class="comment">// get char from user input</span></span><br><span class="line">        str[i] = get_fs_byte(name + i);</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= <span class="number">25</span> &amp;&amp; str[i++] != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">24</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(global_name, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>要注意的是，这里代码是位于内核态的。我们定义的数据都是在内核态中定义的。无法直接获取用户态的内容，所以这里用了两个函数<code>get_fs_byte</code>和<code>put_fs_byte</code>，第一个用来得到用户态的数据，第二个用来将数据存入用户态</strong>。</p>
<h3 id="whoami-1">whoami</h3>
<p>操作同iam，函数体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//它将内核中由 `iam()` 保存的名字拷贝到 name 指向的用户地址空间中，</span></span><br><span class="line"><span class="comment">//同时确保不会对 `name` 越界访存（`name` 的大小由 `size` 说明）。返回值是拷贝的字符数。</span></span><br><span class="line"><span class="comment">//如果 `size` 小于需要的空间，则返回“-1”，并置 errno 为 EINVAL。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_mywhoami</span><span class="params">(<span class="type">char</span>* name, <span class="type">unsigned</span> <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(global_name);</span><br><span class="line">    <span class="keyword">if</span>(length&gt;size)&#123;</span><br><span class="line">        <span class="keyword">return</span> -(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123; </span><br><span class="line">        put_fs_byte(global_name[i], name + i);</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; length);</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<h3 id="修改-makefile">修改 Makefile</h3>
<p>要想让我们添加的 <code>kernel/who.c</code> 可以和其它 Linux
代码编译链接到一起，必须要修改 Makefile 文件。</p>
<p>Makefile 里记录的是所有源程序文件的编译、链接规则，《注释》3.6
节有简略介绍。我们之所以简单地运行 make 就可以编译整个代码树，是因为
make 完全按照 Makefile 里的指示工作。</p>
<p>Makefile在代码树中有很多，分别负责不同模块的编译工作。我们要修改的是kernel/Makefile。需要修改两处。一处是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS  = sched.o system_call.o traps.o asm.o fork.o \</span><br><span class="line">        panic.o printk.o vsprintf.o sys.o exit.o \</span><br><span class="line">        signal.o mktime.o</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS  = sched.o system_call.o traps.o asm.o fork.o \</span><br><span class="line">        panic.o printk.o vsprintf.o sys.o exit.o \</span><br><span class="line">        signal.o mktime.o who.o mywho.o</span><br></pre></td></tr></table></figure>
<p>另一处：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">### Dependencies:</span></span><br><span class="line">exit.s exit.o: exit.c ../<span class="keyword">include</span>/errno.h ../<span class="keyword">include</span>/signal.h \</span><br><span class="line">  ../<span class="keyword">include</span>/sys/types.h ../<span class="keyword">include</span>/sys/wait.h ../<span class="keyword">include</span>/linux/sched.h \</span><br><span class="line">  ../<span class="keyword">include</span>/linux/head.h ../<span class="keyword">include</span>/linux/fs.h ../<span class="keyword">include</span>/linux/mm.h \</span><br><span class="line">  ../<span class="keyword">include</span>/linux/kernel.h ../<span class="keyword">include</span>/linux/tty.h ../<span class="keyword">include</span>/termios.h \</span><br><span class="line">  ../<span class="keyword">include</span>/asm/segment.h</span><br></pre></td></tr></table></figure>
<p>在末尾添加：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">### Dependencies:</span></span><br><span class="line">...</span><br><span class="line">mywho.s mywho.o: mywho.c ../<span class="keyword">include</span>/linux/kernel.h ../<span class="keyword">include</span>/unistd.h</span><br></pre></td></tr></table></figure>
<p>这一行规则表示了如何生成目标文件 <code>mywho.s</code> 和
<code>mywho.o</code>，它们依赖于源文件 <code>mywho.c</code>
以及两个头文件 <code>../include/linux/kernel.h</code> 和
<code>../include/unistd.h</code>。</p>
<h3 id="用printk调试内核">用printk()调试内核</h3>
<p>oslab实验环境提供了基于C语言和汇编语言的两种调试手段。除此之外，适当地向屏幕输出一些程序运行状态的信息，也是一种很高效、便捷的调试方法，有时甚至是唯一的方法，被称为“printf法”。</p>
<p>要知道到，<code>printf()</code>是一个只能在用户模式下执行的函数，而系统调用是在内核模式中运行，所以<code>printf()</code>不可用，要用<code>printk()</code>。它和<code>printf</code>的接口和功能基本相同，只是代码上有一点点不同。<code>printk()</code>需要特别处理一下<code>fs</code>寄存器，它是专用于用户模式的段寄存器。看一看<code>printk</code>的代码（在kernel/printk.c中）就知道了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    __asm__(<span class="string">&quot;push %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;push %%ds\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl $buf\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl $0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;call tty_write\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;addl $8,%%esp\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;popl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs&quot;</span></span><br><span class="line">            ::<span class="string">&quot;r&quot;</span> (i):<span class="string">&quot;ax&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，<code>printk()</code>首先<code>push %fs</code>保存这个指向用户段的寄存器，在最后<code>pop %fs</code>将其恢复，<code>printk</code>的核心仍然是调用<code>tty_write()</code>。查看<code>printf()</code>可以看到，它最终也要落实到这个函数上。</p>
<h3 id="编写测试程序">编写测试程序</h3>
<p>激动地运行一下由你亲手修改过的“Linux 0.11
pro++”！然后编写一个简单的应用程序进行测试。比如在<code>sys_iam()</code>中向终端<code>printk()</code>一些信息，让应用程序调用<code>iam()</code>，从结果可以看出系统调用是否被真的调用到了。</p>
<p>可以直接在Linux
0.11环境下用vi编写（别忘了经常执行<code>sync</code>以确保内存缓冲区的数据写入磁盘），也可以在Ubuntu或Windows下编完后再传到Linux
0.11下。无论如何，最终都必须在Linux 0.11下编译。</p>
<p>myiam测试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//iam()在用户空间的接口函数</span></span><br><span class="line"><span class="comment">// 这是定义在unistd.h里面的一个宏，展开后是一个包含int 0x80中断的代码。</span></span><br><span class="line">_syscall1(<span class="type">int</span>, myiam, <span class="type">const</span> <span class="type">char</span>*, name);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    myiam(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mywhoami测试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// whoami()在用户空间的接口函数</span></span><br><span class="line"><span class="comment">// 这是定义在unistd.h里面的一个宏，展开后是一个包含int 0x80中断的代码。</span></span><br><span class="line">_syscall2(<span class="type">int</span>, mywhoami,<span class="type">char</span>*,name,<span class="type">unsigned</span> <span class="type">int</span>,size);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">char</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">    mywhoami(name, <span class="number">30</span>);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在宿主linux下面挂载镜像文件hdc-linux0.11.img</p>
<p>在HIT目录下运行： <code>sudo ./mount-hdc</code></p>
<p>拷贝目录后运行： <code>sudo umount hdc</code></p>
<p>详见文章：<a href="https://www.cnblogs.com/mirage-mc/p/12683481.html">参考文章</a></p>
<p>注意修改sh文件权限：</p>
<p><code>sudo chmod -R 755 xxx</code></p>
<p>这里如果使用虚拟机可以正常挂载，如果使用wsl2，由于内核问题无法挂载minix文件系统镜像，需要重新编译内核并更换内核。解决方案详见：
<a href="https://blog.csdn.net/weixin_60738001/article/details/130739183">wsl2更换内核</a></p>
<p>结果：</p>
<figure>
<img src="/2023/11/06/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20231119230212969.png" alt="image-20231119230212969">
<figcaption aria-hidden="true">image-20231119230212969</figcaption>
</figure>
<h2 id="报错">报错</h2>
<h3 id="nr_whoami-undeclared">__NR_whoami undeclared</h3>
<p>__NR_iam undeclared</p>
<p>在unistd.h中存在函数调用 in function iam: __NR_iam undeclared</p>
<p>in function whoami: __NR_whoami undeclared</p>
<p>原因
在写好的库中也就是在编译完运行之后的系统库中确实不存在这两个号</p>
<p>在0.11环境下编译C程序，包含的头文件都在/usr/include目录下。该目录下的unistd.h是标准头文件（它和0.11源码树中的unistd.h并不是同一个文件，虽然内容可能相同），没有__NR_whoami和__NR_iam两个宏，需要手工加上它们，也可以直接从修改过的0.11源码树中拷贝新的unistd.h过来。</p>
<p>所以要在镜像中修改这些文件</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>HIT</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>从开机加电到main函数之前过程</title>
    <url>/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>16位实模式 -&gt; 32位保护模式</p>
<p>EP/EIP 相当于pc指针，从实模式16位-&gt;保护模式32位</p>
<h1 id="bios">BIOS</h1>
<p>加电后进入实模式运行，16位。</p>
<p>上电后CS（代码段寄存器）设置为0XF000（纯硬件完成）,因此第一条程序跳到0XF000执行。<strong>0XF000是BIOS的程序入口地址</strong>,因此此时主动权交到了BIOS手上</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20230926154112305.png" alt="image-20230926154112305">
<figcaption aria-hidden="true">image-20230926154112305</figcaption>
</figure>
<p>如图可以看出BIOS的中断向量表有0x400大小-&gt;1024-&gt;1KB</p>
<p>BIOS 的中断向量表256个中断向量：cs+ip</p>
<p>bios
执行int0x19中断，将磁盘的第一个扇区（bootsect.s的程序）复制到0x07C00处</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20230927080114009.png" alt="image-20230927080114009">
<figcaption aria-hidden="true">image-20230927080114009</figcaption>
</figure>
<h1 id="bootsect.s">bootsect.s</h1>
<p>此时位于实模式，寻址空间1MB （<span class="math inline">\(2^{20}\)</span>)</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20230927090739464.png" alt="image-20230927090739464">
<figcaption aria-hidden="true">image-20230927090739464</figcaption>
</figure>
<h2 id="第一步将bootsect的程序一个扇区512字节复制到0x90000处并跳转过去执行0x90000-0x901ff">第一步：将bootsect的程序(一个扇区512字节）复制到0x90000处，并跳转过去执行（0x90000-0x901FF)</h2>
<p>CS寄存器存储当前代码段的起始地址，IP寄存器存储下一条要执行的指令的偏移量，它们共同组成了8086处理器中的程序计数器（PC），指导CPU按照指令序列执行程序。</p>
<p>一开始cs在0x7c0</p>
<p><code>DS:SI</code>(偏移量) 和 <code>ES:DI</code>（偏移量）
是在x86汇编语言中常用于字符串操作的寄存器组合。它们通常在字符串复制、字符串比较和其他字符串处理操作中一起使用。在字符串操作中，<code>DS:SI</code>
组合通常用于指示源字符串（例如，要复制的字符串），而 <code>ES:DI</code>
组合通常用于指示目标字符串（例如，复制到的目标位置）。这些寄存器组合使汇编程序员能够高效地复制、比较或处理字符串数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start:</span><br><span class="line">	mov	ax,#BOOTSEG</span><br><span class="line">	mov	ds,ax !</span><br><span class="line">	mov	ax,#INITSEG </span><br><span class="line">	mov	es,ax</span><br><span class="line">	mov	cx,#256 !一个字是2字节-》512字节就是第一扇区的大小，循环256次</span><br><span class="line">	sub	si,si</span><br><span class="line">	sub	di,di</span><br><span class="line">	rep</span><br><span class="line">	movw</span><br><span class="line">	jmpi	go,INITSEG</span><br><span class="line">go:	mov	ax,cs</span><br><span class="line">	mov	ds,ax</span><br><span class="line">	mov	es,ax</span><br></pre></td></tr></table></figure>
<p>因此上一段程序中</p>
<p>设置了 ds：si BOOTSEG：0x0000 es：di INITSEG :0x9000</p>
<p><code>CX</code>
寄存器是x86架构中的一个16位通用寄存器，它常常用于循环计数和计数相关的操作。<code>CX</code>
寄存器的前身是8086处理器中的 <code>CX</code>
寄存器，后来的x86处理器也保留了这个寄存器，并且它在汇编语言和编程中仍然非常重要。</p>
<p><code>rep</code>
是一个前缀指令，通常与一些数据传输或操作指令一起使用，如
<code>movs</code>、<code>stos</code>、<code>cmps</code>
等。它表示重复执行指定的操作，直到满足某个条件为止。</p>
<p>​
movw是指一次移动两个字节，因此这里就是重复操作移动2个字节，重复256次</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20230927094109074.png" alt="image-20230927094109074">
<figcaption aria-hidden="true">image-20230927094109074</figcaption>
</figure>
<p>在x86汇编语言中，<code>CS:IP</code>
寄存器组合（也称为程序计数器，PC）用于指示当前正在执行的指令的内存地址。跳转指令（如<code>jmp</code>、<code>call</code>、<code>ret</code>
等）可以影响 <code>CS:IP</code>
寄存器组合，从而改变程序的控制流。更加深入了解请参考链接：https://cloud.tencent.com/developer/article/1680474</p>
<p>实模式下物理地址的计算方式是：CS ＊ 16 ＋ IP。
段基址寻址参考博客：https://mp.ofweek.com/it/a256714278117</p>
<p>执行完这段循环，执行go语句。go转移指令会导致pc指针的变化，即ip寄存器被修改为（0x90000）。因此下一条语句执行<code>mov   ax,cs</code>cs段变为INITSEG段</p>
<p><strong>完成复制以后，cs ip段通过jmpi
go,INITSEG跳转继续执行，此时0x07c00和0x90000的代码是一致的</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go:	mov	ax,cs</span><br><span class="line">	mov	ds,ax</span><br><span class="line">	mov	es,ax</span><br></pre></td></tr></table></figure>
<p>上述代码将其它寄存器的值做了调整，压栈方向从高地址到低地址</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20230927134028219.png" alt="image-20230927134028219">
<figcaption aria-hidden="true">image-20230927134028219</figcaption>
</figure>
<h2 id="第二步-加载磁盘25个扇区的setup程序">第二步
加载磁盘2~5个扇区的setup程序</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load_setup:</span><br><span class="line">	mov	dx,#0x0000		! drive 0, head 0</span><br><span class="line">	mov	cx,#0x0002		! sector 2, track 0</span><br><span class="line">	mov	bx,#0x0200		! address = 512, in INITSEG</span><br><span class="line">	mov	ax,#0x0200+SETUPLEN	! service 2, nr of sectors</span><br><span class="line">	int	0x13			! read it</span><br><span class="line">	jnc	ok_load_setup		! ok - continue</span><br><span class="line">	mov	dx,#0x0000</span><br><span class="line">	mov	ax,#0x0000		! reset the diskette</span><br><span class="line">	int	0x13</span><br><span class="line">	j	load_setup</span><br></pre></td></tr></table></figure>
<p>int 0x19 实际上是int 0x13的一个特例。注意这俩都属于BIOS的中断函数</p>
<p>int 0x13，将扇区加载到指定地址的内存</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003092439766.png" alt="image-20231003092439766">
<figcaption aria-hidden="true">image-20231003092439766</figcaption>
</figure>
<p>可以看出bootsect的起始位置是0x90000，占用512字节-》0x901FF</p>
<p>bootsect将setup代码对应的四个扇区加载到SETUPSEG：0x9020紧挨着bootsect</p>
<h2 id="第三步加载内核代码">第三步：加载内核代码</h2>
<p>仍使用int 0x13 将240个扇区加载到内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	ax,#SYSSEG</span><br><span class="line">mov	es,ax		! segment of 0x010000</span><br><span class="line">call	read_it</span><br><span class="line">call	kill_motor</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read_it:</span><br><span class="line">	mov ax,es</span><br><span class="line">	test ax,#0x0fff</span><br><span class="line">die:	jne die			! es must be at 64kB boundary</span><br><span class="line">	xor bx,bx		! bx is starting address within segment</span><br><span class="line">rp_read:</span><br><span class="line">	mov ax,es</span><br><span class="line">	cmp ax,#ENDSEG		! have we loaded all yet?</span><br><span class="line">	jb ok1_read</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>调用 read_it 将240个扇区加载到SYSSEG
=0x100,首先将SYSSEG赋值给ax，ax又赋值给es，其中es是int0x13读取时的输入参数，</p>
<p><code>jne die</code>：根据前面的测试结果，如果 <code>ax</code>
的低12位不全为零（即测试结果不等于零），则跳转到标签
<code>die</code>，进入无限循环</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003100723241.png" alt="image-20231003100723241">
<figcaption aria-hidden="true">image-20231003100723241</figcaption>
</figure>
<h2 id="跳到setup">跳到setup</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! after that (everyting loaded), we jump to</span><br><span class="line">! the setup-routine loaded directly after</span><br><span class="line">! the bootblock:</span><br><span class="line"></span><br><span class="line">	jmpi	0,SETUPSEG ！0代表偏移量是0，目标地址是SETUPSEG</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003101530040.png" alt="image-20231003101530040">
<figcaption aria-hidden="true">image-20231003101530040</figcaption>
</figure>
<h1 id="setup.s">setup.s</h1>
<h2 id="第一步卸磨杀驴建立设备信息表">第一步，卸磨杀驴，建立设备信息表</h2>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003102018552.png" alt="image-20231003102018552">
<figcaption aria-hidden="true">image-20231003102018552</figcaption>
</figure>
<p>由于bootesect已经运行完了，所以把设备信息表建立再原来bootesect程序的部分。即0x90000~0x901FD</p>
<h2 id="实现实模式向保护模式跨越">实现实模式向保护模式跨越</h2>
<p>在此之前，系统运行在实模式。现在要执行以下操作：</p>
<ul>
<li><p>打开32位寻址空间</p></li>
<li><p>打开保护模式</p></li>
<li><p>建立保护模式下的中断响应机制</p></li>
<li><p>建立内存分页机制</p></li>
</ul>
<h2 id="中断机制建立">中断机制建立</h2>
<p>首先关闭bios中断，废除bios中断机制</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003105617140.png" alt="image-20231003105617140">
<figcaption aria-hidden="true">image-20231003105617140</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! now we want to move to protected mode ...</span><br><span class="line"></span><br><span class="line">	cli			! no interrupts allowed !</span><br><span class="line"></span><br><span class="line">! first we move the system to it&#x27;s rightful place</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	mov	ax,#0x0000</span><br><span class="line">	cld			! &#x27;direction&#x27;=0, movs moves forward</span><br><span class="line">do_move:</span><br><span class="line">	mov	es,ax		! destination segment  es:di是目的地址(0x0000:0x0)</span><br><span class="line">	add	ax,#0x1000</span><br><span class="line">	cmp	ax,#0x9000</span><br><span class="line">	jz	end_move</span><br><span class="line">	mov	ds,ax		! source segment  ds:si 源地址 0x1000：0x0</span><br><span class="line">	sub	di,di  </span><br><span class="line">	sub	si,si</span><br><span class="line">	mov 	cx,#0x8000 ！移动0x8000字，即32kB字=64KB字节</span><br><span class="line">	rep</span><br><span class="line">	movsw</span><br><span class="line">	jmp	do_move</span><br><span class="line"></span><br><span class="line">! then we load the segment descriptors</span><br></pre></td></tr></table></figure>
<p>将位于0x10000的内核程序复制到0x0000处，覆盖原来的BIOS中断向量表和数据区</p>
<p>这一部分具有head.s和main里面的kernel代码</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003145416320.png" alt="image-20231003145416320">
<figcaption aria-hidden="true">image-20231003145416320</figcaption>
</figure>
<p>下一步建立新的中断机制</p>
<p>通过GDT(全局描符表)，GDTR(gdt基址寄存器)，IDT 中断描述符表，IDTR（IDT
基址寄存器）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">end_move:</span><br><span class="line">	mov	ax,#SETUPSEG	! right, forgot this at first. didn&#x27;t work :-)</span><br><span class="line">	mov	ds,ax           ! ds指向本程序</span><br><span class="line">	lidt	idt_48		! load idt with 0,0</span><br><span class="line">	lgdt	gdt_48		! load gdt with whatever appropriate</span><br><span class="line">gdt:</span><br><span class="line">	.word	0,0,0,0		! dummy</span><br><span class="line">     !第0项，空的</span><br><span class="line">     ！第一项，这里在gdt的表中偏移量是0x08.当加载代码段寄存器CS的时候，使用的是这个偏移值，指向内核代码段</span><br><span class="line">	.word	0x07FF		! 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">	.word	0x0000		! base address=0</span><br><span class="line">	.word	0x9A00		! code read/exec</span><br><span class="line">	.word	0x00C0		! granularity=4096, 386</span><br><span class="line">    ！第二项，这里在gdt的表中偏移量是0x10.当加载数据段寄存器	DS的时候，使用的是这个偏移值，指向内核数据段</span><br><span class="line">	.word	0x07FF		! 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">	.word	0x0000		! base address=0</span><br><span class="line">	.word	0x9200		! data read/write</span><br><span class="line">	.word	0x00C0		! granularity=4096, 386</span><br><span class="line"></span><br><span class="line">idt_48:</span><br><span class="line">	.word	0			! idt limit=0</span><br><span class="line">	.word	0,0			! idt base=0L</span><br><span class="line"></span><br><span class="line">gdt_48:</span><br><span class="line">	.word	0x800		! 0x800=2^(3+8)=2048=2kB字节,8B组成一个描述项因此256 GDT entries</span><br><span class="line">	.word	512+gdt,0x9	! gdt base = 0X9xxxx 定义了gdt的基址</span><br><span class="line">	!0x0009&lt;&lt;16+0x0200+gdt :32位基地址</span><br></pre></td></tr></table></figure>
<p>这里的gdt表定义了三项</p>
<ol type="1">
<li><p><code>lidt idt_48</code>: 这是加载中断描述符表（Interrupt
Descriptor Table，IDT）的指令。它用 <code>idt_48</code> 指定的地址加载了
IDT。IDT 是用于存储中断和异常处理程序地址的数据结构。</p></li>
<li><p><code>lgdt gdt_48</code>: 这是加载全局描述符表（Global Descriptor
Table，GDT）的指令。它用 <code>gdt_48</code> 指定的地址加载了 GDT。GDT
是用于描述段属性的数据结构，包括代码段和数据段的起始地址和限制。
代码解读：</p></li>
</ol>
<p><code>.word</code>
是汇编语言中的伪指令，通常用于定义数据或者常量。它告诉汇编器将后面的值以16位或32位的形式存储在内存中。<code>.word</code>
可以用于定义字、半字（16位）或者双字（32位）等数据。</p>
<p>在上面提到的汇编代码中，<code>.word</code> 用于定义 GDT
的限制字段和基址字段。例如，<code>.word 0x800</code>
定义了一个16位的字，其值为
<code>0x800</code>。<code>.word 512+gdt, 0x9</code>
定义了两个16位的字，分别是 <code>512+gdt</code> 和 <code>0x9</code></p>
<p><code>.word 0x800</code>: 这一行定义了 GDT
的限制字段（limit）。<code>0x800</code> 是一个16位的值，表示 GDT
的大小。在这里，它的值是 <code>0x800</code>，对应于2048字节。这表示 GDT
中可以包含2048/8=256个条目。</p>
<p><strong>GDT</strong>
GDT的数据结构是一个描述符数组，每个描述符8个字节，可以存放在内存当中任意位置：</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003111046230.png" alt="image-20231003111510079">
<figcaption aria-hidden="true">image-20231003111510079</figcaption>
</figure>
<p>一个GDT段描述符占用8个字节，包含三个部分：</p>
<p>段基址（32位），占据描述符的第16～39位和第55位～63位，前者存储低16位，后者存储高16位
段界限（20位），占据描述符的第0～15位和第48～51位，前者存储低16位，后者存储高4位。
段属性（12位），占据描述符的第39～47位和第49～55位，段属性可以细分为8种：TYPE属性、S属性、DPL属性、P属性、AVL属性、L属性、D/B属性和G属性
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003111819195.png" alt="image-20231003111819195"></p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003160110786.png" alt="image-20231003160110786">
<figcaption aria-hidden="true">image-20231003160110786</figcaption>
</figure>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003114017638.png" alt="image-20231003114017638">
<figcaption aria-hidden="true">image-20231003114017638</figcaption>
</figure>
<p>gdt表放在了是0x90200部分，也就是setup刚执行完的代码部分立刻就被覆盖用来干别的了。</p>
<p>其中gdt表的段基址和限长被保存在看GDTR中，保证gdt的唯一性。gdtr可以看成是一个指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idt_48:</span><br><span class="line">	.word	0			! idt limit=0</span><br><span class="line">	.word	0,0			! idt base=0L</span><br></pre></td></tr></table></figure>
<p>可以看出IDT此时只是搭了一个框架，还没有填东西，填东西这部分在后面main函数的内核部分完成。同理idtr指向了idt</p>
<h2 id="打开a20实现32位寻址">打开A20,实现32位寻址</h2>
<p>IBM 公司最初推出的个人计算机 IBM PC 使用的 CPU 是 Intel
8088。在该微机中地址 线只有 20 根(A0 – A19)。其所能寻址的最高地址是
0xffff:0xffff，也即 0x10ffef。对于超出 0x100000(1MB)的寻址地址
将默认地==环绕==到 0x0ffef。当 IBM 公司于 1985 年引入 AT 机时，使用的是
Intel 80286 CPU，具有 24 根地 址线，最高可寻址 16MB，并且有一个与 8088
完全兼容的实模式运行方式。然而，在寻址值超过 1MB时它却不能象 8088
那样实现地址寻址的环绕。但是当时已经有一些程序是利用这种地址环绕机制进行工
作的。为了实现完全的<strong>兼容性</strong>，IBM
公司发明了使用一个<strong>开关来开启或禁止 0x100000
地址比特位</strong>。由 于在当时的 8042
键盘控制器上恰好有空闲的端口引脚（输出端口 P2，引脚
P21），于是便使用了该引脚 来作为与门控制这个地址比特位。该信号即被称为
A20。如果它为零，则比特 20 及以上地址都被清除。 从而实现了兼容性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! that was painless, now we enable A20</span><br><span class="line">	call	empty_8042  ! 等待输入缓冲器空</span><br><span class="line">	mov	al,#0xD1		! command write，0xD1 表示要写数据到</span><br><span class="line">	out	#0x64,al</span><br><span class="line">	call	empty_8042</span><br><span class="line">	mov	al,#0xDF		! A20 on</span><br><span class="line">	out	#0x60,al</span><br><span class="line">	call	empty_8042</span><br></pre></td></tr></table></figure>
<p>在汇编语言中，<code>out</code>
是一个用于向特定端口发送数据的指令。它通常用于与外部设备或I/O端口进行通信。</p>
<p><code>out #0x64, al</code>: 这一行使用 <code>out</code> 汇编指令将
<code>al</code> 中的值 <code>0xD1</code> 写入端口
<code>0x64</code>。在这里，端口 <code>0x64</code>
是用于与键盘控制器通信的端口。通过向该端口发送命令或数据，可以控制键盘的行为或向键盘发送数据。</p>
<p>地址由原来的1M扩展为4G</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003145504688.png" alt="image-20231003145504688">
<figcaption aria-hidden="true">image-20231003145504688</figcaption>
</figure>
<h2 id="打开保护模式">打开保护模式</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	ax,#0x0001	! protected mode (PE) bit</span><br><span class="line">lmsw	ax		! This is it!</span><br><span class="line">jmpi	0,8		! jmp offset 0 of segment 8 (cs)</span><br></pre></td></tr></table></figure>
<p>CR0 控制寄存器(32位）用于存放系统控制标志，</p>
<ul>
<li><p>CR0的第０位是PE(protection enable 开启保护模式的标志位)
置零为实模式，置一为保护模式</p></li>
<li><p>CR0的第31位是paging即(分页的标志位)</p>
<p><code>lmsw</code>
是汇编语言中的指令，用于加载机器状态字寄存器（Machine Status Word
Register，MSW）指令执行后，源操作数中的值将被加载到机器状态字寄存器中，从而改变了处理器的一些状态和特性。这个指令通常用于操作系统内核或特权级别的代码，以更改处理器的运行模式或特权级别</p></li>
</ul>
<h2 id="划重点-jmpi-0-8是什么意思"><strong>划重点 jmpi 0，
8是什么意思</strong></h2>
<p>跳转到内核代码段，从setup跳转到head.s开始执行</p>
<p>分析：0指的是段内偏移为0，8指的是段选择符。8的二进制：8(0b0000 0000
0000
1000)这里最后两个0代表特权级00内核特权级，11代表用户特权级，第三位0代表全局描述符表即GDT如果是1代表局部描述符表LDT。第四位的1代表是GDT中的第一项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdt:</span><br><span class="line">	.word	0,0,0,0		! dummy</span><br><span class="line">     !第0项，空的</span><br><span class="line">     ！第一项，这里在gdt的表中偏移量是0x08.当加载代码段寄存器CS的时候，使用的是这个偏移值，指向内核代码段</span><br><span class="line">	.word	0x07FF		! 8Mb - limit=2047 (2048*4096=8Mb)段限长8MB</span><br><span class="line">	.word	0x0000		! base address=0</span><br><span class="line">	.word	0x9A00		! code read/exec</span><br><span class="line">	.word	0x00C0		! granularity=4096, 386</span><br><span class="line">    ！第二项，这里在gdt的表中偏移量是0x10.当加载数据段寄存器	DS的时候，使用的是这个偏移值，指向内核数据段</span><br><span class="line">	.word	0x07FF		! 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">	.word	0x0000		! base address=0</span><br><span class="line">	.word	0x9200		! data read/write</span><br><span class="line">	.word	0x00C0		! granularity=4096, 386</span><br></pre></td></tr></table></figure>
<p>第一项是cs段，可以用于确定段基址和段限长等信息。这里段基址目前为0x0000，偏移前面说了是0，因此代码跳转到0x0000处执行。而这一部分是之前0x10000部分的代码，在废除BIOS的中断之后，这部分代码被搬移到了0x0000处也就是head.s+main里面的kernel。所以这里跳转到head.s开始执行。（这部分代码首先由bootsect加载到0x10000，然后在setup.s打开保护模式的过程中挪到了0x0000处）</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003160040393.png" alt="image-20231003160040393">
<figcaption aria-hidden="true">image-20231003160040393</figcaption>
</figure>
<h1 id="head.s">head.s</h1>
<h2 id="完善保护模式">完善保护模式</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl _idt,_gdt,_pg_dir,_tmp_floppy_area</span><br><span class="line">_pg_dir:</span><br></pre></td></tr></table></figure>
<p>_pg_dir,用于标识内核分页后内核的起始位置，也就是物理内存的起始位置0x000000</p>
<h2 id="设置dsesp栈等">设置DS，esp栈等</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">startup_32:</span><br><span class="line">	movl $0x10,%eax</span><br><span class="line">	mov %ax,%ds</span><br><span class="line">	mov %ax,%es</span><br><span class="line">	mov %ax,%fs</span><br><span class="line">	mov %ax,%gs</span><br></pre></td></tr></table></figure>
<p>可知在jmpi
0，8部分CS已经从实模式的寻址转变到了保护模式寻址，这一段代码是将其它寄存器也转变到保护模式</p>
<p>ds，es，fs，gs设置为0x10 。
0x10：b（10000）特权级是0，全局描述符表，第10也就是第三项，即内核数据段。</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003162657094.png" alt="image-20231003162657094">
<figcaption aria-hidden="true">image-20231003162657094</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lss _stack_start,%esp</span><br></pre></td></tr></table></figure>
<p>_stack_start 这种加了下滑线的代表在C语言里面也有定义：</p>
<p>kernel/sched.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> * a;</span><br><span class="line">	<span class="type">short</span> b;</span><br><span class="line">	&#125; stack_start = &#123; &amp; user_stack [PAGE_SIZE&gt;&gt;<span class="number">2</span>] , <span class="number">0x10</span> &#125;;</span><br><span class="line">    <span class="comment">//#define PAGE_SIZE 4096 因此这里是user_stack [1024]</span></span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个结构体（struct）<code>stack_start</code>，该结构体包含两个成员：</p>
<ol type="1">
<li><code>a</code>：一个指向长整数（long）的指针。在这里，<code>a</code>
被初始化为指向 <code>user_stack[PAGE_SIZE&gt;&gt;2]</code> 的指针，其中
<code>PAGE_SIZE&gt;&gt;2</code> 表示将 <code>PAGE_SIZE</code>
右移两位，相当于将 <code>PAGE_SIZE</code> 除以 4，然后
<code>user_stack</code> 是一个数组，这个指针 <code>a</code> 最终指向数组
<code>user_stack</code> 中的某个元素。</li>
<li><code>b</code>：一个短整数（short）。在这里，<code>b</code>
被初始化为 <code>0x10</code>，表示十六进制数 0x10，也就是十进制数
16。</li>
</ol>
<p>所以，这段代码的目的是创建一个名为 <code>stack_start</code>
的结构体，并初始化其中的两个成员，一个是指针 <code>a</code> 指向数组
<code>user_stack</code> 中的某个元素，另一个是短整数 <code>b</code>
被初始化为十六进制数 0x10（十进制数 16）.</p>
<p>将32位栈顶指针指向user_stack数据结构的最末位置如下所示。</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003163507170.png" alt="image-20231003163507170">
<figcaption aria-hidden="true">image-20231003163507170</figcaption>
</figure>
<p>在内核初始化操作过程中被用作内核栈，初始化完成以后将被用作task0的用户态堆栈。</p>
<h2 id="设置idt">设置IDT</h2>
<p>中断描述符:</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003165058386.png" alt="image-20231003165058386">
<figcaption aria-hidden="true">image-20231003165058386</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setup_idt:</span><br><span class="line">	lea ignore_int,%edx</span><br><span class="line">	movl $0x00080000,%eax</span><br><span class="line">	movw %dx,%ax		/* selector = 0x0008 = cs */</span><br><span class="line">	movw $0x8E00,%dx	/* interrupt gate - dpl=0, present */</span><br><span class="line"></span><br><span class="line">	lea _idt,%edi /*_idt中断描述符表的地址*/</span><br><span class="line">	mov $256,%ecx</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003165553164.png" alt="image-20231003165553164">
<figcaption aria-hidden="true">image-20231003165553164</figcaption>
</figure>
<p><code>lea</code> 是 x86 汇编语言中的一条指令，它代表 "Load Effective
Address"，用于将一个有效地址加载到目标寄存器中。<code>lea</code>
指令并不执行内存引用操作，而只是将 <code>ignore_int</code>
变量的内存地址（有效地址）加载到 <code>edx</code> 寄存器中ignore_int
是中断门。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_idt:	.fill 256,8,0		# idt is uninitialized</span><br></pre></td></tr></table></figure>
<p>这行汇编指令的作用是创建一个名为 <code>_idt</code>
的数组，这个数组的长度是 256 个元素，每个元素占据 8
个字节，并且将所有元素初始化为
0。这种语法通常用于声明并分配一块内存，用于存储中断描述符表（Interrupt
Descriptor Table，IDT）的内容。 IDT 通常用于 x86
架构的操作系统中，用于处理中断和异常。</p>
<h2 id="废除已有的gdt新建gdt">废除已有的GDT新建GDT</h2>
<p>因为原有的gdt表建在setup那段程序中，后面会被用来干别的覆盖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setup_gdt:</span><br><span class="line">	lgdt gdt_descr</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdt_descr:</span><br><span class="line">	.word 256*8-1		# so does gdt (not that that&#x27;s any</span><br><span class="line">	.long _gdt		# magic number, but it works for me :^)</span><br><span class="line"></span><br><span class="line">	.align 3</span><br></pre></td></tr></table></figure>
<ul>
<li><code>.word 256*8-1</code> 表示 GDT 的限制（limit）。在这里，256*8-1
是 GDT 表的限制值，表示 GDT 中可以存放的描述符数量。每个描述符占用 8
个字节，所以限制值设置为 <code>256*8-1</code> 表示 GDT 中可以存放 256
个描述符。</li>
<li><code>.long _gdt</code> 表示 GDT 的基地址（base
address）。在这里，<code>_gdt</code> 是 GDT 数组的地址，这个地址将作为
GDT 表的基地址。</li>
<li><code>.align 3</code> 指令用于确保接下来的数据或代码在内存中按照 2^3
= 8 字节对齐。这通常用于对齐数据或代码，以提高访问效率。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_gdt:	.quad 0x0000000000000000	/* NULL descriptor */</span><br><span class="line">	.quad 0x00c09a0000000fff	/* 16Mb */</span><br><span class="line">	.quad 0x00c0920000000fff	/* 16Mb 为啥是16M:段限长：0x00fff，C:1100 G=1粒度是4k ，0~0fff-&gt;2^12*4k=16M*/</span><br><span class="line">	.quad 0x0000000000000000	/* TEMPORARY - don&#x27;t use */</span><br><span class="line">	.fill 252,8,0			/* space for LDT&#x27;s and TSS&#x27;s etc 有增加了一项空项*/</span><br></pre></td></tr></table></figure>
<p><code>.quad</code> 是汇编中的伪指令，用于定义 64 位（8
字节）的数据项</p>
<p>0x00c09a0000000fff /* 16Mb */为啥?</p>
<p>16Mb 为啥是16M:段限长：0x00fff，C:1100 G=1粒度是4k
，0~0fff-&gt;2^12<em>4k=16M</em></p>
<p>前八位是段基址，即C0。</p>
<p>注意后三位的FFF是段限长，说明段限长由原来的7FF（8MB)变为了16MB</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003171101035.png" alt="image-20231003171101035">
<figcaption aria-hidden="true">image-20231003171101035</figcaption>
</figure>
<p>因为段限长变了，所以要对DS,ES,FS,GS,SS进行修改，每个描述符的限长也修改了，因此需要重新加载一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl $0x10,%eax		# reload all the segment registers</span><br><span class="line">mov %ax,%ds		# after changing gdt. CS was already</span><br><span class="line">mov %ax,%es		# reloaded in &#x27;setup_gdt&#x27;</span><br><span class="line">mov %ax,%fs</span><br><span class="line">mov %ax,%gs</span><br><span class="line">lss _stack_start,%esp</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003192816784.png" alt="image-20231003192816784">
<figcaption aria-hidden="true">image-20231003192816784</figcaption>
</figure>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003201544973.png" alt="image-20231003201544973">
<figcaption aria-hidden="true">image-20231003201544973</figcaption>
</figure>
<h2 id="测试a20是否打开">测试A20是否打开</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xorl %eax,%eax</span><br><span class="line">1:	incl %eax		# check that A20 really IS enabled</span><br><span class="line">	movl %eax,0x000000	# loop forever if it isn&#x27;t</span><br><span class="line">	cmpl %eax,0x100000</span><br><span class="line">	je 1b</span><br></pre></td></tr></table></figure>
<p>测试A20是否真的打开了<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003193634497.png" alt="image-20231003193634497"></p>
<h2 id="main函数压栈">main函数压栈</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">after_page_tables:</span><br><span class="line">	pushl $0		# These are the parameters to main :-)</span><br><span class="line">	pushl $0</span><br><span class="line">	pushl $0</span><br><span class="line">	pushl $L6		# return address for main, if it decides to.</span><br><span class="line">	pushl $_main</span><br><span class="line">	jmp setup_paging</span><br><span class="line">L6:</span><br><span class="line">	jmp L6			# main should never return here, but</span><br><span class="line">				# just in case, we know what happens.</span><br></pre></td></tr></table></figure>
<p>将L6和main函数入口地址压栈，当head.s执行完以后执行·ret就会pop栈顶指针，跳转到main函数执行，这里面的栈就是上面的栈</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003194434372.png" alt="image-20231003194434372">
<figcaption aria-hidden="true">image-20231003194434372</figcaption>
</figure>
<h2 id="建立分页机制">建立分页机制</h2>
<p>完成main函数的压栈后，开始建立分页机制</p>
<p>首先从内存起始位置放一个页目录表和四个页表，每页4KB</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setup_paging:</span><br><span class="line">	movl $1024*5,%ecx		/* 5 pages - pg_dir+4 page tables */</span><br><span class="line">	xorl %eax,%eax</span><br><span class="line">	xorl %edi,%edi			/* pg_dir is at 0x000 */</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003195656562.png" alt="image-20231003195656562">
<figcaption aria-hidden="true">image-20231003195656562</figcaption>
</figure>
<p>设置页目录表前四项使之分别指向四个页表。</p>
<p>32位地址：CPU 在看到我们给出的内存地址后，首先把线性地址被拆分成</p>
<p>高 10 位：中间 10 位：后 12 位。</p>
<p>线性地址的位 31-22 共 10 个比特用来确定页目录中的目录项，位 21-12
用来寻址页目录项指定的页 表中的页表项，最后的 12
个比特正好用作页表项指定的一页物理内存中的偏移地址。</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231006092145578.png" alt="image-20231006092145578">
<figcaption aria-hidden="true">image-20231006092145578</figcaption>
</figure>
<p><span class="math inline">\(2^{10}\)</span>=1K,一个页目录表有1k个页表，一个页表包含1k个页表项，一个页表指向一个页面(4k)。</p>
<p>因此一个页表对应了4M的物理空间。这里一共建立了4个页表：16M空间，理论上可以更大。由于硬件中cpu是4k对齐的</p>
<p>因此低12位会是零，所以可以用高20位来表示4KB对齐的页表和页，因此可以用后12位设置权限。</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231006092929709.png" alt="image-20231006092929709">
<figcaption aria-hidden="true">image-20231006092929709</figcaption>
</figure>
<p>其中，页框地址(PAGE FRAME
ADDRESS)指定了一页内存的物理起始地址。因为内存页是位于
4K边界上的，所以其低 12 比特总是 0，因此表项的低 12
比特可作它用。图中的存在位（PRESENT –
P）确定了一个页表项是否可以用于地址转换过程。P=1 表示该项可用。
当目录表项或第二级表项的 P=0
时，则该表项是无效的，不能用于地址转换过程。此时该表项的所有其
它比特位都可供程序使用；处理器不对这些位进行测试。</p>
<p>当 CPU 试图使用一个页表项进行地址转换时，如果此时任意一级页表项的
P=0，则处理器就会发出
页异常信号。此时缺页中断异常处理程序就可以把所请求的页加入到物理内存中，并且导致异常的指令
会被重新执行。</p>
<p>已访问（Accessed – A）和已修改（Dirty –
D）比特位用于提供有关页使用的信息。除了页目录项中
的已修改位，这些比特位将由硬件置位，但不复位。</p>
<p>在对一页内存进行读或写操作之前，CPU
将设置相关的目录和二级页表项的已访问位。在向一个二
级页表项所涵盖的地址进行写操作之前，处理器将设置该二级页表项的已修改位，而页目录项中的已修
改位是不用的。当所需求的内存超出实际物理内存量时，内存管理程序就可以使用这些位来确定那些页
可以从内存中取走，以腾出空间。内存管理程序还需负责检测和复位这些比特位。</p>
<p>读/写位（Read/Write – R/W）和用户/超级用户位（User/Supervisor –
U/S）并不用于地址转换，但用 于分页级的保护机制，是由 CPU
在地址转换过程中同时操作的。</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003225759273.png" alt="image-20231003225759273">
<figcaption aria-hidden="true">image-20231003225759273</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.org 0x1000</span><br><span class="line">pg0:</span><br><span class="line"></span><br><span class="line">.org 0x2000</span><br><span class="line">pg1:</span><br><span class="line"></span><br><span class="line">.org 0x3000</span><br><span class="line">pg2:</span><br><span class="line"></span><br><span class="line">.org 0x4000</span><br><span class="line">pg3:</span><br><span class="line"></span><br><span class="line">.org 0x5000</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   movl $pg0+7,_pg_dir		/* set present bit/user r/w */</span><br><span class="line">movl $pg1+7,_pg_dir+4		/*  --------- &quot; &quot; --------- */</span><br><span class="line">movl $pg2+7,_pg_dir+8		/*  --------- &quot; &quot; --------- */</span><br><span class="line">movl $pg3+7,_pg_dir+12		/*  --------- &quot; &quot; --------- */</span><br><span class="line">	/*在这段汇编代码中，_pg_dir 是一个地址，_pg_dir+4 是将 _pg_dir 的地址值增加 4 个字节，</span><br><span class="line">以访问 _pg_dir 中的下一个 4 字节的位置。这种情况通常出现在处理数组或数据结构的情况下，</span><br><span class="line">需要按字节访问连续的内存位置。</span><br><span class="line">在汇编语言中，符号$通常用于表示立即数（immediate value），而不是地址偏移。$pg2+7 </span><br><span class="line">中的7是一个立即数，而不是偏移量。这个7代表了一个具体的数值，而不是表示字节或二进制值。 */</span><br></pre></td></tr></table></figure>
<p>上面的7代表111，这三位分别代表用户u，读写rw，存在p。如果是000代表内核，只读，不存在页。加7就是把后12位用于存权限问题。<code>movl $pg0+7,_pg_dir</code>
这行汇编指令的含义是将地址 <code>pg0</code> 加上 7 存储到
<code>_pg_dir</code>
地址处。因此上面这一段代码的意义就是让页目录表指向每个页表项，同时第一个地方指向页目录自己，每次递增4个字节即32位地址。也就是如下图所示,这里的_pg_dir就是head的起始地址，这里是在一边执行head.s的代码一边覆盖。</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003232851762.png" alt="image-20231003232851762">
<figcaption aria-hidden="true">image-20231003232851762</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	movl $pg3+4092,%edi/*一个页表的最后一项在页表中的位置是1023*4=4092（一共1024项，第1024项的开始地址） */</span><br><span class="line">	movl $0xfff007,%eax		/*  16Mb - 4096 + 7 (r/w user,p) 一个页面4k=4096，16M是整个页面管理的空间，所以这里是最后一个页面的地址*/	   </span><br><span class="line">	std/*方向位置位，edi递减 */</span><br><span class="line">1:	stosl			/* fill pages backwards - more efficient :-) */</span><br><span class="line">	subl $0x1000,%eax  /*每写好一项物理地址递减0x1000 ，16^3=2^12=4k */</span><br><span class="line">	jge 1b/*如果小于0说明全填好了 */</span><br></pre></td></tr></table></figure>
<p>edi指向了第一个页面，eax指向了最后一个页面</p>
<p><strong>设置CR3,CR0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xorl %eax,%eax		/* pg_dir is at 0x0000 */</span><br><span class="line">movl %eax,%cr3		/* cr3 - page directory start */</span><br><span class="line">movl %cr0,%eax</span><br><span class="line">orl $0x80000000,%eax</span><br><span class="line">movl %eax,%cr0		/* set paging (PG) bit */</span><br><span class="line">ret			/* 依赖前面的push stack转到main函数运行。this also flushes prefetch-queue */</span><br></pre></td></tr></table></figure>
<p>CR3是页目录基址寄存器，其高20位存放页目录表基地址，这里就是0。orl
$0x80000000,%eax，将最高位置一。==CR0寄存器==的第31位是分页机制控制位，置一代表开启分页。至此内核分页构建完成</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003235254879.png" alt="image-20231003235254879">
<figcaption aria-hidden="true">image-20231003235254879</figcaption>
</figure>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231006092016126.png" alt="image-20231006092016126">
<figcaption aria-hidden="true">image-20231006092016126</figcaption>
</figure>
<h2 id="内核内存恒等映射">内核内存恒等映射</h2>
<p>根据内核分页为线性地址恒等映射的要求，推导出四个页表的映射公式，写出页表的设置代码。</p>
<p>在Linux 0.11
内核中，为了有效地使用机器中的物理内存，内存被划分成几个功能区域</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231005095121645.png" alt="image-20231005095121645">
<figcaption aria-hidden="true">image-20231005095121645</figcaption>
</figure>
<p>在 Linux 0.11 内核中，给每个程序（进程）都划分了总容量为 64MB
的虚拟内存空 间。因此程序的逻辑地址范围是 0x0000000 到 0x4000000。</p>
<p>在内存分段系统中，一个程序的逻辑地址是通过分段机制自动地映射（变换）到中间层的线性地址
上。每次对内存的引用都是对内存段中内存的引用。当一个程序引用一个内存地址时，通过把相应的段
基址加到程序员看得见的逻辑地址上就形成了一个对应的线性地址。此时若没有启用分页机制，则该线
性地址就被送到 CPU 的外部地址总线上，用于直接寻址对应的物理内存。</p>
<p><strong>转到main</strong></p>
<p>ret返回，结合前面所说的main函数压栈，这里返回，得到main函数的入口地址，接下来就执行main函数了。</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003235415139.png" alt="image-20231003235415139">
<figcaption aria-hidden="true">image-20231003235415139</figcaption>
</figure>
<h1 id="小结">小结</h1>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003150359552.png" alt="image-20231003150359552">
<figcaption aria-hidden="true">image-20231003150359552</figcaption>
</figure>
<h1 id="实模式和保护模式的寻址区别">实模式和保护模式的寻址区别</h1>
<p>在实模式中，CPU通过段地址和段偏移量寻址。其中段地址保存到段寄存器，包含：CS、SS、DS、ES、FS、GS。段偏移量可以保存到IP、BX、SI、DI寄存器。在汇编代码<code>mov ds:[si], ax</code>中，会将AX寄存器的数据写入到物理内存地址<code>DS * 16 + SI</code>中。</p>
<p>而在保护模式下，也是通过段寄存器和段偏移量寻址，但是此时段寄存器保存的数据意义不同了。
此时的CS和SS寄存器后13位相当于GDT表中某个描述符的索引，即<strong>==段选择子==</strong>。第2位存储了TI值（0代表GDT，1代表LDT），第0、1位存储了当前的特权级（CPL）。</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003111510079.png" alt="image-20231003111510079">
<figcaption aria-hidden="true">image-20231003111510079</figcaption>
</figure>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003150641596.png" alt="image-20231003150641596">
<figcaption aria-hidden="true">image-20231003150641596</figcaption>
</figure>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003201644907.png" alt="image-20231003201644907">
<figcaption aria-hidden="true">image-20231003201644907</figcaption>
</figure>
<h2 id="分页后寻址">分页后寻址</h2>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231003201757163.png" alt="image-20231003201757163">
<figcaption aria-hidden="true">image-20231003201757163</figcaption>
</figure>
<p>高 10
位负责在<strong>页目录表</strong>中找到一个<strong>页目录项</strong>，这个页目录项的值加上中间
10
位拼接后的地址去<strong>页表</strong>中去寻找一个<strong>页表项</strong>，这个页表项的值，再加上后
12 位偏移地址，就是最终的物理地址。</p>
<p>intel CPU
使用段（Segment）的概念来对程序进行寻址。每个段定义了内存中的某个区域以及访问
的优先级等信息。而每个程序都可有若干个内存段组成。访问控制是基于段的访问控制</p>
<p>程序的==逻辑地址==（或称为虚拟地址）即是用于
寻址这些段和段中具体地址位置。在 Linux 0.11
中，程序逻辑地址到线性地址的变换过程使用了 CPU 的 全局段描述符表 GDT
和局部段描述符表 LDT。由 GDT 映射的地址空间称为全局地址空间，由 LDT 映
射的地址空间则称为局部地址空间，而这两者构成了虚拟地址的空间。</p>
<figure>
<img src="/2023/10/09/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/image-20231005100625737.png" alt="image-20231005100625737">
<figcaption aria-hidden="true">image-20231005100625737</figcaption>
</figure>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>LINUX011内核学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>openmp</title>
    <url>/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/</url>
    <content><![CDATA[<h1 id="openmp">openmp</h1>
<h2 id="openmp-syntax-in-cc"><strong>OpenMP: Syntax in
C/C++</strong></h2>
<p><strong>包含头文件:</strong><code>#include &lt;omp.h&gt;</code></p>
<p><strong>编译制导</strong></p>
<p>编译制导指令以#pragma omp
开始，后边跟具体的功能指令，格式如：<strong>#pragma omp 指令[子句[,子句]
…]</strong>。</p>
<h2 id="测试小案例1openmp的简单使用">测试小案例1：openmp的简单使用</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;Hello wrold from %d!\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ hello.cpp -fopenmp -o hello</span><br></pre></td></tr></table></figure>
<p>OPENMP中设置线程数量的方法：</p>
<p>在环境变量中设置<a href="https://so.csdn.net/so/search?q=environment&amp;spm=1001.2101.3001.7020">environment</a>
variables。在命令窗口中配置 ：<code>export OMP_NUM_THREADS</code> =
3</p>
<p>其他常见的环境变量：</p>
<p>▪ <strong>Loop scheduling:</strong> <strong>OMP_SCHEDULE,
Stacksize:</strong> <strong>OMP_STACKSIZE</strong></p>
<p>▪ <strong>Dynamic adjustment of threads:</strong>
<strong>OMP_DYNAMIC</strong></p>
<p>运行以后有这样的效果：</p>
<p><img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240619093725037.png"></p>
<h2 id="测试小案例2私有变量和共享变量">测试小案例2：私有变量和共享变量</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> shared_sum = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for shared(shared_sum)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">omp_get_num_threads</span>(); i++) &#123;</span><br><span class="line">	shared_sum += i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tid %d, shared_sum = %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), shared_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> private_sum = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for private(private_sum)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">omp_get_num_threads</span>(); i++) &#123;</span><br><span class="line">	private_sum += i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tid %d, private_sum = %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), private_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;outside private_sum = %d\n&quot;</span>, private_sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>privatized variables</strong> defined in scope outside the
<strong>parallel region</strong></p>
<p><img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240619110116719.png"></p>
<h2 id="调度的策略">调度的策略</h2>
<p>默认的静态调度策略是将程序整段均分，分块后分给不同的线程。</p>
<p>动态调度</p>
<figure>
<img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240521145024346.png" alt="image-20240521145024346">
<figcaption aria-hidden="true">image-20240521145024346</figcaption>
</figure>
<p>例如：</p>
<p><code>#pragma omp for schedule(static, 1)</code></p>
<ol type="1">
<li><strong><code>#pragma omp for</code></strong>：
这条指令告诉编译器，后面的 for
循环应该被并行化。编译器会生成多线程代码来执行循环的各个迭代。</li>
<li><strong><code>schedule(static, 1)</code></strong>：
这是一个调度策略，定义了如何将循环迭代分配给不同的线程。
<ul>
<li><strong><code>static</code></strong>：
静态调度策略。表示在程序执行前（即编译时）确定每个线程将处理的迭代次数。每个线程处理的迭代是连续的块。</li>
<li><strong><code>1</code></strong>：
表示块大小，即每个线程一次处理一个迭代。这意味着循环的每个迭代（即每次循环）都被分配给不同的线程。</li>
</ul></li>
</ol>
<p>综上所述，<code>#pragma omp for schedule(static, 1)</code>
的意思是：</p>
<ol type="1">
<li>将 for 循环并行化。</li>
<li>使用静态调度策略。</li>
<li>每个线程处理一个迭代。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STATIC_CHUNK 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DYNAMIC_CHUNK 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_LOOPS 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLEEP_EVERY_N 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nStatic1[NUM_LOOPS],</span><br><span class="line">        nStaticN[NUM_LOOPS];</span><br><span class="line">    <span class="type">int</span> nDynamic1[NUM_LOOPS],</span><br><span class="line">        nDynamicN[NUM_LOOPS];</span><br><span class="line">    <span class="type">int</span> nGuided[NUM_LOOPS];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">omp_set_num_threads</span>(NUM_THREADS);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="meta">#<span class="keyword">pragma</span> omp for schedule(static, 1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; NUM_LOOPS ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % SLEEP_EVERY_N) == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">usleep</span>(<span class="number">0</span>);</span><br><span class="line">            nStatic1[i] = <span class="built_in">omp_get_thread_num</span>( );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp for schedule(static, STATIC_CHUNK)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; NUM_LOOPS ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % SLEEP_EVERY_N) == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">usleep</span>(<span class="number">0</span>);</span><br><span class="line">            nStaticN[i] = <span class="built_in">omp_get_thread_num</span>( );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp for schedule(dynamic, 1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; NUM_LOOPS ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % SLEEP_EVERY_N) == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">usleep</span>(<span class="number">0</span>);</span><br><span class="line">            nDynamic1[i] = <span class="built_in">omp_get_thread_num</span>( );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp for schedule(dynamic, DYNAMIC_CHUNK)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; NUM_LOOPS ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % SLEEP_EVERY_N) == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">usleep</span>(<span class="number">0</span>);</span><br><span class="line">            nDynamicN[i] = <span class="built_in">omp_get_thread_num</span>( );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp for schedule(guided)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; NUM_LOOPS ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % SLEEP_EVERY_N) == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">usleep</span>(<span class="number">0</span>);</span><br><span class="line">            nGuided[i] = <span class="built_in">omp_get_thread_num</span>( );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;| static | static | dynamic | dynamic | guided |\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;|    1   |    %d   |    1    |    %d    |        |\n&quot;</span>,</span><br><span class="line">             STATIC_CHUNK, DYNAMIC_CHUNK);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;NUM_LOOPS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;|    %d   |    %d   |    %d    |    %d    |&quot;</span></span><br><span class="line">                 <span class="string">&quot;    %d   |\n&quot;</span>,</span><br><span class="line">                 nStatic1[i], nStaticN[i],</span><br><span class="line">                 nDynamic1[i], nDynamicN[i], nGuided[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240619171358820.png" alt="image-20240619171358820">
<figcaption aria-hidden="true">image-20240619171358820</figcaption>
</figure>
<p>可以看得出，静态调度的时候都是按顺序把块分配给相应的进程的</p>
<p><code>#pragma omp for schedule(guided)</code> 的含义是：</p>
<ol type="1">
<li><p>将 <code>for</code> 循环并行化。</p></li>
<li><p>使用指引调度策略。一开始的块很大，后面的块依次减小分给不同的线程。</p>
<p><img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240619172109430.png"></p>
<p><strong>Deferred Scheduling（延迟调度）</strong></p>
<ul>
<li>自动调度（Auto Scheduling）</li>
</ul>
<p>​ <strong>定义</strong>：程序员允许实现使用任何可能的映射方案。</p>
<ul>
<li>由运行时决定
<ul>
<li><code>runtime</code>：调度可以是上述调度类型之一（例如<code>static</code>或<code>dynamic</code>），具体由环境变量<code>OMP_SCHEDULE</code>设置，或者通过调用<code>omp_set_schedule()</code>覆盖环境设置。</li>
<li>可以通过调用<code>omp_get_schedule()</code>查找当前的活动调度。</li>
</ul></li>
</ul>
<p>例子：</p>
<p><strong>环境设置</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> OMP_SCHEDULE=<span class="string">&quot;guided,4&quot;</span></span><br><span class="line">./a.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>API调用</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp do schedule(runtime)</span></span><br><span class="line"><span class="function">call <span class="title">omp_set_schedule</span><span class="params">(omp_sched_dynamic,<span class="number">4</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>Collapsing Loop Nests（嵌套循环合并）</strong></p>
<p>将多个嵌套的循环合并成一个单一的迭代空间进行并行处理。</p>
<p>限制条件</p>
<ul>
<li><strong>迭代空间在进入循环时可计算</strong>：必须是矩形的迭代空间。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for collapse(2)</span></span><br><span class="line"><span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;kmax; ++k) </span><br><span class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;jmax; ++j)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>collapse(n)</strong>：参数n指定要合并的循环层次数量。</p>
<p><code>kmax=3, jmax=3</code>时，合并后的逻辑迭代空间如下：</p>
<figure>
<img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240620132537912.png" alt="image-20240620132537912">
<figcaption aria-hidden="true">image-20240620132537912</figcaption>
</figure>
<p>优化效果</p>
<ul>
<li><p><strong>可能改善内存局部性</strong>。</p></li>
<li><p><strong>可能减少核心之间的数据流量</strong>。</p></li>
<li><p><strong>嵌套循环合并适用于需要优化内存访问模式并减少数据传输开销的场景。</strong></p></li>
</ul>
<p>嵌套循环合并是优化并行执行的有效方法，尤其在需要处理复杂的嵌套循环结构时，通过将其转换为单一的迭代空间，可以改善内存局部性并提高执行效率。</p>
<h2 id="performance-tuning-the-nowait-clause性能调优nowait子句"><strong>Performance
Tuning: the nowait clause（性能调优：nowait子句）</strong></h2>
<p><code>nowait</code>子句用于消除隐式同步，从而提高性能。通常情况下，OpenMP的循环和其他并行结构在结束时会有隐式的同步点，<code>nowait</code>子句可以避免这种同步。</p>
<p><strong>使用场景</strong></p>
<ul>
<li>在并行区域内的多个循环中，如果不需要在每个循环结束时进行同步，可以使用<code>nowait</code>子句来提高性能。</li>
<li>特别适用于负载不平衡的情况，如果某些线程完成的时间明显早于其他线程，可以通过消除不必要的等待来优化性能。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> omp for nowait</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    A[i] = B[i] + C[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> omp for nowait</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    D[i] = E[i] * F[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="explicit-barrier-synchronization显式屏障同步">Explicit barrier
synchronization（显式屏障同步）</h2>
<h4 id="屏障指令">屏障指令</h4>
<ul>
<li>屏障构造是一个独立的指令，用于同步所有线程的执行流。</li>
<li>当每个线程到达屏障时，它们会阻塞，直到所有线程都到达屏障。</li>
</ul>
<h4 id="隐式屏障">隐式屏障</h4>
<ul>
<li>在某些指令中存在隐式屏障：
<ul>
<li>并行区域的开始和结束处。</li>
<li><code>do</code>、<code>single</code>、<code>sections</code>、<code>workshare</code>块的结束处（除非指定了<code>nowait</code>子句）。</li>
<li>执行团队中的所有线程都会在这些指令处同步。</li>
<li>这些隐式屏障使这些指令“易用且安全”。</li>
</ul></li>
</ul>
<p><strong>并行段</strong>是一个非迭代的工作共享构造，用于将一组结构化的代码块分配给线程团队中的不同线程执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> omp sections</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 代码块1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 代码块2</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="the-single-directive单线程指令">The Single
Directive（单线程指令）</h2>
<h3 id="定义">定义</h3>
<ul>
<li><code>single</code>指令指定代码块只由一个线程执行，所有其他线程等待该代码块执行完成。</li>
<li>常用于需要更新共享实体的操作。</li>
</ul>
<h3 id="允许的子句">允许的子句</h3>
<ul>
<li><code>private</code>：指定变量在每个线程中是私有的。</li>
<li><code>firstprivate</code>：指定变量在每个线程中是私有的，并且从主线程复制初始值。</li>
<li><code>copyprivate</code>：在<code>single</code>指令结束时，将执行线程的变量值复制到所有其他线程。</li>
<li><code>nowait</code>：消除隐式同步，使其他线程无需等待<code>single</code>块的执行完成</li>
</ul>
<h3 id="使用场景">使用场景</h3>
<ul>
<li><code>single</code>指令用于需要在并行区域中由一个线程执行的代码块，例如更新共享数据、文件I/O操作等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> s = …;</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> omp single copyprivate(s)</span></span><br><span class="line">  &#123;</span><br><span class="line">    s = …;</span><br><span class="line">  &#125;</span><br><span class="line">  … = … + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240620142640565.png"></p>
<p>在OpenMP中，<code>flush</code>
是一种同步机制，用于确保在并行执行中对共享变量的更新在各个线程之间可见。它的语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp flush(list)</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>list</code>
是一个可选的参数，用于指定需要刷新的共享变量列表。如果没有提供
<code>list</code>，则刷新所有共享变量。</p>
<p><code>flush</code> 指令通常与 <code>#pragma omp barrier</code>
或者其他同步指令一起使用，以确保线程在访问共享数据时的正确同步。</p>
<p>在使用 <code>flush</code>
时要小心，过度使用可能会导致性能下降，因为它会导致线程间的通信和同步。</p>
<h3 id="命名临界区named-critical">命名临界区（Named Critical）</h3>
<p>在多线程编程中，当多个线程同时访问和修改共享资源时，可能会引发竞态条件和数据不一致性问题。</p>
<p>使用临界区（critical
regions）可以确保一次只有一个线程执行临界区内的代码，从而避免竞态条件。</p>
<ul>
<li><p>使用命名临界区（Named
Critical），即通过给临界区命名，只对同名的临界区进行互斥操作。</p></li>
<li><p>这样做的好处是可以提高程序性能，因为只有同名的临界区会互斥，而不同名字的临界区不会互斥，从而减少了不必要的性能损失。</p></li>
</ul>
<h3 id="有序子句和指令ordered-clause-and-directive">有序子句和指令（Ordered
Clause and Directive）</h3>
<p>在并行循环中，有时需要按照顺序执行某些操作。这种情况下，可以使用有序子句和指令。</p>
<p>有序指令类似于单一指令，但它是针对循环体内的某些操作，使这些操作按照顺序执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for ordered</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; ++i) &#123;</span><br><span class="line">  O1</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> omp ordered</span></span><br><span class="line">  &#123; O2 &#125;</span><br><span class="line">  O3</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>O1</code> 是在所有线程中并行执行的操作。</p>
<p><code>O2</code>
是在有序区域中按顺序执行的操作，即所有线程在此处按顺序执行，而不是并行。</p>
<p><code>O3</code> 是在有序区域之外继续并行执行的操作。</p>
<p><img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240621094056777.png"></p>
<h3 id="使用锁实现互斥mutual-exclusion-with-locks">使用锁实现互斥（Mutual
Exclusion with Locks）</h3>
<p>共享锁变量可以用来实现特定的同步机制。</p>
<p>在 C/C++ 中，锁变量的类型为 <code>omp_lock_t</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">omp_lock_t</span> lock;</span><br><span class="line">    <span class="built_in">omp_init_lock</span>(&amp;lock);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">omp_test_lock</span>(&amp;lock)) &#123;</span><br><span class="line">            <span class="comment">// 在无法获取锁时执行其他工作</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thread %d doing other work\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 成功获取锁后，执行关键代码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d acquired the lock\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        <span class="built_in">omp_unset_lock</span>(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">omp_destroy_lock</span>(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>C/C++</strong>:
<code>omp_init_lock(omp_lock_t *var)</code></p>
<ul>
<li>作用：初始化一个锁，初始状态为未锁定。</li>
<li>注意：在调用此例程之前，锁变量不能与任何锁关联。</li>
</ul>
<h4 id="设置锁">设置锁</h4>
<ul>
<li><p>C/C++</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">omp_set_lock</span><span class="params">(<span class="type">omp_lock_t</span> *var)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>作用：如果锁可用，设置锁并继续执行；如果锁不可用，阻塞等待。</li>
</ul></li>
</ul>
<h4 id="解除锁">解除锁</h4>
<ul>
<li><p>C/C++</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">omp_unset_lock</span><span class="params">(<span class="type">omp_lock_t</span> *var)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>作用：解除对锁的所有权，允许其他线程获取锁。</li>
</ul></li>
</ul>
<h3 id="嵌套锁nestable-locks">嵌套锁（Nestable Locks）</h3>
<p>嵌套锁允许一个任务多次获取同一个锁，并在完成后需要相同次数的释放操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">omp_nest_lock_t</span> lock;</span><br><span class="line">    <span class="built_in">omp_init_nest_lock</span>(&amp;lock);  <span class="comment">// 初始化嵌套锁</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取嵌套锁</span></span><br><span class="line">        <span class="built_in">omp_set_nest_lock</span>(&amp;lock);</span><br><span class="line">        <span class="built_in">omp_set_nest_lock</span>(&amp;lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行关键代码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d acquired the nest lock twice\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放嵌套锁</span></span><br><span class="line">        <span class="built_in">omp_unset_nest_lock</span>(&amp;lock);</span><br><span class="line">        <span class="built_in">omp_unset_nest_lock</span>(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">omp_destroy_nest_lock</span>(&amp;lock);  <span class="comment">// 销毁嵌套锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="任务执行模型task-execution-model">任务执行模型（Task Execution
Model）</h3>
<p>任务执行模型支持非结构化并行性，例如无限循环和递归函数。多个线程可以创建和执行任务。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp single </span></span><br><span class="line"><span class="keyword">while</span> (elem != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp task</span></span><br><span class="line">    <span class="built_in">compute</span>(elem);</span><br><span class="line">    elem = elem-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240621124710815.png"></p>
<h4 id="任务的定义与作用">任务的定义与作用</h4>
<p>任务是 OpenMP
工作共享的一个更灵活的扩展，允许程序员将代码块和数据项打包为任务，然后将这些任务分配给线程进行执行。任务的主要特点包括：</p>
<p><strong>任务的生成</strong>：当一个线程遇到任务构造时，从关联的结构化代码块生成一个任务。</p>
<p><strong>数据环境的创建</strong>：根据数据共享属性和默认规则创建任务的数据环境。</p>
<p><strong>任务的执行</strong>：生成任务的线程可以立即执行任务，或者将其推迟到稍后执行。在后者情况下，团队中的任何线程都可以被分配执行该任务。</p>
<figure>
<img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240621130647583.png" alt="image-20240621130647583">
<figcaption aria-hidden="true">image-20240621130647583</figcaption>
</figure>
<p><strong>处理链表的函数 <code>process_list</code></strong>：</p>
<ul>
<li><p>创建并行区域：<code>#pragma omp parallel</code></p></li>
<li><p>单线程执行块：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp single</span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化指针 <code>p</code> 指向链表头。</p></li>
<li><p>使用 <code>while</code> 循环遍历链表。</p></li>
<li><p>对于每个节点，创建一个任务：</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp task firstprivate(p)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>do_work(p-&gt;data)</code>
处理当前节点的数据。</p></li>
<li><p>移动指针 <code>p</code> 到下一个节点。</p></li>
</ul>
<p><img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240621131418625.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> omp single</span></span><br><span class="line">      &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;t%d execute work1.\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> omp single</span></span><br><span class="line">      &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;t%d execute work2.\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> omp single nowait</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;t%d comes to end;.\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240621132540792.png"></p>
<p><code>nowait</code> 子句确实可以消除在某些 OpenMP
结构中的隐式同步，但在 <code>single</code>
结构中的作用可能并不像在其他结构（如 <code>for</code> 或
<code>sections</code>）中那样明显。</p>
<p>对于 <code>single</code> 结构，<code>nowait</code>
子句的效果应该是允许其他线程在不等待执行 <code>single</code>
代码块的线程完成其工作后，继续执行其他代码。</p>
<p>尽管 <code>nowait</code>
子句用于消除隐式同步，但在实际执行中，线程调度和前面的隐式同步点仍可能影响代码的执行顺序。这解释了为什么你观察到
<code>t2 comes to end;</code> 总是在最后执行。要验证 <code>nowait</code>
的效果，可以尝试在代码中加入更多的并行工作或调整代码结构，观察其对执行顺序的影响。</p>
<h3 id="任务同步与屏障task-synchronization-with-barrier-and-taskwait">任务同步与屏障（Task
Synchronization with Barrier and Taskwait）</h3>
<p><strong>屏障同步（Barrier Synchronization）</strong></p>
<p>在 OpenMP
中，屏障同步用于确保所有线程都达到某个同步点，然后才继续执行后续的代码。这在并行编程中非常重要，以保证所有线程在同步点之前的工作都已经完成。</p>
<p><code>#pragma omp barrier</code></p>
<p>当线程遇到 <code>barrier</code>
指令时，它会在此处等待，直到所有线程都到达屏障，然后所有线程才会继续执行。</p>
<p><strong>任务等待（Taskwait）</strong></p>
<p>任务等待指令用于等待当前任务的子任务完成。与屏障不同，任务等待只同步当前任务的直接子任务，不影响其他线程的执行。</p>
<p><code>#pragma omp taskwait</code></p>
<p>任务组允许创建一个包含多个任务的组，并提供一种方式来等待该组中的所有任务完成。任务组的语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp taskgroup</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 任务组中的任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240621230122377.png"></p>
<h4 id="taskyield-指令简介"><code>taskyield</code> 指令简介</h4>
<p><code>taskyield</code> 指令是 OpenMP
提供的一种机制，允许当前任务主动让出处理器，使得运行时系统可以调度和执行其他任务。这对于实现更好的负载均衡和资源利用非常有用，特别是在存在大量任务时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma omp taskyield</span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240621231710794.png"></p>
<h3 id="绑定任务tied-tasks">绑定任务（Tied Tasks）</h3>
<p>绑定任务是指任务与执行它的线程绑定在一起。一旦任务开始执行，它必须由同一个线程完成，不能由其他线程接手。</p>
<h4 id="特性">特性</h4>
<ol type="1">
<li><strong>任务线程绑定</strong>：任务创建后，始终由同一个线程执行，确保任务执行的顺序和连续性。</li>
<li><strong>性能优势</strong>：由于不需要在多个线程间切换，减少了上下文切换的开销。</li>
</ol>
<h3 id="非绑定任务untied-tasks">非绑定任务（Untied Tasks）</h3>
<p>非绑定任务允许任务在执行过程中切换线程。这意味着一个线程可以开始执行任务，而另一个线程可以完成任务。</p>
<p>数据环境（Data Environment）</p>
<p><strong>数据环境子句</strong>：</p>
<ul>
<li><strong>shared</strong>：显式声明变量为共享。</li>
<li><strong>private</strong>：显式声明变量为私有。</li>
<li><strong>firstprivate</strong>：声明变量为私有，并使用其初始值进行初始化。</li>
<li><strong>lastprivate</strong>：声明变量为私有，并在并行区域结束时将其值赋给原变量。</li>
<li><strong>reduction</strong>：对变量进行归约操作。</li>
</ul>
<figure>
<img src="/2024/04/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/openmp/image-20240521163518828-1718983010879-2.png" alt="image-20240521163518828">
<figcaption aria-hidden="true">image-20240521163518828</figcaption>
</figure>
]]></content>
      <categories>
        <category>并行处理</category>
      </categories>
      <tags>
        <tag>并行处理</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是并行计算</title>
    <url>/2024/03/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="并行并发">并行并发</h1>
<h2 id="并行和并发的区别">并行和并发的区别</h2>
<p><img src="/2024/03/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/image-20240315090639192.png"></p>
<ol type="1">
<li><strong>并行 (Parallelism)</strong>:
<ul>
<li>并行指的是同时执行多个操作，它们在同一时刻发生，可以是在多个处理单元（如多核处理器）上同时执行，也可以是在多台计算机上同时执行。</li>
<li>在并行中，多个任务被同时处理，它们的执行时间是重叠的。这意味着这些任务同时在不同的处理单元上进行，可以显著地提高整体性能。</li>
<li>典型的例子包括多线程并行执行、多进程并行执行以及分布式系统中的并行计算。</li>
</ul></li>
<li><strong>并发 (Concurrency)</strong>:
<ul>
<li>并发指的是在同一时间段内处理多个任务，但并不一定是同时执行。任务可能交替执行，每个任务在一段时间内执行一部分，然后切换到另一个任务继续执行。</li>
<li>在并发中，任务可能通过时间片轮转或事件驱动等方式交替执行，以便利用系统资源，同时让多个任务看起来好像是同时在运行。</li>
<li>典型的例子包括操作系统中的多任务处理、网络服务器同时处理多个客户端请求以及图形用户界面(GUI)程序中的事件处理。</li>
</ul></li>
</ol>
<h2 id="type-of-parallelism">Type of Parallelism</h2>
<h3 id="job-level-parallelism">Job Level Parallelism</h3>
<ol type="1">
<li><strong>Inter-Job Parallelism（任务间并行性）</strong>:
<ul>
<li>Inter-Job Parallelism 涉及多个独立任务或作业之间的并行执行。</li>
<li>在这种并行性中，每个任务都是独立的，彼此之间没有直接的依赖关系，因此可以同时执行。</li>
<li>典型的例子包括批处理系统中的并行作业，或者在云计算环境中同时运行的多个虚拟机实例。</li>
</ul></li>
<li><strong>Intra-Job Parallelism（任务内部并行性）</strong>:
<ul>
<li>Intra-Job Parallelism 指的是在单个任务或作业内部的并行执行。</li>
<li>在这种并行性中，一个单独的任务被分解为多个子任务，这些子任务可以并行执行以提高整体性能。</li>
<li>典型的例子包括在一个大型计算任务中使用多线程或多进程并行处理数据，或者使用向量化指令集来加速数值计算。</li>
</ul></li>
</ol>
<p><img src="/2024/03/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/image-20240315091006734.png"></p>
<h3 id="task-level">task level</h3>
<p>程序级别的并行</p>
<h3 id="thread-level">thread level</h3>
<p><img src="/2024/03/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/image-20240315091235831.png"></p>
<h3 id="instruction-level">instruction level</h3>
<ul>
<li>独立的指令运行在硬件上</li>
<li>假设：有多个硬件资源（ALU,Adder，MUltiplier，Loader,MAC
unit等）</li>
<li>例如指令流水线</li>
</ul>
<p><img src="/2024/03/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/image-20240315091621694.png"></p>
<h2 id="并行计算的原则">并行计算的原则</h2>
<ul>
<li>找到足够多的并行（Amdahl 定律）</li>
<li>粒度：每一个并行的任务应该有多大</li>
<li>Locality： 移动数据的开销比计算要大</li>
<li>负载均衡：不能让1k个处理器等一个慢的处理器</li>
<li>协调和同步：安全的共享数据</li>
</ul>
<p><img src="/2024/03/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/image-20240315093419606.png"></p>
<p>即使并行部分完全加速，性能也会受到串行部分的限制</p>
<p><img src="/2024/03/13/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/image-20240315093734079.png"></p>
<ul>
<li><p>大的内存很慢，快的内存很小</p></li>
<li><p>平均而言，存储层次结构大且快</p></li>
<li><p>并行处理器总体上具有大而快的cache</p></li>
<li><p>对“远程”数据的缓慢访问，我们称之为“通信”。</p></li>
</ul>
<p>​ 算法应该在本地数据上做大部分工作</p>
]]></content>
      <categories>
        <category>并行处理</category>
      </categories>
      <tags>
        <tag>并行处理</tag>
      </tags>
  </entry>
  <entry>
    <title>6.S081-Lab 1 Xv6 and Unix utilities实验笔记</title>
    <url>/2024/03/05/MIT6S081/6.S081-Lab%201%20Xv6%20and%20Unix%20utilities%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="绑定自己的仓库">绑定自己的仓库</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin  git://g.csail.mit.edu/xv6-labs-2021 (fetch)</span><br><span class="line">origin  git://g.csail.mit.edu/xv6-labs-2021 (push)</span><br></pre></td></tr></table></figure>
<p>使用<code>git remote remove</code>命令移除远程仓库的关联。请将`<code>替换为要移除的远程仓库的名称，一般为</code>origin`。</p>
<p>然后绑定自己的仓库：<code>git remote add origin git@github.com:sherecho/MyOS_Prj.git</code></p>
<h1 id="gdb-调试">gdb 调试</h1>
<p>设置.gdbinit 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">add-auto-load-safe-path /xv6-labs-2021/.gdbinit</span><br><span class="line">set confirm off</span><br><span class="line">set architecture riscv:rv64</span><br><span class="line">target remote 127.0.0.1:25000</span><br><span class="line">symbol-file kernel/kernel</span><br><span class="line">set disassemble-next-line auto</span><br><span class="line">set riscv use-compressed-breakpoints yes</span><br><span class="line">file user/_primes</span><br><span class="line">layout src</span><br><span class="line">b main</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>运行<code>make qemu-gdb</code></p>
<p>在另一个shell里面运行</p>
<p><code>gdb-multiarch -x .gdbinit</code></p>
<h1 id="primes">primes</h1>
<p>创建一系列的进程，父子进程之间通过管道进行通信，以此实现质数过滤的效果。第一个进程将2-35通过管道送入子进程，子进程打印第一个2，然后将管道中剩余数中能被2整除的<strong>丢弃</strong>，剩余的数通过管道送入它自己的子进程，如此递归。</p>
<figure>
<img src="/2024/03/05/MIT6S081/6.S081-Lab%201%20Xv6%20and%20Unix%20utilities%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/sieve.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>设计思路：</p>
<p>首先最初始的父进程负责将所有的数字通过管道协调如</p>
<p>子进程递归调用：每次从传入的管道段读取数值并过滤，然后将剩余的数通过管道传给下一个子进程</p>
<p>注意：读取管道时要关闭管道的输入端，管道输入端不关闭时，输出端使用
<code>read</code>读取时会阻塞不返回，程序就死在了某处。</p>
<p><img src="/2024/03/05/MIT6S081/6.S081-Lab%201%20Xv6%20and%20Unix%20utilities%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/image-20240307153742049.png"></p>
<p>程序代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file primes.c 创建一系列的管道，用于过滤质数，本题需要注意的是一定将不使用的管道端关闭，不然有些读操作会阻塞</span></span><br><span class="line"><span class="comment"> * @author sherecho (sherecho@163.com)</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2024-03-07</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2024</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">childproc</span><span class="params">(<span class="type">int</span> *p)</span>&#123;</span><br><span class="line">     <span class="type">int</span> num;  </span><br><span class="line">     <span class="type">int</span> ret;</span><br><span class="line">     <span class="comment">//没收到数说明过滤完了就退出</span></span><br><span class="line">     <span class="keyword">if</span>((ret=read(p[<span class="number">0</span>],&amp;num,<span class="keyword">sizeof</span>(<span class="type">int</span>)))!=<span class="keyword">sizeof</span>(<span class="type">int</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;program finished!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>,num);</span><br><span class="line">     <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line">     <span class="type">int</span> pr=pipe(p1);</span><br><span class="line">     <span class="keyword">if</span>(pr&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;pipe p1 err\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//close(p[0]);</span></span><br><span class="line">     <span class="comment">//过滤数并通过管道传输给子进程</span></span><br><span class="line">     <span class="type">int</span> pid;</span><br><span class="line">     <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork err\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        childproc(p1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//close(p[1]); //如果不注释这一句会发生write err1</span></span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> num2;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="keyword">while</span>((ret=read(p[<span class="number">0</span>],&amp;num2,<span class="keyword">sizeof</span>(<span class="type">int</span>)))==<span class="keyword">sizeof</span>(<span class="type">int</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(num2%num!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((ret=write(p1[<span class="number">1</span>],&amp;num2,<span class="keyword">sizeof</span>(<span class="type">int</span>)))!=<span class="keyword">sizeof</span>(<span class="type">int</span>))&#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write err1\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    pipe(p);</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid=fork())&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in child: %d\n&quot;</span>,getpid());</span><br><span class="line">        childproc(p);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">35</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(write(p[<span class="number">1</span>],&amp;i,<span class="keyword">sizeof</span>(<span class="type">int</span>))!=<span class="keyword">sizeof</span>(<span class="type">int</span>))&#123;</span><br><span class="line">             <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write err\n&quot;</span>);</span><br><span class="line">             <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//exit(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名管道通信">匿名管道通信</h3>
<p>在实验过程中，发现如果加入<code>close(p[1])</code>
见代码。会导致程序错误无法完成写管道操作。为了仔细分析一下产生这种情况的原因，首先分析管道的原理：</p>
<p>首先，因为进程之间具有独立性，一个进程是看不到另一个进程的资源的。</p>
<p><img src="/2024/03/05/MIT6S081/6.S081-Lab%201%20Xv6%20and%20Unix%20utilities%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/image-20240307151158784.png"></p>
<p>一个管道是半双工的，所以一般使用两个管道进行通信 <img src="/2024/03/05/MIT6S081/6.S081-Lab%201%20Xv6%20and%20Unix%20utilities%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/image-20240307151249290.png"></p>
<p><img src="/2024/03/05/MIT6S081/6.S081-Lab%201%20Xv6%20and%20Unix%20utilities%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/image-20240307151344237.png"></p>
<ol type="1">
<li><p>如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次
read 会返回0，就像读到文件末尾一样。</p></li>
<li><p>如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次
read 会阻塞，直到管道中有数据可读了才读取数据并返回。</p></li>
</ol>
<h3 id="通过gdb调试多进程分析错误原因">通过gdb调试多进程分析错误原因</h3>
<p>这里虽然是进程，但是实际上属于一种线程。可以用gdb info threads
查看线程并调试</p>
<p><img src="/2024/03/05/MIT6S081/6.S081-Lab%201%20Xv6%20and%20Unix%20utilities%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/image-20240307232516874.png"></p>
<p>调试的时候发现，不知道为啥p和p1的写管道描述符是一样的，所以关了p的话会存在问题</p>
<p>但是为啥会是一样的呢？这看起来不太合理。</p>
<h1 id="find">find</h1>
<p>这道题是要求实现一个简易版本的find命令，思路也是比较简单，递归的遍历目录中的子文件或子目录，可以参考<code>ls.c</code>文件来实现。需要注意细节问题，也就是关于<code>.</code>和<code>..</code>目录的处理，遍历遇到这两个目录时不要进去，不然会无穷递归。</p>
<p>首先，通过 <code>kernel/fs.h</code> 中的 <code>fstat</code>
可以读取路径信息，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(path, <span class="number">0</span>);     <span class="comment">// fd 作为文件标识符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span>             <span class="comment">// st 用来存储文件信息</span></span><br><span class="line">fstat(fd, &amp;st);             <span class="comment">// 读取文件信息存入 st</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (st.type == T_FILE) &#123;&#125;   <span class="comment">// 打开的是文件（按第一部操作使用当前路径判断）</span></span><br><span class="line"><span class="keyword">if</span> (st.type == T_DIR)  &#123;&#125;   <span class="comment">// 打开的是文件夹</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先看下fmtname是干啥的：</p>
<p><code>printf("buf:%s, fmtnamr(buf):%s %d %d %d\n", buf,fmtname(buf), st.type, st.ino, st.size);</code></p>
<p><img src="/2024/03/05/MIT6S081/6.S081-Lab%201%20Xv6%20and%20Unix%20utilities%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/image-20240308224226337.png"></p>
<p>可以看出，fmtname是把名字打印出来了。考虑修改fmtname是可能实现题目要求的</p>
<p>注意：<code>memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));</code>
是用空格填充了字符串，我们可以看出如果字符填充，调用fmtname可能会出现不等的情况如下图所示：</p>
<p><img src="/2024/03/05/MIT6S081/6.S081-Lab%201%20Xv6%20and%20Unix%20utilities%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/image-20240309001826046.png"></p>
<p>所以要改成<code>memset(buf+strlen(p), 0, DIRSIZ-strlen(p));</code>用结束符号填充</p>
<p>实验代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file find.c </span></span><br><span class="line"><span class="comment"> * @author sherecho(sherecho@163.com)</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2024-03-08</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2024</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="number">0</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">iffrec</span><span class="params">(<span class="type">char</span> * path)</span>&#123;</span><br><span class="line">  <span class="type">char</span> * buf;</span><br><span class="line">  buf=fmtname(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>]==<span class="string">&#x27;.&#x27;</span>&amp;&amp;buf[<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>]==<span class="string">&#x27;.&#x27;</span>&amp;&amp;buf[<span class="number">1</span>]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path,<span class="type">char</span> * target)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strcmp</span>(path,target)==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,path);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">  <span class="comment">// case T_FILE:</span></span><br><span class="line">  <span class="comment">//   //printf(&quot;path :%s ,fmtname(path),%s %d %d %l\n&quot;,path, fmtname(path), st.type, st.ino, st.size);</span></span><br><span class="line">  <span class="comment">//   break;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> T_DIR:</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">      <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      memmove(p, de.name, DIRSIZ);</span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(fmtname(buf),target)==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(iffrec(buf))&#123;</span><br><span class="line">        find(buf,target);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(argc==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error wrong input num\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(argc == <span class="number">2</span>)&#123;</span><br><span class="line">    find(<span class="string">&quot;.&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(argc==<span class="number">3</span>)&#123;</span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/05/MIT6S081/6.S081-Lab%201%20Xv6%20and%20Unix%20utilities%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/image-20240309003523368.png"></p>
<h1 id="xargs">xargs</h1>
<p>第一个命令的输出会变成第二个命令的输入</p>
<p>-n 表示遇到一个换行符执行一次命令，所以这里有两行，执行两次命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;1\n2&quot;</span> | xargs -n 1 <span class="built_in">echo</span> line</span><br><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>首先，如何获取前一个命令的标准化输出，如何获取自己的命令后参数。如何使用exec执行命令</p>
<p>在内部，xv6内核为每一个进程单独维护一个以文件描述符为索引的表，因此每个进程都有一个从0开始的文件描述符私有空间。按照约定，一个进程从文件描述符0(标准输入)读取数据，向文件描述符1(标准输出)写入输出，向文件描述符2(标准错误)写入错误信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 16</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    read(<span class="number">0</span>,buf,BUFSIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input:%s\n&quot;</span>,buf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;argc;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv: %c\n&quot;</span>,argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    exec(<span class="string">&quot;echo&quot;</span>,argv);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过将 <code>p</code> 赋值为 <code>buf</code>，<code>p</code>
就指向了缓冲区 <code>buf</code> 的首地址。这样，通过操作指针
<code>p</code>，可以对缓冲区进行读取、写入等操作。</p>
<p>在这段代码中，<code>p</code>
的作用是用于处理从标准输入读取的一行字符串。通过不断地移动
<code>p</code>，可以逐个字符地处理输入的字符串，直到遇到换行符，表示读取完一行。在处理完一行后，通过将
<code>p</code> 重新指向 <code>buf</code>
的起始位置，准备处理下一行。这样循环处理，达到逐行处理输入的效果。</p>
<p>解题代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file xargs.c UNIX xargs 的简易实现</span></span><br><span class="line"><span class="comment"> * @author sherecho (sherecho@163.com)</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2024-03-09</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2024</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: xargs command\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* args[MAXARG+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;argc; ++i) &#123;</span><br><span class="line">        args[index++] = argv[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">char</span> *p = buf;</span><br><span class="line">    <span class="keyword">while</span> (read(<span class="number">0</span>, p, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*p) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            *p = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> pid;</span><br><span class="line">            <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// child</span></span><br><span class="line">                <span class="comment">// exec only one arg</span></span><br><span class="line">                args[index] = buf;</span><br><span class="line">                exec(argv[<span class="number">1</span>], args);</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;exec %s failed\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// parent</span></span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            p = buf;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>编译和链接</title>
    <url>/2024/02/28/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="编译和链接">编译和链接</h1>
<h3 id="基本流程">基本流程</h3>
<p>当我们 Build
一个项目的时候，一般分为四个步骤：<strong>预处理</strong>，<strong>编译</strong>，<strong>汇编</strong>，<strong>链接</strong></p>
<p><img src="/2024/02/28/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/cxy_5.png"></p>
<p>预编译：主要处理以#开头的预编译指令</p>
<p>编译：进行词法分析，语法分析和优化生成汇编代码文件</p>
<p>GCC将预编译和编译合成了一个步骤使用cc1程序完成，c++使用cc1plus完成</p>
<p>汇编：汇编指令转换为机器指令，gcc使用汇编器as完成</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>队列栈总结</title>
    <url>/2024/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E9%98%9F%E5%88%97%E6%A0%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="用栈实现其它数据结构或者函数">用栈实现其它数据结构或者函数</h1>
<h2 id="用栈实现队列">用栈实现队列</h2>
<h3 id="描述">描述</h3>
<p>用两个栈来实现一个队列，使用n个元素来完成 n
次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。
队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</p>
<p>数据范围： n*≤1000</p>
<p>要求：存储n个元素的空间复杂度为 O<em>(</em>n<em>)
，插入与删除的时间复杂度都是 O</em>(1)</p>
<h3 id="解题思路">解题思路</h3>
<p>借助栈的<strong>先进后出</strong>规则模拟实现队列的<strong>先进先出</strong></p>
<p><strong>1、</strong>当插入时，直接插入 stack1</p>
<p>2、当弹出时，当 stack2 不为空，弹出 stack2 栈顶元素，如果 stack2
为空，将 stack1 中的全部数逐个出栈入栈 stack2，再弹出 stack2
栈顶元素</p>
<p>注意一定要将2用空再将1的倒入并且是全部倒入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        stack1.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(stack2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">          <span class="keyword">while</span>(!stack1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">            stack1.<span class="built_in">pop</span>();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> ret=stack2.<span class="built_in">top</span>();</span><br><span class="line">       stack2.<span class="built_in">pop</span>();</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析：</h3>
<p>时间复杂度：对于插入和删除操作，时间复杂度均为
O(1)。插入不多说，对于删除操作，虽然看起来是O(n)
的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 stack2
一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)。</p>
<p>空间复杂度O(N)：辅助栈的空间，最差的情况下两个栈共存储N个元素</p>
<h2 id="用栈实现min函数">用栈实现min函数</h2>
<p><img src="/2024/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E9%98%9F%E5%88%97%E6%A0%88%E6%80%BB%E7%BB%93/image-20240126120312200.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stackdata.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            mindata=value;</span><br><span class="line">            stackmin.<span class="built_in">push</span>(mindata);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//这里注意要加=</span></span><br><span class="line">         <span class="keyword">if</span>(mindata&gt;=value)&#123;          </span><br><span class="line">            mindata=value;</span><br><span class="line">            stackmin.<span class="built_in">push</span>(mindata);</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stackdata.<span class="built_in">push</span>(value);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> top=stackdata.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(top==mindata)&#123;</span><br><span class="line">            stackmin.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!stackmin.<span class="built_in">empty</span>())</span><br><span class="line">              mindata=stackmin.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">               mindata=INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        stackdata.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> stackdata.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mindata;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> stack&lt;<span class="type">int</span>&gt; stackdata;</span><br><span class="line"> stack&lt;<span class="type">int</span>&gt; stackmin;</span><br><span class="line"> <span class="type">int</span> mindata;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="栈压入弹出序列">栈压入弹出序列</h1>
<h2 id="jz31-栈的压入弹出序列"><strong>JZ31</strong>
<strong>栈的压入、弹出序列</strong></h2>
<h3 id="思路">思路</h3>
<p>题目要我们判断两个序列是否符合入栈出栈的次序，我们就可以用一个栈来模拟。对于入栈序列，只要栈为空，序列肯定要依次入栈。那什么时候出来呢？自然是遇到一个元素等于当前的出栈序列的元素，那我们就放弃入栈，让它先出来。如果能按照这个次序将两个序列都访问完，那说明是可以匹配入栈出栈次序的。</p>
<p><img src="/2024/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E9%98%9F%E5%88%97%E6%A0%88%E6%80%BB%E7%BB%93/image-20240127161813796.png"></p>
<h3 id="代码">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param pushV int整型vector </span></span><br><span class="line"><span class="comment">     * @param popV int整型vector </span></span><br><span class="line"><span class="comment">     * @return bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsPopOrder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushV, vector&lt;<span class="type">int</span>&gt;&amp; popV)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">       stack &lt;<span class="type">int</span>&gt; mystack1;</span><br><span class="line">       <span class="comment">//stack&lt;int&gt; mystack2;</span></span><br><span class="line">       <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pushV.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">           mystack1.<span class="built_in">push</span>(pushV[i]);</span><br><span class="line">          <span class="keyword">while</span>(!mystack1.<span class="built_in">empty</span>()&amp;&amp;j&lt;popV.<span class="built_in">size</span>()&amp;&amp;mystack1.<span class="built_in">top</span>()==popV[j])&#123;</span><br><span class="line">            mystack1.<span class="built_in">pop</span>();</span><br><span class="line">            j++;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (!mystack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">             <span class="type">int</span> tmp=mystack1.<span class="built_in">top</span>();</span><br><span class="line">             mystack1.<span class="built_in">pop</span>();</span><br><span class="line">             <span class="keyword">if</span>(tmp!=popV[j])</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">             j++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(j!=popV.<span class="built_in">size</span>())</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="翻转单词">翻转单词</h3>
<p><img src="/2024/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E9%98%9F%E5%88%97%E6%A0%88%E6%80%BB%E7%BB%93/image-20240127221525510.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">ReverseSentence</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        stack&lt;string&gt; mystack;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">          <span class="type">int</span> j=i;</span><br><span class="line">          <span class="keyword">while</span>(j&lt;str.<span class="built_in">size</span>()&amp;&amp;str[j]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            j++;</span><br><span class="line">          mystack.<span class="built_in">push</span>(str.<span class="built_in">substr</span>(i,j-i));</span><br><span class="line">          i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        string strret=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!mystack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            strret+=mystack.<span class="built_in">top</span>();</span><br><span class="line">            mystack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!mystack.<span class="built_in">empty</span>())</span><br><span class="line">                strret += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/24/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Untitled/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>树专题总结</title>
    <url>/2024/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E6%A0%91%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="二叉搜索树">二叉搜索树</h1>
<p>二叉搜索树的中序遍历是有序的。</p>
<h2 id="中序遍历的利用">中序遍历的利用</h2>
<h3 id="jz36-二叉搜索树与双向链表"><strong>JZ36</strong>
<strong>二叉搜索树与双向链表</strong></h3>
<p>充分利用中序遍历的有序性构造有序的双向链表。</p>
<p><img src="/2024/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E6%A0%91%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/image-20240123164130362.png"></p>
<p>改造原始的中序遍历，避免构造额外的空间。核心的逻辑是：左中右中，中的前驱是左，后继是右子树。所以可以使用一共pre指针指向左节点，然后root的left指向pre，pre的right指向root。pre更新到root，pre设置为全局的变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *  pre;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(pRootOfTree==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        pre=<span class="literal">nullptr</span>;</span><br><span class="line">		<span class="comment">//找到头节点</span></span><br><span class="line">		TreeNode * ret;</span><br><span class="line">		ret=pRootOfTree;</span><br><span class="line">		<span class="keyword">while</span>(ret-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ret=ret-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">inorder</span>(pRootOfTree);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode * root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">			<span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//中序处理环节</span></span><br><span class="line">		root-&gt;left=pre;</span><br><span class="line">		<span class="keyword">if</span>(pre!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">			pre-&gt;right=root;</span><br><span class="line">		&#125;</span><br><span class="line">        pre=root;</span><br><span class="line">		<span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">			<span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="jz8-二叉树的下一个结点"><strong>JZ8</strong>
<strong>二叉树的下一个结点</strong></h3>
<p>描述：</p>
<p>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针</p>
<p>要求：**空间复杂度 O*(1) **，时间复杂度 <em>O</em>(<em>n</em>)</p>
<p>分析可能存在的三种情况：</p>
<ol type="1">
<li>如果给出的结点有右子节点，则最终要返回的下一个结点即右子树的最左下的结点</li>
<li>如果给出的结点无右子节点，且当前结点是其父节点的左子节点，则返回其父节点</li>
<li>如果给出的结点无右子节点，且当前结点是其父节点的右子节点，则先要沿着左上方父节点爬树，一直爬到当前结点是其父节点的左子节点为止，返回的就是这个父节点；或者没有满足上述情况的则返回为NULL</li>
</ol>
<p><img src="/2024/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E6%A0%91%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/image-20240123184817662.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *right;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *next;</span></span><br><span class="line"><span class="comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode==<span class="literal">nullptr</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//情况1</span></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">           TreeLinkNode* cur=pNode-&gt;right;</span><br><span class="line">           TreeLinkNode* pre=cur;</span><br><span class="line">           <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur-&gt;left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//情况2</span></span><br><span class="line">       <span class="keyword">if</span>(pNode-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">       <span class="keyword">if</span>(pNode-&gt;next-&gt;left==pNode)&#123;</span><br><span class="line">          <span class="keyword">return</span> pNode-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//情况3</span></span><br><span class="line">       TreeLinkNode* cur=pNode;</span><br><span class="line">       <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>&amp;&amp;(cur!=cur-&gt;next-&gt;left))&#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(cur==cur-&gt;next-&gt;left)</span><br><span class="line">       <span class="keyword">return</span> cur-&gt;next;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="利用搜索二叉树的有序性">利用搜索二叉树的有序性</h2>
<h3 id="jz68-二叉搜索树的最近公共祖先"><strong>JZ68</strong>
<strong>二叉搜索树的最近公共祖先</strong></h3>
<p><img src="/2024/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E6%A0%91%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/image-20240124170733878.png"></p>
<p>解答：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *	struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        queue&lt;TreeNode *&gt;myqueue;</span><br><span class="line">        myqueue.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> rettmp;</span><br><span class="line">        <span class="type">int</span> minnum=<span class="built_in">min</span>(p,q);</span><br><span class="line">        <span class="type">int</span> maxnum=<span class="built_in">max</span>(p,q);</span><br><span class="line">        TreeNode *cur=root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span>(maxnum&lt;cur-&gt;val)</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span>(minnum&gt;cur-&gt;val)</span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;val&gt;=minnum&amp;&amp;cur-&gt;val&lt;=maxnum)&#123;</span><br><span class="line">                  rettmp=cur-&gt;val;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;          </span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rettmp;</span><br><span class="line">     </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="jz86-在二叉树中找到两个节点的最近公共祖先"><strong>JZ86</strong>
<strong>在二叉树中找到两个节点的最近公共祖先</strong></h3>
<p>递归思路：</p>
<p>分析遍历到任意的一个结点（之前没有找到过那两个结点），可能的情况分为四类：</p>
<ul>
<li>该结点和要找的任意一个值相等---》返回该节点</li>
</ul>
<p><img src="/2024/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E6%A0%91%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/image-20240124182843151.png"></p>
<ul>
<li>该节点的左树上没找到目标节点---》说明结果在右子树上，继续遍历右子树</li>
<li>该节点的右树上没找到目标节点---》说明结果在左子树上，继续遍历左子树</li>
<li>该节点的左树上找到了目标节点，右边也找到了节点---》返回该节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *	struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        TreeNode * ret=<span class="built_in">subtask</span>(root,o1,o2);</span><br><span class="line">        <span class="keyword">return</span> ret-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode * <span class="title">subtask</span><span class="params">(TreeNode* root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(root==<span class="literal">nullptr</span>||root-&gt;val==o1||root-&gt;val==o2)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">         &#125;</span><br><span class="line">         TreeNode *left=<span class="built_in">subtask</span>(root-&gt;left,  o1,  o2);</span><br><span class="line">         TreeNode  * right=<span class="built_in">subtask</span>(root-&gt;right,o1,o2);</span><br><span class="line">         <span class="keyword">if</span>(left==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题还可以使用hashmap和hashset暴力求解（思路比较简单此处不做陈述）</p>
<p>这种用hashmap记录的一条可以反向回去的链条的方法也是比较经典值得思考的。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">       </span><br><span class="line">         unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mymap;</span><br><span class="line">         mymap[root-&gt;val]=<span class="number">-1</span>;</span><br><span class="line">         queue&lt;TreeNode *&gt;myqueue;</span><br><span class="line">         myqueue.<span class="built_in">push</span>(root);</span><br><span class="line">         TreeNode * cur;</span><br><span class="line">         <span class="keyword">while</span>(!myqueue.<span class="built_in">empty</span>()&amp;&amp;(mymap.<span class="built_in">find</span>(o1)==mymap.<span class="built_in">end</span>()||mymap.<span class="built_in">find</span>(o2)==mymap.<span class="built_in">end</span>()))&#123;</span><br><span class="line">               cur=myqueue.<span class="built_in">front</span>();</span><br><span class="line">              myqueue.<span class="built_in">pop</span>();</span><br><span class="line">              <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                 mymap[cur-&gt;left-&gt;val]=cur-&gt;val;</span><br><span class="line">                 myqueue.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                mymap[cur-&gt;right-&gt;val]=cur-&gt;val;</span><br><span class="line">                myqueue.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">              &#125;                        </span><br><span class="line">         &#125;</span><br><span class="line">         unordered_set&lt;<span class="type">int</span>&gt; ancestor;</span><br><span class="line">         <span class="comment">//ancestor.insert(o1);</span></span><br><span class="line">         <span class="type">int</span> curnum=o1;</span><br><span class="line">         <span class="keyword">while</span>(mymap.<span class="built_in">find</span>(curnum)!=mymap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            ancestor.<span class="built_in">insert</span>(curnum);</span><br><span class="line">            curnum=mymap[curnum];            </span><br><span class="line">         &#125;</span><br><span class="line">         curnum=o2;</span><br><span class="line">         <span class="keyword">while</span>(ancestor.<span class="built_in">find</span>(curnum)==ancestor.<span class="built_in">end</span>())&#123;</span><br><span class="line">              curnum=mymap[curnum];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> curnum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="利用层次遍历">利用层次遍历</h1>
<h2 id="jz28-对称的二叉树"><strong>JZ28</strong>
<strong>对称的二叉树</strong></h2>
<p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）</p>
<p>对称的二叉树每一层都是回文的情况。那我们从左往右遍历一层（包括空节点），和从右往左遍历一层（包括空节点），应该得到相同的结果。而且我们不需要两个层次遍历都完整地遍历二叉树，只需要一半就行了，从左往右遍历左子树，从右往左遍历右子树，各自遍历一半相互比对，因为遍历到另一半都已经检查过了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *	struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param pRoot TreeNode类 </span></span><br><span class="line"><span class="comment">     * @return bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        queue&lt;TreeNode*&gt; myqueue1,myqueue2;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        myqueue1.<span class="built_in">push</span>(pRoot-&gt;left);</span><br><span class="line">        myqueue2.<span class="built_in">push</span>(pRoot-&gt;right);</span><br><span class="line">        <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> numnew=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!myqueue1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(myqueue2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            num--;</span><br><span class="line">            TreeNode * cur1=myqueue1.<span class="built_in">front</span>();</span><br><span class="line">            TreeNode * cur2=myqueue2.<span class="built_in">front</span>();</span><br><span class="line">            myqueue1.<span class="built_in">pop</span>();</span><br><span class="line">            myqueue2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(cur1==<span class="literal">nullptr</span>&amp;&amp;cur2==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((cur1==<span class="literal">nullptr</span>&amp;&amp;cur2!=<span class="literal">nullptr</span>)||(cur1!=<span class="literal">nullptr</span>&amp;&amp;cur2==<span class="literal">nullptr</span>))</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur1-&gt;val!=cur2-&gt;val)</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur1-&gt;left!=<span class="literal">nullptr</span>&amp;&amp;cur2-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">              myqueue1.<span class="built_in">push</span>(cur1-&gt;left);</span><br><span class="line">              myqueue2.<span class="built_in">push</span>(cur2-&gt;right);</span><br><span class="line">              numnew++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(cur2-&gt;left!=<span class="literal">nullptr</span>&amp;&amp;cur1-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">              myqueue2.<span class="built_in">push</span>(cur2-&gt;left);</span><br><span class="line">              myqueue1.<span class="built_in">push</span>(cur1-&gt;right);</span><br><span class="line">              numnew++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>((cur2-&gt;left==<span class="literal">nullptr</span>&amp;&amp;cur1-&gt;right!=<span class="literal">nullptr</span>)||(cur2-&gt;left!=<span class="literal">nullptr</span>&amp;&amp;cur1-&gt;right==<span class="literal">nullptr</span>)||(cur1-&gt;left==<span class="literal">nullptr</span>&amp;&amp;cur2-&gt;right!=<span class="literal">nullptr</span>)|| </span><br><span class="line">            ( cur1-&gt;left!=<span class="literal">nullptr</span>&amp;&amp;cur2-&gt;right==<span class="literal">nullptr</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num=numnew;</span><br><span class="line">            numnew=<span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="路径和问题">路径和问题</h1>
<h2 id="jz82-二叉树中和为某一值的路径一">JZ82
二叉树中和为某一值的路径(一)</h2>
<p>只判断路径是否存在的：</p>
<p><img src="/2024/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E6%A0%91%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/image-20240124203025531.png"></p>
<p>使用简单的递归就可以解决：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param root TreeNode类 </span></span><br><span class="line"><span class="comment">     * @param sum int整型 </span></span><br><span class="line"><span class="comment">     * @return bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">subtask</span>(root,sum);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">subtask</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum-root-&gt;val==<span class="number">0</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试左边路径</span></span><br><span class="line">       <span class="type">bool</span> lefttry=<span class="literal">false</span>;</span><br><span class="line">       <span class="type">bool</span> righttry=<span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">         lefttry=<span class="built_in">subtask</span>(root-&gt;left,  sum-root-&gt;val);</span><br><span class="line">        <span class="comment">//尝试右边路径</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">          righttry=<span class="built_in">subtask</span>(root-&gt;right,  sum-root-&gt;val);</span><br><span class="line">       <span class="keyword">return</span> lefttry||righttry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="jz34-二叉树中和为某一值的路径二"><strong>JZ34</strong>
<strong>二叉树中和为某一值的路径(二)</strong></h2>
<p>进阶版本，需要给出所有的路径，需要用深度优先搜索有恢复现场的步骤</p>
<p>这个在DFS深度优先搜索博文中介绍过，如下链接：</p>
<p><a href="https://sherecho.cn/2024/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">解析博客</a></p>
<h2 id="jz84-二叉树中和为某一值的路径三"><strong>JZ84</strong>
<strong>二叉树中和为某一值的路径(三)</strong></h2>
<p>不再限制是不是从根节点到叶子节点的路径。要计算路径的数量</p>
<p><img src="/2024/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E6%A0%91%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/image-20240124203947938.png"></p>
<p>感觉有点动态规划的意思，不过这里不用改成动态规划，用递归解决即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *	struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param root TreeNode类 </span></span><br><span class="line"><span class="comment">     * @param sum int整型 </span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        ret+=<span class="built_in">subtask</span>(root,  sum);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">           ret+=<span class="built_in">FindPath</span>(root-&gt;right,sum);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">          ret+=<span class="built_in">FindPath</span>(root-&gt;left,sum);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subtask</span><span class="params">(TreeNode * root ,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面注释掉的写法是错的，因为这里的值是存在负数的，</span></span><br><span class="line">        <span class="comment">//因此不能用等于0来作为结束标志了。就算等于负数也是有可能的    </span></span><br><span class="line">        <span class="comment">// if(target==0)&#123;</span></span><br><span class="line">        <span class="comment">//     return 1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr&amp;&amp;target!=0)&#123;</span></span><br><span class="line">        <span class="comment">//     return 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//这里也不能只是返回0</span></span><br><span class="line">        target-=root-&gt;val;   </span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">           ret++;       </span><br><span class="line">          ret+=<span class="built_in">subtask</span>(root-&gt;right,target);       </span><br><span class="line">          ret+=<span class="built_in">subtask</span>(root-&gt;left,target);  </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS深度优先搜索</title>
    <url>/2024/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="dfs深度优先搜索">DFS深度优先搜索</h1>
<p>深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search.</p>
<p>深度优先搜索一般用于树或者图的遍历，其他有分支的（如二维矩阵）也适用。它的原理是从初始点开始，一直沿着同一个分支遍历，直到该分支结束，然后回溯到上一级继续沿着一个分支走到底，如此往复，直到所有的节点都有被访问到。</p>
<h2 id="基本思路">基本思路</h2>
<p>深度优先遍历图的方法是，从图中某顶点v出发：</p>
<p>（1）访问顶点v；
（2）依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；
（3）若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。　</p>
<h2 id="解决-jz34-二叉树中和为某一值的路径二">解决 <strong>JZ34</strong>
<strong>二叉树中和为某一值的路径(二)</strong></h2>
<p><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;tqId=23276&amp;ru=/exam/oj/ta&amp;qru=/ta/coding-interviews/question-ranking&amp;sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D13%26type%3D13">题目链接</a></p>
<p><img src="/2024/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/image-20240122115402956.png"></p>
<p>根节点开始向左右子树进行递归，由于要返回具体的路径，递归函数中需要处理的是：</p>
<ol type="1">
<li>当前的路径<code>path</code>要更新</li>
<li>当前的目标值<code>expectNumber</code>要迭代，减去当前节点的值</li>
<li>若当前节点是叶子节点，考虑是否满足路径的期待值，并考虑是否将路径添加到返回列表中（和之前二叉树中和为某一值的路径(一)不同需要加入返回列表）</li>
</ol>
<p>tips：下面回溯与之前一般的分治解决问题的区别在于，使用了全局变量保留路径(当然也可以借助传引用保留，主要是要跨递归不能是局部变量）。且会有清理全局变量即清理现场的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *	struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param root TreeNode类 </span></span><br><span class="line"><span class="comment">     * @param target int整型 </span></span><br><span class="line"><span class="comment">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">FindPath</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">         vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; ret;</span><br><span class="line">         <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">             <span class="keyword">return</span> ret;</span><br><span class="line">         <span class="built_in">dfs</span>(ret,root,target);</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;retpaths,TreeNode* root, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否满足要求</span></span><br><span class="line">        target-=root-&gt;val;</span><br><span class="line">        path.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">         <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>&amp;&amp; target==<span class="number">0</span>)&#123;</span><br><span class="line">            retpaths.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="comment">//return; 这里不能return不然后面就没法path pop掉这一层的结点。也可以在上面加一个pathpopback然后再return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(retpaths,root-&gt;left,target);</span><br><span class="line">         <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(retpaths,root-&gt;right,target);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分治法总结</title>
    <url>/2024/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E5%88%86%E6%B2%BB%E6%B3%95%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="分治法总结">分治法总结</h1>
<h2 id="什么是分治算法">什么是分治算法</h2>
<p>分治算法（divide and conquer）的核心思想其实就是四个字，分而治之
，也就是将原问题划分成 <code>k</code>
个规模较小，并且结构与原问题相似的子问题，<strong>递归</strong>
地解决这些子问题，然后再合并其结果，就得到原问题的解。</p>
<p>关于分治和递归的区别：</p>
<ul>
<li>分治算法是一种处理问题的思想;</li>
<li>递归是一种编程技巧。</li>
</ul>
<p>比较经典的应用就是归并排序（Merge Sort)以及 快速排序（Quick
Sort)。</p>
<h2 id="算法特征">算法特征</h2>
<p>分治所能解决的问题一般具有以下几个特征：</p>
<ol type="1">
<li>该问题的规模缩小到一定的程度 <strong>可以直接求解</strong></li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有
<strong>最优子结构性质</strong></li>
<li>利用该问题分解出的子问题的解 <strong>可以合并</strong>
为该问题的解</li>
<li>该问题所分解出的各个子问题是相互独立的，即
<strong>子问题之间不包含公共的子问题</strong></li>
</ol>
<p>说明：</p>
<ol type="1">
<li>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</li>
<li>第二条特征是应用分治算法的前提，他也是大多数问题可以满足的，此特征反映了
<strong>递归思想</strong> 的引用；</li>
<li><strong>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心算法或动态规划法</strong>；</li>
<li>第四条特征涉及到
<strong>分治的效率</strong>，如果各子问题是不独立的，则分治要做许多不必要的工作，重复地解公共的子问题，此时虽然也可用分治，但
<strong>一般用动态规划较好</strong>。</li>
</ol>
<h2 id="设计思路">设计思路</h2>
<p>设计过程分为三个步骤：</p>
<p>实际上，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p>
<ul>
<li><strong>拆分 Divide</strong>：将原问题拆分成若干个子问题；</li>
<li><strong>解决
Conquer</strong>：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题；</li>
<li><strong>合并
Merge</strong>：将各个子问题的解合并，形成原问题的解。</li>
</ul>
<p>分治的执行步骤可以分为三个阶段，即划分数据阶段、递归处理阶段和综合合并阶段。有些问题的划分阶段时间费用较多，有些问题则合并阶段的时间费用较多。</p>
<h2 id="用分治解决-jz33-二叉搜索树的后序遍历序列-问题">用分治解决：
<strong>JZ33</strong> <strong>二叉搜索树的后序遍历序列</strong>
问题</h2>
<p><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=23289&amp;ru=/exam/oj/ta&amp;qru=/ta/coding-interviews/question-ranking&amp;sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D13%26type%3D13">题目链接</a></p>
<p>题目：</p>
<p><img src="/2024/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E5%88%86%E6%B2%BB%E6%B3%95%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/image-20240121224234784.png"></p>
<p>分治法解决思路：</p>
<p>后序遍历顺序是左右根。所以一个要判断的数组的最后一个肯定是根。按照搜索树的性质可以找到比根小的结点：左子树。以及比根大的结点：右子树。问题就拆分成了判断左子树是否满足bst，以及判断右子树是否满足bst。最窄merge的条件是左子树是bst且右子树是bst。</p>
<p>解题代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> ret=<span class="built_in">versubtask</span>(sequence, <span class="number">0</span>, sequence.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">versubtask</span><span class="params">(vector&lt;<span class="type">int</span>&gt; sequence,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;         </span><br><span class="line">         <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="type">int</span> rootval=sequence[right];</span><br><span class="line">         <span class="type">int</span> leftnew1=left;</span><br><span class="line">         <span class="type">int</span> rightnew1=left;</span><br><span class="line">         <span class="keyword">while</span>(rightnew1&lt;right&amp;&amp;sequence[rightnew1]&lt;rootval)&#123;</span><br><span class="line">            rightnew1++;</span><br><span class="line">         &#125;    </span><br><span class="line">         rightnew1=rightnew1<span class="number">-1</span>;<span class="comment">//重要</span></span><br><span class="line">         </span><br><span class="line">         <span class="type">int</span> leftnew2=rightnew1+<span class="number">1</span>;</span><br><span class="line">         <span class="type">bool</span> rightdata;</span><br><span class="line">         <span class="comment">//**重要** 检查右子树是否存在小于root的结点</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=leftnew2;i&lt;right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence[i]&lt;rootval)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;      </span><br><span class="line">         <span class="type">bool</span> leftdata=<span class="built_in">versubtask</span>(sequence,leftnew1,rightnew1);</span><br><span class="line">         <span class="comment">//当右子树满足都大于根的条件时检查右子树是否是bst</span></span><br><span class="line">         <span class="keyword">if</span>(leftnew2&lt;right)&#123;</span><br><span class="line">             <span class="type">int</span> rightnew2=right<span class="number">-1</span>;</span><br><span class="line">             rightdata=<span class="built_in">versubtask</span>(sequence,leftnew2,rightnew2);  </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">         &#123;</span><br><span class="line">           rightdata=<span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> leftdata&amp;&amp;rightdata;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径算法对比-Dijkstra-bellman-floyd</title>
    <url>/2024/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94-Dijkstra-bellman-floyd/</url>
    <content><![CDATA[<h1 id="最短路径算法对比-dijkstra-bellman-floyd">最短路径算法对比-Dijkstra-bellman-floyd</h1>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径算法对比-Dijkstra-bellman-floyd</title>
    <url>/2024/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B7%A6/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h1 id="最短路径算法对比-dijkstra-bellman-floyd">最短路径算法对比-Dijkstra-bellman-floyd</h1>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>自旋锁的实现</title>
    <url>/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%97%8B%E9%94%81%E5%9C%A8MIPS%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="自旋锁的实现">自旋锁的实现</h1>
<h2 id="mips中llsc指令介绍">MIPS中LL/SC指令介绍</h2>
<p>在多线程程序中，为了实现对共享变量的互斥访问，一般都会用spinlock实现，而spinlock需要一个TestAndSet的原子操作。而这种原子操作是需要专门的硬件支持才能完成的，在MIPS中，是通过特殊的Load，Store操作LL（Load
Linked，链接加载）以及SC（Store Conditional，条件存储）完成的。</p>
<blockquote>
<p>LL 指令的功能是从内存中读取一个字</p>
<p>SC 指令的功能是向内存中写入一个字</p>
</blockquote>
<p>LL/SC
指令的独特之处在于，它们不是一个简单的内存读取/写入的函数，当使用 LL
指令从内存中读取一个字之后，比如 LL d, off(b)，处理器会记住 LL
指令的这次操作（会在 CPU 的寄存器中设置一个不可见的 bit 位），同时 LL
指令读取的地址 off(b) 也会保存在处理器的寄存器中。接下来的 SC 指令，比如
SC t, off(b)，会检查上次 LL 指令执行后的 RMW
操作是否是原子操作（即不存在其它对这个地址的操作），如果是原子操作，则 t
的值将会被更新至内存中，同时 t 的值也会变为1，表示操作成功；反之，如果
RMW 的操作不是原子操作（即存在其它对这个地址的访问冲突），则 t
的值不会被更新至内存中，且 t 的值也会变为0，表示操作失败。</p>
<p>SC 指令执行失败的原因有两种：</p>
<ul>
<li>在 LL/SC
操作序列的过程中，发生了一个异常（或中断），这些异常（或中断）可能会打乱
RMW 操作的原子性。</li>
<li>在多核处理器中，一个核在进行 RMW
操作时，别的核试图对同样的地址也进行操作，这会导致 SC
指令执行的失败。</li>
</ul>
<p><strong>简单的应用例子：</strong></p>
<p>用MIPS
LL/SC指令实现从内存单元100（R2)取数，把取出来的数加100并存回到100（R2)中的原子操作代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1:  LL R3,100(R2)</span><br><span class="line">     ADDI R3,R3,#100</span><br><span class="line">     SC   R3,100(R2)</span><br><span class="line">     beqz R3,1b</span><br><span class="line">     NOP</span><br></pre></td></tr></table></figure>
<h2 id="cas-原语">CAS 原语</h2>
<p>CAS （Compare-And-Swap） LL/SC这对CPU指令没有实现,但是实现了CAS.
CAS是一组原语指令，用来实现多线程下的变量同步。 在 x86
下的指令CMPXCHG实现了CAS，前置LOCK既可以达到原子性操作。截止2013，大部分多核处理器均支持CAS。
CAS原语有三个参数，内存地址，期望值，新值。如果内存地址的值==期望值，表示该值未修改，此时可以修改成新值。否则表示修改失败，返回false，由用户决定后续操作。</p>
<h2 id="简单自旋锁实现">简单自旋锁实现</h2>
<h3 id="什么是自旋锁">什么是自旋锁</h3>
<p>我们没有方法去控制对共享资源访问的有序性，但是我们有能力对共享资源采用锁的保护机制，当某个共享资源被锁住时，只有获取该锁的
CPU 核能够操作共享资源，其余试图访问共享资源的 CPU
核只能够等待这个锁的释放，这就是在 Linux 中被称为 Spinlock
的自旋锁保护机制。</p>
<p>Spinlock 的设计思想是基于一种被称为 Test-and-Set
的机制，它的操作分为三部分：</p>
<p>1）INIT</p>
<p>初始化 <em>lock</em> 值。示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lock := CLEAR;</span><br></pre></td></tr></table></figure>
<p>2）LOCK</p>
<p>这个流程包括两部分：首先 CPU 核反复轮询 <em>lock</em>
值直到它处于空闲状态为止，然后利用 Test-and-Set 方式尝试设置该
<em>lock</em> 值，Test-and-Set 的操作可以描述成三步：</p>
<p>（a）读取 <em>lock</em> 值；</p>
<p>（b）设置 <em>lock</em> 值</p>
<p>(c）检查 <em>lock</em> 值是否设置成功，如果在步骤 （a）
之后还存在别的对 <em>lock</em> 值的操作，说明存在有并发访问
<em>lock</em> 值的情况，则步骤 （b） 的 <em>lock</em>
值将不能设置成功，还需要回到步骤 （a） 重新执行这个流程。</p>
<p>示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((lock == BUSY) || (TestAndSet(lock) == BUSY));</span><br></pre></td></tr></table></figure>
<p>（3）UNLOCK</p>
<p>释放 <em>lock</em> 值。示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lock := CLEAR;</span><br></pre></td></tr></table></figure>
<h3 id="mips实现基于llsc原语实现">MIPS实现（基于LL/SC原语实现）</h3>
<p>传统的 C 语言是无法实现 Test-and-Set
的机制的，因为它无法在多核之间建立一个交互的机制，因此 Test-and-Set
需要处理器给以相应的支持。以 MIPS 为例，它提供了 LL（Load Linked Word）
和 SC（Store Conditional Word）
这两个汇编指令来实现对共享资源的保护。</p>
<h4 id="简单的自旋锁">简单的自旋锁</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock： </span><br><span class="line"> 1： LL t0, 0x0(a0) //取回锁值，0 表示未被锁，1 表示有人持有锁 </span><br><span class="line"> BNEZ t0, 1b //如果已经被锁，则自旋等待 </span><br><span class="line"> ADDIU t0, t0, 0x1 //将 t0 改为已持有 </span><br><span class="line"> SC t0, 0x0(a0) //存回 </span><br><span class="line"> BEQZ t0, 1b //检查是否成功，否则重做 </span><br><span class="line"> NOP </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unlock： </span><br><span class="line">//mem fence </span><br><span class="line">SW $0, 0x0(a0) //解锁时写 0 </span><br><span class="line">//mem fence</span><br></pre></td></tr></table></figure>
<h4 id="基于排队的公平的自旋锁">基于排队的公平的自旋锁</h4>
<p>简单自旋排队锁 设 a0 为锁的地址。按请求顺序来 service。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock: (锁值为高低各 2 字节组成，高位为 tickets, 低位为 serve) </span><br><span class="line"> 1: LL v0, 0x0(a0) //同时取回高低位 </span><br><span class="line"> LI t0, 0x10000 //将高位 tickets 加一 </span><br><span class="line"> ADDU t0, t0, v0 </span><br><span class="line"> SC t0, 0x0(a0) //存回去 </span><br><span class="line"> BEQZ t0, 1b //检查是否 LLSC 成功，失败则重试 </span><br><span class="line"> NOP </span><br><span class="line"> SRL v0, v0, 16 //取出此时已经确定拿到的 tickets，放到低位 </span><br><span class="line"> 2: LHU t0, 0x0(a0) //检查当前 serve 值 </span><br><span class="line"> BNE t0, v0, 2b //如果当前 serve 不是自己，则循环等待 </span><br><span class="line"> NOP </span><br><span class="line">Unlock： </span><br><span class="line"> //mem fence </span><br><span class="line"> LHU t0, 0x0(a0) //取出当前 serve </span><br><span class="line"> ADDIU t0, t0, 0x1 </span><br><span class="line"> SH t0, 0x0(a0) //加 1 存回去 </span><br><span class="line"> //mem fence</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><code>LL</code> 指令是 Load
Linked，用于原子地将内存中的值加载到寄存器 <code>v0</code>。</li>
<li><code>LI</code> 指令是 Load Immediate，将立即数 <code>0x10000</code>
加载到寄存器 <code>t0</code>。</li>
<li><code>ADDU</code> 指令是无符号整数相加。</li>
<li><code>SC</code> 指令是 Store Conditional，尝试将 <code>t0</code>
存储回内存，如果存储成功，则返回 1，否则返回 0。</li>
<li><code>BEQZ</code> 指令是 Branch on Equal to Zero，如果
<code>t0</code> 为零（存储失败），则跳转到标号
<code>1b</code>，即重新尝试获取锁。</li>
<li><code>SRL</code> 指令是 Shift Right Logical，将 <code>v0</code>
寄存器右移 16 位，得到高位 tickets。</li>
<li><code>LHU</code> 指令是 Load Halfword
Unsigned，将内存中的半字加载到寄存器 <code>t0</code>。</li>
<li><code>BNE</code> 指令是 Branch on Not Equal，如果 <code>t0</code>
不等于 <code>v0</code>，则跳转到标号
<code>2b</code>，即循环等待，直到拿到锁。</li>
<li><code>LHU</code> 指令是 Load Halfword
Unsigned，将内存中的半字加载到寄存器 <code>t0</code>。</li>
<li><code>ADDIU</code> 指令是 Add Immediate Unsigned，将 <code>t0</code>
寄存器的值加 1。</li>
<li><code>SH</code> 指令是 Store Halfword，将 <code>t0</code>
寄存器的值存储回内存。</li>
</ul>
<h2 id="cas-实现自旋锁">CAS 实现自旋锁</h2>
<p>CAS：指令定义 cas r1, r2, Mem；r1 存放期望值，r2 存放更新值，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获得锁：//锁初始化为 0 </span><br><span class="line">la t0, sem </span><br><span class="line">TryAgain: </span><br><span class="line">li t1, 0 </span><br><span class="line">li t2, 1 </span><br><span class="line">cas t1, t2, 0x0(t0) </span><br><span class="line">bnez t1, TryAgain </span><br><span class="line">nop </span><br><span class="line">relLOCK: </span><br><span class="line">la t0, sem </span><br><span class="line">li t1, 0 </span><br><span class="line">sw t1, 0x0(t0)</span><br></pre></td></tr></table></figure>
<h2 id="cas-llsc原语">CAS/ LL/SC原语</h2>
<p>Compare_And_Swap(CAS)和 Load-Linked and
Store-Conditional(LL/SC)是两种比较常见的 硬件同步原语。例如，Intel、AMD
的 x86 指令集和 Oracle/SUN 的 Sparc 指令集实现了
CAS指令；Alpha、PowerPC、MIPS、ARM 均实现了 LL/SC 指令。</p>
<p>（2）CAS 指令硬件实现比 LL/SC 的硬件实现复杂。使用 CAS 指令会碰到 ABA
问题，但是 LL/SC指令不会碰到该问题。LL/SC 指令中由于 SC
是尝试去写，因此在某些情况下，SC 执行成功 率很低，导致用 LL/SC
实现的锁执行开销变得很大。</p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>自旋锁</tag>
      </tags>
  </entry>
  <entry>
    <title>MIPS 汇编指令</title>
    <url>/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="mips-汇编指令">MIPS 汇编指令</h1>
<p>MIPS的意思是 “无内部互锁流水级的微处理器” (Microprocessor without
interlocked piped stages)</p>
<h2 id="指令系统常见指令分类">指令系统常见指令分类</h2>
<ul>
<li><strong>算术和逻辑运算指令</strong></li>
</ul>
<p>​ <strong>加、减、乘、除、开方……</strong></p>
<p>​ <strong>移位：左移与右移、逻辑移位与算术移位……</strong></p>
<p>​ <strong>与、或、非、异或……</strong></p>
<p>​ <strong>格式转换……</strong></p>
<ul>
<li><strong>访存指令：取数、存数</strong></li>
</ul>
<p>​
<strong>不同长度和不同类型：定点/浮点，字节/半字/字/双字</strong></p>
<p>​ <strong>不同寻址方式</strong></p>
<ul>
<li><strong>转移指令</strong></li>
</ul>
<p>​ <strong>相对/绝对、直接/间接、条件/无条件</strong></p>
<ul>
<li><strong>系统管理指令</strong></li>
</ul>
<p>​ <strong>TLB管理、Cache管理、异常管理、安全管理</strong></p>
<h2 id="指令特点">指令特点</h2>
<ul>
<li><p>所有指令都是32位长</p></li>
<li><p>指令操作必须符合流水线</p>
<p>MIPS指令一次只能修改一个寄存器的值</p></li>
<li><p>3操作数指令</p></li>
<li><p>32个寄存器</p></li>
<li><p>没有条件标志位</p></li>
</ul>
<h2 id="mips-的寄存器">MIPS 的寄存器</h2>
<ul>
<li><p>MIPS下一共有32个通用寄存器</p></li>
<li><p>在汇编中，寄存器标志由 <code>$</code> 符开头</p></li>
<li><p>寄存器表示可以有两种方式</p>
<ul>
<li><p>直接使用该寄存器对应的编号，例如：从 <code>$0</code> 到
<code>$31</code></p></li>
<li><p>使用对应的寄存器名称例如： <code>$t1</code> ,
<code>$sp</code></p></li>
</ul></li>
<li><p>栈的走向是从高地址到低地址</p></li>
<li><table>
<colgroup>
<col style="width: 15%">
<col style="width: 14%">
<col style="width: 70%">
</colgroup>
<thead>
<tr class="header">
<th>寄存器编号</th>
<th>寄存器名</th>
<th>寄存器用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>zero</td>
<td>永远返回零</td>
</tr>
<tr class="even">
<td>1</td>
<td>$at</td>
<td>汇编保留寄存器</td>
</tr>
<tr class="odd">
<td>2-3</td>
<td>$v0 - $v1</td>
<td>存储表达式或者是函数的返回值</td>
</tr>
<tr class="even">
<td>4-7</td>
<td>$a0 - $a3</td>
<td>存储子程序的前4个参数，在子程序调用过程中释放</td>
</tr>
<tr class="odd">
<td>8-15</td>
<td>$t0 - $t7</td>
<td>临时变量</td>
</tr>
<tr class="even">
<td>16-23</td>
<td>$s0 - $s7</td>
<td>静态变量</td>
</tr>
<tr class="odd">
<td>24-25</td>
<td>$t8 - $t9</td>
<td>临时变量</td>
</tr>
<tr class="even">
<td>26-27</td>
<td>$k0 - $k1</td>
<td>中断函数返回值</td>
</tr>
<tr class="odd">
<td>28</td>
<td>$gp</td>
<td>指向静态数据块的中间地址</td>
</tr>
<tr class="even">
<td>29</td>
<td>$sp</td>
<td>栈顶指针</td>
</tr>
<tr class="odd">
<td>30</td>
<td>$fp</td>
<td>帧指针</td>
</tr>
<tr class="even">
<td>31</td>
<td>$ra</td>
<td>返回地址</td>
</tr>
</tbody>
</table></li>
</ul>
<h2 id="三种类型指令">三种类型指令</h2>
<h3 id="r-typearithmetic-instruction">R-type：arithmetic
instruction</h3>
<p>寄存器寻址</p>
<h3 id="i-typedata-transfer-arithmetic-instruction">I-type：data
transfer, arithmetic instruction</h3>
<p>立即寻址</p>
<h3 id="j-typebranch-instructionconditional-unconditional">J-type：branch
instruction(conditional &amp; unconditional)</h3>
<p>相对寻址：J(I)-type</p>
<p>伪直接寻址：J-type</p>
<figure>
<img src="/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231001100653770.png" alt="操作码操作数位数">
<figcaption aria-hidden="true">操作码操作数位数</figcaption>
</figure>
<figure>
<img src="/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20240110095539899.png" alt="MIPS指令编码格式">
<figcaption aria-hidden="true">MIPS指令编码格式</figcaption>
</figure>
<ul>
<li><p>R-type：寄存器类指令主要完成寄存器-寄存器的ALU操作</p></li>
<li><p>I-type
：立即数类指令主要用于LOAD-STORE操作，条件转移指令等。访存指令是由RS1寄存器的值+immediate得到内存地址，将
RS2的值存入内存或者从内存取数存RS2。访存指令对存储器进行读写：<code>lw $s1,100(\$s2)</code></p>
<figure>
<img src="/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231002172735180.png" alt="访存对象">
<figcaption aria-hidden="true">访存对象</figcaption>
</figure>
<p>条件转移指令，转移条件可能为RS1是否为0，也可能是RS1和RS2是否相等。</p></li>
<li><p>J-type：直接跳转指令。转移地址是PC的高四位和target直接拼接，后面两位补0（因为内存4字节对齐）。</p></li>
</ul>
<h3 id="常见指令"><strong>常见指令</strong></h3>
<figure>
<img src="/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20240110101934646.png" alt="MIPSloadstore指令">
<figcaption aria-hidden="true">MIPSloadstore指令</figcaption>
</figure>
<p>其中SDC1,LDC1等是浮点类的指令</p>
<figure>
<img src="/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20240110102135710.png" alt="ALU常见指令">
<figcaption aria-hidden="true">ALU常见指令</figcaption>
</figure>
<figure>
<img src="/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20240110102244573.png" alt="MIPS控制流指令">
<figcaption aria-hidden="true">MIPS控制流指令</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th>BEQZ</th>
<th>条件转移指令，当寄存器中内容为0时转移发生</th>
<th>BEQZ R1,0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BENZ</td>
<td>条件转移指令，当寄存器中内容不为0时转移发生</td>
<td>BNEZ R1,0</td>
</tr>
</tbody>
</table>
<h2 id="寄存器和立即计算指令数据流">寄存器和立即计算指令数据流</h2>
<figure>
<img src="/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231001102233068.png" alt="image-20231001102233068">
<figcaption aria-hidden="true">image-20231001102233068</figcaption>
</figure>
<h2 id="常数加载">常数加载</h2>
<p>加载立即数常数</p>
<p>dla、la: 用来加载程序中某些带标号的位置或者变量的地址的宏指令；</p>
<p>dli、li: 装入立即数常数，这是一个宏指令；</p>
<p>lui: 把立即数加载到寄存器高位。</p>
<h2 id="ll-sc指令">ll sc指令</h2>
<p>LL 指令的功能是从内存中读取一个字，以实现接下来的
RMW（Read-Modify-Write） 操作；</p>
<p>SC 指令的功能是向内存中写入一个字，以完成前面的 RMW 操作。</p>
<p>LL/SC
指令的独特之处在于，它们不是一个简单的内存读取/写入的函数，当使用 LL
指令从内存中读取一个字之后，比如 LL d, off(b)，处理器会记住 LL
指令的这次操作（会在 CPU 的寄存器中设置一个不可见的 bit 位），同时 LL
指令读取的地址 off(b) 也会保存在处理器的寄存器中。接下来的 SC 指令，比如
SC t, off(b)，会检查上次 LL 指令执行后的 RMW 操作是否是<a href="https://so.csdn.net/so/search?q=原子操作&amp;spm=1001.2101.3001.7020">原子操作</a>（即不存在其它对这个地址的操作），如果是原子操作，则
t 的值将会被更新至内存中，同时 t 的值也会变为1，表示操作成功；反之，如果
RMW 的操作不是原子操作（即存在其它对这个地址的访问冲突），则 t
的值不会被更新至内存中，且 t 的值也会变为0，表示操作失败。</p>
<h3 id="例子">例子：</h3>
<figure>
<img src="/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231002170111052.png" alt="image-20231002170111052">
<figcaption aria-hidden="true">image-20231002170111052</figcaption>
</figure>
<p><strong>为啥后面还要加一个nop指令？</strong></p>
<p><strong>延迟槽填充（Delay Slot Filling）：</strong>
在MIPS体系结构中，条件分支指令（如<code>beq</code>）的执行是延迟的，意味着在分支判断之前会执行分支指令后的一条指令。为了最大程度地利用流水线处理器的性能，程序员通常需要填充延迟槽，以确保流水线中始终有有效的指令在执行。</p>
<h2 id="lwl-lwr-swl-swr-大小端问题">lwl lwr swl swr 大小端问题</h2>
<p>https://courses.cs.duke.edu/fall02/cps104/homework/lwswlr.html</p>
<p>lw sw用于word对齐情况下的一个字节的移动，lwl lwr swl
swr用于字节没有对齐情况下的移动</p>
<h3 id="lwr">LWR</h3>
<p>This instruction reads the right portion of a register (low-order
bytes).</p>
<p>这条指令从寄存器的右边(低地址字节）开始读</p>
<p>Conceptually, LWR starts at the specified byte in memory and loads
that byte into the low-order (right most) byte of the destination
register.</p>
<p>Then, it proceeds (进入）to the ==high-order byte of the word in
memory== (since SPARC is big-endian, this is toward lower memory
addresses) and the high-order byte of the register, loading bytes from
memory into the register until it reaches the high-order byte of the
memory word.
在加载完一个字节以后，进入内存中下一个高字节部分（对于大端模式，高字节部分在低地址位，小端模式反之）并存入寄存器中直到到达内存最高字节</p>
<p>So, start at some specified address, and start copying bytes from
memory and <strong>decrement</strong> the memory byte address until you
reach the next lowest memory address that is word aligned, including the
byte at this last address. The most significant (left-most) byte(s) of
the register will not be changed.</p>
<p>例子：<code>lwr $4, 2($0)</code></p>
<p><code>lwr $t, offset($s)</code></p>
<p>从计算得到的地址开始，加载4个字节的数据（一个字）到目标寄存器
<code>$t</code>
中，同时将目标寄存器中的其余3个字节保持不变（即不受影响）。</p>
<figure>
<img src="/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231002112606615.png" alt="image-20231002112606615">
<figcaption aria-hidden="true">image-20231002112606615</figcaption>
</figure>
<p>从地址0+2处开始取u，到2放到寄存器的右端，然后因为大端模式向高位继续读取1，0依次放到寄存器中，直到遇到了字对齐的地址（内存中四个字一对齐）</p>
<h3 id="lwl">lwl</h3>
<p>同理lwl 放到寄存器的左端</p>
<p>LWL starts at the specified byte in memory and loads that byte into
the high-order (left most) byte of the destination register. Then, it
proceeds to the ==low-order byte== of the word in memory (since SPARC is
big-endian, this is toward higher memory addresses) and the low-order
byte of the register, loading bytes from memory into the register until
it reaches the low-order byte of the memory word.</p>
<p><code>lwl $4, 2($0)</code></p>
<figure>
<img src="/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231002114134669.png" alt="image-20231002114134669">
<figcaption aria-hidden="true">image-20231002114134669</figcaption>
</figure>
<h3 id="swr">SWR</h3>
<p><code>swr $4, 5($0)</code></p>
<figure>
<img src="/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231002114423677.png" alt="image-20231002114423677">
<figcaption aria-hidden="true">image-20231002114423677</figcaption>
</figure>
<p>从寄存器4的最有端的值取值，存到地址为5($0)
的内存中，其中$0+5原来存放的是5，现在存寄存器最右端的D，然后向高位移动。Bytes
are copied toward the ==left== until the word aligned address is reached
(byte 0 of word at memory address 4, which has the initial value of 4 in
this example).</p>
<h3 id="swl">SWL</h3>
<p><code>swL $4, 5($0)</code>.Bytes are copied toward the ==right==
until the the last byte of this memory word is reached (byte 3 of word
at memory address 4, which has the initial value of 7 in this
example).</p>
<figure>
<img src="/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231002115214583.png" alt="image-20231002115214583">
<figcaption aria-hidden="true">image-20231002115214583</figcaption>
</figure>
<h3 id="作业例题">作业例题</h3>
<p>在一台小尾端的MIPS机器上，用LWL/LWR/SWL/SWR指令编写一段程序，把内存单元1005-1008的值取到寄存器R1,再存到内存单元2005~2008中</p>
<ul>
<li><p>首先，注意由于内存对齐的问题，1005~1008不是一个完整的字，4字节对齐后，开头都是4的倍数：</p>
<p>因为是小尾端，lwr向高字节走就是向高地址走。lwl向低字节走就是向低地址走。如果是大尾端，lwr向高字节就是向低地址走，lwl就是向高地址走</p>
<table>
<thead>
<tr class="header">
<th>1008</th>
<th>1009</th>
<th>100A</th>
<th>100B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1004</td>
<td>1005</td>
<td>1006</td>
<td>1007</td>
</tr>
</tbody>
</table>
<p>因此，首先我们需要将基地址1005这个立即数存到寄存器当中：</p>
<p><code>dli \$2 ,1005</code></p>
<p>,下一步，将内存单元的值加载到寄存器r1当中。</p>
<p><code>lwr \$1 , 0x0($2)</code></p>
<p>此时R2:</p>
<table>
<thead>
<tr class="header">
<th>X</th>
<th>1007</th>
<th>1006</th>
<th>1005</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p><code>lwl \$1 , 0x3($2)</code></p>
<p>此时R2:</p>
<table>
<thead>
<tr class="header">
<th>1008</th>
<th>1007</th>
<th>1006</th>
<th>1005</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>下一步，将r1的内容存到内存2005-2008</p>
<p>同理该部分内存也不属于一个字</p>
<table>
<thead>
<tr class="header">
<th>2008</th>
<th>2009</th>
<th>200A</th>
<th>200B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2004</td>
<td>2005</td>
<td>2006</td>
<td>2007</td>
</tr>
</tbody>
</table></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dli \$2 ,2005 #装载基地址</span><br><span class="line">swr  $1, 0x0($2)</span><br><span class="line">swl  $1, 0x3($2)</span><br></pre></td></tr></table></figure>
<p><strong>思考：如果变成大尾端会有什么变化</strong></p>
<p>改为大尾端后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dli \$2 ,1005 #装载基地址</span><br><span class="line">lwl  $1, 0x0($2)</span><br><span class="line">lwr  $1, 0x3($2)</span><br><span class="line">dli \$2 ,2005</span><br><span class="line">swl  $1, 0x0($2)</span><br><span class="line">swr  $1, 0x3($2)</span><br></pre></td></tr></table></figure>
<h2 id="常见指令汇总">常见指令汇总</h2>
<table>
<colgroup>
<col style="width: 7%">
<col style="width: 3%">
<col style="width: 2%">
<col style="width: 3%">
<col style="width: 7%">
<col style="width: 19%">
<col style="width: 8%">
<col style="width: 19%">
<col style="width: 8%">
<col style="width: 19%">
</colgroup>
<thead>
<tr class="header">
<th><strong>MIPS 指令集(共31条）</strong></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>助记符</strong></td>
<td><strong>指令格式</strong></td>
<td><strong>示例</strong></td>
<td><strong>示例含义</strong></td>
<td><strong>操作及其解释</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Bit #</td>
<td>31..26</td>
<td>25..21</td>
<td>20..16</td>
<td>15..11</td>
<td>10..6</td>
<td>5..0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R-type</td>
<td>op</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>shamt</td>
<td>func</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>add</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100000</td>
<td>add $1,$2,$3</td>
<td>$1=$2+$3</td>
<td>rd &lt;- rs + rt ；其中rs＝$2，rt=$3, rd=$1</td>
</tr>
<tr class="odd">
<td>addu</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100001</td>
<td>addu $1,$2,$3</td>
<td>$1=$2+$3</td>
<td>rd &lt;- rs + rt ；其中rs＝$2，rt=$3, rd=$1,无符号数</td>
</tr>
<tr class="even">
<td>sub</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100010</td>
<td>sub $1,$2,$3</td>
<td>$1=$2-$3</td>
<td>rd &lt;- rs - rt ；其中rs＝$2，rt=$3, rd=$1</td>
</tr>
<tr class="odd">
<td>subu</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100011</td>
<td>subu $1,$2,$3</td>
<td>$1=$2-$3</td>
<td>rd &lt;- rs - rt ；其中rs＝$2，rt=$3, rd=$1,无符号数</td>
</tr>
<tr class="even">
<td>and</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100100</td>
<td>and $1,$2,$3</td>
<td>$1=$2 &amp; $3</td>
<td>rd &lt;- rs &amp; rt ；其中rs＝$2，rt=$3, rd=$1</td>
</tr>
<tr class="odd">
<td>or</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100101</td>
<td>or $1,$2,$3</td>
<td>$1=$2</td>
<td>$3</td>
</tr>
<tr class="even">
<td>xor</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100110</td>
<td>xor $1,$2,$3</td>
<td>$1=$2 ^ $3</td>
<td>rd &lt;- rs xor rt ；其中rs＝$2，rt=$3, rd=$1(异或）</td>
</tr>
<tr class="odd">
<td>nor</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100111</td>
<td>nor $1,$2,$3</td>
<td>$1=~($2</td>
<td>$3)</td>
</tr>
<tr class="even">
<td>slt</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>101010</td>
<td>slt $1,$2,$3</td>
<td>if($2&lt;$3) $1=1 else $1=0</td>
<td>if (rs &lt; rt) rd=1 else rd=0 ；其中rs＝$2，rt=$3, rd=$1</td>
</tr>
<tr class="odd">
<td>sltu</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>101011</td>
<td>sltu $1,$2,$3</td>
<td>if($2&lt;$3) $1=1 else $1=0</td>
<td>if (rs &lt; rt) rd=1 else rd=0 ；其中rs＝$2，rt=$3, rd=$1
(无符号数）</td>
</tr>
<tr class="even">
<td>sll</td>
<td>000000</td>
<td>00000</td>
<td>rt</td>
<td>rd</td>
<td>shamt</td>
<td>000000</td>
<td>sll $1,$2,10</td>
<td>$1=$2&lt;&lt;10</td>
<td>rd &lt;- rt &lt;&lt; shamt ；shamt存放移位的位数，
也就是指令中的立即数，其中rt=$2, rd=$1</td>
</tr>
<tr class="odd">
<td>srl</td>
<td>000000</td>
<td>00000</td>
<td>rt</td>
<td>rd</td>
<td>shamt</td>
<td>000010</td>
<td>srl $1,$2,10</td>
<td>$1=$2&gt;&gt;10</td>
<td>rd &lt;- rt &gt;&gt; shamt ；(logical) ，其中rt=$2, rd=$1</td>
</tr>
<tr class="even">
<td>sra</td>
<td>000000</td>
<td>00000</td>
<td>rt</td>
<td>rd</td>
<td>shamt</td>
<td>000011</td>
<td>sra $1,$2,10</td>
<td>$1=$2&gt;&gt;10</td>
<td>rd &lt;- rt &gt;&gt; shamt ；(arithmetic) 注意符号位保留 其中rt=$2,
rd=$1</td>
</tr>
<tr class="odd">
<td>sllv</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>000100</td>
<td>sllv $1,$2,$3</td>
<td>$1=$2&lt;&lt;$3</td>
<td>rd &lt;- rt &lt;&lt; rs ；其中rs＝$3，rt=$2, rd=$1</td>
</tr>
<tr class="even">
<td>srlv</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>000110</td>
<td>srlv $1,$2,$3</td>
<td>$1=$2&gt;&gt;$3</td>
<td>rd &lt;- rt &gt;&gt; rs ；(logical)其中rs＝$3，rt=$2, rd=$1</td>
</tr>
<tr class="odd">
<td>srav</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>000111</td>
<td>srav $1,$2,$3</td>
<td>$1=$2&gt;&gt;$3</td>
<td>rd &lt;- rt &gt;&gt; rs ；(arithmetic) 注意符号位保留
其中rs＝$3，rt=$2, rd=$1</td>
</tr>
<tr class="even">
<td>jr</td>
<td>000000</td>
<td>rs</td>
<td>00000</td>
<td>00000</td>
<td>00000</td>
<td>001000</td>
<td>jr $31</td>
<td>goto $31</td>
<td>PC &lt;- rs</td>
</tr>
<tr class="odd">
<td>I-type</td>
<td>op</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>addi</td>
<td>001000</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>addi $1,$2,100</td>
<td>$1=$2+100</td>
<td>rt &lt;- rs + (sign-extend)immediate ；其中rt=$1,rs=$2</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>addiu</td>
<td>001001</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>addiu $1,$2,100</td>
<td>$1=$2+100</td>
<td>rt &lt;- rs + (zero-extend)immediate ；其中rt=$1,rs=$2</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>andi</td>
<td>001100</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>andi $1,$2,10</td>
<td>$1=$2 &amp; 10</td>
<td>rt &lt;- rs &amp; (zero-extend)immediate ；其中rt=$1,rs=$2</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>ori</td>
<td>001101</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>andi $1,$2,10</td>
<td>$1=$2 | 10</td>
<td>rt &lt;- rs | (zero-extend)immediate ；其中rt=$1,rs=$2</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>xori</td>
<td>001110</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>andi $1,$2,10</td>
<td>$1=$2 ^ 10</td>
<td>rt &lt;- rs xor (zero-extend)immediate ；其中rt=$1,rs=$2</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>lui</td>
<td>001111</td>
<td>00000</td>
<td>rt</td>
<td>immediate</td>
<td>lui $1,100</td>
<td>$1=100*65536</td>
<td>rt &lt;- immediate*65536 ；将16位立即数放到目标寄存器高16
位，目标寄存器的 低16位填0</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>lw</td>
<td>100011</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>lw $1,10($2)</td>
<td>$1=memory[$2 +10]</td>
<td>rt &lt;- memory[rs + (sign-extend)immediate] ；rt=$1,rs=$2</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>sw</td>
<td>101011</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>sw $1,10($2)</td>
<td>memory[$2+10] =$1</td>
<td>memory[rs + (sign-extend)immediate] &lt;- rt ；rt=$1,rs=$2</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>beq</td>
<td>000100</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>beq $1,$2,10</td>
<td>if($1==$2) goto PC+4+40</td>
<td>if (rs == rt) PC &lt;- PC+4 + (sign-extend)immediate&lt;&lt;2</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>bne</td>
<td>000101</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>bne $1,$2,10</td>
<td>if($1!=$2) goto PC+4+40</td>
<td>if (rs != rt) PC &lt;- PC+4 + (sign-extend)immediate&lt;&lt;2</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>slti</td>
<td>001010</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>slti $1,$2,10</td>
<td>if($2&lt;10) $1=1 else $1=0</td>
<td>if (rs &lt;(sign-extend)immediate) rt=1 else rt=0 ；
其中rs＝$2，rt=$1</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>sltiu</td>
<td>001011</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>sltiu $1,$2,10</td>
<td>if($2&lt;10) $1=1 else $1=0</td>
<td>if (rs &lt;(zero-extend)immediate) rt=1 else rt=0 ；
其中rs＝$2，rt=$1</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>J-type</td>
<td>op</td>
<td>address</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>j</td>
<td>000010</td>
<td>address</td>
<td>j 10000</td>
<td>goto 10000</td>
<td>PC &lt;- (PC+4)[31..28],address,0,0 ；address=10000/4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>jal</td>
<td>000011</td>
<td>address</td>
<td>jal 10000</td>
<td>$31&lt;-PC+4; goto 10000</td>
<td>$31&lt;-PC+4；PC &lt;- (PC+4)[31..28],address,0,0
；address=10000/4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>BEQZ</th>
<th>条件转移指令，当寄存器中内容为0时转移发生</th>
<th>BEQZ R1,0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BENZ</td>
<td>条件转移指令，当寄存器中内容不为0时转移发生</td>
<td>BNEZ R1,0</td>
</tr>
</tbody>
</table>
<h2 id="内存对齐">内存对齐</h2>
<p><strong>在32位微处理器中，处理器访问内存都是按照32位进行的，即一次读取或写入都是4个字节</strong>，比如，地址0x0
~
0xF这16字节的内存，对于微处理器来说，<strong>不是将其看作16个单一字节，而是4个块，每块4个字节</strong></p>
<figure>
<img src="/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231002131220203.png" alt="image-20231002131220203">
<figcaption aria-hidden="true">image-20231002131220203</figcaption>
</figure>
<p>假设要求变量的内存空间按照4字节对齐，则内存空间的首地址必须是4的整数倍，满足条件的地址有0x0、0x4、0x8、0xC……</p>
<h2 id="大尾端和小尾端的字节序问题">大尾端和小尾端的字节序问题</h2>
<p>big-endian又名<strong>大尾序</strong>，就是数值的尾巴存储在大地址上。尾是相对我们认识的变量值，大是指地址；
相对应，little-endian又名<strong>小尾序</strong>，数值的尾巴存储在小地址上。
一句话大小是尾巴的地址，尾巴是数值的尾巴</p>
<figure>
<img src="/2024/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/MIPS%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231002152257410.png" alt="image-20231002152257410">
<figcaption aria-hidden="true">image-20231002152257410</figcaption>
</figure>
<p>计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合比如网络传输和文件储存，几乎都是用的大端字节序。正是因为这些原因才有了字节序。</p>
<p>计算机处理字节序的时候，如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序则正好相反v</p>
<h2 id="浮点运算问题">浮点运算问题</h2>
<p>https://gaozhiyuan.net/assembly/mips-floating-point-arithmetic.html</p>
<p>在MIPS体系结构中，最多支持4个协处理器(Co-Processor)。其中，CP0用作系统控制，CP1和CP3用于FPU，CP2用于特点实现。CP0是必须具备的协处理器，其余三个协处理器是选配的。</p>
<h3 id="浮点数加载">浮点数加载</h3>
<p>下面的代码就可以分别将位于内存中的 number1和 number2
加载到浮点寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	number1:	.float 2.5</span><br><span class="line">	number2:	.float 3.5</span><br><span class="line">.text</span><br><span class="line">	main:</span><br><span class="line">		lwc1	$f1, number1</span><br><span class="line">		lwc1	$f2, number2</span><br></pre></td></tr></table></figure>
<h3 id="浮点数运算">浮点数运算</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	number1:	.float 3.6</span><br><span class="line">	number2:	.float 3.5</span><br><span class="line">.text</span><br><span class="line">	main:</span><br><span class="line">		lwc1	$f1, number1</span><br><span class="line">		lwc1	$f2, number2</span><br><span class="line">		</span><br><span class="line">		# 浮点数相加</span><br><span class="line">		add.s	$f3, $f1, $f2</span><br><span class="line">		# 浮点数相减</span><br><span class="line">		sub.s	$f4, $f1, $f2</span><br><span class="line">		# 浮点数相乘</span><br><span class="line">		mul.s 	$f5, $f1, $f2</span><br><span class="line">		# 浮点数相除</span><br><span class="line">		div.s 	$f6, $f1, $f2</span><br></pre></td></tr></table></figure>
<h3 id="例子-1">例子：</h3>
<p>**对于向量运算x(i)=a*X(i)+Y(i),假设X和Y的首地址分别存在定点寄存器R1,R2,a存在浮点寄存器f0中，写出mips代码**,假设数组的长度是n</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADDIU     R3,R0,N;    #首先用一个寄存器记录数组的末端地址,这里0寄存器就是0</span><br><span class="line">SLL       R3,R3,2;    #R3左移2位=》R3=R3*4</span><br><span class="line">ADDU      R3,R3,R1;   #基址+偏移</span><br><span class="line">Loop:    </span><br><span class="line">          LWC1 F1,(0)R1;#将X,y加载到浮点寄存器里面</span><br><span class="line">          LWC1 F2,(0)R2;</span><br><span class="line">          MUL.S F3,F1,F0;</span><br><span class="line">          ADD.S F4,F3,F2;</span><br><span class="line">          #数组指针移动</span><br><span class="line">          ADDIU R1,R1,4;</span><br><span class="line">          ADDIU R2,R2,4;</span><br><span class="line">          #判断数组是否已经遍历完了</span><br><span class="line">          BNE R3,R1,Loop；</span><br><span class="line">          #将结果存储,这里利用延迟槽所以会先执行这一句</span><br><span class="line">          SWC1 F4,-4(R1);</span><br><span class="line">          </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>MIPS</tag>
      </tags>
  </entry>
  <entry>
    <title>多核处理器</title>
    <url>/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="多核处理器">多核处理器</h1>
<h2 id="消息传递与共享存储">消息传递与共享存储</h2>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114090340471.png"></p>
<h3 id="共享存储与消息传递的编程复杂度">共享存储与消息传递的编程复杂度</h3>
<p>任务划分与数据划分 ：</p>
<ul>
<li>共享存储编程只需划分任务</li>
<li>消息传递编程除了划分任务外，还需划分数据和考虑通信
（类似于微信与短信）</li>
</ul>
<p>传递复杂的数据结构较困难</p>
<ul>
<li>多个指针组成的结构 ：struct {int <em>pa; int pb</em>; int *pc}</li>
</ul>
<p>动态通信</p>
<ul>
<li><p>{for (i,j){ x=…; y=…; a[i][j]=b[x][y];}}</p></li>
<li><p>进程迁移及进程数目的变化</p></li>
</ul>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114091003581.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 4 <span class="comment">//假设线程数目为4</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> n 1000</span></span><br><span class="line"><span class="type">double</span> *A,*B,*C;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">matrixMult</span><span class="params">(<span class="type">void</span> *id)</span> &#123;<span class="comment">//计算矩阵乘</span></span><br><span class="line">    <span class="type">int</span> my_id = (<span class="type">int</span> ) id;</span><br><span class="line">    <span class="type">int</span> i,j,k,start,end;</span><br><span class="line">    <span class="comment">//计算进程负责的部分</span></span><br><span class="line">      start = my_id*(n/NUM_THREADS);</span><br><span class="line">     <span class="keyword">if</span>(my_id == NUMTHREADS<span class="number">-1</span>)</span><br><span class="line">     end = n;</span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">      end = start+(n/NUM_THREADS);</span><br><span class="line">     <span class="keyword">for</span>(i=start;i&lt;end;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">         C[i*n+j] = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">          C[i*n+j]+=A[i*n+k]*B[k*n+j];</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">pthread_t</span> tids[NUM_THREADS];</span><br><span class="line">    <span class="comment">//分配数据空间</span></span><br><span class="line">   A = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>)*n*n);</span><br><span class="line">   B = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>)*n*n);</span><br><span class="line">  C = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>)*n*n);</span><br><span class="line">  <span class="comment">//初始化数组</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">      <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123; </span><br><span class="line">        A[i*n+j] = <span class="number">1.0</span>;</span><br><span class="line">        B[i*n+j] = <span class="number">1.0</span>；</span><br><span class="line">       &#125;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM_THREADS; i++)</span><br><span class="line">     pthread_create(&amp;tids[i], <span class="literal">NULL</span>, matrixMult, (<span class="type">void</span> *) i);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM_THREADS; i++)</span><br><span class="line">        pthread_join(tids[i], <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="共享存储多核处理器的关键问题">共享存储多核处理器的关键问题</h2>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114091418918.png"></p>
<h2 id="共享存储系统中的访存相关性">共享存储系统中的访存相关性</h2>
<h3 id="一致性问题">一致性问题</h3>
<p>在单机系统中，只要保持程序中的数据相关性，就可以保证执行正确。在多处理机系统中，不仅要考虑单机内的数据相关，而且要考虑多机之间的数据相关</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114091903096.png"></p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114092004333.png"></p>
<h2 id="并行程序模型">并行程序模型</h2>
<p><strong>程序模型</strong></p>
<ul>
<li><p>一个进程P是一个二元组<span class="math inline">\(&lt;V(P),P_0(P)&gt;\)</span>，其中V(P)是LOAD和STORE指令的集合，<span class="math inline">\(P_0(P)\)</span>是V(P) 上的一个全序关系</p></li>
<li><p>由N个进程P1,P2,…,Pn组成的程序PRG(P1,P2,…,Pn)是一个二元组<span class="math inline">\(&lt;V(PRG),P_0(PRG)&gt;\)</span>，其 中<span class="math inline">\(V(PRG)=V(P1) \cup V(P2)...\cup
V(Pn)\)</span>是程序PRG的指令集，<span class="math inline">\(P_O(PRG)=P_O(P1) \cup P_O(P2)...\cup
P_O(Pn)\)</span>是程序PRG的程序序</p></li>
</ul>
<p><strong>冲突访问</strong></p>
<ul>
<li>如果两个访存操作访问的是同一单元且其中至少有一个是存数操作,
则称这两个访存操作是冲突的。</li>
</ul>
<p><span class="math inline">\(C(PRG)=\{(u,v)|((u,v) \in V(PRG)) \cap
(u,v是冲突访问)\}\)</span> 称为程序PRG中冲突访问对集</p>
<p><strong>执行的概念</strong></p>
<p>在在一个并行执行中，一旦互相冲突的访问的执行次序确定了。那么执行结果也就确定了。</p>
<p>在程序PRG中,
对冲突访问对集C(PRG)的任一无圈定序称为程序PRG的一个执行，记为E(PRG)。</p>
<p><strong>执行的正确性</strong></p>
<p>程序PRG的执行E(PRG)正确的充要条件是<span class="math inline">\(E(PRG)
\cup P_O(PRG)\)</span>无圈。</p>
<p>例子：</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114093419318.png"></p>
<p>针对上图有：</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114093550941.png"></p>
<p>为了保证执行的正确性,程序中的数据相关性不能被破坏。如果两条访存指令访问的是同一变量且其中至少有一条是存数指令，则这两条指令是数据相关的。在单处理器中,程序执行的结果是由程序中数据相关的指令的执行次序来唯一决定的。在多处理器中,与单处理器中“数据相关”这一概念相对应的是“冲突访问”。在共享存储多处理器系统中,如果两个访存操作访问的是同一单元，且其中至少有一个是存数操作,则称这两个访存操作是冲突的。上面的程序PRG1中,L11和L22是冲突访问,因为它们都访问单元a且L1]是存数操作:同样,112和L21也是冲突访问。把程序PRG中冲突访问对的集合记为((PRG),即
<span class="math inline">\(C(PRG)=\{(u,v)|(u\in V(PRG)) \cap (v \in
V(PRG))N(u;v 是冲突访问)\}\)</span></p>
<p>上图中有：</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114095015293.png"></p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114095123417.png"></p>
<p>判断是否有圈：</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114095317661.png"></p>
<p>可见c是有圈的，不是正确执行。</p>
<p>下图中的程序PRG2的冲突访问对集为:</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114094845632.png"></p>
<p><span class="math inline">\(C(PRG2)=((L11,L21),(L11,L32),(L31,L22)\)</span></p>
<h2 id="存储一致性模型">存储一致性模型</h2>
<p>常见的存储一致性模型</p>
<ul>
<li>顺序一致性模型（Sequential Consistency）</li>
<li>处理器一致性模型（Processor Consistency）</li>
<li>弱一致性模型（Weak Ordering）</li>
<li>释放一致性模型（Release Consistency）</li>
<li>域一致性模型（Scope Consistency）</li>
<li>单项一致性模型（Entry Consistency）</li>
</ul>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114095522795.png"></p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114095631203.png"></p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114095706642.png"></p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114095858742.png"></p>
<h2 id="cache一致性协议">CACHE一致性协议</h2>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114095954406.png"></p>
<h3 id="单写和多写">单写和多写</h3>
<p>单写：任一时刻只有一个处理机能写某共享单位</p>
<p>多写：多个处理机同时写某共享单位的不同部分</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114100050238.png"></p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114100146570.png"></p>
<h3 id="esimsi协议">ESI/MSI协议</h3>
<p>ESI 是指Cache 行的三种一致性状态：</p>
<ul>
<li>E（Exclusive，独占）：表明对应Cache
行被当前处理器核独占，当前处理器核可
以随意读写，其他处理器核如果想读写这个cache 行需要请求占有这个cache 块的
处理器核释放该Cache 行</li>
<li>S（Shared，共享）：表明当前Cache
行可能被多个处理器核共享，只能读取，不能 写入</li>
<li>I （Invalid，无效）：表明当前Cache 块是无效的</li>
</ul>
<p><strong>协议举例</strong></p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114100740279.png"></p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114100805349.png"></p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114101019050.png"></p>
<p>a)初始状态，目录中块X为CLEAN，Pi为INV，Pj和Pk为SHD。</p>
<ol start="2" type="a">
<li>Pi发出store操作。Pi向目录申请write，目录通告P和Pk
invalid，P和Pk状态设置为INV，并回复invalid ack。目录通告Pi，write
ack允许写，并记录下X的备份在Pi，修改状态为DIRTY。Pi修改状态为EXC。</li>
</ol>
<p>c)Pk发出store操作。Pk向目录申请write,目录通告Pi invalid和write
backPi回复invalid writeback
ack，回传一个修改备份给目录。目录更新备份，发送给Pk，并write
ack允许写，并记录下X的备份在Pk，修改状态为DIRTY。Pk修改状态为EXC</p>
<p>d)P发出oad操作。Pi向目录申请read，目录通告Pk write back，Pk复
writeback ack，回传一个修改备份给目录，目录更新备份，发关给Pi，read
ack允许读，并记录下X的备份在Pk与Pi，修改状态为CLEAN.P和PK修改状态为SHD</p>
<p>e)P发出oad操作。Pi问目录申请read，目录将备份发送给P，并read
ack允许读，并记录下X的备份在Pk、P和Pi。Pi修改状态为SHD。
状态，目录中块X为清洁，n为IN V,pj和pk为SH D。</p>
<h3 id="msi">MSI</h3>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/image-20240114101617788.png"></p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>软流水解析</title>
    <url>/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="软流水解析">软流水解析</h1>
<p><strong>基本思想</strong>：将有真相关的指令分隔到不同的循环周期内执行。</p>
<p>软流水后，循环体会变成<strong>装入、主体循环、排空</strong>三个部分</p>
<h2 id="软流水解题思路">软流水解题思路</h2>
<p>例子：将以下代码使用软流水优化：</p>
<figure>
<img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20231105140817405.png" alt="image-20231105140817405">
<figcaption aria-hidden="true">image-20231105140817405</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L1: LDC1  F0, 0(R1)</span><br><span class="line">    ADD.D F2,F0,F1</span><br><span class="line">    SDC1  F2,0(R1)</span><br><span class="line">    ADDIU R1,R1,-8</span><br><span class="line">    BNE  R1,R2,L1</span><br><span class="line">    NOP</span><br></pre></td></tr></table></figure>
<p>首先确定循环主体:</p>
<h3 id="执行顺序确定">1.执行顺序确定</h3>
<p>暂时不需要考虑循环控制部分,分析依赖关系画出数据流图：</p>
<figure>
<img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20231105133645193.png" alt="image-20231105133645193">
<figcaption aria-hidden="true">image-20231105133645193</figcaption>
</figure>
<p>软件流水前后主循环程序的运行逻辑发生了如下所示的变化：</p>
<figure>
<img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/示意图.png" alt="image-20231105133645193">
<figcaption aria-hidden="true">image-20231105133645193</figcaption>
</figure>
<p><strong>为什么要这样？</strong></p>
<p>竖着执行的时候指令1，2，3之间存在相关性。但如果是不同循环的指令交替就没有相关性了，举个栗子：</p>
<p>从上面的图中可以看出来，第i次循环指令3执行，需要依赖第i次循环的指令2，如果横着执行：2，1，3，在执行3的时候2已经执行过了，而且中间隔了1指令和<code>ADDIU R1,R1,-8 BNE  R1,R2,L1</code>是隔了足够数量的指令的，不会有延迟</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第i次的循环</span><br><span class="line">L1: LDC1 F0,0,0(R1) </span><br><span class="line">    ADD.D F2,F0,F1</span><br><span class="line">    SDC1  F2,0(R1)</span><br><span class="line"># 第i+1次的循环</span><br><span class="line">    LDC1 F0,0,-8(R1) </span><br><span class="line">    ADD.D F2,F0,F1</span><br><span class="line">    SDC1  F2,-8(R1)</span><br><span class="line">#第i+2次循环</span><br><span class="line">    LDC1 F0,0,-16(R1) </span><br><span class="line">    ADD.D F2,F0,F1</span><br><span class="line">    SDC1  F2,-16(R1)</span><br></pre></td></tr></table></figure>
<p>因此最终执行顺序：</p>
<figure>
<img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20231105143413047.png" alt="image-20231105143413047">
<figcaption aria-hidden="true">image-20231105143413047</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDC1  F2,0(R1)</span><br><span class="line">ADD.D F2,F0,F1</span><br><span class="line">LDC1 F0,0,-16(R1) </span><br><span class="line">ADDIU R1,R1,-8</span><br><span class="line">BNE  R1,R2,L1</span><br><span class="line">NOP</span><br></pre></td></tr></table></figure>
<h3 id="修改偏移量防止数组越界">2.修改偏移量防止数组越界</h3>
<p>上述代码片段存在越界的问题：</p>
<p>分析：判断循环是否结束的条件是：<code>BNE  R1,R2,L1</code>,也就是判断r1是否越界，R1是递减的，也就是说条件是R1&gt;XX，而上述代码还存在R1-16的值，也就是说当R1满足循环结束条件时，-16(R1)已经越界了，所以需要考虑一个偏移把最后一项归零。这里需要+16：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第i次的循环</span><br><span class="line">L1: LDC1 F0,0,16(R1) </span><br><span class="line">    ADD.D F2,F0,F1</span><br><span class="line">    SDC1  F2,16(R1)</span><br><span class="line"># 第i+1次的循环</span><br><span class="line">    LDC1 F0,0,8(R1) </span><br><span class="line">    ADD.D F2,F0,F1</span><br><span class="line">    SDC1  F2,8(R1)</span><br><span class="line">#第i+2次循环</span><br><span class="line">    LDC1 F0,0,0(R1) </span><br><span class="line">    ADD.D F2,F0,F1</span><br><span class="line">    SDC1  F2,0(R1)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDC1  F2,16(R1)</span><br><span class="line">ADD.D F2,F0,F1</span><br><span class="line">LDC1 F0,0,0(R1) </span><br><span class="line">ADDIU R1,R1,-8</span><br><span class="line">BNE  R1,R2,L1</span><br><span class="line">NOP</span><br></pre></td></tr></table></figure>
<h3 id="延迟槽填充">3.延迟槽填充</h3>
<p>可以考虑把<code>ADDIU R1,R1,-24</code>指令用于填充延迟槽，这样在判断完条件后才会-8，也就是说会多-8越界，所以需要把r1的初始值再偏移8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDC1  F2,24(R1) 8</span><br><span class="line">ADD.D F2,F0,F1</span><br><span class="line">LDC1 F0,0,8(R1) </span><br><span class="line">BNE  R1,R2,L1</span><br><span class="line">ADDIU R1,R1,-8</span><br></pre></td></tr></table></figure>
<h3 id="装入代码">4. 装入代码</h3>
<p>装入就是预处理。</p>
<p>装入代码就是上面这部分代码</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20231105192657593.png" alt="image-20231105192657593" style="zoom:80%;"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第i次的循环</span><br><span class="line">L1: LDC1 F0,0,24(R1) </span><br><span class="line">    ADD.D F2,F0,F1</span><br><span class="line">    SDC1  F2,24(R1)</span><br><span class="line"># 第i+1次的循环</span><br><span class="line">    LDC1 F0,0,16(R1) </span><br><span class="line">    ADD.D F2,F0,F1</span><br><span class="line">    SDC1  F2,16(R1)</span><br><span class="line">#第i+2次循环</span><br><span class="line">    LDC1 F0,0,8(R1) </span><br><span class="line">    ADD.D F2,F0,F1</span><br><span class="line">    SDC1  F2,8(R1)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDC1 F0,0,24(R1) </span><br><span class="line">ADD.D F2,F0,F1</span><br><span class="line">LDC1 F0,0,16(R1) </span><br></pre></td></tr></table></figure>
<p>整个程序第一次取到的应该是0(R1)和0(R2)的值，而后续主循环体中的偏移量是+24，因此要对装入代码的偏移量进行修正对R1-24，这样就24-24=0了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDC1 F0,0,0(R1) </span><br><span class="line">ADD.D F2,F0,F1</span><br><span class="line">LDC1 F0,0,-8(R1) </span><br><span class="line">ADDIU R1,R1,-24</span><br></pre></td></tr></table></figure>
<h3 id="排空代码">5.排空代码</h3>
<p>排空就是收尾</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20231105193621362.png" alt="image-20231105193621362" style="zoom:67%;"></p>
<figure>
<img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20231223142849981.png" alt="image-20231223142849981">
<figcaption aria-hidden="true">image-20231223142849981</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDC1  F2,16(R1)</span><br><span class="line">ADD.D F2,F0,F1</span><br><span class="line">SDC1  F2,8(R1)</span><br></pre></td></tr></table></figure>
<p>因为在循环体里面的延迟槽执行了-8操作，从循环出来还要+8</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SDC1  F2,<span class="number">24</span>(R1)</span><br><span class="line">ADD.D F2,F0,F1</span><br><span class="line">SDC1  F2,<span class="number">16</span>(R1)</span><br></pre></td></tr></table></figure>
<h3 id="软流水后执行周期数计算">软流水后执行周期数计算</h3>
<p>假设R1初始值8n+R2：循环n次</p>
<p>装入代码中：<code>LDC1 F0,0,24(R1)  ADD.D F2,F0,F1</code>
存在数据相关，根据表知道延迟2周期，也就+1拍</p>
<p>同理排空代码中<code>ADD.D F2,F0,F1 SDC1  F2,8(R1)</code>
存在数据相关，延迟3周期+2拍</p>
<p>主循环体5拍</p>
<p>一共：(4+1) + (5*(n-2)) + (3+2) = 5n 拍</p>
<h2 id="例题">例题</h2>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20240115145657013.png"></p>
<p>首先分析相关性：</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20240115145857142.png"></p>
<p>计算主循环代码：在这条关键路径（1-&gt;2-&gt;4-&gt;5）上指令的数量，就是做软件流水时需要展开循环的次数（原因：保证有相关的指令能被分隔到不同循环执行）。</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20240115150010409.png"></p>
<p>指令3和指令4之间有相关，它们之间不能有间隔。因此指令3要和指令2绑定在一起。
不能和1绑定的原因：假如3和1取自同一循环，指令4要使用3（蓝色圈）的结果，但是从左往右执行时，这个结果会被另一个3（红色圈）覆盖。而如果3和2取自同一循环就不会出错。</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20240115150141696.png"></p>
<p>于是我们可以得到下面的表，高亮部分是软件流水的主体循环代码，上方是装入代码，下方是排空代码。</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20240115150253277.png"></p>
<p>首先得到结果如下图左边所示，需要将偏移置零，得到右边</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20240115163136301.png"></p>
<p>这里我们可以看出4需要用的3的寄存器，但是3寄存器和5寄存器是同名的，而5在4之前执行，5本来需要存的是4产生的值。软流水后5变成了存3加载的值，所以需要修改寄存器名</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20240115163154560.png"></p>
<figure>
<img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20240115163215387.png" alt="循环主体">
<figcaption aria-hidden="true">循环主体</figcaption>
</figure>
<p>装入代码是一开始的，所以偏移从0开始。因为主循环有-24的偏移，为了保证进入循环有这个偏移需要+24，如下所示：</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20240115163251278.png"></p>
<p>排空代码本身就有主循环的-24偏移。因为最后会比主循环多+8所以需要还需要再-8，如下所示：</p>
<p><img src="/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AF%E6%B5%81%E6%B0%B4%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/image-20240115163305625.png"></p>
<h2 id="其它参考博客">其它参考博客</h2>
<p><a href="https://blog.csdn.net/diyinqian/article/details/86360396">参考文章1</a></p>
<p><a href="https://blog.csdn.net/csdn_muxin/article/details/114491152?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114491152-blog-86360396.235%5Ev38%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114491152-blog-86360396.235%5Ev38%5Epc_relevant_default_base&amp;utm_relevant_index=2">参考文章2</a></p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>存储管理</title>
    <url>/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="存储管理">存储管理</h1>
<h2 id="tlb基本原理">TLB基本原理</h2>
<p>TLB实际上是操作系统中页表的Cache</p>
<p>TLB主要负责完成用户空间到物理空间的转化</p>
<ul>
<li>一般与Cache访问同时进行</li>
<li>TLB内容：虚地址（Cache的Tag），物理地址（Cache的
Data），保护位（Cache的状态）</li>
<li>TLB失效处理 • TLB失效时需要把相应页表内容从内存取到TLB</li>
<li>TLB失效时硬件（如X86的page
walker）和软件（如MIPS的特殊例外）来填充TLB</li>
</ul>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/image-20240113202408794.png"></p>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/image-20240113202722252.png"></p>
<h3 id="tlb例外类型">TLB例外类型</h3>
<ul>
<li><p>Refill :</p>
<ul>
<li><p>如果查找TLB没有找到一个虚地址匹配（VPN2+ASID/G）</p></li>
<li><p>例外入口：80000000 （除非exl=1）
（<strong>由于TLB失效比较频繁，这里是一个单独的例外入口，不用查找，比较快</strong>）</p></li>
</ul></li>
<li><p>TLB invalid</p>
<ul>
<li>如果找到一个虚地址匹配项，但其v=0（无效）</li>
<li>例外入口：80000180</li>
<li>细分为两种：TLBL for loads, TLBS for stores</li>
</ul></li>
<li><p>TLB modify ：</p>
<ul>
<li><p>如果找到一个虚地址匹配项，其v=1，但D=0且访问为store</p></li>
<li><p>例外入口80000180</p></li>
</ul></li>
</ul>
<h3 id="mips-tlb">mips tlb</h3>
<p>TLB一项对应两个连续的物理地址（一个虚拟地址对应两项）</p>
<figure>
<img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/image-20240113204657916.png" alt="image-20240113204657916">
<figcaption aria-hidden="true">image-20240113204657916</figcaption>
</figure>
<h2 id="tlb例外次数计算">TLB例外次数计算</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Array=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">0x1000</span>)</span><br></pre></td></tr></table></figure>
<p>执行上面的语句后， 用户程序malloc(0x1000)返回虚地址0x450000</p>
<p>操作系统在该进程的vma_struct链表中记录地址范围0x450000-0x4501000为已
分配地址，可读可写。此时分配了<strong>虚拟地址</strong>但是物理地址还没有分配。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">For (I=<span class="number">0</span>;I&lt;<span class="number">1024</span>;I++) Array[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>用户程序试图写0x450000，TLB查找失败，引起一次 tlb refill例外</p>
<p>Tlb refill从相应页表位置取入页表内容填入TLB。但该页表还没初始化</p>
<p>例外返回到用户程序，重新开始访问 ：TLB表项找到，但是无效，发生TLB
Invalid例外</p>
<p>操作系统查找vma_struct，判断该地址已分配，处于可写状态，因此为它分配物理页面，并将物理地址填入页表，更新TLB
，例外返回，写操作再次重试，成功。</p>
<p>用户程序继续写0x450004,008…，因为TLB项已经存在，将全速运行，除非中间
发生进程切换导致其TLB项被换出。如果发生被换出的情况，再次运行时将发生
refill例外从页表取得有效内容，不会再发生invalid例外（refill例外频率&gt;&gt;invalid)）</p>
<p><strong>为什么要分成两次例外</strong></p>
<p>因为TLB更容易失效，而内存（比较大）相对不容易失效。</p>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/image-20240113205920609.png"></p>
<h2 id="tlb-verilog简单实现">TLB verilog简单实现</h2>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tlb_cam(vpn_in, pfn_out, hit, valid_out); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">input</span> [<span class="number">33</span>:<span class="number">0</span>] vpn_in; </span><br><span class="line"><span class="keyword">output</span> [<span class="number">25</span>:<span class="number">0</span>] pfn_out; </span><br><span class="line"><span class="keyword">output</span> hit; </span><br><span class="line"><span class="keyword">output</span> valid_out; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">60</span>:<span class="number">0</span>] cam_content [<span class="number">63</span>:<span class="number">0</span>];<span class="comment">//[60:60] valid [59:34] pfn [33:0] vpn </span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">63</span>:<span class="number">0</span>] entry_hit; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">assign</span> entry_hit[<span class="number">0</span>] = (vpn_in==cam_content[<span class="number">0</span>][<span class="number">33</span>:<span class="number">0</span>]); </span><br><span class="line"><span class="keyword">assign</span> entry_hit[<span class="number">1</span>] = (vpn_in==cam_content[<span class="number">1</span>][<span class="number">33</span>:<span class="number">0</span>]); </span><br><span class="line">…… </span><br><span class="line"><span class="keyword">assign</span> entry_hit[<span class="number">63</span>] = (vpn_in==cam_content[<span class="number">63</span>][<span class="number">33</span>:<span class="number">0</span>]); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">assign</span> hit = |entry_hit; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">assign</span> pfn_out = &#123;<span class="number">26</span>&#123;entry_hit[ <span class="number">0</span>]&#125;&#125; &amp; cam_content[<span class="number">0</span>][<span class="number">59</span>:<span class="number">34</span>] | </span><br><span class="line"> &#123;<span class="number">26</span>&#123;entry_hit[ <span class="number">1</span>]&#125;&#125; &amp; cam_content[<span class="number">1</span>][<span class="number">59</span>:<span class="number">34</span>] | </span><br><span class="line">…… </span><br><span class="line"> &#123;<span class="number">26</span>&#123;entry_hit[<span class="number">63</span>]&#125;&#125; &amp; cam_content[<span class="number">63</span>][<span class="number">59</span>:<span class="number">34</span>]; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">assign</span> valid_out = entry_hit[ <span class="number">0</span>] &amp;&amp; cam_content[ <span class="number">0</span>][<span class="number">60</span>] || </span><br><span class="line"> entry_hit[ <span class="number">1</span>] &amp;&amp; cam_content[ <span class="number">1</span>][<span class="number">60</span>] || </span><br><span class="line"> … </span><br><span class="line"> entry_hit[<span class="number">63</span>] &amp;&amp; cam_content[<span class="number">63</span>][<span class="number">60</span>]; </span><br><span class="line"><span class="keyword">endmodule</span> </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>运算部件</title>
    <url>/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="运算部件">运算部件</h1>
<h2 id="定点补码加法器设计">定点补码加法器设计</h2>
<h3 id="全加器">全加器</h3>
<p>全加器的S有三级门延迟，cout端有两级门延迟。</p>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240112193434166.png"></p>
<h3 id="串行进位加法器">串行进位加法器</h3>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240112194828901.png"></p>
<h3 id="先行进位加法器">先行进位加法器</h3>
<p><strong>进位的传递</strong></p>
<p><span class="math inline">\(g_i\)</span>
是进位生成因子。当相加的两位为1的时候才会产生进位因此：<span class="math inline">\(g_i=a_i*b_i\)</span></p>
<p><span class="math inline">\(p_i\)</span>是进位传递因子，当相加的两位有一个为1的时侯上一级的进位可以传递到下一级，因此<span class="math inline">\(p_t=a_i+b_i\)</span></p>
<p>此时有：<span class="math inline">\(c_{i+1}=pi+g_i*ci\)</span></p>
<p><strong>4位并行进位逻辑</strong></p>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240112195555732.png"></p>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240112195657959.png"></p>
<p>此时可以实现块内并行</p>
<h3 id="块间并行">块间并行</h3>
<p><strong>思路</strong></p>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240112200121104.png"></p>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240112200155944.png"></p>
<p><strong>块间并行加法器</strong></p>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240112200312853.png"></p>
<p>如上图所示，首先a和b生成p，g需要两级门延迟。第一层的p生成第二级的p0-p3,g0-g3输入需要两级门延迟，然后第二层级的p0-p3和C0生成c1-c3（也就是第一级的c4，c8，c12）需要两级门延迟。最后第一级根据c4，c8,c12，生成c4-c15.需要两级门延迟，一共是8级门延迟。如果是生成16位加法器的s15.需要c15与a15，b15经过全加器得到需要3级门延迟。一共是11级门延迟。</p>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240112202228012.png"></p>
<p>同理如果是得到s31需要10+2+3=15级门延迟</p>
<h3 id="加法器的verilog实现">加法器的verilog实现</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> add16(a, b, cin, out, cout); </span><br><span class="line"> <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] a; </span><br><span class="line"> <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] b; </span><br><span class="line"> <span class="keyword">input</span> cin; </span><br><span class="line"> <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] out; </span><br><span class="line"> <span class="keyword">output</span> cout; </span><br><span class="line"> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] p = a|b; </span><br><span class="line"> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] g = a&amp;b; </span><br><span class="line"> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] P, G; </span><br><span class="line"> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] c; </span><br><span class="line"> <span class="keyword">assign</span> c[<span class="number">0</span>] = cin; </span><br><span class="line"> C4 C0_3 (<span class="variable">.p</span>(p[<span class="number">3</span>:<span class="number">0</span>]),<span class="variable">.g</span>(g[<span class="number">3</span>:<span class="number">0</span>]),<span class="variable">.cin</span>(c[<span class="number">0</span>]),<span class="variable">.P</span>(P[<span class="number">0</span>]),<span class="variable">.G</span>(G[<span class="number">0</span>]),<span class="variable">.cout</span>(c[<span class="number">3</span>:<span class="number">1</span>])); </span><br><span class="line"> C4 C4_7 (<span class="variable">.p</span>(p[<span class="number">7</span>:<span class="number">4</span>]),<span class="variable">.g</span>(g[<span class="number">7</span>:<span class="number">4</span>]),<span class="variable">.cin</span>(c[<span class="number">4</span>]),<span class="variable">.P</span>(P[<span class="number">1</span>]),<span class="variable">.G</span>(G[<span class="number">1</span>]),<span class="variable">.cout</span>(c[<span class="number">7</span>:<span class="number">5</span>])); </span><br><span class="line"> C4 C8_11(<span class="variable">.p</span>(p[<span class="number">11</span>:<span class="number">8</span>]),<span class="variable">.g</span>(g[<span class="number">11</span>:<span class="number">8</span>]),<span class="variable">.cin</span>(c[<span class="number">8</span>]),<span class="variable">.P</span>(P[<span class="number">2</span>]),<span class="variable">.G</span>(G[<span class="number">2</span>]),<span class="variable">.cout</span>(c[<span class="number">11</span>:<span class="number">9</span>])); </span><br><span class="line"> C4 C12_15(<span class="variable">.p</span>(p[<span class="number">15</span>:<span class="number">12</span>]),<span class="variable">.g</span>(g[<span class="number">15</span>:<span class="number">12</span>]),<span class="variable">.cin</span>(c[<span class="number">12</span>]),<span class="variable">.P</span>(P[<span class="number">3</span>]),<span class="variable">.G</span>(G[<span class="number">3</span>]),<span class="variable">.cout</span>(c[<span class="number">15</span>:<span class="number">13</span>])); </span><br><span class="line"> C4 C_INTER(<span class="variable">.p</span>(P),<span class="variable">.G</span>(G),<span class="variable">.cin</span>(c[<span class="number">0</span>]),<span class="variable">.P</span>(),<span class="variable">.G</span>(),<span class="variable">.cout</span>(&#123;c[<span class="number">12</span>],c[<span class="number">8</span>],c[<span class="number">4</span>]&#125;)); </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">assign</span> cout = (a[<span class="number">15</span>]&amp;b[<span class="number">15</span>]) | (a[<span class="number">15</span>]&amp;c[<span class="number">15</span>]) | (b[<span class="number">15</span>]&amp;c[<span class="number">15</span>]); </span><br><span class="line"> <span class="keyword">assign</span> out = (~a&amp;~b&amp;c)|(~a&amp;b&amp;~c)|(a&amp;~b&amp;~c)|(a&amp;b&amp;c); </span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> C4(p,g,cin,P,G,cout) </span><br><span class="line"> <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] p, g; </span><br><span class="line"> <span class="keyword">input</span> cin; </span><br><span class="line"> <span class="keyword">output</span> P,G; </span><br><span class="line"> <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] cout; </span><br><span class="line"> <span class="keyword">assign</span> P=&amp;p; </span><br><span class="line"> <span class="keyword">assign</span> G=g[<span class="number">3</span>]|(p[<span class="number">3</span>]&amp;g[<span class="number">2</span>])|(p[<span class="number">3</span>]&amp;p[<span class="number">2</span>]&amp;g[<span class="number">1</span>])|(p[<span class="number">3</span>]&amp;p[<span class="number">2</span>]&amp;p[<span class="number">1</span>]&amp;g[<span class="number">0</span>]);  </span><br><span class="line"> <span class="keyword">assign</span> cout[<span class="number">0</span>]=g[<span class="number">0</span>]|(p[<span class="number">0</span>]&amp;cin); </span><br><span class="line"> <span class="keyword">assign</span> cout[<span class="number">1</span>]=g[<span class="number">1</span>]|(p[<span class="number">1</span>]&amp;g[<span class="number">0</span>])|(p[<span class="number">1</span>]&amp;p[<span class="number">0</span>]&amp;cin); </span><br><span class="line"> <span class="keyword">assign</span> cout[<span class="number">2</span>]=g[<span class="number">2</span>]|(p[<span class="number">2</span>]&amp;g[<span class="number">1</span>])|(p[<span class="number">2</span>]&amp;p[<span class="number">1</span>]&amp;g[<span class="number">0</span>])|(p[<span class="number">2</span>]&amp;p[<span class="number">1</span>]&amp;p[<span class="number">0</span>]&amp;cin); </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="booth乘法器">BOOTH乘法器</h2>
<h3 id="补码乘法原理">补码乘法原理</h3>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240112233013561.png"></p>
<h3 id="booth算法">Booth算法</h3>
<figure>
<img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240112233435404.png" alt="基本原理">
<figcaption aria-hidden="true">基本原理</figcaption>
</figure>
<h3 id="booth二位一乘算法">Booth二位一乘算法</h3>
<p>对于16位乘法一位Booth算法还是需要计算32个数的加法，使用二位一乘后加法只需要进行16个数的相加。</p>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240112233659387.png"></p>
<h3 id="booth两位乘电路">Booth两位乘电路</h3>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240112234147018.png"></p>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240112235842919.png"></p>
<h2 id="华莱士树">华莱士树</h2>
<p>利用全加器减小加法数量，全加器把三个加数变成两个加数</p>
<h3 id="基本思想">基本思想</h3>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240113000223881.png"></p>
<h3 id="结构">结构</h3>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240113000407627.png"></p>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240113000458439.png"></p>
<p>华莱士树进位连接要求
：进位输入信号必须接到进位输出该信号层次的上一层或更高</p>
<p>不这样连接的后果：</p>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240113000607824.png"></p>
<h3 id="位华莱士树">16位华莱士树</h3>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240113084933537.png"></p>
<h2 id="位定点补码乘法器">32位定点补码乘法器</h2>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240113085202444.png"></p>
<p><img src="/2024/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/image-20240113085618753.png"></p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>转移猜测</title>
    <url>/2024/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AC%E7%A7%BB%E7%8C%9C%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="转移猜测">转移猜测</h1>
<h2 id="转移指令的控制相关">转移指令的控制相关</h2>
<p>以单发射为例：</p>
<ul>
<li><p>如果转移指令计算下一条指令地址在EX阶段计算，下一条指
令等2拍</p></li>
<li><p>如果使用专门的地址运算部件把地址计算提前到<code>译码阶段</code>可以少等一拍</p></li>
<li><p>使用一个delay slot可以不用等待</p></li>
</ul>
<p>​ 但是多发射情况下延迟槽成为需要专门照顾的负担</p>
<p><img src="/2024/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AC%E7%A7%BB%E7%8C%9C%E6%B5%8B/image-20240111233007142.png"></p>
<h2 id="转移指令对性能的影响">转移指令对性能的影响</h2>
<p><img src="/2024/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AC%E7%A7%BB%E7%8C%9C%E6%B5%8B/image-20240111233231910.png"></p>
<p>第10级产生结果，如果等待，前9级流水线stall-》4*9=36个气泡。总容量是：36+8（8是执行的8条指令，因为每8条遇到一个转移指令
）</p>
<h2 id="如何减少控制相关">如何减少控制相关</h2>
<h3 id="延迟槽与局限性">延迟槽与局限性</h3>
<figure>
<img src="/2024/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AC%E7%A7%BB%E7%8C%9C%E6%B5%8B/image-20240111234208073.png" alt="延迟槽局限性">
<figcaption aria-hidden="true">延迟槽局限性</figcaption>
</figure>
<h3 id="循环展开">循环展开</h3>
<p>会造成代码膨胀</p>
<p><img src="/2024/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AC%E7%A7%BB%E7%8C%9C%E6%B5%8B/image-20240111234313234.png"></p>
<p>循环展开后数据相关又分为循环内相关和循环间相关。循环内相关导致一个循环体内的多
条指令不能并行执行，循环间相关 导致多个循环体不能并行执行。</p>
<p><img src="/2024/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AC%E7%A7%BB%E7%8C%9C%E6%B5%8B/image-20240111234514175.png"></p>
<h3 id="软流水">软流水</h3>
<p>新循环体的每个操作来自不同的循环体，
以分开数据相关的指令，相当于软件的 Tomasulo算法</p>
<p>符号级循环展开，比真正循环展开代码开销小，不会造成代码膨胀。</p>
<h2 id="硬件转移预测">硬件转移预测</h2>
<h3 id="基本思想">基本思想</h3>
<p><img src="/2024/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AC%E7%A7%BB%E7%8C%9C%E6%B5%8B/image-20240111234824835.png"></p>
<p>精确例外的难点： 如何识别流水线中的指令哪些需要取消，哪些不要取消</p>
<p>例外取消一般在提交时，取消所有后续指令但是转移取消一般在执行后，只取消部分指令</p>
<p>预测思路：</p>
<p><img src="/2024/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AC%E7%A7%BB%E7%8C%9C%E6%B5%8B/image-20240111234958572.png"></p>
<h3 id="局部转移预测">局部转移预测</h3>
<p>独立考虑单个循环的历史记录，寻找其中的重复性规律，
并根据该规律预测未来的转移行为 •
对于重复性特征明显的转移指令（如循环）效果好</p>
<h4 id="bht">bht</h4>
<figure>
<img src="/2024/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AC%E7%A7%BB%E7%8C%9C%E6%B5%8B/image-20240111235908000.png" alt="一位BHT">
<figcaption aria-hidden="true">一位BHT</figcaption>
</figure>
<p>采用两位BHT(branch history table)</p>
<figure>
<img src="/2024/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%BD%AC%E7%A7%BB%E7%8C%9C%E6%B5%8B/image-20240111235802139.png" alt="BHT">
<figcaption aria-hidden="true">BHT</figcaption>
</figure>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>多发射数据通路</title>
    <url>/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="多发射数据通路">多发射数据通路</h1>
<h2 id="指令级并行的关键技术">指令级并行的关键技术</h2>
<ul>
<li><p>指令流水线: 时间重叠</p></li>
<li><p>多发射: 空间重复</p></li>
<li><p>乱序执行（有序结束）: 充分利用资源</p></li>
<li><p>动态调度：前面指令因相关而等待时，后面的可继续前进。</p></li>
<li><p>转移猜测：在转移条件确定前，猜测某个分支取指并执行</p></li>
<li><p>非阻塞访存：提高访存指令执行效率，减少访存阻塞</p></li>
</ul>
<h2 id="指令缓存保留站结构">指令缓存(保留站）结构</h2>
<ul>
<li>独立保留站：每个功能部件一个保留站</li>
<li>分组保留站：多个功能部件共享保留站</li>
<li>全局保留站：所有功能部件共享保留站</li>
</ul>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240111092616629.png" alt="独立保留站">
<figcaption aria-hidden="true">独立保留站</figcaption>
</figure>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240111092702540.png" alt="分组保留站">
<figcaption aria-hidden="true">分组保留站</figcaption>
</figure>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240111092723119.png" alt="全局保留站">
<figcaption aria-hidden="true">全局保留站</figcaption>
</figure>
<h2 id="寄存器与保留站的关系">寄存器与保留站的关系</h2>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240111092933855.png"></p>
<h2 id="寄存器重命名方法">寄存器重命名方法</h2>
<p>双重作用</p>
<ul>
<li>例外或转移猜测错误时取消后面操作</li>
<li>解决WAR和WAW相关</li>
</ul>
<p>核心思想</p>
<ul>
<li><p>一个操作写寄存器时重命名到其他寄存器</p></li>
<li><p>一个操作结束时再写到结构寄存器</p></li>
</ul>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240111093142281.png" alt="重命名方法">
<figcaption aria-hidden="true">重命名方法</figcaption>
</figure>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240111093320600.png" alt="物理寄存器到逻辑寄存器映射重命名">
<figcaption aria-hidden="true">物理寄存器到逻辑寄存器映射重命名</figcaption>
</figure>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240111093939285.png"></p>
<p>使用物理寄存器堆的重命名算法执行流程：</p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240111093606833.png"></p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240111093619867.png"></p>
<p><strong>例子</strong></p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240112101445919.png"></p>
<h2 id="yeh和patt">Yeh和patt</h2>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240112101515801.png" alt="分类">
<figcaption aria-hidden="true">分类</figcaption>
</figure>
<h3 id="两层自适应预测器组合情况">两层自适应预测器组合情况</h3>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240112101649869.png" alt="组合情况">
<figcaption aria-hidden="true">组合情况</figcaption>
</figure>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240112101816349.png" alt="具体结构">
<figcaption aria-hidden="true">具体结构</figcaption>
</figure>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240112101904793.png"></p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240112102241440.png"></p>
<h2 id="分支别名干扰问题">分支别名干扰问题</h2>
<p>无论BHR和PHT表如何增大，效果也不是很明显</p>
<p>主要原因是不同分支地址访问同一个PHT，造成分支干扰</p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240112102443209.png"></p>
<h3 id="gshare和gselect">gshare和gselect</h3>
<p>gselect使用地址拼接，gshare使用hash</p>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240112102945110.png" alt="0">
<figcaption aria-hidden="true">0</figcaption>
</figure>
<h3 id="agree分支预测">Agree分支预测</h3>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240112103323331.png" alt="原理">
<figcaption aria-hidden="true">原理</figcaption>
</figure>
<p>这里BTB是为了减少猜测延迟，BTB就是一个查找表本质上是一个cache，这张表只有一个输入key：pc，输出转移目标地址。</p>
<p>需要进行地址全相等比较，直接预测PC值而不是根据指令内容计算
，失效时进行替换</p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240112103702254.png"></p>
<p>BTB的BHT里面填的是taken/not
taken的倾向值。PHT里面存的是同意BHT的判断or不同意BHT的判断</p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/image-20240112104027211.png"></p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>动态流水线</title>
    <url>/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="动态流水线">动态流水线</h1>
<h2 id="编译器静态调度">编译器静态调度</h2>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110224505607.png" alt="静态调度">
<figcaption aria-hidden="true">静态调度</figcaption>
</figure>
<h3 id="循环展开技术"><strong>循环展开技术</strong></h3>
<p>会造成代码膨胀，可以减少转移指令执行的次数，可以通过换位置消除一定的相关</p>
<h2 id="硬件动态调度">硬件动态调度</h2>
<h3 id="动态调度基本思想">动态调度基本思想</h3>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240111002043089.png" alt="动态调度基本思想">
<figcaption aria-hidden="true">动态调度基本思想</figcaption>
</figure>
<p>名字相关：</p>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240111002234348.png" alt="名字相关">
<figcaption aria-hidden="true">名字相关</figcaption>
</figure>
<p>解决方法：</p>
<ul>
<li>每个功能部件的输入端有一些寄存器</li>
<li>每个寄存器（包括功能部件输入端的寄存器以及通用寄存器）都记录一个功能部件号，指定它当前接收哪个功能部件的值</li>
<li>每个功能部件的输出接到每个功能部件的输入</li>
</ul>
<p>有了上述功能，WAR和WAW相关不用阻塞</p>
<h3 id="tomasulo算法">Tomasulo算法</h3>
<p>保留站：是将有序执行变为乱序执行的地方。</p>
<p>ROB：是将无序变成有序的地方，保证乱序执行有序退出以实现精确例外。</p>
<h4 id="精确例外"><strong>精确例外</strong></h4>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240111003146708.png" alt="精确例外">
<figcaption aria-hidden="true">精确例外</figcaption>
</figure>
<p>如何实现：</p>
<ul>
<li>实现精确例外处理的一个办法是把后面指令对机器状态的修改延迟到前面指令都已经执行完
，有些指令在EX阶段也修改机器状态，如运算指令修改结果状态</li>
<li>在执行阶段停止流水线会影响后面的指令执行可以用一些缓冲器来临时保存执行结果，当前面所有指令执行完后,
再把保存在缓冲器中的结果写回到寄存器或存储器</li>
<li>在流水线修改机器状态时（在执行或写回阶段）写到缓冲器增加提交（Commit）阶段，把缓冲器的内容写回到寄存器或存储器</li>
<li>提交阶段只有前面指令都结束后才能进行
<ul>
<li>有序提交：乱序执行，有序结束</li>
<li>所用的缓冲器通常被称为Reorder Buffer（ROB）
（在猜测执行中也用上述机制
：都是在某些情况不确定的情况下先执行，但留有反悔的余地）</li>
</ul></li>
</ul>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240111003837109.png" alt="ROB">
<figcaption aria-hidden="true">ROB</figcaption>
</figure>
<h4 id="tomasulo算法的流水阶段带精确例外"><strong>Tomasulo算法的流水阶段</strong>（带精确例外）</h4>
<figure>
<img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240111003949071.png" alt="流水线">
<figcaption aria-hidden="true">流水线</figcaption>
</figure>
<h4 id="tomasulo过程"><strong>Tomasulo过程</strong></h4>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240111004340173.png"></p>
<p>DIV指令需要用到寄存器F0，结果要写回ROB的1号项，需要的操作数都已经准备好了不用等待</p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240111004928250.png"></p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240111004958203.png"></p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240111005023628.png"></p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240111005109003.png"></p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240111005204449.png"></p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240111005342405.png"></p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240111005454727.png"></p>
<p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240111085703895.png"></p>
<h2 id="动态流水小结">动态流水小结</h2>
<p>核心：<code>有序进入、乱序执行（允许超车）、有序结束</code></p>
<p>主要数据结构</p>
<ul>
<li>保留站（发射队列）把有序变成乱序，临时存指令</li>
<li>重命名寄存器用于保存未提交的临时结果，临时存数据</li>
<li>ROB把乱序重新变成有序</li>
</ul>
<p>乱序的能力和有关队列大小紧密相关</p>
<ul>
<li>现代高性能CPU一般都有100条以上指令在流水线中乱序执行</li>
</ul>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>静态流水线</title>
    <url>/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="静态流水线">静态流水线</h1>
<h2 id="标准五级静态流水线">标准五级静态流水线</h2>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110141429147.png" alt="五级静态流水线">
<figcaption aria-hidden="true">五级静态流水线</figcaption>
</figure>
<p>按照上面的设计，指令流水线是五级流水线如下图所示。</p>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110141557595.png" alt="标准指令流水线">
<figcaption aria-hidden="true">标准指令流水线</figcaption>
</figure>
<h3 id="if-取指">IF 取指</h3>
<p>IF阶段pc取指，从上图中可以看出，pc取值有俩个来源：pc+4即顺序取值。和来自转移指令计算得到的地址。从下图中可以看出，当为转移指令时，地址是立即数的有符号扩展（有符号表明PC指针可以往前跳也可以往后跳）。这个MUX2的控制逻辑由两部分组成：判断指令是不是条件转移指令(C1),以及是否满足跳转条件（由cond产生）。</p>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110142341788.png" alt="IF的PC">
<figcaption aria-hidden="true">IF的PC</figcaption>
</figure>
<p>转移指令是否跳转如果在EX执行阶段才能算出来的话，会导致流水线堵塞两拍（下级的IF要到EX执行完以后才能完成）。因此为例减少堵塞，转移指令的地址在cond也就是ID阶段就完成了判断。这样后面只需要卡一拍。MIPS为了解决这个问题，设计了转移指令延迟槽，也就是不管指令要不要跳转，转移指令的下一条指令都要执行，这样就避免了流水线阻塞。一般可以通过调度，填充NOP提高效率，如下所示。</p>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110143242112.png" alt="延迟槽">
<figcaption aria-hidden="true">延迟槽</figcaption>
</figure>
<h3 id="id译码">ID译码</h3>
<p>以MIPS为例，根据指令格式进行译码，然后从寄存器中读数为执行级做准备。转移指令比较特殊，会在ID判断是否需要taken</p>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110154829572.png" alt="指令格式">
<figcaption aria-hidden="true">指令格式</figcaption>
</figure>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110154732175.png" alt="指令译码">
<figcaption aria-hidden="true">指令译码</figcaption>
</figure>
<h3 id="ex执行与alu">EX执行与ALU</h3>
<p>ALU简单的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module alu_module </span><br><span class="line">( </span><br><span class="line"> input [ 3:0] aluop, </span><br><span class="line"> input [31:0] in1, </span><br><span class="line"> input [31:0] in2, </span><br><span class="line"> output [31:0] out </span><br><span class="line">); </span><br><span class="line">wire slt_res; </span><br><span class="line">assign slt_res = (in1[31] &amp;&amp; !in2[31]) &amp; 1’b1 | </span><br><span class="line"> (in1[31] &amp;&amp; in2[31] ) &amp; (in1&lt;in2) | </span><br><span class="line"> (!in1[31] &amp;&amp; !in2[31]) &amp; (in1&lt;in2) | </span><br><span class="line"> (!in1[31] &amp;&amp; in2[31]) &amp; 1’b0;  </span><br><span class="line">assign out = </span><br><span class="line">&#123;32&#123;aluop==4’b0000&#125;&#125; &amp; (in1+in2) | </span><br><span class="line"> &#123;32&#123;aluop==4’b0001&#125;&#125; &amp; (in1-in2) |  &#123;32&#123;aluop==4’b0010&#125;&#125; &amp; &#123;31’b0, slt_res&#125; | </span><br><span class="line"> &#123;32&#123;aluop==4’b0011&#125;&#125; &amp; &#123;31’b0, in1&lt;in2&#125; | </span><br><span class="line"> &#123;32&#123;aluop==4’b0100&#125;&#125; &amp; (in1&amp;in2) | </span><br><span class="line"> &#123;32&#123;aluop==4’b0101&#125;&#125; &amp; (in1|in2) | </span><br><span class="line"> &#123;32&#123;aluop==4’b0110&#125;&#125; &amp; (in1^in2) | </span><br><span class="line"> &#123;32&#123;aluop==4’b0111&#125;&#125; &amp; ~(in1|in2) | </span><br><span class="line"> &#123;32&#123;aluop==4’b1000&#125;&#125; &amp; (in1&lt;&lt;in2) | </span><br><span class="line"> &#123;32&#123;aluop==4’b1010&#125;&#125; &amp; (in1&gt;&gt;in2) | </span><br><span class="line"> &#123;32&#123;aluop==4’b1011&#125;&#125; &amp; ($signed(in1)&gt;&gt;&gt;in2); //verilog2001 中算术</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="简单例子">简单例子</h3>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110143755060.png" alt="例题">
<figcaption aria-hidden="true">例题</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LW R2,0(R1)</span><br><span class="line">LW R3,4(R1)</span><br><span class="line">ADD R4,R2,R3</span><br><span class="line">SUB R5,R2,R4</span><br><span class="line">SW R4,0(R1)</span><br><span class="line">SW R5,4(R1)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110144430333.png" alt="时空图">
<figcaption aria-hidden="true">时空图</figcaption>
</figure>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110144504481.png" alt="时空图">
<figcaption aria-hidden="true">时空图</figcaption>
</figure>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110144522280.png" alt="时空图">
<figcaption aria-hidden="true">时空图</figcaption>
</figure>
<h2 id="指令相关和流水线冲突">指令相关和流水线冲突</h2>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110152327011.png" alt="指令相关">
<figcaption aria-hidden="true">指令相关</figcaption>
</figure>
<h3 id="数据相关">数据相关</h3>
<p>数据相关按照读写次序可以分为三种：RAW,WAR,WAW</p>
<p>RAW:<strong>后面指令用到前面指令所写的数据</strong> ,是真相关</p>
<p>WAW和WAR又称为名字相关，是寄存器相同导致的相关，可以通过寄存器重命名来消除</p>
<p><strong>WAW(Write After Write)</strong></p>
<ul>
<li><p><strong>两条指令写同一个单元</strong></p></li>
<li><p><strong>在简单流水线中没有此类相关，因为不会乱序执行</strong>。乱序执行后存在WAW</p></li>
</ul>
<p><strong>WAR(Write After Read)</strong></p>
<ul>
<li><p><strong>后面指令覆盖前面指令所读的单元</strong></p></li>
<li><p><strong>在简单流水线中没有此类相关</strong>,在乱序执行时会遇到这类相关</p></li>
</ul>
<p><strong>访存相关</strong>：寄存器不一样但是内存物理地址可能相同造成的相关，这个比较麻烦，因为虚实地址转换是比较慢的。</p>
<p>请给出一种在多发射动态调度的处理器上解决访存相关的方案。</p>
<p>1）使用 store buffer 来作为一个临时性位置存放写操作的值。在 store
指令提交的时候才写入到 cache 中。</p>
<p>2）store 指令按程序的顺序写回到 cache 中。任何访问相同地址的 load
可以从之前的 store 指令中获得值，即 load forwarding 技术</p>
<p>3）两种方法：一是非推测的方法，后续的 load 指令不能超过前面的 store
指令，通常采用 load forwarding 技术；二是推测的方法，speculative load
execution。例如一条 store 指令后面有一条 load 指令，而 store
指令的访存地址还没有计算出来，很可能 load 的地址 就是 store
的指令的地址，因此可能存在着 RAW 相关。推测的方法 speculative load-store
reordering
是一种推测执行的技术，就像分支预测之后的推测执行一样，可以把阻塞的 store
指令之后的 load 指令提前执行，等 store 指令访存地址计算之后，和其后续的
load 指令的访存地址进行比较，如果访存地址有交叉，则需要取消该 load
指令，以及和它相关 的后续指令，重新开始执行，和分支误预测一样处理</p>
<h3 id="控制相关">控制相关</h3>
<p>例如转移指令造成的相关</p>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110153448016.png" alt="控制相关">
<figcaption aria-hidden="true">控制相关</figcaption>
</figure>
<h3 id="结构相关">结构相关</h3>
<p>两条指令要同时访问流水线中同一个功能部件造成的。例如控制相关本质上就是PC指针的控制相关</p>
<h2 id="流水线前递技术">流水线前递技术</h2>
<p>如下所示就是EX和MEM实现前递的通路，前递后下一级需要使用寄存器的值就不用等到wb写回后才能完成ID了，可以减少流水线阻塞。</p>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110153856677.png" alt="流水线前递">
<figcaption aria-hidden="true">流水线前递</figcaption>
</figure>
<p>寄存器堆的读写端口内部也可以做前递即WB级的前递。</p>
<h3 id="例子">例子</h3>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110145145900.png" alt="例子">
<figcaption aria-hidden="true">例子</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADDIU R5,R0,N</span><br><span class="line">SLL R5,R5 ,3</span><br><span class="line">LOOP: LWC1 F1,0(R1) </span><br><span class="line">      LWC1 F2,0(R2)</span><br><span class="line">      MUL.D F3,F0,F1     </span><br><span class="line">      ADD.D F4,F2,F3</span><br><span class="line">      ADDIU R1,R1,#8</span><br><span class="line">      ADDIU R2,R2,#8</span><br><span class="line">      BNE R1,R5,LOOP</span><br><span class="line">      SDC1 F1,-8(R1)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110151511119.png" alt="image-20240110151511119">
<figcaption aria-hidden="true">image-20240110151511119</figcaption>
</figure>
<h2 id="takennot-taken-策略">taken/not taken 策略</h2>
<p>taken：默认会发生跳转，所以取指是取要跳转的指令</p>
<p>not taken：默认不会发生跳转，取下一条指令</p>
<h3 id="例子-1">例子</h3>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110181540330.png" alt="taken/not taken">
<figcaption aria-hidden="true">taken/not taken</figcaption>
</figure>
<ol type="1">
<li></li>
</ol>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110185806306.png" alt="image-20240110185806306">
<figcaption aria-hidden="true">image-20240110185806306</figcaption>
</figure>
<figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110185827228.png" alt="image-20240110185827228">
<figcaption aria-hidden="true">image-20240110185827228</figcaption>
</figure>
<ol start="2" type="1">
<li><figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110190324885.png" alt="image-20240110190324885">
<figcaption aria-hidden="true">image-20240110190324885</figcaption>
</figure></li>
<li><figure>
<img src="/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20240110191359992.png" alt="image-20240110191359992">
<figcaption aria-hidden="true">image-20240110191359992</figcaption>
</figure></li>
</ol>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 信号和定时器</title>
    <url>/2024/01/01/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E4%BF%A1%E5%8F%B7%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="linux-信号">Linux 信号</h1>
<h2 id="什么是信号">什么是信号</h2>
<p>linux系统中无时无该产生着信号．信号在linux上又称<strong>软件中断</strong>，用来通知进程发生了<strong>异步事件</strong>。在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。</p>
<h2 id="发送信号处理信号">发送信号处理信号</h2>
<p>linux下通过<code>kill</code>函数由一个进程向另一个进程发送信号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(pid_d pid,<span class="type">int</span> sig)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/01/01/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E4%BF%A1%E5%8F%B7%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/image-20240124222756948.png"></p>
<p>SIG_DFL 使用信号的默认处理方式。SIG_IGN 表示忽略目标信号</p>
<p><strong>中断系统调用：</strong></p>
<p>当程序（处于阻塞状态）执行系统调用时收到信号，且已经为信号设置了信号处理函数，则默认情况下<strong>系统调用将被中断</strong>。可以使用sigaction
函数设置标志以自动重启被信号中断的系统调用。对于LINUX来说：如果默认行为是暂停进程的信号（SIGSTOP,SIGTTIN)就算我们不设置信号处理函数，这类信号也可以中断模型系统调用例如：（connect，epoll_wait)</p>
<h2 id="信号集">信号集</h2>
<p>linux使用数据结构sigset_t来表示一组信号，本质上是一个长整型数组，数组的每个元素的每个位表示一个信号（位图）</p>
<p>设置进程信号掩码以后，被屏蔽的信号不会被进程接收。</p>
<h2 id="统一事件源">统一事件源</h2>
<h3 id="为啥要统一事件源">为啥要统一事件源：</h3>
<p>信号处理是一种异步的事件：信号处理函数和程序主循环是两条不同的执行路线</p>
<p>为了避免一些竞态条件，信号处理期间，系统不会再次触发它（借助进程信号掩码的机制，进程即使多次收到同一个被挂起的信号，sigpending函数也只能反映一次，因此在使用sigprocmask使能挂起信号的时候信号处理函数只能触发一次）</p>
<p>所以说如果信号处理的时间过久，就相当于该类信号被屏蔽了很久，因此我们希望处理时间越短越好（有点类似于中断处理函数不能太长）</p>
<p>解决方法是：信号处理被触发时通知主循环执行对应处理的逻辑代码，信号处理函数往管道端写入信号值，主循环从管道端读出该信号值。</p>
<h3 id="什么是统一事件源">什么是统一事件源：</h3>
<p>使用IO复用系统调用来监听管道描述符上的可读事件。这样信号事件就可以和其它的I/O事件一样被处理，即统一事件源。（指的是信号处理和其它I/O事件处理触发来源统一）</p>
<h3 id="简单实现">简单实现</h3>
<p>部分较为重要的函数：</p>
<p><code>epoll_event</code> 是 Linux 中 epoll 事件的结构体，定义在
<code>&lt;sys/epoll.h&gt;</code> 头文件中。它包含以下字段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> events; <span class="comment">// 表示关注的事件类型（EPOLLIN、EPOLLOUT等）</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">// 用户数据（可以是一个指针或者文件描述符等）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 epoll 的基本步骤如下：</p>
<ol type="1">
<li><p>创建一个 epoll
实例：<code>int epoll_fd = epoll_create(MAX_EVENT_NUMBER);</code></p></li>
<li><p>向 epoll
实例中添加关注的事件：<code>epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);</code></p></li>
<li><p>等待事件发生：<code>int event_count = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER, timeout);</code></p></li>
<li><p>处理发生的事件：遍历 <code>events</code>
数组，处理每个事件。</p></li>
</ol>
<p>在这个过程中，<code>events</code> 数组就用于存储发生的 epoll
事件，每个元素都是一个 <code>epoll_event</code> 结构体。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">( <span class="type">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用 fcntl 函数，获取指定文件描述符 fd 的文件状态标志。</span></span><br><span class="line">    <span class="comment">//这个标志包含了文件的访问模式（读、写、追加等）以及其他特殊标志。</span></span><br><span class="line">    <span class="comment">//这一步用于保存原来的文件状态标志</span></span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>( fd, F_GETFL );</span><br><span class="line">    <span class="comment">//通过按位或运算，将 O_NONBLOCK（非阻塞标志）添加到原来的文件状态标志中。</span></span><br><span class="line">    <span class="comment">//这就将文件描述符设置为非阻塞模式，表示 I/O 操作将是非阻塞的。</span></span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="comment">//// 设置新的文件状态标志</span></span><br><span class="line">    <span class="built_in">fcntl</span>( fd, F_SETFL, new_option );</span><br><span class="line">    <span class="comment">//返回修改后的文件标志</span></span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">( <span class="type">int</span> epollfd, <span class="type">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//epoll_event event;：创建一个 epoll 事件结构体 event，用于描述要添加的文件描述符 fd 的关注事件。</span></span><br><span class="line">    epoll_event event;</span><br><span class="line">    <span class="comment">//event.data.fd = fd;：设置 event 结构体中的 data.fd 字段，表示关注的文件描述符。</span></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    <span class="comment">//设置 event 结构体中的 events 字段，表示关注的事件类型。在这里，</span></span><br><span class="line">    <span class="comment">//设置为 EPOLLIN 表示关注可读事件，EPOLLET 表示使用边缘触发模式（Edge Triggered）。</span></span><br><span class="line">    <span class="comment">//边缘触发模式要求对文件描述符的读写操作一旦发生变化就会触发一次事件通知</span></span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="comment">//调用 epoll_ctl 函数，将文件描述符 fd 添加到 epoll 实例 epollfd 中，并设置关注的事件类型和其他参数。</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_ADD, fd, &amp;event );</span><br><span class="line">    <span class="built_in">setnonblocking</span>( fd );<span class="comment">//设为非阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_handler</span><span class="params">( <span class="type">int</span> sig )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line">    <span class="type">int</span> msg = sig;</span><br><span class="line">    <span class="built_in">send</span>( pipefd[<span class="number">1</span>], ( <span class="type">char</span>* )&amp;msg, <span class="number">1</span>, <span class="number">0</span> );</span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addsig</span><span class="params">( <span class="type">int</span> sig )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    <span class="built_in">memset</span>( &amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>( sa ) );</span><br><span class="line">    sa.sa_handler = sig_handler;</span><br><span class="line">    sa.sa_flags |= SA_RESTART;</span><br><span class="line">    <span class="built_in">sigfillset</span>( &amp;sa.sa_mask );</span><br><span class="line">    <span class="built_in">assert</span>( <span class="built_in">sigaction</span>( sig, &amp;sa, <span class="literal">NULL</span> ) != <span class="number">-1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( listenfd &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int nReuseAddr = 1;</span></span><br><span class="line">    <span class="comment">//setsockopt( listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;nReuseAddr, sizeof( nReuseAddr ) );</span></span><br><span class="line">    ret = <span class="built_in">bind</span>( listenfd, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    <span class="keyword">if</span>( ret == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is %d\n&quot;</span>, errno );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//assert( ret != -1 );</span></span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( listenfd, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    epoll_event events[ MAX_EVENT_NUMBER ];</span><br><span class="line">    <span class="comment">//events是用于存储 epoll 事件的数组声明。</span></span><br><span class="line">    <span class="comment">//在使用 Linux 中的 epoll I/O 多路复用机制时，需要使用 epoll_event 结构体来描述关注的事件以及发生的事件。</span></span><br><span class="line">    <span class="comment">/*epoll_create 是一个系统调用，用于创建一个 epoll 实例。</span></span><br><span class="line"><span class="comment">    它接受一个整数参数，表示要为 epoll 实例预留的文件描述符数量的大小。5 是传递给 epoll_create 的参数，</span></span><br><span class="line"><span class="comment">    表示要为 epoll 实例预留的文件描述符数量。</span></span><br><span class="line"><span class="comment">    在这里，5 是一个初始值，指示 epoll 实例可能会关注的文件描述符数量。</span></span><br><span class="line"><span class="comment">    这个值在创建 epoll 实例时并不是一个硬性要求，只是一个建议值。</span></span><br><span class="line"><span class="comment">    epollfd 是一个整数变量，用于存储 epoll 实例的文件描述符。这个文件描述符可以用于后续的 epoll 操作，比如将关注的文件描述     符添加到 epoll 实例中、等待事件的发生等。*/</span></span><br><span class="line">    <span class="type">int</span> epollfd = <span class="built_in">epoll_create</span>( <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( epollfd != <span class="number">-1</span> );</span><br><span class="line">    <span class="built_in">addfd</span>( epollfd, listenfd );</span><br><span class="line">    <span class="comment">//socketpair 是一个系统调用，用于创建一对相互连接的套接字。这对套接字可以在进程之间进行通信。</span></span><br><span class="line">    <span class="comment">//PF_UNIX 表示使用 Unix 域套接字（Unix domain socket）。Unix 域套接字用于在同一台主机上的进程之间进行通信，</span></span><br><span class="line">    <span class="comment">//而不涉及网络协议。</span></span><br><span class="line">    <span class="comment">//SOCK_STREAM 表示创建的套接字是面向连接的流套接字。这种套接字提供了可靠的、基于流的、双向的连接</span></span><br><span class="line">    <span class="comment">//0 是协议类型的参数，通常可以设置为 0，表示由系统选择合适的协议。</span></span><br><span class="line">    <span class="comment">//pipefd 是一个长度为 2 的数组前面定义的静态变量，用于存储创建的两个套接字的文件描述符。</span></span><br><span class="line">    <span class="comment">//pipefd[0] 是读取端，pipefd[1] 是写入端。</span></span><br><span class="line">    ret = <span class="built_in">socketpair</span>( PF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line">    <span class="comment">//设置指定文件描述符 （写入端：即socket的输入端，另一台主机通过tcp/udp发送过来的端口） 为非阻塞模式</span></span><br><span class="line">    <span class="built_in">setnonblocking</span>( pipefd[<span class="number">1</span>] );</span><br><span class="line">    <span class="comment">//将进程之间通信的文件描述符设为可读，边沿触发并与epollfd绑定</span></span><br><span class="line">    <span class="built_in">addfd</span>( epollfd, pipefd[<span class="number">0</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add all the interesting signals here</span></span><br><span class="line">    <span class="comment">//调用了 addsig 函数，用于注册信号处理函数。</span></span><br><span class="line">    <span class="comment">//它将指定的信号加入到进程的信号掩码中，当程序接收到这些信号时，将执行预先设置的信号处理函数。</span></span><br><span class="line">    <span class="built_in">addsig</span>( SIGHUP );<span class="comment">//SIGHUP：通常表示挂起信号，当终端关闭或控制进程死亡时发送。</span></span><br><span class="line">    <span class="built_in">addsig</span>( SIGCHLD );<span class="comment">//SIGCHLD：子进程退出时发送给父进程的信号</span></span><br><span class="line">    <span class="built_in">addsig</span>( SIGTERM );<span class="comment">//SIGTERM：终止进程的信号，通常是由系统管理员发出</span></span><br><span class="line">    <span class="built_in">addsig</span>( SIGINT );<span class="comment">//SIGINT：中断信号，通常由用户按下 Ctrl+C 发送给前台进程组。</span></span><br><span class="line">    <span class="type">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( !stop_server )</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//调用 epoll_wait 函数，等待 epoll 实例 epollfd 上的事件发生。</span></span><br><span class="line">        <span class="comment">//events 是一个数组，用于存储发生的事件。MAX_EVENT_NUMBER 是数组的大小，表示最多存储的事件数量。</span></span><br><span class="line">        <span class="comment">//-1 表示一直阻塞，直到有事件发生。</span></span><br><span class="line">        <span class="type">int</span> number = <span class="built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span> );</span><br><span class="line">        <span class="comment">//number 是 epoll_wait 返回的事件数量，如果返回值小于 0，表示发生了错误。</span></span><br><span class="line">         <span class="comment">//errno 是一个全局变量，表示系统调用发生错误时的错误码。</span></span><br><span class="line">        <span class="comment">//EINTR 表示系统调用被中断。在这里，检查 errno 不是 EINTR 是为了排除 epoll_wait 被中断的情况。</span></span><br><span class="line">        <span class="keyword">if</span> ( ( number &lt; <span class="number">0</span> ) &amp;&amp; ( errno != EINTR ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;epoll failure\n&quot;</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//处理发生的事件</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span>( sockfd == listenfd )<span class="comment">//如果就绪的文件是lisenfd则处理新的连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">                <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>( client_address );</span><br><span class="line">                <span class="type">int</span> connfd = <span class="built_in">accept</span>( listenfd, ( <span class="keyword">struct</span> sockaddr* )&amp;client_address, &amp;client_addrlength );</span><br><span class="line">                <span class="built_in">addfd</span>( epollfd, connfd );</span><br><span class="line">                <span class="comment">//这段代码的目的是在监听套接字上接受新的连接请求，</span></span><br><span class="line">                <span class="comment">//并为新的连接套接字设置非阻塞模式，然后将其添加到 epoll 实例中，以便后续对其进行事件的关注。</span></span><br><span class="line">            &#125; 。</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( ( sockfd == pipefd[<span class="number">0</span>] ) &amp;&amp; ( events[i].events &amp; EPOLLIN ) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//检查当前事件的文件描述符是否是管道的读取端 pipefd[0]，并且事件是可读事件（EPOLLIN）。</span></span><br><span class="line">                <span class="type">int</span> sig;</span><br><span class="line">                <span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">                ret = <span class="built_in">recv</span>( pipefd[<span class="number">0</span>], signals, <span class="built_in">sizeof</span>( signals ), <span class="number">0</span> );</span><br><span class="line">                <span class="comment">//使用 recv 从管道读取数据，将数据存储在 signals 缓冲区中。ret 是实际读取的字节数。</span></span><br><span class="line">                <span class="comment">//如果 ret == -1，表示发生错误，继续下一个事件。</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">//如果 ret == 0，表示管道被关闭，继续下一个事件。</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">//如果 ret &gt; 0，表示成功读取到了数据，进入下面的处理逻辑。遍历读取到的信号数据：</span></span><br><span class="line">                <span class="keyword">if</span>( ret == <span class="number">-1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( ret == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; ++i )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//printf( &quot;I caugh the signal %d\n&quot;, signals[i] );</span></span><br><span class="line">                        <span class="comment">//根据读取到的信号值，执行相应的操作。</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//如果是 SIGCHLD 或 SIGHUP 信号，直接跳过，不进行处理。</span></span><br><span class="line">                        <span class="comment">//如果是 SIGTERM 或 SIGINT 信号，设置 stop_server 标志为 true，表示需要停止服务器。</span></span><br><span class="line">                        <span class="keyword">switch</span>( signals[i] )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">case</span> SIGCHLD:</span><br><span class="line">                            <span class="keyword">case</span> SIGHUP:</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">case</span> SIGTERM:</span><br><span class="line">                            <span class="keyword">case</span> SIGINT:</span><br><span class="line">                            &#123;</span><br><span class="line">                                stop_server = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;close fds\n&quot;</span> );</span><br><span class="line">    <span class="built_in">close</span>( listenfd );</span><br><span class="line">    <span class="built_in">close</span>( pipefd[<span class="number">1</span>] );</span><br><span class="line">    <span class="built_in">close</span>( pipefd[<span class="number">0</span>] );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I/O复用相关操作详见之前写的这章博客的记载：<a href="https://sherecho.cn/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/#epoll">参考博客</a></p>
<h2 id="网络编程相关信号">网络编程相关信号</h2>
<p>主要介绍在网络编程中几个密切相关的函数：SIGUP，SIGPIPE，SIGURG。</p>
<p>先来了解两个概念：进程组和会话。</p>
<p><strong>进程组</strong></p>
<p>　　进程组就是一系列相互关联的进程集合，系统中的每一个进程也必须从属于某一个进程组；每个进程组中都会有一个唯一的
ID(process group id)，简称 PGID；PGID 一般等同于进程组的创建进程的
Process ID，而这个进进程一般也会被称为进程组先导(process group
leader)，同一进程组中除了进程组先导外的其他进程都是其子进程；我们可以一次性发送一个信号量给同一进程组中的所有进程。</p>
<p><strong>会话</strong></p>
<p>　　会话（session）是一个若干进程组的集合，同样的，系统中每一个进程组也都必须从属于某一个会话；一个会话只拥有最多一个控制终端（也可以没有），该终端为会话中所有进程组中的进程所共用。一个会话中前台进程组只会有一个，只有其中的进程才可以和控制终端进行交互；除了前台进程组外的进程组，都是后台进程组；和进程组先导类似，会话中也有会话先导(session
leader)的概念，用来表示建立起到控制终端连接的进程。在拥有控制终端的会话中，session
leader 也被称为控制进程(controlling
process)，一般来说控制进程也就是登入系统的 shell 进程(login shell)；</p>
<h3 id="sighup">SIGHUP</h3>
<p>当挂起的进程控制终端时，触发SIGHUP 信号。SIGHUP
信号在<strong>用户终端连接(正常或非正常)结束</strong>时发出,
通常是在终端的控制进程结束时, 通知同一session内的各个作业,
这时它们与控制终端不再关联.
系统对SIGHUP信号的<strong>默认处理是终止收到该信号的进程</strong>。所以若程序中没有捕捉该信号，当收到该信号时，进程就会退出。</p>
<p><strong>SIGHUP会在以下3种情况下被发送给相应的进程：</strong> 　　</p>
<p>1、终端关闭时，该信号被发送到session首进程以及作为job提交的进程（即用
&amp; 符号提交的进程）； 　　</p>
<p>2、session首进程退出时，该信号被发送到该session中的前台进程组中的每一个进程；
　　</p>
<p>3、若父进程退出导致进程组成为孤儿进程组，且该进程组中有进程处于停止状态（收到SIGSTOP或SIGTSTP信号），该信号会被发送到该进程组中的每一个进程。
　　</p>
<p>例如：在我们登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个
Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进
程组和后台有终端输出的进程就会中止。</p>
<p><strong>此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</strong></p>
<p>比如Linux超级守护进程——xinetd.</p>
<p>　当<code>xinetd</code>程序在接收到SIGHUP信号之后调用<code>hard_reconfig</code>函数，它将循环读取/etc/xinetd.d/目录下的每个子配置文件，并检测其变化。如果某个正在运行的子服务的配置文件被修改以停止服务，则xinetd主进程讲给该子服务进程发送SIGTERM信号来结束它。如果某个子服务的配置文件被修改以开启服务，则xinetd将创建新的socket并将其绑定到该服务对应的端口上。</p>
<h3 id="sigpipe">SIGPIPE</h3>
<p>在网络编程中，SIGPIPE这个信号是很常见的。当往一个<strong>写端关闭</strong>的管道或socket连接中连续写入数据时会引发SIGPIPE信号,引发SIGPIPE信号的写操作将设置errno为EPIPE。</p>
<p>在TCP通信中，当通信的双方中的一方close一个连接时，若另一方接着发数据，根据TCP协议的规定，会收到一个RST响应报文，若再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，告诉进程这个连接已经断开了，不能再写入数据。
　　</p>
<p>此外，因为<strong>SIGPIPE信号的默认行为是结束进程</strong>，而我们绝对不希望因为写操作的错误而导致程序退出，尤其是作为服务器程序来说就更恶劣了。所以我们应该对这种信号加以处理，在这里，介绍两种处理SIGPIPE信号的方式：
　　</p>
<p>１ 、给SIGPIPE设置SIG_IGN信号处理函数，忽略该信号:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br></pre></td></tr></table></figure>
<p>　　前文说过，引发SIGPIPE信号的写操作将设置errno为EPIPE。所以，第二次往关闭的socket中写入数据时,
会返回-1, 同时errno置为EPIPE.
这样，便能知道对端已经关闭，然后进行相应处理，而不会导致整个进程退出.
　　</p>
<p>2、使用send函数的MSG_NOSIGNAL 标志来禁止写操作触发SIGPIPE信号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">send</span>(sockfd , buf , size , MSG_NOSIGNAL);</span><br></pre></td></tr></table></figure>
<p>​
同样，我们可以根据send函数反馈的errno来判断socket的读端是否已经关闭。此外，我们也可以通过IO复用函数来检测管道和socket连接的读端是否已经关闭。以POLL为例，当socket连接被对方关闭时，socket上的POLLRDHUP事件将被触发。</p>
<h3 id="sigurg">SIGURG</h3>
<h4 id="带外数据">带外数据</h4>
<p>　　带外数据用于迅速告知对方本端发生的重要的事件。它比普通的数据（带内数据）拥有更高的优先级，不论发送缓冲区中是否有排队等待发送的数据，它总是被立即发送。带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中。</p>
<p>实际应用中，带外数据是使用很少见UDP没有没有实现带外数据传输，TCP也没有真正的带外数据。不过TCP利用头部的紧急指针标志和紧急指针，为应用程序提供了一种紧急方式，含义和带外数据类似。TCP的紧急方式利用传输普通数据的连接来传输紧急数据。</p>
<h4 id="sigurg信号的作用">SIGURG信号的作用</h4>
<p>　　内核通知应用程序带外数据到达的方式有两种：一种就是利用Ｉ/Ｏ复用技术的系统调用（如select）在接受到带外数据时将返回，并向应用程序报告socket上的异常事件。另一种方法就是使用SIGURG信号。</p>
<h4 id="sigurg信号检测带外数据是否到达的例程">SIGURG信号检测带外数据是否到达的例程</h4>
<p><strong>sigaction</strong>：结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">    <span class="built_in">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">    <span class="type">int</span>        sa_flags;</span><br><span class="line">    <span class="built_in">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> connfd;</span><br><span class="line"><span class="comment">//SIGURG信号的处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_urg</span><span class="params">( <span class="type">int</span> sig )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> save_errno = errno;  </span><br><span class="line">    <span class="type">char</span> buffer[ BUF_SIZE ];</span><br><span class="line">    <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE );</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="number">-1</span>, MSG_OOB );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;got %d bytes of oob data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line"></span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addsig</span><span class="params">( <span class="type">int</span> sig, <span class="type">void</span> ( *sig_handler )( <span class="type">int</span> ) )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    <span class="built_in">memset</span>( &amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>( sa ) );</span><br><span class="line">    <span class="comment">//将sigaction结构的sa_handler字段设置为sig_handler指向的函数。当接收到指定的信号时，将调用此函数。</span></span><br><span class="line">    sa.sa_handler = sig_handler;</span><br><span class="line">    <span class="comment">//在sa_flags字段中设置SA_RESTART标志。此标志指示某些系统调用在被指定信号中断时自动重新启动。</span></span><br><span class="line">    <span class="comment">//即：重新调用之前被该信号终止的系统调用</span></span><br><span class="line">    sa.sa_flags |= SA_RESTART;</span><br><span class="line">    <span class="comment">//使用sigfillset初始化信号掩码，该函数将信号集（sa_mask）填充为所有可用信号。</span></span><br><span class="line">    <span class="comment">//这意味着在执行信号处理程序期间，所有信号都将被阻塞。</span></span><br><span class="line">    <span class="built_in">sigfillset</span>( &amp;sa.sa_mask );</span><br><span class="line">    <span class="built_in">assert</span>( <span class="built_in">sigaction</span>( sig, &amp;sa, <span class="literal">NULL</span> ) != <span class="number">-1</span> ); <span class="comment">//调用sigaction函数为指定的信号（sig）设置信号处理。</span></span><br><span class="line">    <span class="comment">//如果函数调用失败（返回-1），assert宏将触发一个断言失败，表示发生了错误。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>( client );</span><br><span class="line">    connfd = <span class="built_in">accept</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">addsig</span>( SIGURG, sig_urg );</span><br><span class="line">        <span class="built_in">fcntl</span>( connfd, F_SETOWN, <span class="built_in">getpid</span>() );</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buffer[ BUF_SIZE ];</span><br><span class="line">        <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE );</span><br><span class="line">            ret = <span class="built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">            <span class="keyword">if</span>( ret &lt;= <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="定时器">定时器</h1>
<h2 id="socket-so_rcvtimeo和so_sndtimeo">socket
SO_RCVTIMEO和SO_SNDTIMEO</h2>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line"><span class="built_in">assert</span>( sockfd &gt;= <span class="number">0</span> );</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> timeout; <span class="comment">//声明了一个timeval结构体变量，用于表示时间值。</span></span><br><span class="line">timeout.tv_sec = time; <span class="comment">//将timeout结构体的tv_sec字段设置为time变量的值。这个字段表示超时的秒数。</span></span><br><span class="line">timeout.tv_usec = <span class="number">0</span>;<span class="comment">//timeout.tv_usec = 0;：将timeout结构体的tv_usec字段设置为0。这个字段表示超时的微秒数。</span></span><br><span class="line"><span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>( timeout );</span><br><span class="line">ret = <span class="built_in">setsockopt</span>( sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, len );</span><br></pre></td></tr></table></figure>
<p>这段代码是在设置一个套接字（socket）选项，具体来说，是设置发送操作的超时时间。</p>
<ol type="1">
<li><p><code>struct timeval timeout;</code>：声明了一个<code>timeval</code>结构体变量，用于表示时间值。</p></li>
<li><p><code>timeout.tv_sec = time;</code>：将<code>timeout</code>结构体的<code>tv_sec</code>字段设置为<code>time</code>变量的值。这个字段表示超时的秒数。</p></li>
<li><p><code>timeout.tv_usec = 0;</code>：将<code>timeout</code>结构体的<code>tv_usec</code>字段设置为0。这个字段表示超时的微秒数。</p></li>
<li><p><code>socklen_t len = sizeof(timeout);</code>：声明了一个<code>socklen_t</code>类型的变量<code>len</code>，并将其设置为<code>timeout</code>结构体的大小，即结构体中的字节数。</p></li>
<li><p><code>ret = setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, len);</code>：调用<code>setsockopt</code>函数设置套接字选项。具体来说，它将发送超时时间应用到指定的套接字上。</p>
<ul>
<li><p><code>sockfd</code>是套接字的文件描述符。</p></li>
<li><p><code>SOL_SOCKET</code>是套接字选项的级别，表示通用套接字选项。</p></li>
<li><p><code>SO_SNDTIMEO</code>是要设置的选项，表示设置发送操作的超时时间。</p></li>
<li><p><code>&amp;timeout</code>是包含超时值的结构体的地址。</p></li>
<li><p><code>len</code>是结构体的大小。</p></li>
</ul></li>
</ol>
<p>设置connect超时时间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">timeout_connect</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* ip, <span class="type">int</span> port, <span class="type">int</span> time )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sockfd &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout; <span class="comment">//声明了一个timeval结构体变量，用于表示时间值。</span></span><br><span class="line">    timeout.tv_sec = time; <span class="comment">//将timeout结构体的tv_sec字段设置为time变量的值。这个字段表示超时的秒数。</span></span><br><span class="line">    timeout.tv_usec = <span class="number">0</span>;<span class="comment">//timeout.tv_usec = 0;：将timeout结构体的tv_usec字段设置为0。这个字段表示超时的微秒数。</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>( timeout );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>( sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, len );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">connect</span>( sockfd, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    <span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( errno == EINPROGRESS )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;connecting timeout\n&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;error occur when connecting to server\n&quot;</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">timeout_connect</span>( ip, port, <span class="number">10</span> );</span><br><span class="line">    <span class="keyword">if</span> ( sockfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sigalem信号">SIGALEM信号</h2>
<p>定时信号SIGALRM的用途：
在编程的过程中，很多时候我们需要为程序设置一个闹钟，然后到了闹钟设定的时刻然后再去采取相关的操作。比如进行socket编程时，如果客户端长时间没有与服务器进行交互，需要服务器在一定时间之后主动关闭socket连接。在这种场景下，就可以在服务器收到客户端的socket的连接时，设置一个定时信号，然后在定时信号到来时，关闭掉socket连接即可。</p>
<p>通过alarm函数触发定时信号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	seconds：表示在当前时刻seconds秒之后产生一个SIGALRM信号，若seconds=0，表示取消闹钟</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">0或者一个大于0的值。若值大于0，表示上一个定时器还剩余多少秒。比如：</span></span><br><span class="line"><span class="comment">int ret1 = alarm(10);    // 第0秒时刻，设定一个定时闹钟，准备10秒后触发SIGALRM信号, 此时返回值为0</span></span><br><span class="line"><span class="comment">sleep(5);</span></span><br><span class="line"><span class="comment">int ret2 = alarm(20); // 重新设定闹钟，定时信号将会在第25秒触发，此时ret2=5，表示上个闹钟还剩余5秒</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>闹钟信号只会触发一次，若想循环触发，可以在闹钟到时后重新通过alarm函数触发
可以重新设置闹钟信号，即在上一个闹钟到时之前，通过alarm函数重新设定响铃时刻或取消闹钟</p>
<h3 id="基于升序链表的定时器">基于升序链表的定时器</h3>
<p>定时器通常至少包含两个成员：超时时间+回调函数</p>
<p>用链表作为容器来串联所有的定时器。</p>
<p>下面代码实现了简单的升序定时器链表，将其中的定时器按照超时时间升序排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LST_TIMER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LST_TIMER</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">util_timer</span>;</span><br><span class="line"><span class="comment">//用户数据信息 客户端的socket地址 socket文件描述符 都缓存和定时器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client_data</span></span><br><span class="line">&#123;</span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">char</span> buf[ BUFFER_SIZE ];</span><br><span class="line">    util_timer* timer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定时器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">util_timer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">util_timer</span>() : <span class="built_in">prev</span>( <span class="literal">NULL</span> ), <span class="built_in">next</span>( <span class="literal">NULL</span> )&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="type">time_t</span> expire;<span class="comment">//超时时间 </span></span><br><span class="line">   <span class="built_in">void</span> (*cb_func)( client_data* );</span><br><span class="line">    <span class="comment">//表示一个函数指针，该指针指向一个以 client_data* 类型参数为输入并返回 void 类型的函数。</span></span><br><span class="line">    <span class="comment">/*cb_func 是一个指针，指向一个函数，这个函数接受一个指向 client_data 类型数据的指针作为参数，并且不返回任何值。</span></span><br><span class="line"><span class="comment">    这样的函数指针通常用于回调函数，允许在运行时动态地指定某个函数，以便在特定事件发生时执行相应的操作。</span></span><br><span class="line"><span class="comment">    在这个声明中，cb_func 用于存储回调函数的地址。*/</span></span><br><span class="line">   client_data* user_data;</span><br><span class="line">   util_timer* prev;</span><br><span class="line">   util_timer* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定时器链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sort_timer_lst</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sort_timer_lst</span>() : <span class="built_in">head</span>( <span class="literal">NULL</span> ), <span class="built_in">tail</span>( <span class="literal">NULL</span> ) &#123;&#125;</span><br><span class="line">    <span class="comment">//链表被销毁时，删除所有的定时器</span></span><br><span class="line">    ~<span class="built_in">sort_timer_lst</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        util_timer* tmp = head;</span><br><span class="line">        <span class="keyword">while</span>( tmp )</span><br><span class="line">        &#123;</span><br><span class="line">            head = tmp-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">            tmp = head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将目标定时器timer添加到链表中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_timer</span><span class="params">( util_timer* timer )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( !timer )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( !head )</span><br><span class="line">        &#123;</span><br><span class="line">            head = tail = timer;</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( timer-&gt;expire &lt; head-&gt;expire )</span><br><span class="line">        &#123;</span><br><span class="line">            timer-&gt;next = head;</span><br><span class="line">            head-&gt;prev = timer;</span><br><span class="line">            head = timer;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add_timer</span>( timer, head );<span class="comment">//调用重载函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只考虑超时延长</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjust_timer</span><span class="params">( util_timer* timer )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( !timer )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        util_timer* tmp = timer-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>( !tmp || ( timer-&gt;expire &lt; tmp-&gt;expire ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( timer == head )</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">add_timer</span>( timer, head );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">            timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">            <span class="built_in">add_timer</span>( timer, timer-&gt;next );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del_timer</span><span class="params">( util_timer* timer )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( !timer )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( ( timer == head ) &amp;&amp; ( timer == tail ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> timer;</span><br><span class="line">            head = <span class="literal">NULL</span>;</span><br><span class="line">            tail = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( timer == head )</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> timer;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( timer == tail )</span><br><span class="line">        &#123;</span><br><span class="line">            tail = tail-&gt;prev;</span><br><span class="line">            tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> timer;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">        timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//SIGALRM 信号触发后信号处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( !head )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;timer tick\n&quot;</span> );</span><br><span class="line">        <span class="type">time_t</span> cur = <span class="built_in">time</span>( <span class="literal">NULL</span> );</span><br><span class="line">        util_timer* tmp = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( tmp )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从头节点开始处理每个定时器直到遇到一个没到期的定时器</span></span><br><span class="line">            <span class="keyword">if</span>( cur &lt; tmp-&gt;expire )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行定时器回调函数</span></span><br><span class="line">            tmp-&gt;<span class="built_in">cb_func</span>( tmp-&gt;user_data );</span><br><span class="line">            <span class="comment">//执行后将定时器从链表中移除</span></span><br><span class="line">            head = tmp-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>( head )</span><br><span class="line">            &#123;</span><br><span class="line">                head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">            tmp = head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//将定时器加到lst_head之后部分的链表中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_timer</span><span class="params">( util_timer* timer, util_timer* lst_head )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        util_timer* prev = lst_head;</span><br><span class="line">        util_timer* tmp = prev-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>( tmp )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( timer-&gt;expire &lt; tmp-&gt;expire )</span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;next = timer;</span><br><span class="line">                timer-&gt;next = tmp;</span><br><span class="line">                tmp-&gt;prev = timer;</span><br><span class="line">                timer-&gt;prev = prev;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = tmp;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( !tmp )</span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;next = timer;</span><br><span class="line">            timer-&gt;prev = prev;</span><br><span class="line">            timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            tail = timer;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    util_timer* head;</span><br><span class="line">    util_timer* tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="处理非活动连接">处理非活动连接</h3>
<p>升序定时器链表的一个实际应用：处理非活动连接</p>
<p>服务器通常需要定期处理非活动连接：给客户端发一个重连接请求或者关闭该连接或其它。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lst_timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_LIMIT 65535</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMESLOT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="type">static</span> sort_timer_lst timer_lst;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> epollfd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">( <span class="type">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>( fd, F_GETFL );</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>( fd, F_SETFL, new_option );</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">( <span class="type">int</span> epollfd, <span class="type">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_ADD, fd, &amp;event );</span><br><span class="line">    <span class="built_in">setnonblocking</span>( fd );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_handler</span><span class="params">( <span class="type">int</span> sig )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line">    <span class="type">int</span> msg = sig;</span><br><span class="line">    <span class="built_in">send</span>( pipefd[<span class="number">1</span>], ( <span class="type">char</span>* )&amp;msg, <span class="number">1</span>, <span class="number">0</span> );</span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addsig</span><span class="params">( <span class="type">int</span> sig )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    <span class="built_in">memset</span>( &amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>( sa ) );</span><br><span class="line">    sa.sa_handler = sig_handler;</span><br><span class="line">    sa.sa_flags |= SA_RESTART;</span><br><span class="line">    <span class="built_in">sigfillset</span>( &amp;sa.sa_mask );</span><br><span class="line">    <span class="built_in">assert</span>( <span class="built_in">sigaction</span>( sig, &amp;sa, <span class="literal">NULL</span> ) != <span class="number">-1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用前面升序定时器链表的定时器处理函数</span></span><br><span class="line">    timer_lst.<span class="built_in">tick</span>();</span><br><span class="line">    <span class="comment">//因为一次alarm调用只会引起一次SIGALRM信号，所以需要重新定时，以不断触发SIGALRM信号</span></span><br><span class="line">    <span class="built_in">alarm</span>( TIMESLOT );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定时器回调函数，删除非活动连接上的注册事件并关闭</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cb_func</span><span class="params">( client_data* user_data )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( user_data );</span><br><span class="line">    <span class="built_in">close</span>( user_data-&gt;sockfd );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;close fd %d\n&quot;</span>, user_data-&gt;sockfd );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( listenfd &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">bind</span>( listenfd, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( listenfd, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    epoll_event events[ MAX_EVENT_NUMBER ];</span><br><span class="line">    <span class="type">int</span> epollfd = <span class="built_in">epoll_create</span>( <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( epollfd != <span class="number">-1</span> );</span><br><span class="line">    <span class="built_in">addfd</span>( epollfd, listenfd );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">socketpair</span>( PF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line">    <span class="built_in">setnonblocking</span>( pipefd[<span class="number">1</span>] );</span><br><span class="line">    <span class="built_in">addfd</span>( epollfd, pipefd[<span class="number">0</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add all the interesting signals here</span></span><br><span class="line">    <span class="built_in">addsig</span>( SIGALRM );</span><br><span class="line">    <span class="built_in">addsig</span>( SIGTERM );</span><br><span class="line">    <span class="type">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    client_data* users = <span class="keyword">new</span> client_data[FD_LIMIT]; </span><br><span class="line">    <span class="type">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">alarm</span>( TIMESLOT );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( !stop_server )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span> );</span><br><span class="line">        <span class="keyword">if</span> ( ( number &lt; <span class="number">0</span> ) &amp;&amp; ( errno != EINTR ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;epoll failure\n&quot;</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="comment">//处理新到的连接</span></span><br><span class="line">            <span class="keyword">if</span>( sockfd == listenfd )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">                <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>( client_address );</span><br><span class="line">                <span class="type">int</span> connfd = <span class="built_in">accept</span>( listenfd, ( <span class="keyword">struct</span> sockaddr* )&amp;client_address, &amp;client_addrlength );</span><br><span class="line">                <span class="built_in">addfd</span>( epollfd, connfd );</span><br><span class="line">                users[connfd].address = client_address;</span><br><span class="line">                users[connfd].sockfd = connfd;</span><br><span class="line">                util_timer* timer = <span class="keyword">new</span> util_timer;</span><br><span class="line">                timer-&gt;user_data = &amp;users[connfd];</span><br><span class="line">                timer-&gt;cb_func = cb_func;</span><br><span class="line">                <span class="type">time_t</span> cur = <span class="built_in">time</span>( <span class="literal">NULL</span> );</span><br><span class="line">                timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">                users[connfd].timer = timer;</span><br><span class="line">                timer_lst.<span class="built_in">add_timer</span>( timer );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理信号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( ( sockfd == pipefd[<span class="number">0</span>] ) &amp;&amp; ( events[i].events &amp; EPOLLIN ) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sig;</span><br><span class="line">                <span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">                ret = <span class="built_in">recv</span>( pipefd[<span class="number">0</span>], signals, <span class="built_in">sizeof</span>( signals ), <span class="number">0</span> );</span><br><span class="line">                <span class="keyword">if</span>( ret == <span class="number">-1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// handle the error</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( ret == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; ++i )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">switch</span>( signals[i] )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">case</span> SIGALRM:</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">//用timeout标记有定时任务需要处理，但是不立即处理定时任务，</span></span><br><span class="line">                                <span class="comment">//因为定时任务的优先级不是很高，我们的优先级处理其它更重要的任务</span></span><br><span class="line">                                timeout = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">case</span> SIGTERM:</span><br><span class="line">                            &#123;</span><br><span class="line">                                stop_server = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理客户连接上收到的数据</span></span><br><span class="line">            <span class="comment">//EPOLLIN 是一个常量，它表示关注可读事件。在 epoll 中，EPOLLIN 标志表示对应的文件描述符可以进行读操作了。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(  events[i].events &amp; EPOLLIN )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>( users[sockfd].buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">                ret = <span class="built_in">recv</span>( sockfd, users[sockfd].buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">                <span class="built_in">printf</span>( <span class="string">&quot;get %d bytes of client data %s from %d\n&quot;</span>, ret, users[sockfd].buf, sockfd );</span><br><span class="line">                util_timer* timer = users[sockfd].timer;</span><br><span class="line">                <span class="keyword">if</span>( ret &lt; <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( errno != EAGAIN )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">cb_func</span>( &amp;users[sockfd] );</span><br><span class="line">                        <span class="keyword">if</span>( timer )</span><br><span class="line">                        &#123;</span><br><span class="line">                            timer_lst.<span class="built_in">del_timer</span>( timer );</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( ret == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果对方关闭连接则我们也关闭连接并移除计时器</span></span><br><span class="line">                    <span class="built_in">cb_func</span>( &amp;users[sockfd] );</span><br><span class="line">                    <span class="keyword">if</span>( timer )</span><br><span class="line">                    &#123;</span><br><span class="line">                        timer_lst.<span class="built_in">del_timer</span>( timer );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果有数据可读，则延长定时器时间以延迟连接被关闭的时间</span></span><br><span class="line">                    <span class="comment">//send( sockfd, users[sockfd].buf, BUFFER_SIZE-1, 0 );</span></span><br><span class="line">                    <span class="keyword">if</span>( timer )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">time_t</span> cur = <span class="built_in">time</span>( <span class="literal">NULL</span> );</span><br><span class="line">                        timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">                        <span class="built_in">printf</span>( <span class="string">&quot;adjust timer once\n&quot;</span> );</span><br><span class="line">                        timer_lst.<span class="built_in">adjust_timer</span>( timer );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// others</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( timeout )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">timer_handler</span>();</span><br><span class="line">            timeout = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( listenfd );</span><br><span class="line">    <span class="built_in">close</span>( pipefd[<span class="number">1</span>] );</span><br><span class="line">    <span class="built_in">close</span>( pipefd[<span class="number">0</span>] );</span><br><span class="line">    <span class="keyword">delete</span> [] users;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="io复用系统调用的超时参数">I/O复用系统调用的超时参数</h3>
<p>利用I.O复用的超时参数，进行超时设定，这期间也可以处理其他事情。在主循环中，一定要每次都更新超时参数，因为I/O复用系统调用可能在超时时间到期之前就返回（有I/O时间发生）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIMEOUT 5000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> timeout = TIMEOUT;</span><br><span class="line"><span class="type">time_t</span> start = <span class="built_in">time</span>( <span class="literal">NULL</span> );</span><br><span class="line"><span class="type">time_t</span> end = <span class="built_in">time</span>( <span class="literal">NULL</span> );</span><br><span class="line"><span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;the timeout is now %d mill-seconds\n&quot;</span>, timeout );</span><br><span class="line">    start = <span class="built_in">time</span>( <span class="literal">NULL</span> );</span><br><span class="line">    <span class="type">int</span> number = <span class="built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, timeout );</span><br><span class="line">    <span class="keyword">if</span>( ( number &lt; <span class="number">0</span> ) &amp;&amp; ( errno != EINTR ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;epoll failure\n&quot;</span> );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( number == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// timeout</span></span><br><span class="line">        timeout = TIMEOUT;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    end = <span class="built_in">time</span>( <span class="literal">NULL</span> );</span><br><span class="line">    timeout -= ( end - start ) * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">if</span>( timeout &lt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// timeout</span></span><br><span class="line">        timeout = TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle connections</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高性能定时器">高性能定时器</h2>
<h3 id="时间轮">时间轮</h3>
<p>基于排序链表的定时器存在一个问题：添加定时器的效率偏低</p>
<figure>
<img src="/2024/01/01/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E4%BF%A1%E5%8F%B7%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/image-20240126110817942.png" alt="简单的时间轮">
<figcaption aria-hidden="true">简单的时间轮</figcaption>
</figure>
<p>时间轮上有多个槽（slot），指针以恒定时间转动，每转动一步指向下一个槽，每次转动位一个滴答（tick）。每个槽指向一个定时器链表</p>
<p>至于在每转到一个槽时都要检查是否到达运行时间，可以这样理解：时间轮进行散列的方法就是取余运算，假设每个槽的间隔为a
秒，共有n个槽，当前转到了第cur个槽，那么一个定时在 t
s以后运行的定时器就要放在第（ cur + t /si ） % n个槽，并在运行t /
n圈后到达该槽时才会运行。因此一个槽中的定时器运行的时间是相差i（i &gt;=
0）个周期的。</p>
<p>所以时间轮简单来说就是散列 +
链表，这样与使用升序链表相比，散列可以直接定位要插入的槽所在位置，可以提高添加定时器的效率，由O(N)到了O(1)。
想要提高定时精度就要使得a足够小，想要提高执行效率就要使得n足够大。复杂的时间轮可以有多个轮子，每个轮子有不同的粒度，类似齿轮</p>
<p>简单的时间轮实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TIME_WHEEL_TIMER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_WHEEL_TIMER</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tw_timer</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client_data</span></span><br><span class="line">&#123;</span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">char</span> buf[ BUFFER_SIZE ];</span><br><span class="line">    tw_timer* timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tw_timer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">tw_timer</span>( <span class="type">int</span> rot, <span class="type">int</span> ts ) </span><br><span class="line">    : <span class="built_in">next</span>( <span class="literal">NULL</span> ), <span class="built_in">prev</span>( <span class="literal">NULL</span> ), <span class="built_in">rotation</span>( rot ), <span class="built_in">time_slot</span>( ts )&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> rotation;</span><br><span class="line">    <span class="type">int</span> time_slot;</span><br><span class="line">    <span class="built_in">void</span> (*cb_func)( client_data* );</span><br><span class="line">    client_data* user_data;</span><br><span class="line">    tw_timer* next;</span><br><span class="line">    tw_timer* prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">time_wheel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">time_wheel</span>() : <span class="built_in">cur_slot</span>( <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            slots[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">time_wheel</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历每个槽</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            tw_timer* tmp = slots[i];</span><br><span class="line">            <span class="comment">//销毁每个槽内的定时器</span></span><br><span class="line">            <span class="keyword">while</span>( tmp )</span><br><span class="line">            &#123;</span><br><span class="line">                slots[i] = tmp-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">                tmp = slots[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建定时器并插入合适的槽中</span></span><br><span class="line">    <span class="function">tw_timer* <span class="title">add_timer</span><span class="params">( <span class="type">int</span> timeout )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( timeout &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ticks = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果定时器时间小于时间轮的槽间隔TI向上折合为1</span></span><br><span class="line">        <span class="keyword">if</span>( timeout &lt; TI )</span><br><span class="line">        &#123;</span><br><span class="line">            ticks = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ticks = timeout / TI;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算定时器在转几圈后被触发</span></span><br><span class="line">        <span class="type">int</span> rotation = ticks / N;</span><br><span class="line">        <span class="comment">//计算待插入的定时器应该插入到那个槽</span></span><br><span class="line">        <span class="type">int</span> ts = ( cur_slot + ( ticks % N ) ) % N;</span><br><span class="line">        <span class="comment">//创建新的定时器</span></span><br><span class="line">        tw_timer* timer = <span class="keyword">new</span> <span class="built_in">tw_timer</span>( rotation, ts );</span><br><span class="line">        <span class="comment">//如果待插入的槽里面还没有定时器直接插入并设为头结点</span></span><br><span class="line">        <span class="keyword">if</span>( !slots[ts] )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;add timer, rotation is %d, ts is %d, cur_slot is %d\n&quot;</span>, rotation, ts, cur_slot );</span><br><span class="line">            slots[ts] = timer;</span><br><span class="line">        &#125;<span class="comment">//头插法</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            timer-&gt;next = slots[ts];</span><br><span class="line">            slots[ts]-&gt;prev = timer;</span><br><span class="line">            slots[ts] = timer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del_timer</span><span class="params">( tw_timer* timer )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( !timer )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ts = timer-&gt;time_slot;</span><br><span class="line">        <span class="keyword">if</span>( timer == slots[ts] )</span><br><span class="line">        &#123;</span><br><span class="line">            slots[ts] = slots[ts]-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>( slots[ts] )</span><br><span class="line">            &#123;</span><br><span class="line">                slots[ts]-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> timer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>( timer-&gt;next )</span><br><span class="line">            &#123;</span><br><span class="line">                timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> timer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TI时间到后调用该函数，时间轮向前滚动一个槽的间隔</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tw_timer* tmp = slots[cur_slot];</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;current slot is %d\n&quot;</span>, cur_slot );</span><br><span class="line">        <span class="keyword">while</span>( tmp )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;tick the timer once\n&quot;</span> );</span><br><span class="line">            <span class="keyword">if</span>( tmp-&gt;rotation &gt; <span class="number">0</span> )<span class="comment">//如果定时器的ritation值大于0，则它在这一轮不起作用</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp-&gt;rotation--;</span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//否则说明定时器已经到期，执行定时任务，然后删除定时器</span></span><br><span class="line">                tmp-&gt;<span class="built_in">cb_func</span>( tmp-&gt;user_data );</span><br><span class="line">                <span class="keyword">if</span>( tmp == slots[cur_slot] )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>( <span class="string">&quot;delete header in cur_slot\n&quot;</span> );</span><br><span class="line">                    slots[cur_slot] = tmp-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> tmp;</span><br><span class="line">                    <span class="keyword">if</span>( slots[cur_slot] )</span><br><span class="line">                    &#123;</span><br><span class="line">                        slots[cur_slot]-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tmp = slots[cur_slot];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tmp-&gt;prev-&gt;next = tmp-&gt;next;</span><br><span class="line">                    <span class="keyword">if</span>( tmp-&gt;next )</span><br><span class="line">                    &#123;</span><br><span class="line">                        tmp-&gt;next-&gt;prev = tmp-&gt;prev;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tw_timer* tmp2 = tmp-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> tmp;</span><br><span class="line">                    tmp = tmp2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_slot = ++cur_slot % N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> N = <span class="number">60</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> TI = <span class="number">1</span>; </span><br><span class="line">    tw_timer* slots[N];</span><br><span class="line">    <span class="type">int</span> cur_slot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>对时间轮而言，添加一个定时器的复杂度是O(1)，删除一个定时器的复杂度是O(1)。执行定时器的时间复杂度是O(n).当使用很多轮子时执行复杂度接近O(1)</p>
<h3 id="时间堆">时间堆</h3>
<p>前面讨论的方案都是以固定的频率调用心搏函数tick，并依次检测到期的定时器。然后执行定时器上的回调函数。</p>
<p>另一种思路是，将所有定时器中最小的定时器的超时值作为心搏间隔。这样一旦tick被调用，最小的定时器必然到期。我们可以找出剩余最小的超时值设为心搏间隔。使用小根堆比较容易实现这种定时方案</p>
<p>使用数组实现小根堆，实现时间堆代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> intIME_HEAP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> intIME_HEAP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::exception;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">heap_timer</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client_data</span></span><br><span class="line">&#123;</span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">char</span> buf[ BUFFER_SIZE ];</span><br><span class="line">    heap_timer* timer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间堆类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">heap_timer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">heap_timer</span>( <span class="type">int</span> delay )</span><br><span class="line">    &#123;</span><br><span class="line">        expire = <span class="built_in">time</span>( <span class="literal">NULL</span> ) + delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="type">time_t</span> expire;</span><br><span class="line">   <span class="built_in">void</span> (*cb_func)( client_data* );</span><br><span class="line">   client_data* user_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">time_heap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">time_heap</span>( <span class="type">int</span> cap ) <span class="keyword">throw</span> ( std::exception )</span><br><span class="line">        : <span class="built_in">capacity</span>( cap ), <span class="built_in">cur_size</span>( <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">	array = <span class="keyword">new</span> heap_timer* [capacity];</span><br><span class="line">	<span class="keyword">if</span> ( ! array )</span><br><span class="line">	&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            array[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用已有数组初始化堆</span></span><br><span class="line">    <span class="built_in">time_heap</span>( heap_timer** init_array, <span class="type">int</span> size, <span class="type">int</span> capacity ) <span class="keyword">throw</span> ( std::exception )</span><br><span class="line">        : <span class="built_in">cur_size</span>( size ), <span class="built_in">capacity</span>( capacity )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( capacity &lt; size )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        array = <span class="keyword">new</span> heap_timer* [capacity];</span><br><span class="line">        <span class="keyword">if</span> ( ! array )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            array[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( size != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> i =  <span class="number">0</span>; i &lt; size; ++i )</span><br><span class="line">            &#123;</span><br><span class="line">                array[ i ] = init_array[ i ];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> i = (cur_size<span class="number">-1</span>)/<span class="number">2</span>; i &gt;=<span class="number">0</span>; --i )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">percolate_down</span>( i );<span class="comment">//对(cur_size-1)/2~0的非叶子节点进行调整操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">time_heap</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i =  <span class="number">0</span>; i &lt; cur_size; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> [] array; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_timer</span><span class="params">( heap_timer* timer )</span> <span class="title">throw</span> <span class="params">( std::exception )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( !timer )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( cur_size &gt;= capacity )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> hole = cur_size++;</span><br><span class="line">        <span class="type">int</span> parent = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( ; hole &gt; <span class="number">0</span>; hole=parent )</span><br><span class="line">        &#123;</span><br><span class="line">            parent = (hole<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( array[parent]-&gt;expire &lt;= timer-&gt;expire )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            array[hole] = array[parent];</span><br><span class="line">        &#125;</span><br><span class="line">        array[hole] = timer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del_timer</span><span class="params">( heap_timer* timer )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( !timer )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// lazy delelte</span></span><br><span class="line">        timer-&gt;cb_func = <span class="literal">NULL</span>;<span class="comment">//将回调函数设为空，节省删除造成的开销，但是容易造成堆数组膨胀</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取堆顶部定时器</span></span><br><span class="line">    <span class="function">heap_timer* <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">empty</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除堆顶部定时器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_timer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">empty</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( array[<span class="number">0</span>] )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> array[<span class="number">0</span>];</span><br><span class="line">            array[<span class="number">0</span>] = array[--cur_size];</span><br><span class="line">            <span class="built_in">percolate_down</span>( <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        heap_timer* tmp = array[<span class="number">0</span>];</span><br><span class="line">        <span class="type">time_t</span> cur = <span class="built_in">time</span>( <span class="literal">NULL</span> );</span><br><span class="line">        <span class="keyword">while</span>( !<span class="built_in">empty</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !tmp )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( tmp-&gt;expire &gt; cur )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( array[<span class="number">0</span>]-&gt;cb_func )</span><br><span class="line">            &#123;</span><br><span class="line">                array[<span class="number">0</span>]-&gt;<span class="built_in">cb_func</span>( array[<span class="number">0</span>]-&gt;user_data );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pop_timer</span>();</span><br><span class="line">            tmp = array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> cur_size == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">percolate_down</span><span class="params">( <span class="type">int</span> hole )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        heap_timer* temp = array[hole];</span><br><span class="line">        <span class="type">int</span> child = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( ; ((hole*<span class="number">2</span>+<span class="number">1</span>) &lt;= (cur_size<span class="number">-1</span>)); hole=child )</span><br><span class="line">        &#123;</span><br><span class="line">            child = hole*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ( (child &lt; (cur_size<span class="number">-1</span>)) &amp;&amp; (array[child+<span class="number">1</span>]-&gt;expire &lt; array[child]-&gt;expire ) )</span><br><span class="line">            &#123;</span><br><span class="line">                ++child;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( array[child]-&gt;expire &lt; temp-&gt;expire )</span><br><span class="line">            &#123;</span><br><span class="line">                array[hole] = array[child];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        array[hole] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">()</span> <span class="title">throw</span> <span class="params">( std::exception )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        heap_timer** temp = <span class="keyword">new</span> heap_timer* [<span class="number">2</span>*capacity];</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*capacity; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            temp[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( ! temp )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        capacity = <span class="number">2</span>*capacity;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; cur_size; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            temp[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> [] array;</span><br><span class="line">        array = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    heap_timer** array;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> cur_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>对时间堆而言，添加一个定时器的复杂度是O(lgn)，删除一个定时器的复杂度是O(1)</p>
]]></content>
      <categories>
        <category>高性能服务器编程</category>
      </categories>
      <tags>
        <tag>Linux，计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>cache索引格式与页着色</title>
    <url>/2023/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/cache%E7%B4%A2%E5%BC%95%E6%A0%BC%E5%BC%8F%E4%B8%8E%E9%A1%B5%E7%9D%80%E8%89%B2/</url>
    <content><![CDATA[<h1 id="cache索引结构和页着色问题">cache索引结构和页着色问题</h1>
<h2 id="cache-结构">cache 结构</h2>
<p>Cache的特征 ：</p>
<p>Cache的内容是主存储器内容的一个子集
，Cache没有程序上的意义，只是为了降低访存延迟
，处理器访问Cache和访问存储器使用相同的地址。由于cache是子集而且cache和内存不一样不能天然的寻址，所以cache索引里面需要保留地址。</p>
<p>Cache的结构特点 ：</p>
<ul>
<li>同时存储数据和地址</li>
<li>通过地址的比较判断相应数据是否在Cache中</li>
<li>需要考虑所需要的数据不在Cache中的情况
<ul>
<li>替换机制，写策略等</li>
</ul></li>
</ul>
<figure>
<img src="/2023/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/cache%E7%B4%A2%E5%BC%95%E6%A0%BC%E5%BC%8F%E4%B8%8E%E9%A1%B5%E7%9D%80%E8%89%B2/image-20240109161759674.png" alt="cache结构">
<figcaption aria-hidden="true">cache结构</figcaption>
</figure>
<h3 id="全相联">全相联</h3>
<p>全相连中内存单元可以映射到任意块中，offset是块内偏移。这种连接方法命中率高，但是需要遍历所有的tag来搜索复杂度较高</p>
<figure>
<img src="/2023/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/cache%E7%B4%A2%E5%BC%95%E6%A0%BC%E5%BC%8F%E4%B8%8E%E9%A1%B5%E7%9D%80%E8%89%B2/image-20240109162044122.png" alt="全相连结构">
<figcaption aria-hidden="true">全相连结构</figcaption>
</figure>
<h3 id="直接相连">直接相连</h3>
<figure>
<img src="/2023/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/cache%E7%B4%A2%E5%BC%95%E6%A0%BC%E5%BC%8F%E4%B8%8E%E9%A1%B5%E7%9D%80%E8%89%B2/image-20240109162427648.png" alt="直接相连">
<figcaption aria-hidden="true">直接相连</figcaption>
</figure>
<h3 id="组相联">组相联</h3>
<p>组相联介于直接相连和全相联之间</p>
<figure>
<img src="/2023/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/cache%E7%B4%A2%E5%BC%95%E6%A0%BC%E5%BC%8F%E4%B8%8E%E9%A1%B5%E7%9D%80%E8%89%B2/image-20240109162501505.png" alt="组相连">
<figcaption aria-hidden="true">组相连</figcaption>
</figure>
<p>以二路组相联为例，每个内存块可以放到任意一路cache中。</p>
<h2 id="cache索引">cache索引</h2>
<h3 id="物理地址实tag">物理地址，实tag</h3>
<figure>
<img src="/2023/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/cache%E7%B4%A2%E5%BC%95%E6%A0%BC%E5%BC%8F%E4%B8%8E%E9%A1%B5%E7%9D%80%E8%89%B2/image-20240109163103579.png" alt="索引结构">
<figcaption aria-hidden="true">索引结构</figcaption>
</figure>
<p>此时访问的流程是这一的：虚地址先通过TLB转换为物理地址，再访问cache找到对应的内存</p>
<figure>
<img src="/2023/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/cache%E7%B4%A2%E5%BC%95%E6%A0%BC%E5%BC%8F%E4%B8%8E%E9%A1%B5%E7%9D%80%E8%89%B2/image-20240109163157153.png" alt="地址转换访问cache">
<figcaption aria-hidden="true">地址转换访问cache</figcaption>
</figure>
<p>此时offset是块内偏移。例如cache的块大小如果为32B那么offset就是5位</p>
<p>index指的是cache块在cache里面的索引。如果cache的大小是64KB.cache的块大小如果为32B。对应全相联的cache，index是0位。</p>
<p>对于直接相连的cache
index是11位。对于二路组相联的index是10位，对于四路组相联的index是9位。</p>
<p>tag的位数是物理地址位数-index位数-offset位数。这里的tag是用于索时物理地址与存在cache块里面的tag进行比对，判断是否命中。</p>
<p>所以cache里面存的tag就是物理地址的高几位（和tag位数一致）</p>
<h3 id="虚地址虚tag">虚地址，虚tag</h3>
<p>offset和index的计量和上面物理地址的一致，不同的是tag是虚地址位数+进程号位数-index-offset。</p>
<p>虚tag的物理意义：</p>
<h3 id="虚地址实tag与页着色">虚地址，实tag与页着色</h3>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络复习网络传输-IP-传输层-DNS</title>
    <url>/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/</url>
    <content><![CDATA[<h1 id="计算机网络复习网络传输-ip-传输层-dns">计算机网络复习网络传输-IP-传输层-DNS</h1>
<h2 id="tcpip和osi网络模型">TCP/IP和OSI网络模型</h2>
<h3 id="为什么需要分层网络模型">为什么需要分层网络模型?</h3>
<p>网络通信中需要很多很多协议、功能、组件的协作。如果采用模块化的网络体系结构，适应性差，难以维护，对系统实现是场灾难。使用分层模型，如果之分为两层的化，每一种新的应用都需要物理层的每个种类适配，扩展性较差。因此需要引入中间层适配物理层和应用层。</p>
<p>分层的优点：各层相互独立，将建造一个网络的问题分解为多个可处理的部分，一层解决一部分问题。灵活性好：任何层发生变化时，只要接口不变，上下层不受影响。结构上可分割开：各层都可以采用最合适的技术实现易于实现和维护能促进标准化工作。</p>
<h3 id="osi七层模型每层都有什么对应什么功能">OSI七层模型每层都有什么，对应什么功能</h3>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112145545892.png" alt="osi模型">
<figcaption aria-hidden="true">osi模型</figcaption>
</figure>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112145749163.png" alt="功能">
<figcaption aria-hidden="true">功能</figcaption>
</figure>
<h3 id="tcpip模型与osi的对应关系">TCP/IP模型与OSI的对应关系</h3>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112150328647.png" alt="TCP/IP">
<figcaption aria-hidden="true">TCP/IP</figcaption>
</figure>
<h3 id="网络体系结构细腰模型的腰在哪">网络体系结构细腰模型的腰在哪？</h3>
<p>研究表明，分层的体系结构最终会演化成细腰模型</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112150946423.png"></p>
<p>未来的发展趋势： <img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112151022957.png"></p>
<h2 id="分层模型工作机制封装与解封装">分层模型工作机制：封装与解封装</h2>
<p>数据发送：由上层传到下层（逐层封装），接收由下层到上层（逐层解封）</p>
<p>层间是虚通信，最下层为实际通信</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112151701341.png"></p>
<h3 id="封装过程">封装过程</h3>
<p>应用进程(Web)，应用进程数据先传送到应用层。加上应用层头部，成为<strong>应用层Data</strong>，再传送到传输层。</p>
<p>在传输层加上传输层头部，成为<strong>传输层报文(message)</strong>,再传送到网络层。</p>
<p>在网络层加上网络层头部，成为<strong>IP分组(packet)</strong>，再传送到数据链路层</p>
<p>在数据链路层加上链路层头部和尾部，成为<strong>数据链路层帧(frame)</strong>，再传送到物理层</p>
<p>在物理层把<strong>比特流</strong>进行编码、调制，传送到物理媒体电信号（或光信号）在物理媒体中传播从发送端物理层传送到接收端物理层。</p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112152131414.png" alt="封装过程">
<figcaption aria-hidden="true">封装过程</figcaption>
</figure>
<h3 id="解封过程">解封过程</h3>
<p>主机2受到主机1的数据，在物理层解调、解码，将比特流，上交给数据链路层。数据链路层剥去<strong>帧头部</strong>和<strong>帧尾部</strong>取出数据部分，上交给网络层。网络层剥去头部，取出数据部分，上交给传输层。输层剥去头部，取出数据部分，上交给应用层。应用层剥去首部，取出应用程序数据上交给应用进程。</p>
<h2 id="每一层都有那些差错检错机制">每一层都有那些差错检错机制</h2>
<h3 id="为什么要进行差错检测">为什么要进行差错检测</h3>
<p>数据在传输过程中可能会产生比特差错。</p>
<p>差错检测的基本思想在数据帧中加入冗余信息来确定是否存在差错</p>
<p>可以通知对方数据有差错，使其重传数据副本（重传机制）通过加入的冗余信息，重新构造正确的数据（纠错码）</p>
<h3 id="数据链路层crc">数据链路层CRC</h3>
<p>数据链路层会对物理层（只负责传输，不做任何改动的传输机器）传输过来的数据进行差错检测（数据链路层的职责之一：差错控制）。增加数据可靠性，将物理层传输过来的数据无差错地传递给上层（网络层）。</p>
<p>差错检测常见三种方法： <img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112154747285.png"></p>
<p>数据链路层广泛使用了 <strong>循环冗余检测CRC</strong>
的比特差错检测技术。使用检测能力更强的CRC</p>
<p>为什么：</p>
<p>使用最少的冗余比特检测最多的错误。</p>
<ul>
<li>数据链路层的差错检测的目的是做到"无比特差错"。使用循环冗余检验CRC差错检测技术</li>
<li>无法管帧丢失、失序、重复，它只负责一个帧要是传对了，就是对的。</li>
</ul>
<h3 id="网路层">网路层</h3>
<p>网络层的校验只用于针对网络层的头部 IP:</p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114124215618.png" alt="Ip报文里面的checksum字段">
<figcaption aria-hidden="true">Ip报文里面的checksum字段</figcaption>
</figure>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114124409390.png" alt="实现过程">
<figcaption aria-hidden="true">实现过程</figcaption>
</figure>
<p>校验和的计算方式：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240118235929411.png"></p>
<h3 id="传输层">传输层</h3>
<p>运输层的差错检测的目的是做到"无传输差错"。即弥补帧丢失、帧重复、帧失序。</p>
<p>udp采用校验和检测在传输过程中是否出错</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116100331113.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116100455078.png"></p>
<p>TCP校验和</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116101458932.png"></p>
<h3 id="应用层">应用层</h3>
<h2 id="码分复用">码分复用</h2>
<h3 id="复用存在的意义">复用存在的意义</h3>
<p>实现媒体共享：</p>
<p>静态划分信道信道复用技术
(Multiplexing)，为多个用户静态划分逻辑信道，相互不冲突：频分复用、时分复用、波分复用、码分复用。</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112160208997.png"></p>
<h3 id="码分复用原理">码分复用原理</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112160346488.png"></p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112160552531.png" alt="正交关系">
<figcaption aria-hidden="true">正交关系</figcaption>
</figure>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112160625589.png"></p>
<h2 id="csmacd和csmaca的相同点和不同点">CSMA/CD和CSMA/CA的相同点和不同点</h2>
<h3 id="csmacd是的原理">CSMA/CD是的原理</h3>
<p><strong>核心思想</strong> ：1-坚持CSMA + 碰撞检测</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112203935954.png"></p>
<p><strong>碰撞检测：</strong>检测结点边发送数据边检测信道上的信号电压大小、当几个结点同时发送数据时，当结点检测到的信号电压摆动值超过一定的门限值时，认为总线上至少有两个结点同时在发送数据，表明产生了碰撞。发生碰撞时，需立即停止发送，避免继续浪费网络资源，然后等待一段随机时间后再次发送。</p>
<p>在侦听/发送发送数据时</p>
<ul>
<li>侦听链路中是否有其它数据在传输，如果信道忙，则继续侦听等待</li>
<li><strong>如果检测信道空闲</strong>，等待一个<strong>最小帧间间隔</strong>时间，则传输数据帧。（以太网最小帧间间隔9.6𝜇𝑠，为了使刚刚接收帧的节点能清理接收缓存)</li>
</ul>
<p>在传输过程中如果遇到碰撞，执行碰撞处理操作：</p>
<ul>
<li>碰撞处理立即停止发送数据帧，并发送特殊阻塞信息，人为的干扰信号(jamming
signal)，通告其它设备有碰撞发生</li>
<li>根据发生碰撞的次数，计算<strong>指数退避时间</strong>，在时间范围内
<strong>随机选择一个</strong>，进行等待后重发数据帧</li>
<li>在尝试给定次数之后将放弃尝试，并向上层报告传输出错</li>
</ul>
<p><strong>碰撞窗口/争用期</strong></p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112205141448.png" alt="碰撞窗口">
<figcaption aria-hidden="true">碰撞窗口</figcaption>
</figure>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112204956188.png"></p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112205543266.png" alt="强化碰撞">
<figcaption aria-hidden="true">强化碰撞</figcaption>
</figure>
<p><strong>CMSA/CD:发送边侦听</strong></p>
<h3 id="为什么需要cmsaca">为什么需要CMSA/CA</h3>
<ul>
<li>碰撞检测的能力要求结点同时具有发送(自己的信号)
和接收(检测其它结点是否在发送)的能力无线网络适配器上，接收信号强度远小于发送信号，制造具有碰撞检测能力的硬件代价过大即使硬件支持</li>
<li>无线网络特有的隐藏终端等问题也使得很多碰撞难以检测</li>
<li>不使用碰撞检测结点一旦开始发送数据帧，即使碰撞仍继续，因此需尽量避免碰撞发生</li>
</ul>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112205716350.png" alt="隐藏终端问题">
<figcaption aria-hidden="true">隐藏终端问题</figcaption>
</figure>
<h3 id="csmaca的主要操作">CSMA/CA的主要操作</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112210411735.png"></p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112210757209.png" alt="碰撞避免">
<figcaption aria-hidden="true">碰撞避免</figcaption>
</figure>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112210931060.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112211854757.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240112232837528.png"></p>
<h3 id="csmaca和csmacd的异同对比">CSMA/CA和CSMA/CD的异同对比</h3>
<h4 id="相同点">相同点</h4>
<p>都是基于载波侦听多点接入(CSMA)涉及以下两方面：</p>
<p>多点接入：</p>
<p>总线型网络，多个结点以多点接入的方式连接在一根总线上，同一冲突域</p>
<p>载波侦听：</p>
<p>结点在发送前先检测信道，是否有其它结点也在发送，若有，则暂时不要发送数据，以免发生碰撞总线上并没有“载波”</p>
<h4 id="差异">差异</h4>
<p>由于适用场景不同CSMA/CD主要适用以太网。CSMA/CA主要适用无线局域网。</p>
<p>针对无线局域网，CSMA/CD存在以下问题</p>
<ul>
<li>碰撞检测的能力要求结点同时具有发送(自己的信号)
和接收(检测其它结点是否在发送)的能力无线网络适配器上，接收信号强度远小于发送信号，制造具有碰撞检测能力的硬件代价过大即使硬件支持</li>
<li>无线网络特有的隐藏终端等问题也使得很多碰撞难以检测</li>
<li>不使用碰撞检测结点一旦开始发送数据帧，即使碰撞仍继续，因此需尽量避免碰撞发生</li>
</ul>
<ol type="1">
<li>csma/cd在发送前先侦听信道，检测是否有其它节点正在发送。而CSMA/CA是通过虚拟载波监听技术进行检测信道是否空闲。</li>
<li>CSMA/CD中退避只在碰撞发生后，而CSMA/CA中信道由忙变闲后，各发送结点都要执行退避(第一次尝试发送的帧除外)。这样是为了更好的避免冲突。</li>
<li>CSMD/CA在发送、接收结点时通过RTS/CTS短帧预约信道，避免碰撞。CSMA/CD没有这个步骤</li>
<li>CSMA/CA会通过虚拟载波监听(Virtual Carrier
Sense)机制预留信道，避免碰撞发送结点将它要占用信道的时间，通过RTS/CTS中的NAV及数据帧MAC头部广播，告知其它结点在此期间停止发送。</li>
<li>CSMA/CA有不同的帧间间隔（任意站点在发现信道空闲后都必须等待一段时间才能发送下一帧，这段等待的时间通称为
IFS）发送不同类型的帧之前需要等待的IFS长度不同，高优先级帧需要等待的IFS较短，因此可优先获得发送权若低优先级帧还没来得及发送而其他站的高优先级帧已发送到媒体，则媒体变为忙状态，因而低优先级帧就只能再推迟发送了，这样就减少了发生碰撞的机会
，并区分出不同类型帧的优先级。</li>
</ol>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113002919227.png"></p>
<h2 id="以太网和wlan-对比">以太网和WLAN 对比</h2>
<p>以太网使用总线型拓扑（星型以太网逻辑上仍为总线型拓扑）</p>
<p>WLAN星型拓扑：中心:接入点（AP)</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113100019905.png"></p>
<h3 id="mac层对比">MAC层对比</h3>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113095140928.png" alt="以太网帧结构">
<figcaption aria-hidden="true">以太网帧结构</figcaption>
</figure>
<p>wlan：</p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113100132316.png" alt="802.11 MAC">
<figcaption aria-hidden="true">802.11 MAC</figcaption>
</figure>
<p>WIFI 帧结构：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113100221747.png"></p>
<p>## 交换技术与生成树算法</p>
<h3 id="为什么会引入交换技术">为什么会引入交换技术</h3>
<p>直连网络本质上是一种广播网络，带宽利用率低、可扩展性很差。在有环路的拓扑中，数据包会在网络中一直被广播下去。</p>
<p>为了提升网络的可扩展性，引入交换技术</p>
<h3 id="网桥工作原理">网桥工作原理</h3>
<p>功能：<strong>在数据链路层扩展局域网</strong></p>
<p>工作方式：</p>
<ul>
<li>过滤</li>
<li>转发</li>
</ul>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113104050673.png"></p>
<p>转发表/转发数据库(Forwarding DataBase,
FDB)存储目的MAC地址到（出）端口的映射关系：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113104329502.png"></p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113104611145.png" alt="网桥对数据帧的处理流程">
<figcaption aria-hidden="true">网桥对数据帧的处理流程</figcaption>
</figure>
<h3 id="转发表fdb生成原理">转发表（FDB)生成原理</h3>
<p>每收一个新的数据帧，记录其源MAC地址和入端口，将该映射关系写入FDB表。FDB格式如下所示，FDB表中MAC地址通过老化机制
(Aging)来更新。在端口收到无差错帧以后，如果源地址在FDB中需要更新方向和定时器，如果不在则将源地址加入FDB中并设置定时器。</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113124401661.png"></p>
<h3 id="生成树算法">生成树算法</h3>
<p><strong>why：这个算法的目的是解决什么问题？</strong></p>
<p>由于网络中存在冗余链路，当网络拓扑由树状结构变成图状结构，在数据转发过程中，形成环路，造成广播风暴。</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113104912659.png"></p>
<p>解决办法：</p>
<p>为网络中每对(源--目的)
结点分配唯一确定的一条路径，这些路径构成构成了一棵树 (生成树，Spanning
Tree)</p>
<p><strong>how：生成树算法的实现过程</strong></p>
<ul>
<li>选择一个网桥作为生成树的根（如选一个最小序号的网桥根网桥总在它所有端口上转发分组）</li>
<li>其它结点确定根端口：每个网桥计算到根的最短路径，并记下路径经过它自己的的哪个端口，即根端口，将根端口作为到根的优先路径</li>
<li>为每个局域网(网段)选定指派网桥：指派网桥负责位该网段向根网桥转发帧</li>
</ul>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113115652244.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113120226744.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113120501430.png"></p>
<h2 id="ip协议的特点">IP协议的特点</h2>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113125754437.png"></p>
<h2 id="rip-和ospf的对比">RIP 和OSPF的对比</h2>
<h3 id="riprouting-information-protocol的原理">RIP(Routing Information
Protocol)的原理</h3>
<p>RIP:基于
<strong>距离向量(DV)算法</strong>的<strong>分布式</strong>动态路由选择协议</p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113153347400.png" alt="基本思想">
<figcaption aria-hidden="true">基本思想</figcaption>
</figure>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113153650521.png" alt="向量表">
<figcaption aria-hidden="true">向量表</figcaption>
</figure>
<p>在RIP中，跳数(hop count)，每条链路的开销为
1（即每经过一个路由器，距离加 1）</p>
<p>RIP 允许距离的最大值为16，一条路径最多只能包含 15
个路由器RIP适用的网络规模有限：网络直径（最大跳数）小于15，跳数大于16，即为不可达</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113154223791.png"></p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113155116478.png" alt="例子">
<figcaption aria-hidden="true">例子</figcaption>
</figure>
<p><strong>RIP存在的问题</strong></p>
<p>Count-to-Infinity (计数到无穷)问题</p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113155241307.png" alt="image-20240113155241307">
<figcaption aria-hidden="true">image-20240113155241307</figcaption>
</figure>
<h3 id="rip-工作流程">RIP 工作流程</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113160900158.png"></p>
<h3 id="rip局限性">RIP局限性</h3>
<ol type="1">
<li><p><strong>可扩展性差</strong>（16作为无穷大(不可达)，它不能在“直径”大于15的网络上使用）</p></li>
<li><p><strong>不能在丢失率高的网络中使用</strong>（受限于RIP更新和超时机制）</p></li>
<li><p><strong>不能动态地使用时延、负载等为依据选择路由</strong>
（RIP在传播路由时使用固定的费用值，距离，在RIP中，每条链路的开销为
1）</p></li>
<li><p><strong>开销较大</strong>
（每30秒信息交换占用网络资源路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加）</p></li>
<li><p><strong>收敛速度慢</strong>
：网络出故障时往往需要较长的时间(例如数分钟)</p></li>
</ol>
<h3 id="ospf-open-shortest-path-first-原理">OSPF (Open Shortest Path
First) 原理</h3>
<p>使用最广泛的分布式<strong>链路状态 (Link State, LS)
</strong>路由协议</p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113165524035.png" alt="open 与shortest path first">
<figcaption aria-hidden="true">open 与shortest path first</figcaption>
</figure>
<p>什么是链路状态：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113162630453.png"></p>
<p><strong>基本思想</strong></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113163235956.png"></p>
<h3 id="ospf怎么构建网络拓扑">ospf怎么构建网络拓扑</h3>
<ol type="1">
<li><p>传播LSP:通过传播链路状态分组（LSP），LSP携带了结点标识，链路开销以及序号生存期等内容。</p></li>
<li><p>更新信息：结点x收到结点y的LSP信息副本后判断之前又没有保存过对应ID的LSP，如果没保存过则保存。如果保存过，则由于新副本的<strong>序列号更大</strong>，更新内容（此时TTL也一并更新了）。</p></li>
<li><p>扩散信息:继续向除y之外的所有节点扩散y的LSP副本</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113164609516.png"></p></li>
</ol>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113164013875.png"></p>
<h3 id="ospf怎么计算路由表">ospf怎么计算路由表</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113165203074.png"></p>
<h3 id="ospf-协议">OSPF 协议</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113194813823.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113195025306.png"></p>
<h3 id="ospf协议的优点">OSPF协议的优点</h3>
<p>克服RIP的缺点：</p>
<ul>
<li>收敛速度更快</li>
<li>使用区域(area)概念，可支撑更大规模的网络路由</li>
<li>链路度量可自定义，表示费用、距离、时延、带宽</li>
</ul>
<h3 id="rip和ospf的对比">RIP和OSPF的对比</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113195219643.png"></p>
<h2 id="域内路由协议与域间路由协议的对比">域内路由协议与域间路由协议的对比</h2>
<h3 id="为什么需要域间路由协议而不是直接用域内路由">为什么需要域间路由协议而不是直接用域内路由</h3>
<ul>
<li><p>域内路由是性能目标导向的，全域有统一目标：根据最小化某种链路度量值(开销)，找到一条最有路径</p></li>
<li><p>域间路由是策略和经济目标导向的，每个AS有自己的策略</p>
<p>寻找最好的策略兼容路径：找到一条无环的通往预定目的地的路径，路径必须兼容沿着路径的不同AS的策略</p></li>
</ul>
<h3 id="域间路由主要要解决的问题">域间路由主要要解决的问题</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113200044022.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113200654946.png"></p>
<h3 id="bgp原理">BGP原理</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113200820619.png"></p>
<p>AS的管理员要选择至少一个路由器作为“ BGP 代言人” 。一般是 BGP
边界路由器。</p>
<p>不同AS的 BGP 代言人建立 TCP 连接，在此连接上交换 BGP 报文以建立 BGP
会话(session)，利用 BGP 会话交换路由信息</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113201723235.png"></p>
<h3 id="bgp-优点">BGP 优点</h3>
<ul>
<li>BGP是基于TCP的路由协议，只要能够建立TCP就能够建立BGP；</li>
<li>BGP只传递路由信息，不计算路由，不会暴露AS内部的网络拓扑；</li>
<li>BGP的路由更新是触发更新，不是周期性更新；</li>
</ul>
<h2 id="三种ip-地址编址方案以及路由寻找对比">三种IP
地址编址方案以及路由寻找对比</h2>
<h3 id="分类-ip-地址">分类 IP 地址</h3>
<p>IP地址的层次结构：IP地址 = 网络号+主机号</p>
<p>分为A,BC,D,E类地址</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240113230133743.png"></p>
<h3 id="分类ip地址存在的问题">分类IP地址存在的问题</h3>
<ol type="1">
<li>IP地址的利用率低，网络号和主机号位数固定，导致网络规模不可调，造成分配的不合理,分配的是网络号而不是40亿个独立的IP地址，耗尽的速度快</li>
<li>每个物理网络分配一个网络号使得路由表过大。大转发表增加路由器开销，增大路由查找延迟，减低路由器性能。</li>
<li>使用不灵活。同一组织在不同地方开通新的物理网络，需要申请新的网络地址不易于扩展、管理</li>
</ol>
<h3 id="子网划分">子网划分</h3>
<p>针对分类IP地址存在的问题做了一定的改进</p>
<p><strong>基本思想</strong></p>
<p>通过划分子网 (subnetting)，在IP
地址中又增加了一个“子网号字段”，将两级的 IP
地址变成为三级。实现多个物理网络共享一个网络号减少分配网络号总数，实现<strong>路由聚合
(aggregation)</strong></p>
<p><strong>路由聚合
(aggregation)</strong>：互联网络不同部分看到不同的路由，远端只看到单一网络</p>
<p>划分子网纯属一个单位内部的事情，对外仍表现为未划分子网的网络</p>
<p><strong>优点</strong></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114000226068.png"></p>
<h3 id="无类地址-构造超网">无类地址 (构造超网)</h3>
<p>为了解决地址空间的效率和可扩展性问题，（见下面的例子），提出CIDR</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114001032649.png"></p>
<p>CIDR地址块：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114001157722.png"></p>
<p><strong>路由聚合和超网</strong></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114001304661.png"></p>
<h3 id="最长前缀匹配">最长前缀匹配</h3>
<p><strong>为什么需要最长前缀匹配</strong></p>
<p>使用 CIDR ，在查找路由表时可能会得到不止一个匹配结果</p>
<p><strong>怎么匹配</strong></p>
<p>从匹配结果中选择具有最长网络前缀的路由，网络前缀越长，其地址块就越小，因而路由就越具体(more
specific)</p>
<p>匹配例子：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114001653044.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114001954031.png"></p>
<h3 id="ip地址的特点">IP地址的特点</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114002115340.png"></p>
<h3 id="三种情况下路由转发对比">三种情况下路由转发对比</h3>
<p><strong>没划分子网</strong></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114125020175.png"></p>
<p><strong>划分子网</strong></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114125116900.png"></p>
<p><strong>CIDR</strong></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114125216695.png"></p>
<p><strong>总结三种方法的异同：</strong></p>
<ol type="1">
<li><p>首先都需要从IP分组的头部提取目的主机的IP地址D，得到目的网络地址N.</p></li>
<li><p>然后三种方法在判断是否是直接交付的时候存在差异，未划分子网的方法是判断N与路由器直接相连的某个网络地址是否相同，若是则直接交付。而划分子网的方法，需要将路由器结点的各个网络子网掩码与目的主机IP地址D逐位相与后，再查看是否与路由器的本地ip相匹配。CIDR则和之前类似，也是直接判断D和路由器是否在同一个网络内判断是否直接交付。</p></li>
<li><p>从精确到模糊进行匹配：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114130654550.png"></p>
<ol start="6" type="1">
<li>如果出现了问题都需要报告转发分组出错（发ICMP 目的不可达报文）</li>
</ol></li>
</ol>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114124903481.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114125151092.png"></p>
<h2 id="地址解析协议arp-address-resolution-protocol原理">地址解析协议ARP
(Address Resolution Protocol)原理</h2>
<p><strong>为什么有ARP</strong></p>
<p>主机或路由器的物理接口硬件在转发数据时，只能理解特定网络的编制方案如
MAC地址 。</p>
<h3 id="网络层的地址解析过程"><strong>网络层的地址解析过程</strong></h3>
<p>地址解析：IP地址-&gt;硬件地址</p>
<p>IP数据报在逐跳转发过程中，每一个结点需要根据本次传输的目的结点IP,找到对应的目的结点的硬件地址,(仅仅是本跳传输的直接接收结点)
随后，网络适配器把IP数据报封装在 目的地址为该硬件地址的的帧中
，发往本次传输的目的结点（可能是最终目的地，也可能是到达最终目的地的中间路由器
，网络适配器，也就是数据链路层的处理并不用关心）</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114213551639.png"></p>
<h3 id="arp原理">ARP原理</h3>
<p>每个结点保留一张对照表：IP地址-&gt;硬件地址</p>
<p><strong>ARP
Cache</strong>：每个三层结点中都有一个ARP高速缓存，存储结点所在局域网内各结点的
IP 地址到其硬件地址的映射。</p>
<p>结点A向局域网内另一结点B发送IP报文时，首先在其 ARP Cache 中查看有无B
的 IP 地址，有则查出其对应的硬件地址，将此硬件地址写入 MAC
帧，通过局域网将该 MAC
帧发往此硬件地址。否则，A向局域网内广播ARP请求，询问B的IP地址对应的硬件地址，B收到该请求后，单播回复自己的硬件地址A和B都会将对方地址的映射关系写入ARP
Cache。</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114215127378.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114215306726.png"></p>
<h3 id="arp报文">ARP报文</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240114215414783.png"></p>
<h2 id="传输层要解决的核心问题">传输层要解决的核心问题</h2>
<p>网络层及其下层技术实现了<strong>主机到主机</strong>的通信。</p>
<p>网络层实现了：无连接的、尽最大努力交付的数据报传输服务。</p>
<p>为了支持网络应用间的数据传输，主机端还需要实现很多功能：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116094739116.png"></p>
<p>传输层实现端系统上运行的<strong>应用进程间</strong>的逻辑通信，即端到端传输</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116094316803.png"></p>
<h2 id="udp和tcp协议的区别">UDP和TCP协议的区别</h2>
<p>用户数据报协议 UDP (User Datagram Protocol)</p>
<ul>
<li><strong>最简单的传输协议</strong>把下层网络的主机到主机的传递服务扩展到进程到进程的通信服务，提供端到端的<strong>尽力而为</strong>的数据报传输服务</li>
<li>IP 的数据报服务之上增加了很少一点的功能
<ul>
<li>多路分解/多路复用，即端口的功能</li>
<li>差错检测的功能</li>
</ul></li>
</ul>
<h3 id="udp特点">UDP特点</h3>
<ul>
<li><p>无连接的，无需建立连接，无需维护状态减小开销和启动延迟，例如DNS就是基于UDP的</p></li>
<li><p>尽最大努力交付，不保证可靠传输，主机不需维持复杂的状态</p></li>
<li><p>没有拥塞控制</p>
<ul>
<li>网络的拥塞不影响源主机的发送速率</li>
<li>以上两点适用于IP电话、视频直播等应用要求恒定发送速率，允许丢包，但是时延敏感应用。</li>
</ul></li>
<li><p>UDP
支持一对一、一对多、多对一和多对多的交互通信需要组播的应用都建立在UDP之上</p></li>
<li><p>面向报文的，在IP的功能上简单扩展到端到端</p>
<ul>
<li>发送方 UDP 对应用交付下来的报文，添加 UDP 头部后，直接交付IP层
<ul>
<li>不合并，不拆分，保留报文的边界，应用层付多长的报文，UDP
就发多长，一次交付发送一个报文</li>
</ul></li>
<li>接收方 UDP 对 IP 层交付上来的 UDP
用户数据报，去除首部后就原封不动地交付上层的应用进程
<ul>
<li>一次交付一个完整的报文</li>
</ul></li>
<li>应用程序必须选择合适大小的报文
<ul>
<li>报文太长，IP层需要分片，降低IP层效率；报文太短，头部相对太长，也降低效率</li>
</ul></li>
</ul></li>
<li><p>作为最基本的传输层协议，上层应用可实现更多功能、按需定制</p>
<ul>
<li>例如：UDT (UDP-based Data Transfer Protocol)，基于UDP的数据传输协议
<ul>
<li>面向连接的应用层协议，在UDP的基础上增加拥塞控制和数据可靠传输控制机制</li>
<li>主要支持高速广域网上的海量数据传输
<ul>
<li>TCP在高带宽长距离网络上性能很差</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="tcp特点">TCP特点</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116100637940.png"></p>
<h3 id="udp-对比-tcp">udp 对比 TCP</h3>
<ol type="1">
<li><strong>TCP 是面向连接的协议，UDP 是无连接协议</strong></li>
</ol>
<p>​ TCP 发送数据前使用三次握手建立连接，UDP
发送数据前不需要建立连接。</p>
<ol start="2" type="1">
<li><strong>TCP 可靠，UDP 不可靠</strong></li>
</ol>
<p>​ TCP 丢包会自动重传，UDP 不会(任何必需的可靠性必须由应用层来提供)。
TCP 可靠性由三个机制保证：1. 序号（TCP 报文的序 号）2. 确认（ACK
机制）3. 重传（超时或者冗余的 ACK）</p>
<ol start="3" type="1">
<li><strong>TCP 有序，UDP 无序</strong></li>
</ol>
<p>消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP
会对其进行重新排序，UDP 不会。</p>
<ol start="4" type="1">
<li><strong>TCP 无界，UDP 有界</strong></li>
</ol>
<p>TCP 通过字节流传输，UDP 中每一个包都是单独的。</p>
<ol start="5" type="1">
<li><strong>TCP 有流量控制（拥塞控制），UDP 没有</strong></li>
</ol>
<p>TCP 协议的流量控制是基于滑窗协议实现的。
拥塞控制和流量控制不同，流量控制是点对点的通信量抑制，抑制发送端发送速率，使得接收端来得及接收。</p>
<ol start="6" type="1">
<li><strong>TCP 传输慢，UDP 传输快</strong></li>
</ol>
<p>因为 TCP 需要建立连接、保证可靠性和有序性，所以比较耗时。
这就是为什么视频流、广播电视、在线多媒体游戏等选择使用 UDP。</p>
<ol start="7" type="1">
<li><strong>TCP 是重量级的，UDP 是轻量级的</strong></li>
</ol>
<p>TCP 要建立连接、保证可靠性和有序性，就会传输更多的信息，如 TCP
的包头比较大。</p>
<ol start="8" type="1">
<li><strong>TCP 的 头部比 UDP 大</strong></li>
</ol>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116100939679.png"></p>
<h2 id="tcp-滑动窗口">TCP 滑动窗口</h2>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240118175410495.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240118175547277.png"></p>
<p>A 收到确认后，移动指针。有效窗口增大</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240118175841454.png"></p>
<p>选择确认方法：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240118180057481.png"></p>
<h2 id="tcp流量控制">TCP流量控制</h2>
<h3 id="什么是流量控制为什么有流量控制">什么是流量控制？为什么有流量控制</h3>
<p>防止快发送方给慢接收方发数据造成接收崩溃，缓冲区溢出</p>
<ul>
<li>窗口大小变化，受“流量控制”、“拥塞控制”的影响发送FIN报文段，表示己方不再发送数据</li>
</ul>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116104234914.png"></p>
<h3 id="流量控制的基本实现原理">流量控制的基本实现原理</h3>
<ol type="1">
<li><p><strong>首先，接收方确定 AdvertisedWindow 大小</strong></p>
<p><strong>AdvertisedWindow = MaxRcvBuffer – ( (NextByteExpected – 1) -
LastByteRead)</strong></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116105318454.png"></p></li>
</ol>
<p>AdertisedWindow
代表缓存区中剩余的空间数量，新的数据到达，NextByteExpected
指针右移，窗口大小可能变小。可以看出，窗口是否缩小依赖于<strong>应用进程读取数据的速度与数据到达的速度的相对快慢</strong>。</p>
<ol start="2" type="1">
<li><p>发送方根据 AdvertisedWindow 值确定有效窗口，限制发送速率</p>
<p>有效窗口(EffectiveWindow) = AdvertisedWindow – (LastByteSent -
LastByteAcked)</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116110103925.png"></p></li>
</ol>
<p>​</p>
<ol start="3" type="1">
<li><p>发送方只有在有效窗口大于0的情况下，才能发送更多数据。</p>
<p>可能的情况：发送方有效窗口已为 0。</p>
<p>此时一个报文段到达而确认x字节，因此LastByteAcked右移x字节，发送窗口减小。然而接收方应用进程未读取任何数据，因此AdvertisedWindow比之前小了x字节。发送方尽管释放了发送缓冲区空间，但仍不能再发送任何数据。</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116110604577.png"></p></li>
<li><p>发送方还必须同时保证发送缓存区不溢出：LastByteWritten –
LastByteAcked ≤ MaxSendBuffer</p>
<p>可能的情况：发送进程试图向 TCP 写入 y 字节，但是 LastByteWritten –
LastByteAcked + y &gt; MaxSendBufferTCP
会<strong>阻塞发送进程</strong>，不让它再产生数据</p></li>
</ol>
<h3 id="举例说明慢接收进程如何对快发送进程进行流控">举例说明，慢接收进程如何对快发送进程进行流控</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116131037611.png"></p>
<h3 id="存在的死锁问题"><strong>存在的死锁问题</strong></h3>
<p>某些情况下，发送方 A 无法知道 AdvertisedWindow 不再为 0</p>
<ul>
<li><p>当 B 没有数据需要向 A 发送时</p></li>
<li><p>原因：TCP
仅在它有数据或者有确认需要向对端发送时才会发送报文段</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116131234370.png"></p></li>
</ul>
<p><strong>解决方案</strong></p>
<p>TCP 为每个 TCP 连接设置一个<strong>持续计时器</strong> (persistence
timer)，只要 TCP 连接的一方收到对方的 0 窗口通知，就启动该计时器。</p>
<p>计时器到期，发送零窗口探测报文 (仅携带1字节数据)。</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116132025242.png"></p>
<h3 id="长肥管道现象">长肥管道现象</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116132201794.png"></p>
<p>通知窗口字段允许的最大值，需要足够大以使得发送方能够保持管道满载</p>
<p><strong>网络的时延带宽积</strong>决定 AdvertisedWindow
字段应有的大小</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116132356130.png"></p>
<h2 id="拥塞控制">拥塞控制</h2>
<h3 id="拥塞控制和流量控制的区别为什么还需要拥塞控制">拥塞控制和流量控制的区别，为什么还需要拥塞控制</h3>
<p>流量控制：确保接收方能否承受。防止发送方发出的数据超出接收方的接收能力。</p>
<p>拥塞控制：确保网络能够承受。防止过多数据注入网络造成网络节点或链路超载。</p>
<p><strong>网络拥塞可能带来的代价</strong></p>
<ul>
<li>分组到达速率接近链路容量时，分组将经历巨大的排队时延</li>
<li>发送方必须执行重传以补偿因为缓存溢出而丢弃的分组</li>
<li>发送方在遇到大时延时所进行的不必要重传会引起路由器及其链路浪费资源转发不必要的分组拷贝</li>
<li>当一个分组沿一条路径传输过程中被丢弃时，每个上游路由器用于转发该分组而使用的传输容量最终被浪费掉了</li>
</ul>
<p>网络拥塞后果：</p>
<p>丢包率升高、时延增大、甚至网络崩溃 (Network Collapse)</p>
<p><strong>拥塞控制的目标</strong></p>
<ul>
<li>保证发送速率适应网络瓶颈</li>
<li>发送速率适应网络处理能力的变化</li>
<li>多条流<strong>公平</strong>地共享资源</li>
</ul>
<h3 id="拥塞控制策略">拥塞控制策略</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116134146351.png"></p>
<p>TCP采用<strong>端到端</strong>的拥塞控制策略,TCP/IP
系统设计倾向端到端原则，将<strong>可扩展性</strong>放到第一位</p>
<p><strong>如何判断是否拥塞</strong></p>
<p>不需要网络设备的拥塞提醒。端设备通过丢包、延迟变化等推测网络拥塞状况。</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116134034806.png"></p>
<h2 id="tcp拥塞控制">TCP拥塞控制</h2>
<p>四种基本算法 (RFC 5681)</p>
<ul>
<li>慢启动 (slow start)</li>
<li>拥塞避免 (AIMD)</li>
<li>快重传 (fast transmit)</li>
<li>快恢复 (fast recovery)</li>
</ul>
<h3 id="拥塞检测">拥塞检测</h3>
<p>可通过丢包进行隐式的拥塞反馈。通过ACK判断是否丢包。</p>
<p><strong>TCP判断拥塞的两个依据</strong></p>
<p>报文段超时</p>
<ul>
<li>现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率是很小的（远小于
1 %），出现超时，就可以猜想网络可能出现了拥塞</li>
</ul>
<p>收到多个重复ACK</p>
<ul>
<li>收到一个重复ACK，就知道接收方必定收到乱序到达的报文段，表明其前面的分组可能丢失</li>
</ul>
<h3 id="拥塞窗口-cwnd-怎么调整的">拥塞窗口 cwnd 怎么调整的</h3>
<p><strong>窗口调整的基本策略</strong></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116151104433.png"></p>
<h4 id="慢启动slow-start"><strong>慢启动(slow-start)</strong></h4>
<p>基本思想</p>
<ul>
<li>主机开始发送数据 (连接刚建立)
或判断拥塞发生时，不确定网络状况，应避免注入大量数据而引起拥塞拥塞窗口大小<strong>从很小的初始值开始</strong>，发送成功则<strong>快速增大</strong>，以探测网络的负载能力。</li>
</ul>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116151504264.png"></p>
<h4 id="拥塞窗口的增减策略"><strong>拥塞窗口的增减策略</strong></h4>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116152344822.png"></p>
<p>怎么选？？</p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116152938464.png" alt="对比">
<figcaption aria-hidden="true">对比</figcaption>
</figure>
<h4 id="tcp-拥塞避免aimd"><strong>TCP 拥塞避免(AIMD)</strong></h4>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116154030888.png"></p>
<p>使用慢启动门限 ssthresh (变量)</p>
<ul>
<li>当 cwnd &lt; ssthresh 时，使用慢启动</li>
<li>当 cwnd &gt; ssthresh 时，停止使用慢启动而改用AIMD</li>
</ul>
<p><strong>慢启动+拥塞避免</strong></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116153835771.png"></p>
<h4 id="快重传快恢复"><strong>快重传+快恢复</strong></h4>
<p>快重传 (Fast Retransmits)：收到 3 个重复 ACK
立即触发重传（阈值减半，开始快恢复）</p>
<p>快速重传不能代替常规超时机制，仅是增强功能并非取消超时重传定时器，而是在某些情况下可更早地触发重传丢失的报文段：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240118165130378.png"></p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240118162151165.png" alt="快重传">
<figcaption aria-hidden="true">快重传</figcaption>
</figure>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116160023260.png"></p>
<p>快速恢复 (Fast Recovery) 阶段 起始于快速重传后，结束于RecoveryPoint
数据被连续确认。RecoveryPoint 为进入快速恢复阶段时发送的最大序列号。</p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116160907712.png" alt="差异对比">
<figcaption aria-hidden="true">差异对比</figcaption>
</figure>
<p>快重传+快恢复的优点：</p>
<ul>
<li><p>减少了慢启动 <strong>（快恢复）</strong></p></li>
<li><p>减少了由于等待超时引起的连接无效 (cwnd不变且无数据发送) 时间
<strong>（快重传）</strong></p></li>
<li><p>可以达到稳态，且稳态时 cwnd 会在最优值附近摆动</p></li>
</ul>
<p><strong>快重传+快恢复的一些现象</strong></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116162137647.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116162745336.png"></p>
<h3 id="拥塞控制总结">拥塞控制总结</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116163305031.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116163612791.png"></p>
<h2 id="tcp拥塞控制的优化">TCP拥塞控制的优化</h2>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240118162755350.png"></p>
<h3 id="快速重传与数据乱序">快速重传与数据乱序</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240118163221577.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240118165328106.png"></p>
<h2 id="tcp-连接">TCP 连接</h2>
<h3 id="连接的目的">连接的目的</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116210737193.png"></p>
<h3 id="连接的特点">连接的特点</h3>
<p>TCP 连接的建立采用 客户-服务器 方式</p>
<p>连接的建立是非对称的：</p>
<p>服务器已预先被动打开创建传输控制块，进入LISTEN状态，表示服务程序已准备好，等待客户的连接请求。连接建立由客户端主动打开开始</p>
<h3 id="三次握手">三次握手</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116211158041.png"></p>
<p><strong>两次握手为啥不行？</strong>（为什么 A
需要向B应答最后一个确认报文段 ？）</p>
<ul>
<li>为防止“已失效的连接请求报文段”突然又传送到B而产生错误。若不采用三次握手，B则单方面建立起了连接，但A并没有建立，因此也不会向B发送数据，B却一直等待，B的资源被浪费</li>
</ul>
<p>“已失效的连接请求报文段”如何产生？</p>
<p>A发出第一个连接请求未丢失，只是在某些网络结点滞留了，以致延误到连接释放后的某个时间才到达B；B收到这个早已失效的请求后，误以为A发起了一次新的连接请求，向A发送确认报文段，同意建立连接。</p>
<h3 id="tcp-连接释放">TCP 连接释放</h3>
<p><strong>特点</strong></p>
<p>连接的任何一方都可以主动关闭连接</p>
<ul>
<li>发送FIN报文段，表示己方不再发送数据</li>
</ul>
<p>另一端可以继续发送数据</p>
<ul>
<li>TCP是一个全双工传输协议，双向的字节流传输，两个方向的数据传输可能不会同时结束。</li>
<li>单向的数据传输仍需要得到接收方的确认</li>
</ul>
<p>报文段异常情况下，任何一方都可以发送 RST 报文段关闭连接</p>
<p><strong>四次挥手释放过程</strong></p>
<p>A、B 都处于 ESTABLISED 状态，假设 A 先传输完数据，主动关闭 TCP
连接。A 向 B 发送连接释放报文段，进入 FIN-WAIT-1 (终止等待1)状态。</p>
<p>B 收到 A 的连接释放报文段后，应答确认，进入 CLOSE-WAIT
(关闭等待)状态。TCP 服务器进程此时应通知高层应用进程，从 A 到 B
的连接就释放了，TCP 连接处于半关闭 (half-close) 状态。</p>
<p>A收到B的确认后，进入FIN-WAIT-2 (终止等待2)
。状态B到A方向的连接未关闭，B若发送数据，A仍要接收</p>
<p>若 B 已没有向 A 的数据，其应用进程通知 TCP 释放连接。B 向 A
发送连接释放报文段后，进入 LAST-ACK (最后确认) 状态</p>
<p>A 必须经过时间等待计时器 (TIME-WAIT timer) 设置的时间 2MSL 后，进入
CLOSED 状态。MSL (Maximum Segment Lifetime,
最长报文段寿命)，RFC793设为2分钟，允许设为更小值。</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116215738845.png"></p>
<p><strong>为什么 A 在 TIME-WAIT 状态必须等待 2MSL
的时间呢？</strong></p>
<p>确保 A 发送的最后一个 ACK 报文段能够到达 B。</p>
<ul>
<li>若这个ACK报文段丢失，处在 LAST-ACK 状态的 B 收不到对已发送的
FIN+ACK报文段的确认，会超时重传该FIN+ACK。A能在 2MSL
时间能收到这个重传的 FIN+ACK
报文段，重新启动2MSL计时器；最后A和B都能正常进入CLOSED状态。否则，A
无法收到 B 重传的 FIN+ACK，因此不会再次发送确认，B
会因收不到确认而无法进入 CLOSED 状态。</li>
</ul>
<p>防止“已失效的连接请求报文段”出现在本连接中</p>
<ul>
<li>A 发送完最后一个 ACK 报文段后，再经过
2MSL，可以使本连接持续时间内产生的所有报文段都从网络中消失，从而使得下个新连接中不会出现这种旧的连接请求报文段</li>
<li>发送FIN报文段，表示己方不再发送数据</li>
</ul>
<h2 id="dns">DNS</h2>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116224911693.png"></p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116233529204.png" alt="域名的层次化空间">
<figcaption aria-hidden="true">域名的层次化空间</figcaption>
</figure>
<p>一个 DNS 服务器所负责管辖的 (或有权限的) 范围叫做区 (zone)</p>
<p>DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位</p>
<p>各单位根据具体情况来划分自己管辖范围的区，但在一个区中的所有节点必须是能够连通的</p>
<p>每一个区设置相应的权威域名服务器，用来保存该区中的所有主机的域名到 IP
地址的映射</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116234555273.png"></p>
<p><strong>根域名服务器</strong></p>
<p>根域名服务器是最高层次的域名服务器，也是最重要的域名服务器，所有的<strong>根域名服务器</strong>都知道所有的<strong>顶级域名服务器的</strong>域名和
IP
地址不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就求助于根域名服务器</p>
<p><strong>顶级域名 (Global Top-level domain, gTLD) 服务器</strong></p>
<p>一般性域名 (e.g. .com, .org, .info)</p>
<p>国家地区域名 (e.g. .cn, .hk, .uk)</p>
<p>一般由专业机构来维护管理 (e.g. VeriSign 管理 .com和 .net域名)</p>
<p><strong>权威 (Authoritative) 域名服务器</strong></p>
<p>负责一个区的域名服务器，提供一个组织内的域名与主机映射关系通常是该组织提供的服务，一般由组织自己维护管理</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240116235611852.png"></p>
<h3 id="递归查询和迭代查询的差别和流程">递归查询和迭代查询的差别和流程</h3>
<p><strong>递归查询</strong></p>
<p>主机向<strong>本地域名服务器</strong>的查询一般都是采用递归查询.若主机所询问的本地域名服务器不知道被查询域名的
IP 地址，那么本地域名服务器就以 DNS
客户的身份，向<strong>其他根域名服务器</strong>继续发出查询请求</p>
<p><strong>报文迭代查询</strong></p>
<p>本地域名服务器向根域名服务器的查询通常是采用迭代查询,当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的
IP
地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”，再让本地域名服务器进行后续的查询</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240117000713208.png"></p>
<p>对比：</p>
<p>递归查询：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20231119202535382.png"></p>
<p>迭代查询：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240117002807890.png"></p>
<h3 id="dns-缓存">DNS 缓存</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20231119204615641.png"></p>
<h3 id="负载均衡">负载均衡</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240117003252669.png"></p>
<h2 id="网络细腰结构再那一层最合适">网络细腰结构再那一层最合适</h2>
<h3 id="为什么要换细腰">为什么要换细腰</h3>
<p>网络发生了翻天覆地的变化： 求及挑战一：”更快”</p>
<p>需求及挑战二：”更灵活”：复杂的网络协议与系统无法支持简单、快速组网</p>
<p>需求及挑战三：”更安全”：TCP/IP 对安全性考虑不够</p>
<h3 id="细腰换成什么">细腰换成什么</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%BC%B9/image-20240117082831016.png"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识总结-网安-QOS-P2P-CDN-网络测量-区块链</title>
    <url>/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/</url>
    <content><![CDATA[<h1 id="计算机网络知识总结网安qosp2pcdn网络测量区块链">计算机网络知识总结：网安，QOS,P2P,CDN,网络测量，区块链</h1>
<h2 id="网络安全">网络安全</h2>
<h3 id="什么是网络安全">什么是网络安全</h3>
<p>网络安全的一个通用定义指网络信息系统的==硬件、软件及其系统中的数据受到保护==，不因偶然的或者恶意的===破坏、更改、泄露==，
系统能连续、可靠、正常地运行，服务不中断</p>
<h3 id="网络安全的五大要素">网络安全的五大要素</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107102612537.png"></p>
<h3 id="网络安全机制位于协议的那一层">网络安全机制位于协议的那一层</h3>
<p>没有一个单独的位置，因为安全性与每一层都有关</p>
<ul>
<li>物理层：传输线封装在包含高压氩气的密封管，漏气报警</li>
<li>数据链路层：点到点线路加解密，不能经过中间路由器</li>
<li>网络层：防火墙、IP报文头的安全域</li>
<li>传输层：端到端连接的加解密</li>
<li>应用层：大多数安全机制都集中在此层</li>
</ul>
<h2 id="加密技术">加密技术</h2>
<h3 id="加密类型">加密类型</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107103512007.png"></p>
<h3 id="什么是对称加密什么是非对称加密对比优缺点">什么是对称加密什么是非对称加密，对比优缺点</h3>
<p>单密钥加密又称为对称加密</p>
<p>经典算法：DES, 3-DES, AES, IDEA, SMS4, RC5, TRIVIUM</p>
<p>非对称加密就是公开密钥加密采用公钥私钥两个密钥。是两位学者以单向函数与单向暗门函数为基础，为发讯与收讯的两
方创建密钥。</p>
<p>经典算法：RSA、ElGamal、Elliptic Curve Cryptography, ECC</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107121024191.png"></p>
<p><strong>对称加密</strong> ：</p>
<ul>
<li><p>优势：加密解密速度快</p></li>
<li><p>缺点：</p>
<ul>
<li>1.密钥管理量大 <img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107104111875.png"></li>
<li><ol start="2" type="1">
<li><p>密钥传输信道要求更高安全性：如何保证密钥可靠</p>
<ul>
<li><p>密钥传输和密文在同一信道传输</p></li>
<li><p>同时被窃取，很容易被破解出明文，并不安全</p></li>
</ul></li>
</ol></li>
<li>3.数字签名的问题:通过对称密钥加密很难实现数字签名技术，无法有效的进行完整性的检验</li>
</ul>
<p><strong>非对称密钥加密</strong></p>
<p>主要特点：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107134311030.png"></p></li>
</ul>
<h3 id="des算法">DES算法</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107115331288.png"></p>
<h3 id="对称加密的加密和签名的基本流程是怎样的">对称加密的加密和签名的基本流程是怎样的</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107122440635.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107134146481.png"></p>
<p>数字签名特性：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107144754168.png"></p>
<p>不可伪造，不可抵赖</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107145023004.png"></p>
<h3 id="rsa算法">RSA算法</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107135122582.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107135221047.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107135333998.png"></p>
<p>例题2：</p>
<blockquote>
<p><strong>1.假设需要加密的明文信息为m=85，选择：e=7，p=11，q=13，说明使用RSA算法的加密和解密</strong></p>
</blockquote>
<p>首先计算 n=p<em>q=143 和z=10 </em> 12 =120</p>
<p>e=7</p>
<p>e*d≡1 mod z</p>
<p>d=103</p>
<p>公钥：（e=7，n=143）</p>
<p>私钥 （d=103，n=143）</p>
<p>加密：<span class="math inline">\(C=M^{e}mod n=85^{7}mod
143\)</span>=123</p>
<p>解密<span class="math inline">\(M=C^{d}mod n\)</span>=85</p>
<h4 id="总结思路">总结思路：</h4>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/RSA.png" alt="rsa">
<figcaption aria-hidden="true">rsa</figcaption>
</figure>
<h4 id="为什么rsa是有效的">为什么RSA是有效的？</h4>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107143132663.png"></p>
<h3 id="单向校验和">单向校验和</h3>
<h4 id="单项校验和是怎么做的收到一个东西怎么验证其完整性没有遭到破坏">单项校验和是怎么做的，收到一个东西怎么验证其完整性没有遭到破坏</h4>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107150154522.png"></p>
<p>发送者首先计算CK(m)，然后用私人密钥将其加密产生密文D_A(CK(M)),将（m，D_A(CK(M))对偶传送到B,报文本身可以使用明文发送或者用公开加密技术加密，后面跟加密的校验和。</p>
<p>当报文和校验和到达B后，B对签名部分即（D_A(CK(m）))应用E_A得到CK(m)。此时B有m，ck(m)和D_A(CK(M))。B对m应用CK看此结果是否与收到的ck(m)一致若是则说明报文没有遭到篡改，否则说明报文被篡改。</p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/单项校验和.png" alt="单项校验和">
<figcaption aria-hidden="true">单项校验和</figcaption>
</figure>
<h4 id="单项校验和出现争议后怎么解决">单项校验和出现争议后怎么解决</h4>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107152236824.png"></p>
<h2 id="网络攻击">网络攻击</h2>
<h3 id="什么是主动攻击什么是被动攻击举例说明">什么是主动攻击？什么是被动攻击？举例说明</h3>
<p>主动攻击：主动攻击会导致某些==数据流的篡改==和==虚假数据流==的产生。这类攻击可分为==篡
改==、==伪造==消息数据和终端，==拒绝服务==。</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107152738053.png"></p>
<p>被动攻击中攻击者==不对数据信息做任何修改==，截取/窃听是指在未经用户同
意的情况下攻击者获得了信息。通常包括==窃听、流量分析、破解弱加密的数据流==等攻击方式</p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107153038734.png" alt="image-20240107153038734">
<figcaption aria-hidden="true">image-20240107153038734</figcaption>
</figure>
<h2 id="qos">QOS</h2>
<h3 id="什么是服务质量服务质量在网络层面主要关注那些指标服务质量的目标有哪些">什么是服务质量？服务质量在网络层面主要关注那些指标？服务质量的目标有哪些？</h3>
<ul>
<li><p>QoS（Quality of Service）即服务质量</p></li>
<li><p>网络层面主要关注：带宽、时延、丢包率等。</p></li>
</ul>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107153632261.png" alt="image-20240107153632261">
<figcaption aria-hidden="true">image-20240107153632261</figcaption>
</figure>
<h3 id="时延">时延</h3>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107154112817.png" alt="image-20240107154112817">
<figcaption aria-hidden="true">image-20240107154112817</figcaption>
</figure>
<p>从一端看</p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107154221547.png" alt="image-20240107154221547">
<figcaption aria-hidden="true">image-20240107154221547</figcaption>
</figure>
<p>其中，传播时延和处理时延都是很难改变的，QOS主要关注的是排队时延</p>
<h3 id="丢包是什么在有线和无线网络中各有什么原因">丢包是什么，在有线和无线网络中各有什么原因</h3>
<p>丢包通常发生在输出队列满的时候，也有一些其他类型的 丢包
（输入队列丢包、错误、故障等）</p>
<p>在有线网络中==链路拥塞==是丢包的重要原因</p>
<p>在无线网络中丢包通常是由于==信道质量差==造成的。</p>
<h3 id="integrated-service">Integrated service</h3>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107155747519.png" alt="image-20240107155747519">
<figcaption aria-hidden="true">image-20240107155747519</figcaption>
</figure>
<h4 id="rsvp-是怎么工作的">RSVP 是怎么工作的？</h4>
<p>RSVP（资源预留协议
），RSVP==运行在从源端到目的端的每个设备上==，可以==监视每个流==，以防止其消耗资源过多。这种体系能够明确区分并保证每一个业务流的服务质量，为网络提
供最细粒度化的服务质量区分。</p>
<h4 id="rsvp-为什么需要逐跳的路由rsvp特点rsvp属于那一层可以单播还是多播单向还是双向">RSVP
为什么需要逐跳的路由？RSVP特点？RSVP属于那一层？可以单播还是多播，单向还是双向。</h4>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107160931053.png" alt="image-20240107160931053" style="zoom:80%;"></p>
<p>==RSVP是面向接收方==</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107161507287.png" alt="image-20240107161507287" style="zoom:80%;"></p>
<h4 id="面向接收方和面向发送方的资源预留各有什么好处你觉得哪一种更好">面向接收方和面向发送方的资源预留各有什么好处，你觉得哪一种更好？</h4>
<p>面向接收方：收费模型一般是按照接收方确认收费的，接收方可以自主选择接收质量</p>
<h3 id="diff-serv">Diff-Serv</h3>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107163533680.png" alt="=">
<figcaption aria-hidden="true">=</figcaption>
</figure>
<h3 id="integrated-service和diff-serv-各自的优缺点和适应的场合对比">Integrated
service和Diff-Serv 各自的优缺点和适应的场合对比</h3>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107163326918.png" alt="=">
<figcaption aria-hidden="true">=</figcaption>
</figure>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107163350249.png" alt="=">
<figcaption aria-hidden="true">=</figcaption>
</figure>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107163656215.png" alt="image-20240107163656215" style="zoom:80%;"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107163822550.png"></p>
<h3 id="e-lsp和l-lsp">E-LSP和L-LSP</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107170111372.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107170022079.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107170225634.png"></p>
<p>e-lsp的EXP标记的交换路径最多可以支持8个服务等级，L-LSP一个标签交换路径支持一个QOS等级</p>
<h3 id="qos机制-拥塞管理和调度策略">QoS机制-拥塞管理和调度策略</h3>
<h4 id="什么是队列调度">什么是队列调度</h4>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107171024284.png"></p>
<h4 id="出端口队列结构三个组件是什么有什么用">出端口队列结构，三个组件是什么？有什么用？</h4>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107171245965.png"></p>
<p>排队策略决定数据包能不能被排队，怎样被排队</p>
<p>服务策略：有很多的数据包怎样选择数据包放到硬件发送队列里面去i。</p>
<h4 id="排队策略">排队策略</h4>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107172057092.png"></p>
<h5 id="优先队列pq">优先队列（PQ）</h5>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107172329578.png" alt="image-20240107172329578" style="zoom:50%;"></p>
<p>优点 ：算法简单，可以保障高优先级的QoS</p>
<p>缺点 ：算法欠公平， 高优先级队列可能会饿死其他队列</p>
<h5 id="定制队列cq">定制队列（CQ）</h5>
<p>CQ (Custom queuing): 定制队列，用户可配置队列占用的带宽比例关系；</p>
<p>各队列在统计规率上满足用户配置的带宽比例；</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107173036744.png"></p>
<p>带抢占的CQ:</p>
<p>CQ共分为17个队列: 0号队列为系统队列，优先调度;
1-16为用户队列，轮询调度；</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107173412873.png" alt="image-20240107173412873" style="zoom:67%;"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107172742923.png" alt="image-20240107172742923" style="zoom:50%;"></p>
<h5 id="加权公平队列wfq">加权公平队列（WFQ）</h5>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107211247115.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107211511926.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107211851230.png" alt="image-20240107211851230" style="zoom:80%;"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107213510784.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107214053096.png"></p>
<p>WFQ入队过程采用HASH算法来自动完成，尽量将不同的流分入不同的队列。（所以说分离不用配置）</p>
<p>在出队的时候，WFQ按流的优先级(precedence)来分配每个流应占有出口的带宽。优先级的数值越小，所得的带宽越少。优先级的数值越大，所得的带宽越多。这样就保证了相同优先级业务之间的公平，体现了不同优先级业务之间的权值。所以兼顾了所有流的带宽，而且优先保障了高优先级的QOS</p>
<h5 id="wfq丢弃例子">WFQ丢弃例子</h5>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107212224454.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107212253846.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107212727616.png" alt="image-20240107212727616" style="zoom:60%;"></p>
<h6 id="为什么这里有10个包">为什么这里有10个包？</h6>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107212859495.png"></p>
<p>这里有10个包，说明上一个来的包可能是那些？</p>
<p>说明上一次和这次一样，超过CDT但是不是系统的最后一个包因此入列了。</p>
<p>因此上一次入队的包可能是下面选中的三个中的一个</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107213356598.png"></p>
<h3 id="流量整形流量限速">流量整形流量限速</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107221848718.png"></p>
<h3 id="令牌桶">令牌桶</h3>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107223522312.png" alt="image-20240107223522312">
<figcaption aria-hidden="true">image-20240107223522312</figcaption>
</figure>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107223756821.png" alt="image-20240107223756821">
<figcaption aria-hidden="true">image-20240107223756821</figcaption>
</figure>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240107223817902.png" alt="image-20240107223817902">
<figcaption aria-hidden="true">image-20240107223817902</figcaption>
</figure>
<h2 id="网络测量">网络测量</h2>
<h3 id="四种流">四种流</h3>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108155208673.png" alt="image-20240108155208673">
<figcaption aria-hidden="true">image-20240108155208673</figcaption>
</figure>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108155220933.png" alt="image-20240108155220933">
<figcaption aria-hidden="true">image-20240108155220933</figcaption>
</figure>
<h3 id="分布特性局部特性">分布特性，局部特性</h3>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108155615910.png" alt="image-20240108155615910">
<figcaption aria-hidden="true">image-20240108155615910</figcaption>
</figure>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108155801545.png" alt="image-20240108155801545">
<figcaption aria-hidden="true">image-20240108155801545</figcaption>
</figure>
<h3 id="网络测量分类">网络测量分类</h3>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108160009131.png" alt="image-20240108160009131">
<figcaption aria-hidden="true">image-20240108160009131</figcaption>
</figure>
<h3 id="主动测量被动测量优缺点">主动测量被动测量优缺点</h3>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108160313664.png" alt="image-20240108160313664">
<figcaption aria-hidden="true">image-20240108160313664</figcaption>
</figure>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108160421526.png" alt="image-20240108160421526">
<figcaption aria-hidden="true">image-20240108160421526</figcaption>
</figure>
<p>测量三要素：测量对象，测量环境，测量方法</p>
<p>什么样的测量方法是比较好的：</p>
<p>1.稳健性-》可重复性 相同的网络环境下，多次测结果是一致的</p>
<p>测量带宽时延丢包率</p>
<h3 id="网络带宽的测量">网络带宽的测量</h3>
<h4 id="带宽大的网络时延一定小吗时延大的网络带宽一定低吗说明原因例子">带宽大的网络时延一定小吗？时延大的网络带宽一定低吗？说明原因/例子</h4>
<p>带宽大的网络时延一定小吗？时延大的网络带宽一定低吗？</p>
<p>不一定。网络的带宽和时延是两个不同的概念，它们描述了网络性能的不同方面。</p>
<ol type="1">
<li><strong>带宽（Bandwidth）：</strong>
带宽是指网络传输数据的能力，通常以每秒传输的比特数（bps）来衡量。更大的带宽表示网络能够传输更多的数据量。高带宽通常与更高的数据传输速率相关。</li>
<li><strong>时延（Latency）：</strong>
时延是指数据从发送端到接收端所经历的总时间。时延可以分为多个组成部分，包括传播时延、传输时延、处理时延等。较小的时延表示数据传输更迅速。</li>
</ol>
<p>现实中，带宽和时延之间没有直接的必然关系。一个网络可以有很大的带宽，但由于其他因素（例如路由器、交换机、距离等），仍然可能有相对较高的时延。同样，一个网络的时延可能很小，但如果其带宽不足以支持大量的数据传输，仍然可能导致性能问题。</p>
<p>综上所述，带宽和时延是两个独立的网络性能指标，它们可以在某些情况下相关，但并不一定总是正相关或负相关。在设计和评估网络时，通常需要同时考虑带宽和时延以确保满足特定的应用需求。</p>
<p>举个例子</p>
<p>考虑一个在线视频流服务作为例子：</p>
<ol type="1">
<li><strong>高带宽、低时延：</strong>
<ul>
<li><strong>情况：</strong>
你的互联网连接速度非常快，具有高带宽，而且你与视频服务器之间的距离很近。</li>
<li><strong>影响：</strong>
视频数据可以以很高的速度传输，因此你能够快速加载视频。时延也很小，因为数据传输速度快且距离近。</li>
</ul></li>
<li><strong>高带宽、高时延：</strong>
<ul>
<li><strong>情况：</strong>
你的互联网连接速度非常快，但由于网络拓扑或路由选择，数据在传输过程中经过了多个节点。</li>
<li><strong>影响：</strong>
虽然你能够快速加载视频（高带宽），但由于数据在多个节点之间传输，总的时延较高。</li>
</ul></li>
<li><strong>低带宽、低时延：</strong>
<ul>
<li><strong>情况：</strong>
你的互联网连接速度较慢，但与视频服务器之间的距离很近。</li>
<li><strong>影响：</strong>
视频数据传输速度较慢，但由于距离近，时延较小，可能仍然能够顺畅地观看视频。</li>
</ul></li>
<li><strong>低带宽、高时延：</strong>
<ul>
<li><strong>情况：</strong>
你的互联网连接速度较慢，同时由于网络拓扑或路由选择，数据在传输过程中经过了多个节点。</li>
<li><strong>影响：</strong>
视频数据传输速度较慢，而且由于数据在多个节点之间传输，总的时延也较高，可能导致视频加载缓慢或卡顿。</li>
</ul></li>
</ol>
<p>这些例子说明了在不同的网络条件下，带宽和时延是可以独立变化的。有时候，需要权衡这两者，根据应用的需求和用户体验来进行网络设计和优化</p>
<h4 id="带宽和瓶颈带宽">带宽和瓶颈带宽</h4>
<p>路径带宽和链路带宽</p>
<p>链路带宽：一条的带宽</p>
<p>路径带宽：多条链路组成，端到端带宽</p>
<p>链路带宽测得是路有==多宽==。</p>
<p>可用带宽：==一条路堵不堵==，可用带宽是考虑了已有负载的情况下。最堵的不一定是最窄的，一定是车最多的</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108161304014.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108212742091.png"></p>
<h4 id="可用带宽测量">可用带宽测量</h4>
<p>建模：</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108213925839.png"></p>
<p>测量方法： <img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108214258060.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108214737343.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108220047404.png"></p>
<h4 id="瓶颈带宽测量">瓶颈带宽测量</h4>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108220311428.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108220531357.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108220754179.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108221021107.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108221214209.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108221618584.png"></p>
<h4 id="丢包率">丢包率</h4>
<p>平均丢包率，突发丢包率</p>
<p>贝努力，马尔可夫</p>
<h3 id="别名解析常用方法不做别名解析会有什么问题">别名解析，常用方法，不做别名解析会有什么问题</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108222411293.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108223041277.png"></p>
<h2 id="cdn-内容分发网络">CDN 内容分发网络</h2>
<h3 id="cdn解决什么问题">CDN解决什么问题</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108225124562.png"></p>
<h3 id="zipf">zipf</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108230305132.png"></p>
<p>说明大家的访问都是集中在一些热门的地方上，基于这个规律的启示 <img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108230454029.png"></p>
<h3 id="web缓存和web缓存存在的问题">web缓存，和web缓存存在的问题</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108234847210.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108234924410.png"></p>
<h3 id="cdn原理">CDN原理</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108235058920.png"></p>
<h4 id="cdn核心问题cdn选择那个服务器">CDN核心问题·：CDN选择那个服务器</h4>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240108235200603.png"></p>
<p>怎么去算距离近的</p>
<h4 id="服务器缓存什么内容">服务器缓存什么内容</h4>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109091912874.png"></p>
<h4 id="存不下怎么办">存不下怎么办</h4>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109092058195.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109092145492.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109092248156.png"></p>
<p>LRU:</p>
<p>LRU
表示以<strong><em>*时间*</em></strong>作为参考，淘汰最长时间未被使用的数据。其核心思想是：如果数据最近被访问过，那么将来被访问的几率也更高。</p>
<p>LRU 也是最常用的淘汰策略，在 Redis 中不管是 allkeys-lru 和
volatile-lru，其实底层原理都一样。</p>
<p>LFU:</p>
<p>LFU
表示以<strong><em>*次数*</em></strong>为参考，淘汰一定时期内被访问次数最少的数据，其核心思想是：如果数据过去被访问多次，那么将来被访问的频率也更高。</p>
<h3 id="dash">dash</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109093023293.png"></p>
<h3 id="qoe关注那些参数">QOE关注那些参数</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109093151883.png"></p>
<h3 id="qoe和qos有什么区别">QOE和QOS有什么区别</h3>
<p>QOS一般指网络层服务质量，考察网络层的基本参数是客观存在的如带宽，时延，丢包率，抖动。</p>
<p>QOE是quality of experience
。是主观的体验，和用户的感官更接近。最早的评价是大家打分。后来的指标也是密切和用户体验相关，如高码率，少
卡顿，少切换。更接近应用层。</p>
<p>卡顿：卡顿次数和卡顿时间。卡顿次数更重要</p>
<h3 id="视频直播的时延有两个时延">视频直播的时延有两个时延</h3>
<p>一个是服务器发出到用户直接接收的时延</p>
<p>一个是同一个房间用户接收一个东西之间的时延</p>
<h2 id="p2p-peer-to-peer">P2P peer-to-peer</h2>
<h3 id="为什么要做p2p">为什么要做P2P</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109100420082.png"></p>
<p>为了降低费用，把闲置的资源利用起来，解决跨ISP流量大协议标准不好识别的问题</p>
<h3 id="flooding">flooding</h3>
<p>和所有的邻居联系，邻居又和邻居的所有邻居联系。</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109102208934.png"></p>
<h3 id="bt">BT</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109103305887.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109103508359.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109103613691.png"></p>
<p>intrest neighbors 邻居间有相同的需求</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109104326912.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109110840233.png"></p>
<p>前两个周期找那些结点对自己的服务比较好优先疏通，第三个周期，随机找一些提供优先疏通。</p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109111016400.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109105347038.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109105605105.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109105851268.png"></p>
<h4 id="bittorrent怎么工作的">bittorrent怎么工作的：</h4>
<p>alice通过搜索引擎下载torrent文件，torrent里面有tracking
server（跟踪那些服务器正在进行这个文件的上下载，向跟踪服务器发出信令的要求，trackingserver拿到请求后返回一个peer
list，alice就可以加入这些peer的洪流，互通有无，进行文件的分发下载。</p>
<h3 id="结构化p2p">结构化P2P</h3>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109112831477.png"></p>
<p>==不需要传统p2p的tracker 每个人都充当一部分tracker==</p>
<h4 id="chord">chord</h4>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109113320105.png"></p>
<p><img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240109113921651.png"></p>
<p>Chord选择SHA-1作为哈希函数，SHA-1会产生一个2160的空间，每项为一个16字节（160bit）的大整数。我们可以认为这些整数首尾相连形成一个环，称之为Chord环。整数在Chord环上按大小顺时针排列，Node（机器的IP地址和Port）与Key（资源标识）都被哈希到Chord环上，这样我们就假定了整个P2P网络的状态为一个虚拟的环，因此我们说Chord是结构化的P2P网络。</p>
<h2 id="区块链">区块链</h2>
<h3 id="比特币和以太坊的区别">比特币和以太坊的区别</h3>
<p>比特币区块链系统是封闭的区块链系统，只有一个应用：比特币</p>
<p>以太坊：开放接口，强调开放性，引入智能合约的概念。</p>
<p>以太坊和比特币：非授权类，公有</p>
<h3 id="授权链非授权链优缺点">授权链非授权链优缺点</h3>
<p>区块链：可以分为非授权类和授权类</p>
<p>非授权类：共有，谁想加入都可以加入不需要授权</p>
<p>授权链：必须是联盟的成员才能进入，不存在身份匿名的问题</p>
<ul>
<li>联盟链</li>
<li>私有链</li>
</ul>
<p>公有链：规模大，性能问题。对大家隐私身份比较好，不容易监管。</p>
<p>私有链：规模小，性能比较好。容易监管，用户身份匿名性不强。</p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240110180346516.png" alt="联盟链">
<figcaption aria-hidden="true">联盟链</figcaption>
</figure>
<h3 id="区块链怎么工作的">区块链怎么工作的</h3>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240110161958373.png" alt="区块链记账">
<figcaption aria-hidden="true">区块链记账</figcaption>
</figure>
<p>挖矿：工作量证明</p>
<p>共识机制：通过一种方式产生一个记账结点，这个记账结点产生本轮的账本区块。</p>
<p>产生账本区块后，记账结点会把账本区块再向全网进行广播，网络中每个结点都会收到账本区块，会对账本区块再进行一次验证（验证数据结构，和业务相关的东西）如果都验证通了，把账本区块记录在本地的区块链账本末端。当网络中绝大多数结点都完成了上述的验证操作，才能说这个区块上包含的交易被真正的记录在区块链上。</p>
<p>两个结点发送交易，做数字签名广播，广播完验证，验证完共识，共识完再广播再验证然后记录，大家都记录完了才完事。</p>
<p>总结：单点出块：任何一轮只能有一个出块结点</p>
<p>广播传输：无论是产生一笔交易还是一个区块都要向全网播</p>
<p>交叉验证：区块链系统收到别人广播来的东西，不是无条件就相信了，需要验证，通过才信任。</p>
<p>共同存储：大家每个人都存着相同的区块。</p>
<h3 id="什么是区块链区块链的优点">什么是区块链，区块链的优点</h3>
<ul>
<li>从宏观上</li>
</ul>
<p>区块链是一个分布式的系统</p>
<p>区块链，多个节点装相同的软件，遵循相同的规则，大家按照相同的规则相互合作，构建多方合作的系统</p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240110162540033.png" alt="image-20240110162540033">
<figcaption aria-hidden="true">image-20240110162540033</figcaption>
</figure>
<ul>
<li><p>微观上</p>
<p>区块链=区块（本子上的纸）+链（本子上的线）</p>
<p>数字签名：保证区块链上面所有的信息是不可伪造，不可抵赖的。</p>
<p>链：哈希链。任何一个区块，要计算他的hash值，把他的hash值作为下一个区块内容的一部分，这样每个区块排在那个区块前面一目了然。原来杂乱无序的多个区块，变成了有序的区块链。后面的区块给前面的区块背书。牵一发动全身，保证区块链不可删除，不可篡改。</p></li>
</ul>
<p>区块链的优点：不可伪造，不可抵赖，不可删除，不可篡改。</p>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240110162619941.png" alt="image-20240110162619941">
<figcaption aria-hidden="true">image-20240110162619941</figcaption>
</figure>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240110175112974.png" alt="image-20240110175112974">
<figcaption aria-hidden="true">image-20240110175112974</figcaption>
</figure>
<h3 id="区块链和数据库的区别">区块链和数据库的区别</h3>
<ol type="1">
<li>首先虽然区块链起到了分布式存储的作用，分布式数据库一般情况下，每个结点都不需要存全量的数据，只需要存一部分数据。区块链上要求所有结点存的数据是一样的，存全量数据。</li>
<li>数据库存在一个单一的拥有者。可以说是银行的数据库。但是区块链没有一个单一的所有者，区块链强调共享共治共建。没有任何一个人对区块链有垄断性的控制权。</li>
<li>数据库：插入删除更新查询。区块链不可删改：只有插入查询</li>
<li>从信任关系来讲：分布式数据库，结点和结点之间是相互信任的关系，区块链结点和结点之间相互不信任，相互制约。</li>
<li>容错性：分布式数据库容错性较差，区块链天生可以容忍拜占庭错误，容错性更好。区块链要确保很多结点出错的情况下，整个系统可靠。</li>
</ol>
<h3 id="区块链牺牲了什么">区块链牺牲了什么</h3>
<p>区块链牺牲了计算和存储，计算存储密集型的更适合中心化。信任更适合区块链。</p>
<ol type="1">
<li><p>计算能力有限，不能和中心化的相比</p></li>
<li><p>区块链的存储。因为区块链的存储需要经过网路广播发送，所以就广播这一条就要受到网络带宽的限制。存储能力无法和中心化的相比。现在的方法：结合型。把原始数据放到中心化中存储，把数据的hash值或者摘要放到区块链中。</p></li>
</ol>
<h3 id="区块链的应用">区块链的应用</h3>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240110175524173.png" alt="image-20240110175524173">
<figcaption aria-hidden="true">image-20240110175524173</figcaption>
</figure>
<ul>
<li>存证溯源类：存完以后一般不会频繁的读它，所以对读的能力要求更低</li>
<li>数据共享类：对读性能要求更高。</li>
<li>价值转移类：要求原子性，安全性</li>
</ul>
<h2 id="区块链跨链技术">区块链跨链技术</h2>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240111104220017.png" alt="跨链">
<figcaption aria-hidden="true">跨链</figcaption>
</figure>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240111104500726.png" alt="image-20240111104500726">
<figcaption aria-hidden="true">image-20240111104500726</figcaption>
</figure>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240111104539397.png" alt="image-20240111104539397">
<figcaption aria-hidden="true">image-20240111104539397</figcaption>
</figure>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240111104801537.png" alt="image-20240111104801537">
<figcaption aria-hidden="true">image-20240111104801537</figcaption>
</figure>
<figure>
<img src="/2023/12/29/Linux%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%BC%B9/image-20240111162143396.png" alt="image-20240111162143396">
<figcaption aria-hidden="true">image-20240111162143396</figcaption>
</figure>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP服务器实验报告</title>
    <url>/2023/12/28/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="http服务器实验报告">HTTP服务器实验报告</h1>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>wireshark抓包分析https</title>
    <url>/2023/12/20/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90https/</url>
    <content><![CDATA[<h1 id="wireshark抓包分析https">wireshark抓包分析https</h1>
<h2 id="wireshark-配置">wireshark 配置</h2>
<h3 id="配置网站的私钥">配置网站的私钥</h3>
<p>我想抓取分析自己服务器搭建出来的模拟https这需要使用网站生成证书使用的私钥进行解密，把它添加到
wireshark 配置中如下所示：</p>
<p><img src=".\抓包分析https/image-20231222222947319.png" alt="配置首选项" style="zoom:67%;"></p>
<p>通过<code>curl</code>访问的 https 协议的
URL，在配置了该服务器对应的私钥后可以抓取到对应的 HTTP 明文。</p>
<p>工作中的wireshark将抓取到相关数据包，在过滤栏设置过滤条件以避免其他无用数据包影响分析，<strong>比如：ip.addr
== xx
&amp;&amp;ssl表示只显示ICPM协议且源主机IP或者目的主机IP为185.199.111.153的数据包。说明：协议名称ssl要小写</strong></p>
<figure>
<img src=".\抓包分析https/image-20231223005322966.png" alt="抓包">
<figcaption aria-hidden="true">抓包</figcaption>
</figure>
<p>部分小问题：</p>
<blockquote>
<p>wireshark提示Ignored Unknow Record</p>
</blockquote>
<p>解决：</p>
<p>通过路径：编辑--首选项--协议--TLS找到以下配置，并勾选“reassemble TLS
records SPANNING Multiple tcp segments”</p>
<h2 id="抓包分析">抓包分析</h2>
<p>通过https传输视频，抓包分析如下：</p>
<figure>
<img src=".\抓包分析https/image-20231225211847573.png" alt="image-20231225211847573">
<figcaption aria-hidden="true">image-20231225211847573</figcaption>
</figure>
<figure>
<img src=".\抓包分析https/image-20231225223656861.png" alt="image-20231225223656861">
<figcaption aria-hidden="true">image-20231225223656861</figcaption>
</figure>
<p>当服务端收到客户端的「Client
Hello」消息后，会确认TLS版本号是否支持持，和从密码套件列表中选择⼀个密码套件，以及⽣成随机数（Server
Random）。接着，返回「Server Hello」消息，消息⾥⾯有服务器确认的 TLS
版本号，也给出了随机数（Server
Random），然后从客户端的密码套件列表选择了⼀个合适的密码套件。如下图所示可以看出，服务端选择密码套件为cipher
Suite
:TLS_AES_256_GCM_SHA384。服务端选择的加密套件是TLS-AES256-GCM-SHA384，注意TLS
1.3 的握手不再支持静态的 RSA 密钥交换，这意味着可以使用带有前向安全的
Diffie-Hellman
进行全面握手，密钥交换机制可提供前向保密。同时还包含服务端的keyshare，可以理解为b
* G。以及Change Cipher
Spec协议让客户端重新计算共享密钥。还可看到服务端此时已经可以发送应用数据，因为服务端根据a
* G,计算出了 a * G *
b（共享密钥），于是用这个共享密钥加密数据并发送。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>并发请求处理</title>
    <url>/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/</url>
    <content><![CDATA[<h2 id="并发请求处理">并发请求处理</h2>
<h2 id="多线程实现的必要性">多线程实现的必要性</h2>
<p>当一个客户端与服务器建立连接以后，服务器端
accept()返回，进而准备循环接收客户端发过来的数据。如果客户端暂时没发数据，服务端会在
recv()处阻塞。此时，其他客户端向服务器发起连接后，由于服务器阻塞了，无法执行
accept()接受连接，也就是其他客户端发送的数据，服务器无法读取。服务器也就无法并发同时处理多个客户端。
服务器如何实现同时处理多个客户端的同时通信：有如下几种方案:多线程，多进程，select，poll，epoll，以及使用epoll+reactor</p>
<h2 id="多线程">多线程</h2>
<p>采用pthread多线程来分别处理单个连接，实现多个客户端连接的同时处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">	    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">	    <span class="keyword">if</span> ((connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">&quot;accept socket error: %s(errno: %d)\n&quot;</span>, strerror(errno), errno);</span><br><span class="line">	        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="type">pthread_t</span> threadid;</span><br><span class="line">		pthread_create(&amp;threadid, <span class="literal">NULL</span>, client_routine, (<span class="type">void</span>*)&amp;connfd);<span class="comment">//创建线程，并执行client_routine回调函数功能，将connfd作为回调函数的参数传入，client_routine函数将处理相应文件描述符connfd的发送和接收功能</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>accept以后创建线程处理响应。服务端接受一个客户端的连接后，创建一个线程（或者进程），然后在新创建的线程或进程中循环处理数据。主线程（父进程）只负责监听客户端的连接，并使用
accept()接受连接,不进行数据的处理。</p>
<figure>
<img src="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/image-20231208162808360.png" alt="多线程">
<figcaption aria-hidden="true">多线程</figcaption>
</figure>
<p>实验代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLNE  4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLL_SIZE	1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">client_routine</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; <span class="comment">//client_routine函数是多线程的回调函数，用来处理每一个连接的请求，也就是接收与发送信息功能</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> connfd = *(<span class="type">int</span> *)arg;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buff[MAXLNE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> n = recv(connfd, buff, MAXLNE, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buff[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv msg from client: %s\n&quot;</span>, buff);</span><br><span class="line"></span><br><span class="line">	    	send(connfd, buff, n, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            close(connfd);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd, n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="type">char</span> buff[MAXLNE];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;<span class="comment">//socket创建listen的文件描述符</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create socket error: %s(errno: %d)\n&quot;</span>, strerror(errno), errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">10000</span>);<span class="comment">//端口信息可以自己设置</span></span><br><span class="line"> <span class="comment">//bind函数绑定IP，端口信息</span></span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind socket error: %s(errno: %d)\n&quot;</span>, strerror(errno), errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">10</span>) == <span class="number">-1</span>) &#123;<span class="comment">//listen监听函数，参数10表示未完成连接与已完成连接队列之和，一般设置为5的倍数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen socket error: %s(errno: %d)\n&quot;</span>, strerror(errno), errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">	    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">	    <span class="keyword">if</span> ((connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">&quot;accept socket error: %s(errno: %d)\n&quot;</span>, strerror(errno), errno);</span><br><span class="line">	        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="type">pthread_t</span> threadid;</span><br><span class="line">		pthread_create(&amp;threadid, <span class="literal">NULL</span>, client_routine, (<span class="type">void</span>*)&amp;connfd);<span class="comment">//创建线程，并执行client_routine回调函数功能，将connfd作为回调函数的参数传入，client_routine函数将处理相应文件描述符connfd的发送和接收功能</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>g++ pthreadserver.cpp -pthread</code></p>
<p>这种方法的不足：</p>
<p>但是每次连接生成创建一个线程，消耗内存会很大。另外进行IO操作时，例如发生
IO 操作 read 时，它会经历两个阶段：</p>
<ul>
<li>等待数据准备就绪</li>
<li>将数据从内核拷贝到进程或者线程中 因此当使用默认的阻塞套接字时，由于1
个线程捆绑处理 1
个连接，这两个阶段合而为一，这样操作套接字的代码所在的线程就得睡眠来等待消息准备好，这导致了高并发下线程会频繁的睡眠、唤醒，从而影响了
CPU 的使用效率。</li>
</ul>
<h2 id="select">select</h2>
<h3 id="原理">原理</h3>
<p>select：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点：每次都要复制，<strong>开销大</strong>），由内核根据就绪状态修改该集合的内容。一个多线程编程很麻烦又容易出错，二是如果连接有几千个的话，线程间切换的开销确实是很大。能能够在一个线程里就实现这个效果？</p>
<p>这个又叫做非阻塞IO多路复用，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高。</p>
<figure>
<img src="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/image-20231208191133361.png" alt="select">
<figcaption aria-hidden="true">select</figcaption>
</figure>
<p>用户程序访问不了内核空间,调用 select 会把所有要管理的 socket 的 fd
(文件描述符，Linux下皆为文件，简单理解就是通过 fd 能找到这个
socket)传到内核中。此时，要遍历所有
socket，看看是否有感兴趣的事件发生。如果没有一个 socket 有事件发生，那么
select 的线程就需要让出 cpu
阻塞等待，这个等待可以是不设置超时时间的死等，也可以是设置 timeout
的有超时时间的等待。</p>
<p>假设此时客户端发送了数据，网卡接收到的数据塞到对应的 socket
的接收队列中，此时 socket 知道来数据了，那如何唤醒 select 呢？</p>
<p>其实每个 socket 有个属于自己的睡眠队列，select
会安排一个内应，即在被管理的 socket 的睡眠队列里面塞入一个 entry。当
socket 接收到网卡的数据后，就会去它的睡眠队列里遍历 entry，调用 entry
设置的 callback 方法，这个 callback 方法里就能唤醒 select ！</p>
<p>所以 select 在每个被它管理的 socket 的睡眠队列里都塞入一个与它相关的
entry，这样不论哪个 socket 来数据了，它立马就能被唤醒然后干活！</p>
<p>但是，select 的实现不太好，因为唤醒的 select
此时只知道来活了，并不知道具体是哪个 socket
来数据了，所以只能傻傻地遍历所有 socket ，看看到底是哪个 scoket
来活了，然后把所有来活的 socket
封装成事件返回。这样用户程序就能获得发生的事件，然后进行 I/O
和业务处理了。</p>
<figure>
<img src="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/image-20231208191319055.png" alt="select2">
<figcaption aria-hidden="true">select2</figcaption>
</figure>
<p>说到select的IO多路复用就不得不提fd_set这个变量类型，首先我们打开Linux的fd_set数据结构的源码我们可以看到，就是一个长度为32的long
int类型的数组(要注意，windows的源码和Linux的不一样)。每一位可以代表一个文件描述符（位图），所以fd_set最多表示1024个文件描述符。</p>
<h3 id="使用例子">使用例子</h3>
<p>fd_set定义的几个宏</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span>   </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *fd_set)</span></span>;   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span></span>;  </span><br></pre></td></tr></table></figure>
<p>我们假设fdset就一个字节，就是8位，那么</p>
<p>（1）执行FD_ZERO(&amp;fdset)，则set用位表示是00000000，就是所有位都清空成0，一般刚开始的时候就需要清空。
（2）执行FD_SET(fd,&amp;fdset)，若fd＝5，后set变为00010000，第5位置为1，就是将客户端连接的描述字(一般就是一个整数啦)放入到set当中。
（3）执行FD_ISSET(fd,&amp;fdset)，若fd＝5，则就是判断set的第5位是否是1，一般用来判断是否客户端的连接。
（4）执行FD_CLR(fd,&amp;fdset)，若fd＝5，则就是将第5位置成0，在断开客户端连接的时候，一定要记得调用这个。</p>
<p>select的函数定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> maxfdp, fd_set *readset, fd_set *writeset, fd_set *exceptset,<span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><p>maxfdp：被监听的文件描述符的总数，它比所有文件描述符集合中的文件描述符的最大值大1，因为文件描述符是从0开始计数的；</p></li>
<li><p>fd_set *readset:
该参数是我们所关心的文件是否可读的文件描述符的集合，如果这个集合中有个文件可读了，那select返回一个大于0的数，表示有文件可读了，比如说服务端接收到客户端的数据，服务端都是读的状态，所以正常读的文件都放在这里。</p></li>
<li><p>fd_set
*writeset：那这个大家就比较好理解了，服务端发到客户端的数据，要写入到缓冲区，那么所有正常写的文件都放在这里。</p></li>
<li><p>fd_set
*exceptset：在所有正常读和正常写的时候，产生了异常情况，那么异常文件就放在这里。</p></li>
<li><p>timeval
*timeout：用于设置select函数的超时时间，即告诉内核select等待多长时间之后就放弃等待。这个参数使select处于三种状态：(1)timeout传入NULL，则select一直等到文件状态有变化时才返回，这段时间一直处于阻塞状态。(2):timeout传入0，则select会立即返回（非阻塞），如果文件状态有变化则返回一个大于0的值没有变化则返回0；(3)timeout传入一个大于0的数，则select在timeout时间内阻塞，一旦文件状态有变化就会返回，超时后不管怎样都会返回值同样是文件状态右边话就返回一个大于0的值，无变化则返回0；</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FD_NUM 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR_EXIT(m)         \</span></span><br><span class="line"><span class="meta">    do                      \</span></span><br><span class="line"><span class="meta">    &#123;                       \</span></span><br><span class="line"><span class="meta">        perror(m);          \</span></span><br><span class="line"><span class="meta">        exit(EXIT_FAILURE); \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="type">int</span> m_sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;create socket fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//初始化socket元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="type">int</span> server_len = <span class="keyword">sizeof</span>(server_addr);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, server_len);</span><br><span class="line"> </span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//server_addr.sin_addr.s_addr = inet_addr(&quot;0.0.0.0&quot;); //用这个写法也可以</span></span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//绑定文件描述符和服务器的ip和端口号</span></span><br><span class="line">    <span class="type">int</span> m_bindfd = bind(m_sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, server_len);</span><br><span class="line">    <span class="keyword">if</span> (m_bindfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;bind ip and port fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//进入监听状态，等待用户发起请求</span></span><br><span class="line">    <span class="type">int</span> m_listenfd = listen(m_sockfd, MAX_FD_NUM);</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;listen client fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//定义客户端的套接字，这里返回一个新的套接字，后面通信时，就用这个m_connfd进行通信</span></span><br><span class="line">    <span class="comment">//struct sockaddr_in client_addr;</span></span><br><span class="line">    <span class="comment">//socklen_t client_len = sizeof(client_addr);</span></span><br><span class="line">    <span class="comment">//int m_connfd = accept(m_sockfd, (struct sockaddr *)&amp;client_addr, &amp;client_len);</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client accept success\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//接收客户端数据，并相应</span></span><br><span class="line">    <span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> array_fd[MAX_FD_NUM];</span><br><span class="line">    <span class="comment">//客户端连接数量</span></span><br><span class="line">    <span class="type">int</span> client_count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    fd_set tmpfd;</span><br><span class="line">    <span class="type">int</span> max_fd = m_sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_FD_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        array_fd[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//array_fd[0] = m_sockfd;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_ZERO(&amp;tmpfd);</span><br><span class="line">        FD_SET(m_sockfd, &amp;tmpfd);</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//所有在线的客户端加入到fd中，并找出最大的socket</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_FD_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (array_fd[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                FD_SET(array_fd[i], &amp;tmpfd); <span class="comment">//set array_fd in red_set</span></span><br><span class="line">                <span class="keyword">if</span> (max_fd &lt; array_fd[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    max_fd = array_fd[i]; <span class="comment">//get max_fd</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> ret = select(max_fd + <span class="number">1</span>, &amp;tmpfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_EXIT(<span class="string">&quot;select fail&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ERR_EXIT(&quot;select timeout&quot;); //超时不是错误，不可断掉连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;select timeout\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//表示有客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(m_sockfd, &amp;tmpfd))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> m_connfd = accept(m_sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_len);</span><br><span class="line">            <span class="keyword">if</span> (m_connfd &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ERR_EXIT(<span class="string">&quot;server accept fail&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//客户端连接数已满</span></span><br><span class="line">            <span class="keyword">if</span> (client_count &gt;= MAX_FD_NUM)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;max connections arrive！！！\n&quot;</span>);</span><br><span class="line">                <span class="comment">// char buff[]=&quot;max connections arrive！！！&quot;;</span></span><br><span class="line">                <span class="comment">// send(m_connfd, buff, sizeof(buff) - 1, 0);</span></span><br><span class="line">                close(m_connfd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//客户端数量加1</span></span><br><span class="line">            client_count++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;we got a new connection, client_socket=%d, client_count=%d, ip=%s, port=%d\n&quot;</span>, m_connfd, client_count, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_FD_NUM; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (array_fd[i] == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    array_fd[i] = m_connfd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//遍历所有的客户端连接，找到发送数据的那个客户端描述符</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_FD_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (array_fd[i] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有客户端发送过来的数据</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (FD_ISSET(array_fd[i], &amp;tmpfd))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer)); <span class="comment">//重置缓冲区</span></span><br><span class="line">                    <span class="type">int</span> recv_len = recv(array_fd[i], buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (recv_len &lt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ERR_EXIT(<span class="string">&quot;recv data fail&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//客户端断开连接</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (recv_len == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        client_count--;</span><br><span class="line">                        <span class="comment">//打印断开的客户端数据</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client_socket=[%d] close, client_count=[%d], ip=%s, port=%d\n\n&quot;</span>, array_fd[i], client_count, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line">                        close(array_fd[i]);</span><br><span class="line">                        FD_CLR(array_fd[i], &amp;tmpfd);</span><br><span class="line">                        array_fd[i] = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;server recv:%s\n&quot;</span>, buffer);</span><br><span class="line">                        <span class="built_in">strcat</span>(buffer, <span class="string">&quot;+ACK&quot;</span>);</span><br><span class="line">                        send(array_fd[i], buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    close(m_sockfd);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server socket closed!!!\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用select实现并发处理请求的缺点：</p>
<p>1:
每次都要将文件描述符集合从用户空间拷贝到内核空间复制，处理完事件之后又需要将监听的fd从用户态拷贝到内核态，开销大</p>
<p>2:
保存fd数组的大小有限，并且监听的fd越多，性能可能越差（当活跃的fd较少时）。</p>
<p>3:
需要轮询遍历所有文件描述符才能知道哪些fd句柄有事件发生，轮询方式效率慢</p>
<h2 id="poll">poll</h2>
<p>poll：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；</p>
<p>用到比较少这里不多介绍</p>
<h2 id="epoll">epoll</h2>
<h3 id="原理-1">原理</h3>
<p><a href="https://blog.csdn.net/JMW1407/article/details/107963618">其它比较好的参考博客</a></p>
<p><a href="https://blog.51cto.com/liangchaoxi/4069668">参考博客2</a></p>
<p>select 的几个可以优化的点。为什么每次 select 需要把监控的 fds
传输到内核里？</p>
<p>为什么 socket 只唤醒 select，不能告诉它是哪个 socket 来数据了？</p>
<p>epoll 主要就是基于上面两点做了优化。</p>
<p>首先，搞了个叫 epoll_ctl 的方法，这方法就是用来管理维护 epoll
所监控的哪些 socket。</p>
<p>如果你的 epoll 要新加一个 socket 来管理，那就调用
epoll_ctl，要删除一个 socket 也调用
epoll_ctl，通过不同的入参来控制增删改。</p>
<figure>
<img src="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/image-20231208193134643.png" alt="epoll_ctl">
<figcaption aria-hidden="true">epoll_ctl</figcaption>
</figure>
<p>这样，在内核里面就维护了此 epoll 管理的 socket
集合，这样就不用每次调用的时候都得把所有管理的 fds 拷贝到内核了。然后和
select 类似，每个 socket 的睡眠队列里都会加个 entry，当每个 socket
来数据之后，同样也会调用 entry 对应的 callback。 socket
集合底层通过红黑树来描述。</p>
<figure>
<img src="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/image-20231208193508298.png" alt="epoll">
<figcaption aria-hidden="true">epoll</figcaption>
</figure>
<p>与 select 不同的是，引入了一个 ready_list 双向链表，callback
里面会把当前的 socket 加入到 ready_list 然后唤醒 epoll。</p>
<p>在使用epoll_wait调用时，仅观察这个list中有没有数据即可。这样被唤醒的
epoll 只需要遍历 ready_list 即可，这个链表里一定是有数据可读的
socket，相比于 select 就不会做无用的遍历了。同时收集到的可读的 fd
按理是要拷贝到用户空间的，这里又做了个优化，利用了
mmp内存映射，让用户空间和内核空间映射到同一块内存中，这样就避免了拷贝。</p>
<figure>
<img src="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/image-20231208193552347.png" alt="readylist">
<figcaption aria-hidden="true">readylist</figcaption>
</figure>
<figure>
<img src="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/image-20231208194416251.png" alt="整体示意图">
<figcaption aria-hidden="true">整体示意图</figcaption>
</figure>
<p>服务器向客户端发送文件的时候整个过程是这样的： <img src="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/image-20231208195020356.png" alt="发送文件"></p>
<h3 id="相关函数接口">相关函数接口</h3>
<h3 id="events">events</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EPOLL_SIZE</span>] =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = listenfd;</span><br></pre></td></tr></table></figure>
<p>events可以是以下几个宏的集合：</p>
<p>EPOLLIN ： 表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
EPOLLOUT： 表示对应的文件描述符可以写； EPOLLPRI：
表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
EPOLLERR： 表示对应的文件描述符发生错误； EPOLLHUP：
表示对应的文件描述符被挂断； EPOLLET： 将 EPOLL设为边缘触发(Edge
Triggered)模式（默认为水平触发），这是相对于水平触发(Level
Triggered)来说的。 EPOLLONESHOT：
只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>
<h4 id="epoll_create文件描述符的创建">epoll_create：文件描述符的创建</h4>
<p>epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。
这个文件描述符使用如下epoll_create函数来创建；
epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。
调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点（epoll_create创建的文件描述符），在内核cache里建了个
红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件</p>
<p>eventpoll对象也是文件系统中的一员，和socket一样，它也会有等待队列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">spin_lock_t</span> lock;            <span class="comment">//对本数据结构的访问</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span>            <span class="comment">//防止使用时被删除</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> wq;        <span class="comment">//sys_epoll_wait() 使用的等待队列</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> poll_wait; <span class="comment">//file-&gt;poll()使用的等待队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span>    <span class="comment">//事件满足条件的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span>          <span class="comment">//用于管理所有fd的红黑树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span>      <span class="comment">//将事件到达的fd进行链接起来发送至用户空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：
epoll_create创建额外的文件描述符，来唯一标识内核中的这个内核事件表（eventpoll对象）</p>
<figure>
<img src="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/image-20231208195420995.png" alt="creat">
<figcaption aria-hidden="true">creat</figcaption>
</figure>
<h3 id="epoll_ctl注册监控事件">epoll_ctl：注册监控事件</h3>
<p>创建epoll对象后，可以用<code>epoll_ctl添加或删除所要监听的socket</code>。以添加socket为例，如果通过epoll_ctl添加sock1、sock2和sock3的监视，内核会将eventpoll添加到这三个socket的等待队列中。</p>
<figure>
<img src="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/image-20231208195733414.png" alt="ctl">
<figcaption aria-hidden="true">ctl</figcaption>
</figure>
<p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);</code>
epoll的事件注册函数，即注册要监听的事件类型。
第一个参数是epoll_create()的返回值，
第二个参数表示动作，用三个宏来表示： EPOLL_CTL_ADD：注册新的fd到epfd中；
EPOLL_CTL_MOD：修改已经注册的fd的监听事件；
EPOLL_CTL_DEL：从epfd中删除一个fd； 第三个参数是需要监听的fd，
第四个参数是告诉内核需要监听什么事</p>
<h3 id="epoll_wait事件等待返回就绪事件">epoll_wait：事件等待，返回就绪事件</h3>
<p>当socket收到数据后，中断程序会给eventpoll的“就绪列表”添加socket引用。如果是sock2和sock3收到数据后，中断程序让rdlist引用这两个socket，而不是像select轮询所有的sock。eventpoll对象相当于是socket和进程之间的中介，socket的数据接收并不直接影响进程，而是通过改变eventpoll的就绪列表来改变进程状态。当程序执行到epoll_wait时，如果rdlist已经引用了socket，那么epoll_wait直接返回，如果rdlist为空，阻塞进程。当socket接收到数据，中断程序一方面修改rdlist，另一方面唤醒eventpoll等待队列中的进程，进程A再次进入运行状态（如下图）。也因为rdlist的存在，进程A可以知道哪些socket发生了变化。</p>
<figure>
<img src="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/image-20231208200347108.png" alt="wait">
<figcaption aria-hidden="true">wait</figcaption>
</figure>
<h3 id="事件类型">事件类型</h3>
<p>epoll的两种模式ET和LT模式</p>
<p>水平触发LT: 高电平代表1</p>
<p>    只要缓冲区中有数据, 就一直通知</p>
<p>边缘触发ET: 电平有变化就代表1</p>
<p>  缓冲区中有数据只会通知一次,
之后再有数据才会通知.(若是读数据的时候没有读完, 则剩余的数据不会再通知,
直到有新的数据到来)</p>
<p>  epoll默认是<code>水平触发LT</code>，在需要高性能的场景下，可以改成边缘ET<code>非阻塞</code>方式来提高效率。</p>
<p>  ET模式由于只通知一次, 所以在读的时候要循环读, 直到读完,
但是当读完之后read就会阻塞,
所以应该将该文件描述符设置为非阻塞模式(fcntl函数)。如果不循环读，读完的话还好，没读完的话数据就会留在<code>读缓冲区</code>，影响数据的接收和判断。read函数在非阻塞模式下读的时候,
若返回-1, 且errno为EAGAIN, 则表示当前资源不可用,
也就是说缓冲区无数据(缓冲区的数据已经读完了);
或者当read返回的读到的数据长度<code>小于</code>请求的数据长度时，就可以确定此时缓冲区中已没有数据可读了，也就可以认为此时读事件已处理完成。</p>
<h3 id="程序框架">程序框架</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">关于epoll_wait返回值的一个简单测试</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> epollfd)</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENT_NUMBER</span>];</span></span><br><span class="line">　　<span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">　　　　<span class="built_in">printf</span>(<span class="string">&quot;number : %2d\n\n&quot;</span>, number);</span><br><span class="line">　　　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　　　sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">　　　　　　<span class="keyword">if</span> (sockfd == listenfd)</span><br><span class="line">　　　　　　&#123;<span class="comment">/*用户上线*/</span></span><br><span class="line"></span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　　　<span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">　　　　　　&#123;<span class="comment">/*有数据可读*/</span></span><br><span class="line"></span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　　　<span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">　　　　　　&#123;<span class="comment">/*有数据可写*/</span></span><br><span class="line"></span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　　　<span class="keyword">else</span></span><br><span class="line">　　　　　　&#123;<span class="comment">/*出错*/</span></span><br><span class="line"></span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过测试发现epoll_wait返回值number是不会大于MAX_EVENT_NUMBER的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试过程中，连接的客户端数远大于MAX_EVENT_NUMBER，由此可以推论：epoll_wait()每次返回的是活跃客户端的个数，每次并将这些活跃的客户端信息加入到events[MAX_EVENT_NUMBER]。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由此可见，活跃客户端的个数相同的情况下，events[MAX_EVENT_NUMBER]越大，epoll_wait()函数执行次数越少，但是events[MAX_EVENT_NUMBER]越大越消耗存储资源。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以，MAX_EVENT_NUMBER的选择应该在效率和资源间取一个平衡点。</span></span><br></pre></td></tr></table></figure>
<h3 id="使用例子-1">使用例子</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLNE  4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLL_SIZE 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listenfd, connfd, n;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="type">char</span> buff[MAXLNE];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create socket error: %s(errno: %d)\n&quot;</span>, strerror(errno), errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">10000</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind socket error: %s(errno: %d)\n&quot;</span>, strerror(errno), errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">10</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen socket error: %s(errno: %d)\n&quot;</span>, strerror(errno), errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EPOLL_SIZE</span>] =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    <span class="comment">//ev.events = EPOLLIN | EPOLLET;//设置ev结构体的关注事件为可读事件（EPOLLIN）和边缘触发（EPOLLET）。</span></span><br><span class="line">    ev.data.fd = listenfd;</span><br><span class="line">    </span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);</span><br><span class="line">        <span class="comment">//设置服务器文件描述符为非阻塞模式。</span></span><br><span class="line">    fcntl(listenfd, F_SETFL, fcntl(listenfd, F_GETFD, <span class="number">0</span>)| O_NONBLOCK);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> nready = epoll_wait(epfd, events, EPOLL_SIZE, <span class="number">5</span>);<span class="comment">//nready是返回的监控文件描述符中有响应的描述符个数</span></span><br><span class="line">        <span class="keyword">if</span>(nready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nready; i++) &#123;</span><br><span class="line">            <span class="type">int</span> clientfd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span>(clientfd == listenfd) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">                <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                <span class="keyword">if</span>((connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;accept socket error: %s(errno: %d)\n&quot;</span>, strerror(errno), errno);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;accept Success fd=  %d\n&quot;</span>, connfd);</span><br><span class="line"></span><br><span class="line">                ev.events = EPOLLIN;</span><br><span class="line">                ev.data.fd = connfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);<span class="comment">//添加socket事件</span></span><br><span class="line">                <span class="comment">//这行代码使用 fcntl 函数来设置文件描述符 client_fd 为非阻塞模式。</span></span><br><span class="line">                fcntl(connfd, F_SETFL,fcntl(connfd, F_GETFD, <span class="number">0</span>)| O_NONBLOCK);</span><br><span class="line">                send(connfd,<span class="string">&quot;Welcome to My server&quot;</span>,<span class="number">21</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//// 当前事件是可读事件</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                n = recv(clientfd, buff, MAXLNE, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buff[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv msg from client: %s\n&quot;</span>, buff);</span><br><span class="line">                    send(clientfd, buff, n, <span class="number">0</span>);<span class="comment">//将发送来的数据依次返回发送回去                 </span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;<span class="comment">//当客户端调用close时，会返回n=0</span></span><br><span class="line">                    ev.events = EPOLLIN;</span><br><span class="line">                    ev.data.fd = clientfd;</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, clientfd, &amp;ev);<span class="comment">//删除该socket</span></span><br><span class="line">                    close(clientfd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll-reactor模型原理">epoll-reactor模型原理</h2>
<h3 id="reactor">reactor</h3>
<p>reactor是一种高并发服务器模型，是一种框架，一个概念，所以reactor没有一个固定的代码，可以有很多变种.</p>
<p>reactor中的IO使用的是select，poll，epoll这些IO多路复用，使用IO多路复用系统不必创建维护大量线程，只使用一个线程、一个选择器就可同时处理成千上万连接，大大减少了系统开销。</p>
<p>I/O 复用结合线程池，这就是 Reactor 模式基本设计思想，如下图：</p>
<figure>
<img src="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/image-20231209001531777.png" alt="reactor">
<figcaption aria-hidden="true">reactor</figcaption>
</figure>
<p>Reactor
模式，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。</p>
<p>服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor
模式也叫 Dispatcher 模式。</p>
<p>即 I/O 多了复用统一监听事件，收到事件后分发(Dispatch
给某进程)，是编写高性能网络服务器的必备技术之一。</p>
<p>Reactor 模式中有 2 个关键组成：</p>
<ul>
<li>1）Reactor：Reactor
在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO
事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li>
<li>2）Handlers：处理程序执行 I/O
事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor
通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。</li>
</ul>
<p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3
种典型的实现：</p>
<ul>
<li>1）单 Reactor 单线程；</li>
<li>2）单 Reactor 多线程；</li>
<li>3）主从 Reactor 多线程。</li>
</ul>
<p><img src="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/image-20231209001842376.png" alt="单线程" style="zoom:80%;"></p>
<p><img src="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/8835f56114360dafcda9377ed29d49ca.jpeg" alt="单reactor多线程" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>高性能服务器编程</category>
      </categories>
      <tags>
        <tag>Linux，计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能服务器程序框架</title>
    <url>/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="高性能服务器程序框架">高性能服务器程序框架</h1>
<h2 id="cs模型">C/S模型</h2>
<p>工作流程：</p>
<p>服务器启动后首先创建一个（或者多个）监听socket，并调用bind函数将其绑定在服务器感兴趣的端口上，然后调用listen函数等待客户连接。服务器稳定后客户端可以调用connect函数向服务器发起连接。由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型监听这一事件。下图是其中一种使用I/O复用技术的select系统调用</p>
<figure>
<img src="/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20231205111626621.png" alt="TCP服务器和TCP客户端工作流程">
<figcaption aria-hidden="true">TCP服务器和TCP客户端工作流程</figcaption>
</figure>
<h2 id="p2p模型">p2p模型</h2>
<figure>
<img src="/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20231205130601314.png" alt="2种服务器模型">
<figcaption aria-hidden="true">2种服务器模型</figcaption>
</figure>
<h2 id="服务器基本框架">服务器基本框架</h2>
<figure>
<img src="/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20231205131014540.png" alt="服务器基本框架">
<figcaption aria-hidden="true">服务器基本框架</figcaption>
</figure>
<p>I/O处理单元是服务器管理客户连接的模块，用于等待并接受新的客户连接，接受客户数据，将服务器响应数据返回给客户端。对于服务器集群而言，i/O处理单元是一个专门的接入服务器，可以用于实现负载均衡</p>
<p>一个逻辑单元通常是一个进程或者线程，用于分析并处理客户的数据将结果传递给I/O处理单元或者直接俄发给客户端。</p>
<p>请求队列是各单元通信方式的抽象，请求队列通常实现为池的一部分。</p>
<h2 id="io模型">I/O模型</h2>
<p>阻塞I/O执行的系统调用可能因为无法立即完成被操作系统挂起，例如accept，send，recv，connect可能被阻塞</p>
<p>非阻塞I/O执行系统调用总数立即返回，如果事件没有立即发生则返回-1.</p>
<h3 id="reactor-模式">reactor 模式</h3>
<p>要求主线程（i/O处理单元）只负责监听文件描述上是否有事件发生，有的话就立刻将事件通知工作线程（逻辑单元），除此之外主线程不做任何实质性的工作</p>
<figure>
<img src="/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20231205134405407.png" alt="reactor模式">
<figcaption aria-hidden="true">reactor模式</figcaption>
</figure>
<p>主线程网epoll内核事件表种主存socket上的读就绪事件</p>
<p>主线程调用epoll_wait等待socket上有数据可读，并放入请求队列，请求队列唤醒睡眠工作线程，读取socket数据，处理客户请求并往epoll内核事件中注册该socket上的写就绪事件。</p>
<h3 id="proactor模式">proactor模式</h3>
<p>与reactor不同，将所有的I/O操作都交给主线程和内核来处理，工作线程仅负责业务逻辑。</p>
<figure>
<img src="/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20231205135753612.png" alt="proactor模式">
<figcaption aria-hidden="true">proactor模式</figcaption>
</figure>
<figure>
<img src="/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20231205140138183.png" alt="同步I/O模拟proactor">
<figcaption aria-hidden="true">同步I/O模拟proactor</figcaption>
</figure>
<h2 id="服务器的主要的两种并发编程模式">服务器的主要的两种并发编程模式</h2>
<h3 id="半同步半异步模式">半同步/半异步模式</h3>
<p>同步：程序代码顺序执行</p>
<p>异步：需要有系统事件驱动（例如中断，信号等）</p>
<figure>
<img src="/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20231205140512919.png" alt="同步和异步">
<figcaption aria-hidden="true">同步和异步</figcaption>
</figure>
<figure>
<img src="/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20231205140713372.png" alt="半同步半异步工作流程">
<figcaption aria-hidden="true">半同步半异步工作流程</figcaption>
</figure>
<p>同步线程用于处理用户逻辑，异步线程用于处理I/O事件，异步线程监听到客户请求后，将其封装成请求对象并插入队列，请求队列通知某个工作在同步模式的工作线程来读取并处理该对象。</p>
<p>变体：</p>
<figure>
<img src="/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20231205141231477.png" alt="半同步半反应堆模式">
<figcaption aria-hidden="true">半同步半反应堆模式</figcaption>
</figure>
<p>只有一个异步线程，由主线程来充当，负责监听所有socket上的事件，睡眠的工作线程在任务到来时通过竞争获得任务管辖权。</p>
<figure>
<img src="/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20231205141628524.png" alt="更高效的半同步/半异步模式">
<figcaption aria-hidden="true">更高效的半同步/半异步模式</figcaption>
</figure>
<h3 id="领导者追随者模式">领导者/追随者模式</h3>
<p>多个工作线程轮流获得事件源集合，轮流监听，分发并处理事件。</p>
<figure>
<img src="/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20231205142645858.png" alt="领导者/追随者模式组件">
<figcaption aria-hidden="true">领导者/追随者模式组件</figcaption>
</figure>
<p>Handle：句柄用于表示I/O资源，</p>
<p>线程集：所有工作进程，每个线程可能存在的状态如下所示：</p>
<figure>
<img src="/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20231205143805570.png" alt="三种状态及转移关系">
<figcaption aria-hidden="true">三种状态及转移关系</figcaption>
</figure>
<p>工作流程： <img src="/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20231205143915697.png" alt="工作流程图"></p>
<h2 id="http请求读取和分析">HTTP请求读取和分析</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 4096<span class="comment">//读缓冲区大小</span></span></span><br><span class="line"><span class="comment">//主机可能的状态</span></span><br><span class="line"><span class="comment">// CHECK_STATE_REQUESTLINE表示正在分析请求行， CHECK_STATE_HEADER表示正在分析头部字段</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CHECK_STATE</span> &#123;</span> CHECK_STATE_REQUESTLINE = <span class="number">0</span>, CHECK_STATE_HEADER, CHECK_STATE_CONTENT &#125;;</span><br><span class="line"><span class="comment">//从状态机三种状态，LINE_OK行可读取状态读取到一个完整的行 LINE_BAD 行出错 LINE_OPEN 行数据尚且不完善</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LINE_STATUS</span> &#123;</span> LINE_OK = <span class="number">0</span>, LINE_BAD, LINE_OPEN &#125;;</span><br><span class="line"><span class="comment">/*服务器处理http请求的结果</span></span><br><span class="line"><span class="comment">NO_REQUEST：请求不完整，需要继续读取客户数据</span></span><br><span class="line"><span class="comment">GET_REQUEST：获得了一个完整的客户请求</span></span><br><span class="line"><span class="comment">BAD_REQUEST：客户请求语法有错误</span></span><br><span class="line"><span class="comment">FORBIDDEN_REQUEST 客户对资源没有足够权限访问</span></span><br><span class="line"><span class="comment">INTERNAL_ERROR 服务器内部错误</span></span><br><span class="line"><span class="comment">CLOSED_CONNECTION 客户已经关闭连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTP_CODE</span> &#123;</span> NO_REQUEST, GET_REQUEST, BAD_REQUEST, FORBIDDEN_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION &#125;;</span><br><span class="line"><span class="comment">//为了简化问题，服务器应答报文不是完整http报文，只是返回了下面处理的结果</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* szret[] = &#123; <span class="string">&quot;I get a correct result\n&quot;</span>, <span class="string">&quot;Something wrong\n&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//从状态机用于解析一行内容</span></span><br><span class="line">LINE_STATUS <span class="title function_">parse_line</span><span class="params">( <span class="type">char</span>* buffer, <span class="type">int</span>&amp; checked_index, <span class="type">int</span>&amp; read_index )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> temp;</span><br><span class="line">    <span class="comment">//checked_index 指向buffer中当前正在分析的字节，read_index指向buffer中客户数据尾部的下一字节</span></span><br><span class="line">    <span class="comment">//buffer中0~checked_index的字节都已经分析完毕，下面的循环分析checked_indx~(read_index-1)字节的内容</span></span><br><span class="line">    <span class="keyword">for</span> ( ; checked_index &lt; read_index; ++checked_index )</span><br><span class="line">    &#123;</span><br><span class="line">        temp = buffer[ checked_index ];<span class="comment">//获取当前要分析的字节</span></span><br><span class="line">        <span class="keyword">if</span> ( temp == <span class="string">&#x27;\r&#x27;</span> )<span class="comment">//如果当前的字节是回车，则说明可能读取到完整的一行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ( checked_index + <span class="number">1</span> ) == read_index )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> LINE_OPEN;<span class="comment">//当前不是完整的行，还需要继续读取客户数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//成功读取到一行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( buffer[ checked_index + <span class="number">1</span> ] == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                buffer[ checked_index++ ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                buffer[ checked_index++ ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则说明客户端语法有问题</span></span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( temp == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( ( checked_index &gt; <span class="number">1</span> ) &amp;&amp;  buffer[ checked_index - <span class="number">1</span> ] == <span class="string">&#x27;\r&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                buffer[ checked_index<span class="number">-1</span> ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                buffer[ checked_index++ ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分析请求行</span></span><br><span class="line">HTTP_CODE <span class="title function_">parse_requestline</span><span class="params">( <span class="type">char</span>* szTemp, CHECK_STATE&amp; checkstate )</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//strpbrk函数，其作用是在字符串 szTemp 中查找包含在字符串 &quot; \t&quot; 中的任何字符的第一个匹配项，</span></span><br><span class="line">    <span class="comment">//并返回指向该位置的指针。接着，通过条件判断语句检查返回的指针是否为空。</span></span><br><span class="line">    <span class="type">char</span>* szURL = <span class="built_in">strpbrk</span>( szTemp, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">    <span class="keyword">if</span> ( ! szURL )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;<span class="comment">//如果请求行中没有空白字符或者回车，说明http请求存在问题</span></span><br><span class="line">    &#125;</span><br><span class="line">    *szURL++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* szMethod = szTemp;</span><br><span class="line">    <span class="comment">//客户端发出GET请求</span></span><br><span class="line">    <span class="keyword">if</span> ( strcasecmp( szMethod, <span class="string">&quot;GET&quot;</span> ) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;The request method is GET\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//strspn函数的作用是计算字符串szURL连续包含\t字符的个数。返回后指针右移，指向下一句</span></span><br><span class="line">    szURL += <span class="built_in">strspn</span>( szURL, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">    <span class="type">char</span>* szVersion = <span class="built_in">strpbrk</span>( szURL, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">    <span class="keyword">if</span> ( ! szVersion )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取http版本号，仅支持HTTP/1.1</span></span><br><span class="line">    *szVersion++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    szVersion += <span class="built_in">strspn</span>( szVersion, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">    <span class="keyword">if</span> ( strcasecmp( szVersion, <span class="string">&quot;HTTP/1.1&quot;</span> ) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if (strncasecmp(szURL, &quot;http://&quot;, 7) == 0): </span></span><br><span class="line">    <span class="comment">//这是一个条件判断语句，使用 strncasecmp 函数比较 szURL 前7个字符（不区分大小写）</span></span><br><span class="line">    <span class="comment">//是否等于 &quot;http://&quot;。如果相等，说明 szURL 以 &quot;http://&quot; 开头。</span></span><br><span class="line">    <span class="keyword">if</span> ( strncasecmp( szURL, <span class="string">&quot;http://&quot;</span>, <span class="number">7</span> ) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//szURL += 7;: 如果以 &quot;http://&quot; 开头，将 szURL 指针向后移动7个字符，以跳过 &quot;http://&quot; 部分。</span></span><br><span class="line">        szURL += <span class="number">7</span>;</span><br><span class="line">        <span class="comment">//szURL = strchr(szURL, &#x27;/&#x27;);: 接下来，</span></span><br><span class="line">        <span class="comment">//使用 strchr 函数在新的 szURL 中找到第一个斜杠 &#x27;/&#x27; 的位置。这将更新 szURL 指针，使其指向第一个斜杠的位置。</span></span><br><span class="line">        szURL = <span class="built_in">strchr</span>( szURL, <span class="string">&#x27;/&#x27;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( ! szURL || szURL[ <span class="number">0</span> ] != <span class="string">&#x27;/&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//URLDecode( szURL );</span></span><br><span class="line">    <span class="comment">//http请求行处理完毕，状态转移到头部字段的分析</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;The request URL is: %s\n&quot;</span>, szURL );</span><br><span class="line">    checkstate = CHECK_STATE_HEADER;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分析头部字段</span></span><br><span class="line">HTTP_CODE <span class="title function_">parse_headers</span><span class="params">( <span class="type">char</span>* szTemp )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( szTemp[ <span class="number">0</span> ] == <span class="string">&#x27;\0&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( szTemp, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span> ) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        szTemp += <span class="number">5</span>;</span><br><span class="line">        szTemp += <span class="built_in">strspn</span>( szTemp, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;the request host is: %s\n&quot;</span>, szTemp );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">//其它头部字段都不受理</span></span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;I can not handle this header\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分析http请求的入口函数</span></span><br><span class="line">HTTP_CODE <span class="title function_">parse_content</span><span class="params">( <span class="type">char</span>* buffer, <span class="type">int</span>&amp; checked_index, CHECK_STATE&amp; checkstate, <span class="type">int</span>&amp; read_index, <span class="type">int</span>&amp; start_line )</span></span><br><span class="line">&#123;</span><br><span class="line">    LINE_STATUS linestatus = LINE_OK;</span><br><span class="line">    HTTP_CODE retcode = NO_REQUEST;</span><br><span class="line">    <span class="comment">//主状态机从buffer中取出所有完整的行</span></span><br><span class="line">    <span class="keyword">while</span>( ( linestatus = parse_line( buffer, checked_index, read_index ) ) == LINE_OK )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* szTemp = buffer + start_line;<span class="comment">//start line是在buffer中的起始位置</span></span><br><span class="line">        start_line = checked_index;<span class="comment">//记录下一行位置</span></span><br><span class="line">        <span class="keyword">switch</span> ( checkstate )<span class="comment">//检查主状态机当前状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_REQUESTLINE: <span class="comment">//第一个状态分析请求行</span></span><br><span class="line">            &#123;</span><br><span class="line">                retcode = parse_requestline( szTemp, checkstate );</span><br><span class="line">                <span class="keyword">if</span> ( retcode == BAD_REQUEST )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_HEADER:<span class="comment">//分析头部字段</span></span><br><span class="line">            &#123;</span><br><span class="line">                retcode = parse_headers( szTemp );</span><br><span class="line">                <span class="keyword">if</span> ( retcode == BAD_REQUEST )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( retcode == GET_REQUEST )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有读取一个完整的行</span></span><br><span class="line">    <span class="keyword">if</span>( linestatus == LINE_OPEN )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> listenfd = socket( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    assert( listenfd &gt;= <span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = bind( listenfd, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( ret != <span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    ret = listen( listenfd, <span class="number">5</span> );</span><br><span class="line">    assert( ret != <span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>( client_address );</span><br><span class="line">    <span class="type">int</span> fd = accept( listenfd, ( <span class="keyword">struct</span> sockaddr* )&amp;client_address, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span>( fd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[ BUFFER_SIZE ];</span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">        <span class="type">int</span> data_read = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> read_index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> checked_index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start_line = <span class="number">0</span>;</span><br><span class="line">        CHECK_STATE checkstate = CHECK_STATE_REQUESTLINE;</span><br><span class="line">        <span class="comment">//循环读取客户数据并分析</span></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            data_read = recv( fd, buffer + read_index, BUFFER_SIZE - read_index, <span class="number">0</span> );</span><br><span class="line">            <span class="keyword">if</span> ( data_read == <span class="number">-1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>( <span class="string">&quot;reading failed\n&quot;</span> );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( data_read == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>( <span class="string">&quot;remote client has closed the connection\n&quot;</span> );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            read_index += data_read;</span><br><span class="line">            HTTP_CODE result = parse_content( buffer, checked_index, checkstate, read_index, start_line );</span><br><span class="line">            <span class="keyword">if</span>( result == NO_REQUEST )<span class="comment">//尚未完成一个完整的，正确的http请求</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( result == GET_REQUEST )</span><br><span class="line">            &#123;</span><br><span class="line">                send( fd, szret[<span class="number">0</span>], <span class="built_in">strlen</span>( szret[<span class="number">0</span>] ), <span class="number">0</span> );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                send( fd, szret[<span class="number">1</span>], <span class="built_in">strlen</span>( szret[<span class="number">1</span>] ), <span class="number">0</span> );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close( fd );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close( listenfd );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>状态转移图：</p>
<figure>
<img src="/2023/12/05/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20231205192142822.png" alt="状态转移">
<figcaption aria-hidden="true">状态转移</figcaption>
</figure>
]]></content>
      <categories>
        <category>高性能服务器编程</category>
      </categories>
      <tags>
        <tag>Linux，计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器程序规范</title>
    <url>/2023/12/02/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="linux服务器程序规范">Linux服务器程序规范</h1>
<h2 id="linux系统日志">Linux系统日志</h2>
<p>内核日志由一个守护进程<code>rklogd</code>管理，内核日志通过printk打印到内核缓存，映射到<code>/proc/kmsg</code></p>
<p><code>syslogd</code>(rsyslogd),另一个守护进程处理系统日志，获取<code>/proc/kmsg</code>文件读取内核日志</p>
<figure>
<img src="/2023/12/02/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83/image-20231202112959449.png" alt="日志体系">
<figcaption aria-hidden="true">日志体系</figcaption>
</figure>
<h2 id="用户信息">用户信息</h2>
<p>UID和EUID</p>
<p><strong>UID（User Identifier）：</strong></p>
<ul>
<li>UID是一个用于唯一标识用户的整数值。每个用户在系统中都有一个唯一的UID。</li>
<li>UID为0的用户是超级用户（root），具有系统中最高的权限。</li>
<li>普通用户的UID通常从非零的正整数开始分配。</li>
</ul>
<p><strong>EUID（Effective User Identifier）：</strong></p>
<ul>
<li>EUID是与进程关联的用户标识符，用于决定进程在执行时拥有哪个用户的权限。</li>
<li>在许多情况下，EUID和UID是相同的，表示进程以指定用户的身份运行。但是，有一些情况下，EUID
可能会变得不同于 UID，以实现一些特殊的权限管理需求。</li>
<li>当一个可执行程序具有设置用户ID位（Set-UID）时，该程序在执行时会以文件所有者的身份（EUID）运行，而不是运行程序的用户（UID）的身份。这允许普通用户在执行特定程序时获得超级用户的权限。</li>
</ul>
<p>我们知道用户的密码都是存放在/etc/shadow文件下，我们看下这个文件的权限
ls -l /etc/shadow</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ ls -l /etc/shadow</span><br><span class="line">-rwxrwxrwx 1 root shadow 1449 Nov 19 00:46 /etc/shadow</span><br></pre></td></tr></table></figure>
<p>可以看出这个文件的所有者是root</p>
<p>假如我是一个普通用户，显然我是可以修改我的密码的，通过passwd命令，无可厚非。自己修改自己的密码肯定是被允许的。但是仔细想想你会发现不对啊，我作为一个普通用户登录后，我的实际用户ID和有效用户ID都是我自己的UID。从上面可以看出，显然我不具有修改/etc/shadow文件的权限，那我执行passwd命令时怎么改我的密码的呢？</p>
<p>我们知道决定我们权限的是执行操作时的有效用户ID，所有我们在执行passwd命令时，我们的有效用户ID肯定被修改了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ ls -l /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x. 1 root root 37288 Aug  3  2022 /usr/bin/passwd</span><br></pre></td></tr></table></figure>
<ul>
<li><ol type="1">
<li><code>-rwsr-xr-x.</code>: 这一部分描述文件的权限和类型。具体地说：
<ul>
<li><code>-</code>:
这是一个普通文件，而不是目录（<code>d</code>）或链接（<code>l</code>）。</li>
<li><code>rws</code>:
这表示用户（owner）有读、写和执行的权限。<code>s</code>
表示设置用户ID位（Set-UID）。</li>
<li><code>r-x</code>:
这表示组用户（group）有读和执行的权限，但没有写的权限。</li>
<li><code>r-x</code>:
这表示其他用户（others）有读和执行的权限，但没有写的权限。</li>
<li><code>.</code>: 表示有额外的文件属性或扩展，通常是 SELinux
安全上下文或其他扩展属性。</li>
</ul></li>
<li><code>1</code>:
文件的链接数。在这种情况下，有一个链接指向该文件。</li>
<li><code>root root</code>:
这是文件的所有者（owner）和所属组（group）。在这里，文件的所有者是 root
用户，所属组也是 root。</li>
<li><code>37288</code>: 文件的大小（以字节为单位）。</li>
<li><code>Aug 3 2022</code>: 文件的最后修改时间。</li>
<li><code>/usr/bin/passwd</code>: 文件的路径和名称。</li>
</ol></li>
</ul>
<p>关于 <code>-rws</code>
部分，当文件具有设置用户ID位（Set-UID）时，它将以文件所有者的身份运行而不是运行它的用户的身份。在这种情况下，<code>passwd</code>
可能以超级用户（root）的权限运行，以便允许用户更改自己的密码而无需超级用户的密码。
Set-UID 位用于提供程序执行过程中临时增加特权的能力。
这就是设置用户ID位的作用，它的存在就是为了普通用户在某些需要特权权限时，去临时的改变有效用户ID而获得特权权限。但是你可能有疑问，为什么我们不用setuid()直接修改呢？何苦绕这么大的弯子。但是如果可以使用setuid()来直接修改有效用户ID来获得特权权限，那么我们的特权权限就会不可控了。这违背了最小权限模型。</p>
<h3 id="测试进程的uid和euid的区别">测试进程的UID和EUID的区别</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uid_t</span> uid = getuid();</span><br><span class="line">    <span class="type">uid_t</span> euid = geteuid();</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;userid is %d, effective userid is: %d\n&quot;</span>, uid, euid );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>g++ testeuid.cpp -o test_uid</code></p>
<p><code>sudo chown root:root test_uid</code></p>
<p><code>sudo chmod +s test_uid</code></p>
<figure>
<img src="/2023/12/02/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83/image-20231202134425094.png" alt="实验">
<figcaption aria-hidden="true">实验</figcaption>
</figure>
<h2 id="切换用户">切换用户</h2>
<p>将以root身份启动的进程切换为以一个普通用户身份运行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">switch_to_user</span><span class="params">( <span class="type">uid_t</span> user_id, <span class="type">gid_t</span> gp_id )</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//先确保目标用户不是root</span></span><br><span class="line">    <span class="keyword">if</span> ( ( user_id == <span class="number">0</span> ) &amp;&amp; ( gp_id == <span class="number">0</span> ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">gid_t</span> gid = <span class="built_in">getgid</span>();</span><br><span class="line">    <span class="type">uid_t</span> uid = <span class="built_in">getuid</span>();</span><br><span class="line">    <span class="comment">//确保当前用户是合法用户：root或者目标用户</span></span><br><span class="line">    <span class="keyword">if</span> ( ( ( gid != <span class="number">0</span> ) || ( uid != <span class="number">0</span> ) ) &amp;&amp; ( ( gid != gp_id ) || ( uid != user_id ) ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是root则已经是目标用户</span></span><br><span class="line">    <span class="keyword">if</span> ( uid != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//切换用户</span></span><br><span class="line">    <span class="keyword">if</span> ( ( <span class="built_in">setgid</span>( gp_id ) &lt; <span class="number">0</span> ) || ( <span class="built_in">setuid</span>( user_id ) &lt; <span class="number">0</span> ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程间关系">进程间关系</h2>
<p><code>ps -o pid,ppid,pgid,sid,comm| less</code></p>
<ul>
<li><code>ps</code>: 进程查看命令。</li>
<li><code>-o pid,ppid,pgid,sid,comm</code>:
使用<code>-o</code>选项指定要显示的进程信息列。具体含义如下：
<ul>
<li><code>pid</code>: 进程ID（Process ID）。</li>
<li><code>ppid</code>: 父进程ID（Parent Process ID）。</li>
<li><code>pgid</code>: 进程组ID（Process Group ID）。</li>
<li><code>sid</code>: 会话ID（Session ID）。</li>
<li><code>comm</code>: 进程的命令名（命令行参数的第一个单词）。</li>
</ul></li>
<li><code>| less</code>:
使用管道将<code>ps</code>命令的输出传递给<code>less</code>命令，以便在屏幕上逐页查看输出。</li>
</ul>
<p>因此，该命令的目的是显示每个进程的进程ID（pid）、父进程ID（ppid）、进程组ID（pgid）、会话ID（sid）和进程命令名（comm），并通过<code>less</code>命令进行分页显示。这样可以更方便地查看系统中运行的进程的相关信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   PID    PPID    PGID     SID COMMAND</span><br><span class="line">235144  235138  235144  235144 zsh</span><br><span class="line">235169       1  235168  235144 zsh</span><br><span class="line">235196       1  235195  235144 zsh</span><br><span class="line">235198       1  235195  235144 zsh</span><br><span class="line">235199  235169  235168  235144 gitstatusd-linu</span><br><span class="line">235452  235144  235451  235144 less</span><br><span class="line">236714  235144  236714  235144 ps</span><br><span class="line">236715  235144  236714  235144 less</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从ppid可以看出，less和ps的父进程是zsh</p>
<figure>
<img src="/2023/12/02/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83/image-20231202160334635.png" alt="进程间关系">
<figcaption aria-hidden="true">进程间关系</figcaption>
</figure>
<p>pgid 是组 pid，等于组首领 pid sid 是 session id, 等于 session 首领
pid</p>
<p>session 主要是和终端相关，同一个终端启动的进程属于同一个 session</p>
<h2 id="服务器程序后台化">服务器程序后台化</h2>
<p>让一个进程以守护进程的方式运行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">daemonize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建子进程关闭父进程，让程序在后台运行</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//设置文件权限掩码</span></span><br><span class="line">    <span class="built_in">umask</span>( <span class="number">0</span> );</span><br><span class="line">   <span class="comment">//创建新的会话，将本进程设为进程组的首领</span></span><br><span class="line">    <span class="type">pid_t</span> sid = <span class="built_in">setsid</span>();</span><br><span class="line">    <span class="keyword">if</span> ( sid &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//切换工作目录 这个调用尝试将当前工作目录更改为根目录（&quot;/&quot;）</span></span><br><span class="line">    <span class="keyword">if</span> ( ( <span class="built_in">chdir</span>( <span class="string">&quot;/&quot;</span> ) ) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Log the failure */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//关闭标准输入输出设备和错误输出设备</span></span><br><span class="line">    <span class="built_in">close</span>( STDIN_FILENO );</span><br><span class="line">    <span class="built_in">close</span>( STDOUT_FILENO );</span><br><span class="line">    <span class="built_in">close</span>( STDERR_FILENO );</span><br><span class="line"><span class="comment">//将标准输入输出和标准错误输出都定向到/dev/null文件</span></span><br><span class="line">    <span class="built_in">open</span>( <span class="string">&quot;/dev/null&quot;</span>, O_RDONLY );</span><br><span class="line">    <span class="built_in">open</span>( <span class="string">&quot;/dev/null&quot;</span>, O_RDWR );</span><br><span class="line">    <span class="built_in">open</span>( <span class="string">&quot;/dev/null&quot;</span>, O_RDWR );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>高性能服务器编程</category>
      </categories>
      <tags>
        <tag>Linux，计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>高级IO函数</title>
    <url>/2023/11/29/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="高级io函数">高级IO函数</h1>
<h2 id="基本的gci服务器">基本的GCI服务器</h2>
<p>CGI（Common Gateway Interface）服务器是一种通过 Web
服务器执行外部程序的标准接口。它允许 Web
服务器调用外部程序来处理客户端的请求，并将程序的输出发送回客户端浏览器。CGI
是连接 Web 服务器和其他软件（通常是动态生成的程序或脚本）的桥梁。</p>
<p>基本上，当 Web
服务器接收到一个对动态内容的请求时，它可以调用与之相关联的 CGI
脚本或程序，将用户的请求传递给该程序进行处理。该程序生成动态内容，然后将其输出返回给
Web 服务器，最终发送到用户的浏览器。</p>
<p>一些关键点和特性：</p>
<ol type="1">
<li><strong>动态内容生成：</strong> CGI
允许服务器调用外部程序来生成动态内容，而不是直接返回静态文件。</li>
<li><strong>编程语言无关性：</strong> CGI
接口是独立于编程语言的，因此可以使用多种编程语言编写 CGI
脚本，包括但不限于 Perl、Python、C、C++等。</li>
<li><strong>处理表单数据：</strong> CGI 可以用于处理来自 HTML
表单的数据。用户提交表单后，服务器可以调用 CGI
脚本来处理表单数据并生成相应的响应。</li>
<li><strong>与 Web 服务器的通信：</strong> CGI 脚本与 Web
服务器通过环境变量和标准输入输出进行通信。</li>
<li><strong>安全性考虑：</strong> 由于 CGI
允许执行外部程序，必须小心处理用户输入，以防止潜在的安全漏洞。</li>
</ol>
<p>虽然 CGI 曾经是 Web
开发的主要方式，但随着时间的推移，其他技术和方法，如
FastCGI、mod_perl、PHP、ASP.NET 等，已经逐渐取代了纯粹的 CGI
模型，提供了更高效和更强大的动态内容生成机制。</p>
<p>将服务器标准输出重定向到客户端：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">accept</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>( STDOUT_FILENO );</span><br><span class="line">        <span class="built_in">dup</span>( connfd );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;abcd\n&quot;</span> );</span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>关闭标准输出（STDOUT_FILENO）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(STDOUT_FILENO);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>close</code>
函数用于关闭文件描述符。在这里，关闭标准输出文件描述符
<code>STDOUT_FILENO</code>，这是与标准输出相关联的文件描述符。</li>
</ul>
<p><strong>复制连接套接字到标准输出：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dup</span>(connfd);</span><br><span class="line"> <span class="built_in">printf</span>( <span class="string">&quot;abcd\n&quot;</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dup</code>
函数用于复制文件描述符。在这里，将连接套接字的文件描述符
<code>connfd</code> 复制到标准输出的文件描述符
<code>STDOUT_FILENO</code>。这样，标准输出将与连接套接字相关联。</li>
<li>dup函数会创建一个新的文件描述符，该描述符和原文件描述符指向相同的文件‘管道或网络连接</li>
<li>现在，<code>printf</code>
函数将数据写入标准输出，实际上是写入了连接套接字，因为标准输出已经被重定向到了连接套接字。</li>
</ul>
<p>测试：</p>
<figure>
<img src="/2023/11/29/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0/image-20231129203845419.png" alt="客户端">
<figcaption aria-hidden="true">客户端</figcaption>
</figure>
<h2 id="web服务器上集中写">web服务器上集中写</h2>
<p>readv函数是将数据从文件描述符读到分散的内存块中，writev函数将分散内存数据一并写入文件描述符中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="comment">//定义两种http状态码和状态信息</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* status_line[<span class="number">2</span>] = &#123; <span class="string">&quot;200 OK&quot;</span>, <span class="string">&quot;500 Internal server error&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number filename\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* file_name = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">accept</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//用于保存http应答的状态行，头部字段和一个空行的缓存区</span></span><br><span class="line">        <span class="type">char</span> header_buf[ BUFFER_SIZE ];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>( header_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">        <span class="comment">//用于存放目标文件内容的应用程序缓存</span></span><br><span class="line">        <span class="type">char</span>* file_buf;</span><br><span class="line">        <span class="comment">//用于获取目标文件的属性</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">stat</span> file_stat;</span><br><span class="line">        <span class="comment">//记录目标文件是否有效</span></span><br><span class="line">        <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//目标文件不存在</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">stat</span>( file_name, &amp;file_stat ) &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            valid = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;  <span class="comment">//目标文件是一个目录</span></span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">S_ISDIR</span>( file_stat.st_mode ) )</span><br><span class="line">            &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//用户有读取目标文件的权限</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( file_stat.st_mode &amp; S_IROTH )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> fd = <span class="built_in">open</span>( file_name, O_RDONLY );</span><br><span class="line">                <span class="comment">//动态分配缓存区大小为目标文件的大小+1，将目标文件读入缓存</span></span><br><span class="line">                file_buf = <span class="keyword">new</span> <span class="type">char</span> [ file_stat.st_size + <span class="number">1</span> ];</span><br><span class="line">                <span class="built_in">memset</span>( file_buf, <span class="string">&#x27;\0&#x27;</span>, file_stat.st_size + <span class="number">1</span> );</span><br><span class="line">                <span class="keyword">if</span> ( <span class="built_in">read</span>( fd, file_buf, file_stat.st_size ) &lt; <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果目标文件有效则发送正常的应答</span></span><br><span class="line">        <span class="keyword">if</span>( valid )</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="comment">//将http应答状态行划入buf</span></span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf, BUFFER_SIZE<span class="number">-1</span>, <span class="string">&quot;%s %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status_line[<span class="number">0</span>] );</span><br><span class="line">            len += ret;</span><br><span class="line">            <span class="comment">//加入Content-Length头部字段</span></span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="number">-1</span>-len, </span><br><span class="line">                             <span class="string">&quot;Content-Length: %d\r\n&quot;</span>, file_stat.st_size );</span><br><span class="line">            len += ret;</span><br><span class="line">            <span class="comment">//加入空行，&quot;\r\n&quot; 是回车和换行符，表示换行。</span></span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span> );</span><br><span class="line">            <span class="comment">//利用weitev将header_buf和file_buf一并写出</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">iovec</span> iv[<span class="number">2</span>];</span><br><span class="line">            iv[ <span class="number">0</span> ].iov_base = header_buf;</span><br><span class="line">            iv[ <span class="number">0</span> ].iov_len = <span class="built_in">strlen</span>( header_buf );</span><br><span class="line">            iv[ <span class="number">1</span> ].iov_base = file_buf;</span><br><span class="line">            iv[ <span class="number">1</span> ].iov_len = file_stat.st_size;</span><br><span class="line">            ret = <span class="built_in">writev</span>( connfd, iv, <span class="number">2</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//发送目标文件无效的状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf, BUFFER_SIZE<span class="number">-1</span>, <span class="string">&quot;%s %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status_line[<span class="number">1</span>] );</span><br><span class="line">            len += ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span> );</span><br><span class="line">            <span class="built_in">send</span>( connfd, header_buf, <span class="built_in">strlen</span>( header_buf ), <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">        <span class="keyword">delete</span> [] file_buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><code>send( connfd, header_buf, strlen( header_buf ), 0 );</code>：</strong></p>
<ul>
<li><code>send</code> 函数用于通过指定的套接字 (<code>connfd</code>)
发送数据。</li>
<li><code>header_buf</code> 是包含待发送数据的缓冲区的地址。</li>
<li><code>strlen(header_buf)</code> 是待发送数据的长度，使用
<code>strlen</code> 函数计算字符串的长度。</li>
<li><code>0</code> 是标志参数，表示不使用特殊的发送选项。</li>
</ul>
<p>测试：</p>
<figure>
<img src="/2023/11/29/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0/image-20231130100039332.png" alt="服务器端运行程序">
<figcaption aria-hidden="true">服务器端运行程序</figcaption>
</figure>
<figure>
<img src="/2023/11/29/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0/image-20231130100120232.png" alt="客户端telnet连接接收">
<figcaption aria-hidden="true">客户端telnet连接接收</figcaption>
</figure>
<h2 id="sendfile函数传输文件">sendfile函数传输文件</h2>
<p>修改schedule函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number filename\n&quot;</span>, basename( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* file_name = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> filefd = open( file_name, O_RDONLY );</span><br><span class="line">    assert( filefd &gt; <span class="number">0</span> );</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">    fstat( filefd, &amp;stat_buf );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    assert( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = listen( sock, <span class="number">5</span> );</span><br><span class="line">    assert( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = accept( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sendfile( connfd, filefd, <span class="literal">NULL</span>, stat_buf.st_size );</span><br><span class="line">        close( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​ 与之前的方法比，不用分配缓存就完成了文件的传输
。实验效果和上面一样</p>
<h2 id="用splice函数实现回射服务器">用splice函数实现回射服务器</h2>
<p>将客户端发送的数据原样返回客户端</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    assert( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = listen( sock, <span class="number">5</span> );</span><br><span class="line">    assert( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = accept( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">        assert( ret != <span class="number">-1</span> );</span><br><span class="line">        ret = pipe( pipefd );<span class="comment">//创建管道</span></span><br><span class="line">        ret = splice( connfd, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE ); </span><br><span class="line">        <span class="comment">//将connfd上流入的客户数据定向到管道中</span></span><br><span class="line">        assert( ret != <span class="number">-1</span> );</span><br><span class="line">        <span class="comment">//将管道的数据定向到connfd客户连接文件描述符</span></span><br><span class="line">        <span class="comment">//前面是管道描述符所以第二个参数是null                                       </span></span><br><span class="line">        ret = splice( pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, connfd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">        assert( ret != <span class="number">-1</span> );</span><br><span class="line">        close( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这段代码涉及到 Linux 中的管道（<code>pipe</code>）和
<code>splice</code> 系统调用，用于实现零拷贝数据传输。</p>
<p>​ <code>int pipefd[2];</code></p>
<ul>
<li><p>定义了一个整型数组 <code>pipefd</code>
用于存储管道的两个文件描述符。</p></li>
<li><p>使用 <code>pipe</code>
函数创建了一个无名管道。<code>pipefd[0]</code>
用于读取，<code>pipefd[1]</code> 用于写入</p></li>
<li><p>使用 <code>splice</code> 将
<code>connfd</code>（客户端连接套接字）的数据传输到管道的写入端
(<code>pipefd[1]</code>)。</p></li>
<li><p><code>32768</code> 是指定的最大传输字节数。</p></li>
<li><p><code>SPLICE_F_MORE | SPLICE_F_MOVE</code> 是传输标志，其中
<code>SPLICE_F_MORE</code>
表示可能还有更多的数据，<code>SPLICE_F_MOVE</code>
：合适的话按整页内存移动数据</p></li>
</ul>
<p>实验效果：</p>
<figure>
<img src="/2023/11/29/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0/image-20231130204012380.png" alt="发送K">
<figcaption aria-hidden="true">发送K</figcaption>
</figure>
<h2 id="tee-同时输出数据到终端和文件">TEE 同时输出数据到终端和文件</h2>
<p>tee在两个管道文件描述符之间复制数据，零拷贝</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( argc != <span class="number">2</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">&quot;usage: %s &lt;file&gt;\n&quot;</span>, argv[<span class="number">0</span>] );</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> filefd = <span class="built_in">open</span>( argv[<span class="number">1</span>], O_CREAT | O_WRONLY | O_TRUNC, <span class="number">0666</span> );</span><br><span class="line">	<span class="built_in">assert</span>( filefd &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pipefd_stdout[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pipe</span>( pipefd_stdout );</span><br><span class="line">	<span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pipefd_file[<span class="number">2</span>];</span><br><span class="line">        ret = <span class="built_in">pipe</span>( pipefd_file );</span><br><span class="line">	<span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line">    <span class="comment">//将标准输入内容输入管道pipefd_stdout</span></span><br><span class="line">	ret = <span class="built_in">splice</span>( STDIN_FILENO, <span class="literal">NULL</span>, pipefd_stdout[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">	<span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line">    <span class="comment">//将pipefd_stdout输出内容复制给pipefd_file输入</span></span><br><span class="line">	ret = <span class="built_in">tee</span>( pipefd_stdout[<span class="number">0</span>], pipefd_file[<span class="number">1</span>], <span class="number">32768</span>, SPLICE_F_NONBLOCK ); </span><br><span class="line">	<span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line">    <span class="comment">//将pipefd_file输出重定向到filefd</span></span><br><span class="line">	ret = <span class="built_in">splice</span>( pipefd_file[<span class="number">0</span>], <span class="literal">NULL</span>, filefd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">	<span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line">    <span class="comment">//将pipefd_stdout重定向到STDOUT_FILENO标准输出 </span></span><br><span class="line">	ret = <span class="built_in">splice</span>( pipefd_stdout[<span class="number">0</span>], <span class="literal">NULL</span>, STDOUT_FILENO, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">	<span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>( filefd );</span><br><span class="line">        <span class="built_in">close</span>( pipefd_stdout[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">close</span>( pipefd_stdout[<span class="number">1</span>] );</span><br><span class="line">        <span class="built_in">close</span>( pipefd_file[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">close</span>( pipefd_file[<span class="number">1</span>] );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>高性能服务器编程</category>
      </categories>
      <tags>
        <tag>Linux，计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>哈工大操作系统实验3进程运行轨迹的跟踪与统计</title>
    <url>/2023/11/29/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="进程运行轨迹的跟踪与统计">进程运行轨迹的跟踪与统计</h1>
<h2 id="实验内容">实验内容</h2>
<p>进程从创建（Linux 下调用
fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出
CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行……</p>
<p>本次实验包括如下内容：</p>
<ul>
<li>基于模板 <code>process.c</code> 编写多进程的样本程序，实现如下功能：
+ 所有子进程都并行运行，每个子进程的实际运行时间一般不超过 30 秒； +
父进程向标准输出打印所有q子进程的
id，并在所有子进程都退出后才退出；</li>
<li>在 <code>Linux0.11</code> 上实现进程运行轨迹的跟踪。 +
基本任务是在内核中维护一个日志文件
<code>/var/process.log</code>，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一
log 文件中。</li>
<li>在修改过的 0.11 上运行样本程序，通过分析 log
文件，统计该程序建立的所有进程的等待时间、完成时间（周转时间）和运行时间，然后计算平均等待时间，平均完成时间和吞吐量。可以自己编写统计程序，也可以使用
python 脚本程序—— <code>stat_log.py</code>（在
<code>/home/teacher/</code> 目录下） ——进行统计。</li>
<li>修改 0.11
进程调度的时间片，然后再运行同样的样本程序，统计同样的时间数据，和原有的情况对比，体会不同时间片带来的差异。</li>
</ul>
<h2 id="编写process.c-样本程序">编写process.c 样本程序</h2>
<p>process.c是样本程序的模板。它主要实现了一个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此函数按照参数占用CPU和I/O时间</span></span><br><span class="line"><span class="comment"> * last: 函数实际占用CPU和I/O的总时间，不含在就绪队列中的时间，&gt;=0是必须的</span></span><br><span class="line"><span class="comment"> * cpu_time: 一次连续占用CPU的时间，&gt;=0是必须的</span></span><br><span class="line"><span class="comment"> * io_time: 一次I/O消耗的时间，&gt;=0是必须的</span></span><br><span class="line"><span class="comment"> * 如果last &gt; cpu_time + io_time，则往复多次占用CPU和I/O，直到总运行时间超过last为止</span></span><br><span class="line"><span class="comment"> * 所有时间的单位为秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cpuio_bound(<span class="type">int</span> last, <span class="type">int</span> cpu_time, <span class="type">int</span> io_time);</span><br></pre></td></tr></table></figure>
<p>比如一个进程如果要占用10秒的CPU时间，它可以调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpuio_bound(<span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// 只要cpu_time&gt;0，io_time=0，效果相同</span></span><br></pre></td></tr></table></figure>
<p>以I/O为主要任务：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpuio_bound(<span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 只要cpu_time=0，io_time&gt;0，效果相同</span></span><br></pre></td></tr></table></figure>
<p>CPU和I/O各1秒钟轮回：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpuio_bound(<span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>较多的I/O，较少的CPU：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpuio_bound(<span class="number">10</span>, <span class="number">1</span>, <span class="number">9</span>);  <span class="comment">// I/O时间是CPU时间的9倍</span></span><br></pre></td></tr></table></figure>
<p>修改此模板，用fork()建立若干个同时运行的子进程，父进程等待所有子进程退出后才退出，每个子进程按照你的意愿做不同或相同的cpuio_bound()，从而完成一个个性化的样本程序。它可以用来检验有关log文件的修改是否正确，同时还是数据统计工作的基础。</p>
<p>wait()系统调用可以让父进程等待子进程的退出。</p>
<p><strong>小技巧：</strong></p>
<ol type="1">
<li>在Ubuntu下，top命令可以监视即时的进程状态。在top中，按u，再输入你的用户名，可以限定只显示以你的身份运行的进程，更方便观察。按h可得到帮助。</li>
<li>在Ubuntu下，ps命令可以显示当时各个进程的状态。“ps
aux”会显示所有进程；“ps aux | grep
xxxx”将只显示名为xxxx的进程。更详细的用法请问man。</li>
<li>在Linux 0.11下，按F1可以即时显示当前所有进程的状态。</li>
</ol>
<p><strong>process.c代码</strong></p>
<p><strong>struct tms 结构体</strong></p>
<p>struct tms 结构体定义在 &lt;sys/times.h&gt;
头文件里，具体定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Structure describing CPU time used by a process and its children.  */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> </span></span><br><span class="line"><span class="class">  &#123;</span> </span><br><span class="line">    <span class="type">clock_t</span> tms_utime ;          <span class="comment">/* User CPU time.  用户程序 CPU 时间*/</span> </span><br><span class="line">    <span class="type">clock_t</span> tms_stime ;          <span class="comment">/* System CPU time. 系统调用所耗费的 CPU 时间 */</span> </span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> tms_cutime ;         <span class="comment">/* User CPU time of dead children. 已死掉子进程的 CPU 时间*/</span> </span><br><span class="line">    <span class="type">clock_t</span> tms_cstime ;         <span class="comment">/* System CPU time of dead children.  已死掉子进程所耗费的系统调用 CPU 时间*/</span> </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>数据类型 clock_t</p>
<p>关于该数据类型的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CLOCK_T_DEFINED typedef long clock_t;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CLOCK_T_DEFINED</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在 time.h 文件中，还定义了一个常量 <code>CLOCKS_PER_SEC</code>
，它用来表示一秒钟会有多少个时钟计时单元，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLOCKS_PER_SEC ((clock_t)1000)</span></span><br></pre></td></tr></table></figure>
<p>下文就模拟cpu操作，定义
HZ=100，<code>#define HZ  100</code>内核的标准时间是jiffy,一个jiffy就是一个内部时钟周期,而内部时钟周期是由100HZ的频率所产生中的,也就是一个时钟滴答,间隔时间是10毫秒(ms).计算出来的时间也并非真实时间，而是时钟滴答次数，乘以10ms可以得到真正的时间:
<code>while ( ( (utime + stime) / HZ )  &lt; cpu_time );</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HZ	100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpuio_bound</span><span class="params">(<span class="type">int</span> last, <span class="type">int</span> cpu_time, <span class="type">int</span> io_time)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_PROC 5</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid[NR_PROC];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NR_PROC; i++) &#123;</span><br><span class="line">        <span class="type">pid_t</span> cur_pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(cur_pid == <span class="number">0</span>) &#123; <span class="comment">//子进程调用fork后，返回0</span></span><br><span class="line">			cpuio_bound(<span class="number">2</span>*(i+<span class="number">1</span>), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;the pid is %d, the father pid is %d.\n&quot;</span>, getpid(), getppid());</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//退出子进程</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//父进程返回的是子进程的pid</span></span><br><span class="line">			pid[i] = cur_pid;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;the %d child pid is %d\n&quot;</span>, i, pid[i]);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//循环创建子进程，然后在父进程利用wait()来等待子进程结束，然后父进程才退出。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NR_PROC; i++)&#123;</span><br><span class="line">		wait(&amp;pid[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the parent is finished.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此函数按照参数占用CPU和I/O时间</span></span><br><span class="line"><span class="comment"> * last: 函数实际占用CPU和I/O的总时间，不含在就绪队列中的时间，&gt;=0是必须的</span></span><br><span class="line"><span class="comment"> * cpu_time: 一次连续占用CPU的时间，&gt;=0是必须的</span></span><br><span class="line"><span class="comment"> * io_time: 一次I/O消耗的时间，&gt;=0是必须的</span></span><br><span class="line"><span class="comment"> * 如果last &gt; cpu_time + io_time，则往复多次占用CPU和I/O</span></span><br><span class="line"><span class="comment"> * 所有时间的单位为秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpuio_bound</span><span class="params">(<span class="type">int</span> last, <span class="type">int</span> cpu_time, <span class="type">int</span> io_time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">start_time</span>, <span class="title">current_time</span>;</span></span><br><span class="line">	<span class="type">clock_t</span> utime, stime;</span><br><span class="line">	<span class="type">int</span> sleep_time;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (last &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* CPU Burst */</span></span><br><span class="line">		times(&amp;start_time);</span><br><span class="line">		<span class="comment">/* 其实只有t.tms_utime才是真正的CPU时间。但我们是在模拟一个</span></span><br><span class="line"><span class="comment">		 * 只在用户状态运行的CPU大户，就像“for(;;);”。所以把t.tms_stime</span></span><br><span class="line"><span class="comment">		 * 加上很合理。*/</span></span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			times(&amp;current_time);</span><br><span class="line">			utime = current_time.tms_utime - start_time.tms_utime;</span><br><span class="line">			stime = current_time.tms_stime - start_time.tms_stime;</span><br><span class="line">		&#125; <span class="keyword">while</span> ( ( (utime + stime) / HZ )  &lt; cpu_time );</span><br><span class="line">		last -= cpu_time;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (last &lt;= <span class="number">0</span> )</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* IO Burst */</span></span><br><span class="line">		<span class="comment">/* 用sleep(1)模拟1秒钟的I/O操作 */</span></span><br><span class="line">		sleep_time=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (sleep_time &lt; io_time)</span><br><span class="line">		&#123;</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">			sleep_time++;</span><br><span class="line">		&#125;</span><br><span class="line">		last -= sleep_time;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="写process.log文件">写process.log文件</h2>
<h3 id="打开log文件">打开log文件</h3>
<p>为了能尽早开始记录，应当在内核启动时就打开 log 文件</p>
<p>在 init()中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> pid,i;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"><span class="comment">//加载文件系统</span></span><br><span class="line">setup((<span class="type">void</span> *) &amp;drive_info);</span><br><span class="line"><span class="comment">// 打开/dev/tty0，建立文件描述符0和/dev/tty0的关联</span></span><br><span class="line">(<span class="type">void</span>) open(<span class="string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 让文件描述符1也和/dev/tty0关联</span></span><br><span class="line">(<span class="type">void</span>) dup(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 让文件描述符2也和/dev/tty0关联</span></span><br><span class="line">(<span class="type">void</span>) dup(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码建立了文件描述符 0、1 和 2，它们分别就是 stdin、stdout 和
stderr。</p>
<p>可以把 log 文件的描述符关联到 3。文件系统初始化，描述符 0、1 和 2
关联之后，才能打开 log 文件，开始记录进程的运行轨迹。</p>
<p>为了能尽早访问log文件，我们要让上述工作在进程0中就完成。所以把这一段代码从init()移动到main()中，放在move_to_user_mode()之后（不能再靠前了），同时加上打开log文件的代码。修改后的main()如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">move_to_user_mode();</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************添加开始***************/</span></span><br><span class="line">setup((<span class="type">void</span> *) &amp;drive_info);</span><br><span class="line">(<span class="type">void</span>) open(<span class="string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="number">0</span>);    <span class="comment">//建立文件描述符0和/dev/tty0的关联</span></span><br><span class="line">(<span class="type">void</span>) dup(<span class="number">0</span>);        <span class="comment">//文件描述符1也和/dev/tty0关联</span></span><br><span class="line">(<span class="type">void</span>) dup(<span class="number">0</span>);        <span class="comment">//文件描述符2也和/dev/tty0关联</span></span><br><span class="line">(<span class="type">void</span>) open(<span class="string">&quot;/var/process.log&quot;</span>,O_CREAT|O_TRUNC|O_WRONLY,<span class="number">0666</span>);</span><br><span class="line"><span class="comment">/***************添加结束***************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;        <span class="comment">/* we count on this going ok */</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>打开log文件的参数的含义是建立只写文件，如果文件已存在则清空已有内容。文件的权限是所有人可读可写。</p>
<p>这样，文件描述符0、1、2和3就在进程0中建立了。根据fork()的原理，进程1会继承这些文件描述符，所以init()中就不必再open()它们。此后所有新建的进程都是进程1的子孙，也会继承它们。但实际上，init()的后续代码和/bin/sh都会重新初始化它们。所以只有进程0和进程1的文件描述符肯定关联着log文件，这一点在接下来的写log中很重要。</p>
<h3 id="写log文件">写log文件</h3>
<p>log文件将被用来记录进程的状态转移轨迹。所有的状态转移都是在内核进行的。在内核状态下，write()功能失效，其原理等同于《系统调用》实验中不能在内核状态调用printf()，只能调用printk()。编写可在内核调用的write()的难度较大，所以这里直接给出源码。它主要参考了printk()和sys_write()而写成的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> logbuf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintk</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    count=<span class="built_in">vsprintf</span>(logbuf, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">3</span>)    <span class="comment">/* 如果输出到stdout或stderr，直接调用sys_write即可 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        __asm__(<span class="string">&quot;push %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;push %%ds\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl $logbuf\n\t&quot;</span> <span class="comment">/* 注意对于Windows环境来说，是_logbuf,下同 */</span></span><br><span class="line">            <span class="string">&quot;pushl %1\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;call sys_write\n\t&quot;</span> <span class="comment">/* 注意对于Windows环境来说，是_sys_write,下同 */</span></span><br><span class="line">            <span class="string">&quot;addl $8,%%esp\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;popl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs&quot;</span></span><br><span class="line">            ::<span class="string">&quot;r&quot;</span> (count),<span class="string">&quot;r&quot;</span> (fd):<span class="string">&quot;ax&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">/* 假定&gt;=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(file=task[<span class="number">0</span>]-&gt;filp[fd]))    <span class="comment">/* 从进程0的文件描述符表中得到文件句柄 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        inode=file-&gt;f_inode;</span><br><span class="line"></span><br><span class="line">        __asm__(<span class="string">&quot;push %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;push %%ds\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl $logbuf\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %1\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %2\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;call file_write\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;addl $12,%%esp\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;popl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs&quot;</span></span><br><span class="line">            ::<span class="string">&quot;r&quot;</span> (count),<span class="string">&quot;r&quot;</span> (file),<span class="string">&quot;r&quot;</span> (inode):<span class="string">&quot;ax&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为和printk的功能近似，建议将此函数放入到<code>kernel/printk.c</code>中。<code>fprintk()</code>的使用方式类同与C标准库函数<code>fprintf()</code>，唯一的区别是第一个参数是文件描述符，而不是文件指针。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fprintk(<span class="number">1</span>, <span class="string">&quot;The ID of running process is %ld&quot;</span>, current-&gt;pid); <span class="comment">//向stdout打印正在运行的进程的ID</span></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">&quot;%ld\t%c\t%ld\n&quot;</span>, current-&gt;pid, <span class="string">&#x27;R&#x27;</span>, jiffies); <span class="comment">//向log文件输出</span></span><br></pre></td></tr></table></figure>
<h3 id="跟踪进程运行轨迹">跟踪进程运行轨迹</h3>
<h4 id="jiffies滴答">jiffies，滴答</h4>
<p>jiffies在kernel/sched.c文件中定义为一个全局变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="keyword">volatile</span> jiffies=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>它记录了从开机到当前时间的时钟中断发生次数。在<code>kernel/sched.c</code>文件中的<code>sched_init()</code>函数中，时钟中断处理函数被设置为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_intr_gate(<span class="number">0x20</span>,&amp;timer_interrupt);</span><br></pre></td></tr></table></figure>
<p>而在kernel/system_call.s文件中将timer_interrupt定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">timer_interrupt:</span><br><span class="line">    ……</span><br><span class="line">    incl jiffies     #增加jiffies计数值</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure>
<p>这说明<strong>jiffies表示从开机时到现在发生的时钟中断次数</strong>，这个数也被称为“滴答数”。</p>
<p>另外，在<code>kernel/sched.c</code>中的<code>sched_init()</code>中有下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">outb_p(<span class="number">0x36</span>, <span class="number">0x43</span>); <span class="comment">//设置8253模式</span></span><br><span class="line">outb_p(LATCH&amp;<span class="number">0xff</span>, <span class="number">0x40</span>);</span><br><span class="line">outb_p(LATCH&gt;&gt;<span class="number">8</span>, <span class="number">0x40</span>);</span><br></pre></td></tr></table></figure>
<p>这三条语句用来设置每次时钟中断的间隔，即为<code>LATCH</code>，而<code>LATCH</code>是定义在文件<code>kernel/sched.c</code>中的一个宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LATCH  (1193180/HZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HZ 100  <span class="comment">//在include/linux/sched.h中</span></span></span><br></pre></td></tr></table></figure>
<p>再加上PC机8253定时芯片的输入时钟频率为1.193180MHz，即1193180/每秒，LATCH=1193180/100，时钟每跳11931.8下产生一次时钟中断，即每1/100秒（10ms）产生一次时钟中断，所以<strong>jiffies实际上记录了从开机以来共经过了多少个10ms</strong>。</p>
<h4 id="寻找状态切换点">寻找状态切换点</h4>
<p>必须找到所有发生进程状态切换的代码点，并在这些点添加适当的代码，来输出进程状态变化的情况到log文件中。此处要面对的情况比较复杂，需要对kernel下的fork.c、sched.c有通盘的了解，而exit.c也会涉及到。</p>
<p>第一个例子是看看如何记录一个进程生命期的开始，当然这个事件就是进程的创建函数fork()，由《系统调用》实验可知，fork()功能在内核中实现为sys_fork()，该“函数”在文件kernel/system_call.s中实现为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sys_fork:</span><br><span class="line">    call find_empty_process</span><br><span class="line">    ……</span><br><span class="line">    push %gs   //传递一些参数</span><br><span class="line">    pushl %esi</span><br><span class="line">    pushl %edi</span><br><span class="line">    pushl %ebp</span><br><span class="line">    pushl %eax</span><br><span class="line">    call copy_process  //调用copy_process实现进程创建</span><br><span class="line">    addl $20,%esp</span><br></pre></td></tr></table></figure>
<h4 id="修改fork.c">修改fork.c</h4>
<p>所以真正实现进程创建的函数是<code>copy_process()</code>，它在<code>kernel/fork.c</code>中定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr,……)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    ……</span><br><span class="line">    p = (<span class="keyword">struct</span> task_struct *) get_free_page();  <span class="comment">//获得一个task_struct结构体空间</span></span><br><span class="line">    ……</span><br><span class="line">    p-&gt;pid = last_pid;</span><br><span class="line">    ……</span><br><span class="line">    p-&gt;start_time = jiffies;    <span class="comment">//设置start_time为jiffies</span></span><br><span class="line">       ……</span><br><span class="line">    p-&gt;state = TASK_RUNNING;    <span class="comment">//设置进程状态为就绪。所有就绪进程的状态都是</span></span><br><span class="line">                    <span class="comment">//TASK_RUNNING(0），被全局变量current指向的</span></span><br><span class="line">                    <span class="comment">//是正在运行的进程。</span></span><br><span class="line">    <span class="keyword">return</span> last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此要完成进程运行轨迹的记录就要在<code>copy_process()</code>中添加输出语句。这里要输出两种状态，分别是“N（新建）”和“J（就绪）”。</p>
<p>下面做出两处修改：</p>
<p>修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	p-&gt;start_time = jiffies;</span><br><span class="line">fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tN\t%d\n&quot;</span>,p-&gt;pid,jiffies);  <span class="comment">//新增进程创建</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//新增进程就绪</span></span><br><span class="line">fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,p-&gt;pid,jiffies);</span><br><span class="line">   <span class="keyword">return</span> last_pid;</span><br></pre></td></tr></table></figure>
<p>第二个例子是记录进入睡眠态的时间。sleep_on()和interruptible_sleep_on()让当前进程进入睡眠状态，这两个函数在<code>kernel/sched.c</code>文件中定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    ……</span><br><span class="line">    tmp = *p;</span><br><span class="line">    *p = current;  <span class="comment">//仔细阅读，实际上是将current插入“等待队列”头部，tmp是原来的头部</span></span><br><span class="line">    current-&gt;state = TASK_UNINTERRUPTIBLE; <span class="comment">//切换到睡眠态</span></span><br><span class="line">    schedule();  <span class="comment">//让出CPU</span></span><br><span class="line">    <span class="keyword">if</span> (tmp)</span><br><span class="line">        tmp-&gt;state=<span class="number">0</span>;    <span class="comment">//唤醒队列中的上一个（tmp）睡眠进程。0换作TASK_RUNNING更好</span></span><br><span class="line">                <span class="comment">//在记录进程被唤醒时一定要考虑到这种情况，实验者一定要注意!!!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TASK_UNINTERRUPTIBLE和TASK_INTERRUPTIBLE的区别在于不可中断的睡眠</span></span><br><span class="line"><span class="comment"> * 只能由wake_up()显式唤醒，再由上面的 schedule()语句后的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   if (tmp) tmp-&gt;state=0;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 依次唤醒，所以不可中断的睡眠进程一定是按严格从“队列”（一个依靠</span></span><br><span class="line"><span class="comment"> * 放在进程内核栈中的指针变量tmp维护的队列）的首部进行唤醒。而对于可</span></span><br><span class="line"><span class="comment"> * 中断的进程，除了用wake_up唤醒以外，也可以用信号（给进程发送一个信</span></span><br><span class="line"><span class="comment"> * 号，实际上就是将进程PCB中维护的一个向量的某一位置位，进程需要在合</span></span><br><span class="line"><span class="comment"> * 适的时候处理这一位。感兴趣的实验者可以阅读有关代码）来唤醒，如在</span></span><br><span class="line"><span class="comment"> * schedule()中：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span></span><br><span class="line"><span class="comment"> *      if (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span></span><br><span class="line"><span class="comment"> *         (*p)-&gt;state==TASK_INTERRUPTIBLE)</span></span><br><span class="line"><span class="comment"> *         (*p)-&gt;state=TASK_RUNNING;//唤醒</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 就是当进程是可中断睡眠时，如果遇到一些信号就将其唤醒。这样的唤醒会</span></span><br><span class="line"><span class="comment"> * 出现一个问题，那就是可能会唤醒等待队列中间的某个进程，此时这个链就</span></span><br><span class="line"><span class="comment"> * 需要进行适当调整。interruptible_sleep_on和sleep_on函数的主要区别就</span></span><br><span class="line"><span class="comment"> * 在这里。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interruptible_sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line">       …</span><br><span class="line">    tmp=*p;</span><br><span class="line">    *p=current;</span><br><span class="line">repeat:    current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">if</span> (*p &amp;&amp; *p != current) &#123; <span class="comment">//如果队列头进程和刚唤醒的进程current不是一个，说明从队列中间唤醒了一个进程，需要处理</span></span><br><span class="line">        (**p).state=<span class="number">0</span>;   <span class="comment">//将队列头唤醒，并通过goto repeat让自己再去睡眠</span></span><br><span class="line">        <span class="keyword">goto</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">    *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp)</span><br><span class="line">        tmp-&gt;state=<span class="number">0</span>;  <span class="comment">//作用和sleep_on函数中的一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信实验者已经找到合适的地方插入记录进程从运行到睡眠的语句了。</p>
<p>总的来说，Linux
0.11支持四种进程状态的转移：就绪到运行、运行到就绪、运行到睡眠和睡眠到就绪，此外还有新建和退出两种情况。其中就绪与运行间的状态转移是通过schedule()（它亦是调度算法所在）完成的；运行到睡眠依靠的是
<code>sleep_on()</code> 和 <code>interruptible_sleep_on()</code>
，还有进程主动睡觉的系统调用 <code>sys_pause()</code> 和
<code>sys_waitpid()</code>
；睡眠到就绪的转移依靠的是<code>wake_up()</code>。所以只要在这些函数的适当位置插入适当的处理语句就能完成进程运行轨迹的全面跟踪了。如下所示：</p>
<h4 id="修改sched.c文件">修改sched.c文件</h4>
<p>schedule：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*p)-&gt;state==TASK_INTERRUPTIBLE)</span><br><span class="line">	(*p)-&gt;state=TASK_RUNNING;</span><br><span class="line">fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,(*p)-&gt;pid,jiffies);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//切换到相同的进程不输出</span></span><br><span class="line"><span class="keyword">if</span>(current-&gt;pid != task[next] -&gt;pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*新建修改--时间片到时程序 =&gt; 就绪*/</span></span><br><span class="line">		<span class="keyword">if</span>(current-&gt;state == TASK_RUNNING)</span><br><span class="line">			fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,current-&gt;pid,jiffies);</span><br><span class="line">		fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tR\t%d\n&quot;</span>,task[next]-&gt;pid,jiffies);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>修改sys_pause函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_pause</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(current-&gt;pid != <span class="number">0</span>)</span><br><span class="line">		fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tW\t%d\n&quot;</span>,current-&gt;pid,jiffies);</span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改sleep_on函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	*修改--当前进程进程 =&gt; 不可中断睡眠</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tW\t%d\n&quot;</span>,current-&gt;pid,jiffies);</span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">if</span> (tmp)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		*修改--原等待队列 第一个进程 =&gt; 唤醒（就绪）</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,tmp-&gt;pid,jiffies);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改interruptible_sleep_on函数同sleep_on</p>
<p>修改wake_up函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; *p) &#123;</span><br><span class="line">		(**p).state=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		*修改--唤醒 最后进入等待序列的 进程</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,(*p)-&gt;pid,jiffies);</span><br><span class="line">		*p=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改exit.c文件">修改exit.c文件</h3>
<p>当一个进程结束了运行或在半途中终止了运行，那么内核就需要释放该进程所占用的系统资源。这包括进程运行时打开的文件、申请的内存等。</p>
<p>当一个用户程序调用exit()系统调用时，就会执行内核函数do_exit()。该函数会首先释放进程代码段和数据段占用的内存页面，关闭进程打开着的所有文件，对进程使用的当前工作目录、根目录和运行程序的<code>i</code>节点进行同步操作。如果进程有子进程，则让<code>init</code>进程作为其所有子进程的父进程。如果进程是一个会话头进程并且有控制终端，则<strong>释放控制终端(如果按照实验的数据，此时就应该打印了)</strong>，并向属于该会话的所有进程发送挂断信号
SIGHUP，这通常会终止该会话中的所有进程。然后把进程状态置为僵死状态
TASK_ZOMBIE。并向其原父进程发送 SIGCHLD
信号，通知其某个子进程已经终止。最后
do_exit()调用调度函数去执行其他进程。由此可见在进程被终止时，它的任务数据结构仍然保留着。因为其父进程还需要使用其中的信息。</p>
<p>在子进程在执行期间，父进程通常使用<code>wait()</code>或
<code>waitpid()</code>函数等待其某个子进程终止。当等待的子进程被终止并处于僵死状态时，父进程就会把子进程运行所使用的时间累加到自己进程中。最终释放已终止子进程任务数据结构所占用的内存页面，并置空子进程在任务数组中占用的指针项。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>HIT</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda表达式解析</title>
    <url>/2023/11/26/C++%E7%AC%94%E8%AE%B0/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="lambda表达式解析">lambda表达式解析</h1>
<h2 id="什么是lambda表达式">什么是lambda表达式</h2>
<p>lambda表达式是一个可调用的代码单元，可以将其理解为一个未命名的内联函数。</p>
<p>lambda表达式形式：</p>
<p><code>[捕获列表](参数列表)-&gt; return type&#123;函数体&#125;</code></p>
<p>其中参数列表和return type可以省略：</p>
<p><code>auto f=[]&#123;return 42;&#125;;</code></p>
<p>我们经常在排序中使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; words=&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bbbb&quot;</span>,<span class="string">&quot;ccccc&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[](<span class="type">const</span> string &amp;a,<span class="type">const</span> string &amp;b)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初步分析">初步分析</h2>
<p>我们借助c++ insight工具对其实现原理进行分析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> fun=[](string a,string b)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>() ;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被编译器转换为：</p>
<p>编译器会将lambda函数转成一个类：class
__lambda_7_12，并inline的重载操作符函数</p>
<p><code>using retType_7_12 = bool (*)(string, string);</code></p>
<p>这一行创建了一个名为<code>retType_7_12</code>的类型别名。该别名表示一个指向接受两个<code>string</code>参数并返回<code>bool</code>的函数的指针。<code>using</code>关键字用于为更好的代码可读性和可维护性定义此类类型别名</p>
<p>实际上fun是一个对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_7_12</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::basic_string&lt;<span class="type">char</span>&gt; a, std::basic_string&lt;<span class="type">char</span>&gt; b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> retType_7_12 = <span class="built_in">bool</span> (*)(string, string);</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">retType_7_12</span> <span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> __invoke;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> __invoke(std::basic_string&lt;<span class="type">char</span>&gt; a, std::basic_string&lt;<span class="type">char</span>&gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> __lambda_7_12&#123;&#125;.<span class="built_in">operator</span>()(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_7_12 fun = __lambda_7_12&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用捕获列表">使用捕获列表</h2>
<p>Lambda 表达式可以使用上下文的变量</p>
<p>下面的函数可以用于输出长度大于sz的字符串（c++ primer 349)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bigger</span><span class="params">(vector&lt;string&gt; &amp;words,vector&lt;string&gt;::size_type sz,ostream &amp;os =cout)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> bigit=<span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[&amp;sz](<span class="type">const</span> string &amp; a)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;sz;&#125;);</span><br><span class="line">    for_each(bigit,words.<span class="built_in">end</span>(),[&amp;os](<span class="type">const</span> string  &amp;s)&#123;os&lt;&lt;s&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;);</span><br><span class="line">    os&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="值捕获">值捕获</h3>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>emplace_pack和push_back</title>
    <url>/2023/11/26/C++%E7%AC%94%E8%AE%B0/emplaceback%E5%92%8Cpushback/</url>
    <content><![CDATA[<h1 id="emplace_pack和push_back">emplace_pack和push_back</h1>
<p><code>emplace_back</code> 和 <code>push_back</code>
都是用于将元素添加到容器尾部的 C++ 函数，但它们有一些关键的区别，使得
<code>emplace_back</code> 在某些情况下比 <code>push_back</code>
更高效。</p>
<ol type="1">
<li><strong>构造对象的方式：</strong>
<ul>
<li><code>push_back</code>
接受一个已经构造好的对象，并将其拷贝（或移动）到容器中。</li>
<li><code>emplace_back</code>
则允许你在容器内部就地构造对象，而不需要提前创建一个对象。它接受参数，并将这些参数传递给对象的构造函数。</li>
</ul></li>
<li><strong>性能优势：</strong>
<ul>
<li>当使用 <code>push_back</code>
时，你需要先创建一个对象，然后将其拷贝（或移动）到容器中。这可能导致额外的构造和拷贝开销，特别是当操作涉及到复杂的对象。</li>
<li><code>emplace_back</code>
可以直接在容器内部构造对象，避免了额外的拷贝或移动操作，因此在性能上可能更高效。</li>
</ul></li>
<li><strong>可变参数：</strong>
<ul>
<li><code>emplace_back</code>
使用可变参数列表，允许传递给构造函数的参数。这使得它对于构造函数带有多个参数的情况更为灵活，而不需要显式创建一个临时对象。</li>
</ul></li>
</ol>
<p>在实际编程中，如果你只需要添加已经存在的对象到容器尾部，那么
<code>push_back</code>
是一个不错的选择。但如果你想要在容器中直接构造对象，并且构造函数带有多个参数，那么
<code>emplace_back</code> 可能更为合适和高效。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>虚函数</title>
    <url>/2023/11/26/C++%E7%AC%94%E8%AE%B0/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="虚函数">虚函数</h1>
<h2 id="什么是虚函数">什么是虚函数</h2>
<p>虚函数是一种由virtual关键字修饰的一种类内函数，可分为虚函数和纯虚函数。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机体系结构基础</title>
    <url>/2023/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="计算机体系结构基础">计算机体系结构基础</h1>
<h2 id="引言按下ppt翻页会发生什么">引言：按下ppt翻页会发生什么</h2>
<p>键盘按下后键盘会产生一个信号发送给南桥芯片，芯片将键盘的编码存储在寄存器中并向处理器发送一个外部中断信号。</p>
<p>外部中断发送到cpu控制寄存器模块，并存储在一个控制寄存器中。没有被屏蔽的中断信号被附在一条译码后的指令上传到重排序缓存（Reoder
buffer），当该指令成为ROB的第一条指令时，发生精确例外，取消后面的指令，修改控制寄存器，系统状态切到核心态。把例外发生的原因和当前PC保存在控制寄存器中，pc设置为例外处理函数入口，处理器跳转执行中断处理。</p>
<p>操作系统保护现场将当前状态压入寄存器，操作系统从cpu控制器中读中断原因，发现是按下键盘，将该原因传给南桥芯片同时清楚南桥中断位。同时操作系统查那个进程在阻塞等待这个按键，发现是ppt在阻塞态，将其唤醒，ppt运行态接收操作系统传过来的数据是按键，表示要翻页，应用程序进行ppt翻页。</p>
<h2 id="常见性能优化方法">常见性能优化方法</h2>
<ul>
<li>加快经常性发生的事件（加速比，Amdahl定律）</li>
<li>开发局部性：时间，空间。例如：cache，TLB，预取，转移猜测</li>
<li>通过并行性提高性能
<ul>
<li>指令级并行：时间并行（流水线），空间并行（多发射）</li>
<li>数据级并行：多数据流的向量结构</li>
<li>任务级并行：多核处理器，多线程处理器</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络编程基础API学习笔记</title>
    <url>/2023/11/20/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/</url>
    <content><![CDATA[<h1 id="linux网络编程基础api-学习笔记">Linux网络编程基础API-学习笔记</h1>
<h2 id="主机字节序和网络字节序">主机字节序和网络字节序</h2>
<p>大端字节序：网络字节序</p>
<p>利用union公用体查看自己电脑的字节序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byteorder</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="type">short</span> value;</span><br><span class="line">		<span class="type">char</span> union_bytes[ <span class="keyword">sizeof</span>( <span class="type">short</span> ) ];</span><br><span class="line">	&#125; test;</span><br><span class="line">	test.value = <span class="number">0x0102</span>;</span><br><span class="line">	<span class="keyword">if</span> (  ( test.union_bytes[ <span class="number">0</span> ] == <span class="number">1</span> ) &amp;&amp; ( test.union_bytes[ <span class="number">1</span> ] == <span class="number">2</span> ) )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">&quot;big endian\n&quot;</span> );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( ( test.union_bytes[ <span class="number">0</span> ] == <span class="number">2</span> ) &amp;&amp; ( test.union_bytes[ <span class="number">1</span> ] == <span class="number">1</span> ) )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">&quot;little endian\n&quot;</span> );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">&quot;unknown...\n&quot;</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/11/20/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20231121191616466.png"></p>
<p>现代的PC机大多采用小端序：主机字节序</p>
<h2 id="socket">socket</h2>
<p>linux：所有的东西都是文件。socket：可读，可写可控制，可关闭的文件描述符。</p>
<h3 id="创建socket">创建socket：</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain,<span class="type">int</span> type,<span class="type">int</span> protocol)</span>;<span class="comment">//domain:底层协议族 type：服务类型（流服务，数据报服务)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建socket</span></span><br><span class="line"><span class="comment">//协议底层族：PF_INET 用于IPV4 PF_INET6用于IPV6 </span></span><br><span class="line"><span class="comment">//SOCK_STREAM，流服务，对于TCP/IP协议族，标识TCP协议</span></span><br><span class="line"><span class="comment">//SOCK_DGRAM 数据报服务，对于对于TCP/IP协议族，表示传输层使用UDP</span></span><br><span class="line"><span class="comment">//0表示默认协议</span></span><br><span class="line"><span class="type">int</span> sock = socket( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<h3 id="bind">bind</h3>
<p>将一个socket和socket地址绑定称为给socket命名。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> bind（<span class="type">int</span> sockfd，<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> * <span class="title">myaddr</span>，<span class="title">socklen_taddrlen</span>）</span></span><br></pre></td></tr></table></figure>
<p>绑定成功返回0，失败返回-1.</p>
<h3 id="监听socket">监听socket</h3>
<p>创建一个监听队列存放待处理的客户连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> listen（<span class="type">int</span> sockfd，<span class="type">int</span> backlog）</span><br></pre></td></tr></table></figure>
<p>backlog：内核监听队列的最大长度，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_term</span><span class="params">( <span class="type">int</span> sig )</span></span><br><span class="line">&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    signal( SIGTERM, handle_term );</span><br><span class="line">     <span class="comment">//该服务程序接收三个参数：IP地址，端口号，backlogzhi</span></span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number backlog\n&quot;</span>, basename( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    <span class="type">int</span> backlog = atoi( argv[<span class="number">3</span>] );</span><br><span class="line">    <span class="comment">//创建socket</span></span><br><span class="line">    <span class="comment">//协议底层族：PF_INET 用于IPV4 PF_INET6用于IPV6 </span></span><br><span class="line">    <span class="comment">//SOCK_STREAM，流服务，对于TCP/IP协议族，标识TCP协议</span></span><br><span class="line">    <span class="comment">//SOCK_DGRAM 数据报服务，对于对于TCP/IP协议族，表示传输层使用UDP</span></span><br><span class="line">    <span class="comment">//0表示默认协议</span></span><br><span class="line">    <span class="type">int</span> sock = socket( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    assert( sock &gt;= <span class="number">0</span> );<span class="comment">//检查创建是否成功</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span><span class="comment">//用于存储 IPv4 地址和端口信息。</span></span><br><span class="line">    bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    <span class="comment">/*使用 bzero 函数将 address 结构的内存区域清零，以确保结构中的所有字段都被初始化为零。bzero 是一个用于将内存区域清零的函数，但在一些系统中，可能会看到 memset 函数来执行相同的操作。*/</span></span><br><span class="line">    address.sin_family = AF_INET;<span class="comment">//这行代码设置 address 结构的地址族为 AF_INET，表示使用 IPv4 地址。</span></span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );<span class="comment">//将字符串格式的 IP 地址转换为二进制形式并将结果存储在    address.sin_addr 中</span></span><br><span class="line">    <span class="comment">//用 htons 函数将端口号从主机字节序转换为网络字节序。网络字节序是一种特定的字节序，通常是大端序（Big Endian）</span></span><br><span class="line">    address.sin_port = htons( port );<span class="comment">//设置端口号并进行字节序转换</span></span><br><span class="line"><span class="comment">//执行了 bind 函数，用于将一个本地地址（例如 IP 地址和端口号）绑定到一个已创建的套接字 sock 上</span></span><br><span class="line">    <span class="type">int</span> ret = bind( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( ret != <span class="number">-1</span> );<span class="comment">//测试是否绑定成功</span></span><br><span class="line"><span class="comment">//监听，设置监听队列长度</span></span><br><span class="line">    ret = listen( sock, backlog );</span><br><span class="line">    assert( ret != <span class="number">-1</span> );</span><br><span class="line"><span class="comment">//循环等待连接，直到有SIGTREAM信号将它中断</span></span><br><span class="line">    <span class="keyword">while</span> ( ! stop )</span><br><span class="line">    &#123;</span><br><span class="line">        sleep( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//关闭socket</span></span><br><span class="line">    close( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序：<code>./a.out  172.21.245.193  255 5</code></p>
<p>报错解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">: Cannot assign requested address</span><br><span class="line">a.out: testlisten.cpp:48: int main(int, char**): Assertion `ret != -1&#x27; failed.</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>第一步，先查一下自己ubuntu的IP地址 hq123@ubuntu:~/a_test$ ifconfig
server.sin_addr.s_addr = inet_addr("xxx"); // 服务器的 IP 地址</li>
<li>第二步 ，bind 绑定的IP地址要和自己电脑（ubuntu）的IP地址一</li>
</ol>
<p>运行上述程序，在客户端远程连接服务器：</p>
<p><code>telnet  服务器公网IP 255</code></p>
<p>此时端口状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ lsof -i :255</span><br><span class="line">COMMAND    PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME</span><br><span class="line">a.out   179304 root    3u  IPv4 1430112      0t0  TCP localhost:255 (LISTEN)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看端口状态：<code>netstat -nt |grep 255</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ netstat -nt |grep 255</span><br><span class="line">tcp        0      0 172.21.245.193:255      111.199.69.168:2733     ESTABLISHED</span><br></pre></td></tr></table></figure>
<p>释放端口：<code>sudo fuser -k -n tcp 255</code></p>
<p>通过实验可以发现，监听队列的长度超过backlog的时候服务器不受理新的客户连接</p>
<h4 id="服务器开启防火墙端口">服务器开启防火墙端口</h4>
<p>查看防火墙状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld.service </span><br></pre></td></tr></table></figure>
<p>开启防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start firewall.service</span><br></pre></td></tr></table></figure>
<p>重启防火墙</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">firewall<span class="operator">-</span>cmd <span class="comment">--reload</span></span><br></pre></td></tr></table></figure>
<p>关闭防火墙</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>
<p>开放端口（更改后要重启防火墙）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=255/tcp --permanent</span><br></pre></td></tr></table></figure>
<h3 id="接受连接">接受连接</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">acept</span><span class="params">(<span class="type">int</span> sockfd,<span class="keyword">struct</span> sockaddr* addr,<span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>addr:被接受的远端socket地址，addrlen地址长度</p>
<p>接受一个异常的连接：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>( client );</span><br><span class="line">    <span class="comment">//定义了一个变量 client_addrlength，用于存储客户端地址结构体的大小。</span></span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">accept</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="comment">//使用 accept 函数接受客户端的连接请求。sock 是监听套接字，&amp;client 是用于存储客户端地址信息的结构体。connfd 是返回的新的套接字描述符，用于与客户端进行通信。</span></span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> remote[INET_ADDRSTRLEN ];<span class="comment">//定义一个字符数组 remote，用于存储远程客户端的 IP 地址。</span></span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, </span><br><span class="line">            <span class="built_in">inet_ntop</span>( AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN ), <span class="built_in">ntohs</span>( client.sin_port ) );</span><br><span class="line">            <span class="comment">//将二进制表示的 IPv4 地址转换为可读的字符串表示形式，并将结果存储在 remote 中</span></span><br><span class="line">            <span class="comment">//将网络字节序的端口号转换为主机字节序。client.sin_port 存储了客户端的端口号。</span></span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );<span class="comment">//关闭连接，并非总是直接关闭连接而是将sock对应的引用计数减一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>address.sin_port</code>
字段表示套接字绑定的端口号。具体来说，<code>sin_port</code> 是
<code>struct sockaddr_in</code>
结构体的一个字段，它存储了套接字的端口信息。和之前不一样，这次是直接连接了</p>
<figure>
<img src="/2023/11/20/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20231128133107509.png" alt="客户端连接">
<figcaption aria-hidden="true">客户端连接</figcaption>
</figure>
<figure>
<img src="/2023/11/20/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20231128133251251.png" alt="服务器连接">
<figcaption aria-hidden="true">服务器连接</figcaption>
</figure>
<p>accept对客户端网络的断开毫不知情。</p>
<h3 id="tcp数据读写">TCP数据读写</h3>
<p>对文件的读写同样适用于socket，其中recv读取sockfd上的数据，send向sockfd写数据</p>
<p>客户端：</p>
<p><code>send( sockfd, normal_data, strlen( normal_data ), 0 );</code></p>
<p>使用 <code>send</code>
函数，第一个参数是套接字描述符，第二个参数是指向要发送数据的指针，第三个参数是要发送的数据的长度，最后一个参数是标志，此处标志为
0，表示普通数据</p>
<p><code>send(sockfd, oob_data, strlen(oob_data), MSG_OOB);</code></p>
<p>发送带外数据到服务器，使用 <code>send</code> 函数，最后一个参数设置为
<code>MSG_OOB</code>，表示带外数据，用于发送或接受紧急数据</p>
<p>整体程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_address;</span><br><span class="line">    <span class="built_in">bzero</span>( &amp;server_address, <span class="built_in">sizeof</span>( server_address ) );</span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );</span><br><span class="line">    server_address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sockfd &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="comment">//connect 发起连接。用于建立与远程服务器的连接</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">connect</span>( sockfd, ( <span class="keyword">struct</span> sockaddr* )&amp;server_address, <span class="built_in">sizeof</span>( server_address ) ) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;connection failed\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;send oob data out\n&quot;</span> );</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* oob_data = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* normal_data = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">send</span>( sockfd, normal_data, <span class="built_in">strlen</span>( normal_data ), <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">send</span>( sockfd, oob_data, <span class="built_in">strlen</span>( oob_data ), MSG_OOB );</span><br><span class="line">        <span class="built_in">send</span>( sockfd, normal_data, <span class="built_in">strlen</span>( normal_data ), <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sockfd );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器接收：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">accept</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[ BUF_SIZE ];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE );</span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE );</span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="number">-1</span>, MSG_OOB );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;got %d bytes of oob data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE );</span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><code>memset(buffer, '\0', BUF_SIZE);</code>：</strong> 将
<code>buffer</code> 数组初始化为零，以确保不会出现垃圾数据。</p>
<p><strong><code>ret = recv(connfd, buffer, BUF_SIZE - 1, 0);</code>：</strong>
使用 <code>recv</code> 函数接收普通数据，<code>connfd</code>
是连接的套接字描述符，<code>buffer</code>
是接收数据的缓冲区，<code>BUF_SIZE - 1</code>
是要接收的最大字节数，<code>0</code> 表示没有特殊标志。</p>
<figure>
<img src="/2023/11/20/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20231128141338742.png" alt="客户端">
<figcaption aria-hidden="true">客户端</figcaption>
</figure>
<figure>
<img src="/2023/11/20/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20231128141355575.png" alt="服务端">
<figcaption aria-hidden="true">服务端</figcaption>
</figure>
<h3 id="udp数据读写">UDP数据读写</h3>
<p>和tcp不同，由于udp是无连接的，因此因此每次都要指定发送端的socket地址（ip+端口）</p>
<h3 id="重用本地地址">重用本地地址</h3>
<ul>
<li><code>SO_REUSEADDR</code>
是套接字选项的一种，用于控制套接字地址的重用。</li>
<li>当 <code>SO_REUSEADDR</code> 设置为非零值时，表示允许重用处于
TIME_WAIT 状态的套接字地址。</li>
<li>这对于快速重新启动服务器程序而无需等待 TIME_WAIT 超时非常有用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="type">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>( sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="built_in">sizeof</span>( reuse ) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">accept</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> remote[INET_ADDRSTRLEN ];</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, </span><br><span class="line">            <span class="built_in">inet_ntop</span>( AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN ), <span class="built_in">ntohs</span>( client.sin_port ) );</span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="修改tcp缓冲区">修改TCP缓冲区</h3>
<p>客户端修改发送缓冲区：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number send_bufer_size\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_address;</span><br><span class="line">    <span class="built_in">bzero</span>( &amp;server_address, <span class="built_in">sizeof</span>( server_address ) );</span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );</span><br><span class="line">    server_address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sendbuf = <span class="built_in">atoi</span>( argv[<span class="number">3</span>] );</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>( sendbuf );</span><br><span class="line">    <span class="built_in">setsockopt</span>( sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, <span class="built_in">sizeof</span>( sendbuf ) );</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    SOL_SOCKET 表示套接字层级的选项，用于指定要设置或获取的选项层级。</span></span><br><span class="line"><span class="comment">    这是一个通用的套接字选项，可用于在套接字 API 中设置或获取各种配置。</span></span><br><span class="line"><span class="comment">    SO_SNDBUF 表示设置或获取套接字发送缓冲区大小的选项</span></span><br><span class="line"><span class="comment">    这行代码使用 setsockopt 函数设置了套接字 sock 的发送缓冲区大小，sendbuf 是要设置的缓冲区大小。这意味着在后续的数据发送过程中，套接字将使用这个指定大小的发送缓冲区。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">getsockopt</span>( sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, ( <span class="type">socklen_t</span>* )&amp;len );</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   这行代码使用 getsockopt 函数获取套接字 sock 的当前发送缓冲区大小，并将结果存储在 sendbuf 中。然后，打印出当前的发送缓    冲区大小。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;the tcp send buffer size after setting is %d\n&quot;</span>, sendbuf );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">connect</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;server_address, <span class="built_in">sizeof</span>( server_address ) ) != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[ BUFFER_SIZE ];</span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;a&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">        <span class="built_in">send</span>( sock, buffer, BUFFER_SIZE, <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20231128234907597.png" alt="socket选项">
<figcaption aria-hidden="true">socket选项</figcaption>
</figure>
<p>服务器端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number receive_buffer_size\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="type">int</span> recvbuf = <span class="built_in">atoi</span>( argv[<span class="number">3</span>] );</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>( recvbuf );</span><br><span class="line">    <span class="built_in">setsockopt</span>( sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, <span class="built_in">sizeof</span>( recvbuf ) );</span><br><span class="line">    <span class="built_in">getsockopt</span>( sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, ( <span class="type">socklen_t</span>* )&amp;len );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;the receive buffer size after settting is %d\n&quot;</span>, recvbuf );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">accept</span>( sock, ( <span class="keyword">struct</span> sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[ BUFFER_SIZE ];</span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">recv</span>( connfd, buffer, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span> ) &gt; <span class="number">0</span> )&#123;&#125;</span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>tips</strong>：</p>
<p>注意有些socket修改选项（例如本次的修改缓冲区选项），在客户端必须要在connect前修改好，connect调用成功后就已经完成了TCP三次握手。而对于服务器端，有些操作必须要在listen前调用完成，因为连接socket由accept调用返回，accept在listen监听队列中选择的接收连接至少都已经完成了TCP的三次握手的前两个握手动作进入SYN_RCVD状态</p>
<p>系统对于发送和接收缓冲区有一个最小值，设定值小于该值会被默认为最小值</p>
<figure>
<img src="/2023/11/20/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20231129125205694.png" alt="客户端">
<figcaption aria-hidden="true">客户端</figcaption>
</figure>
<p><code>tcpdump -nt -i eth0 port 255</code></p>
<ul>
<li><strong><code>tcpdump</code>：</strong>
命令行网络抓包工具，用于捕获和分析网络数据包。</li>
<li><strong><code>-nt</code>：</strong>
<ul>
<li><code>-n</code> 表示禁用主机名解析，只显示 IP 地址。</li>
<li><code>-t</code> 表示不显示时间戳。</li>
</ul></li>
<li><strong><code>-i eth0</code>：</strong>
<ul>
<li><code>-i</code> 后接网络接口的名称，这里是
<code>eth0</code>，表示捕获该网络接口上的数据包。</li>
</ul></li>
<li><strong><code>port 255</code>：</strong>
<ul>
<li>表示捕获目标端口号为 <code>255</code> 的数据包。</li>
<li><code>port</code>
后接端口号，可以是单个端口、一系列端口范围，或者使用服务名（例如，<code>http</code>）。</li>
</ul></li>
</ul>
<p>综合起来，该命令的含义是在 <code>eth0</code>
网络接口上捕获目标端口号为 <code>255</code>
的数据包，同时禁用主机名解析，不显示时间戳，将捕获到的数据包的源和目标
IP 地址以及端口号显示出来。</p>
]]></content>
      <categories>
        <category>高性能服务器编程</category>
      </categories>
      <tags>
        <tag>Linux，计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>剪枝</title>
    <url>/2023/02/08/AI/%E5%89%AA%E6%9E%9D/</url>
    <content><![CDATA[<figure>
<img src="/2023/02/08/AI/%E5%89%AA%E6%9E%9D/image-20230208163700173.png" alt="image-20230208163700173">
<figcaption aria-hidden="true">image-20230208163700173</figcaption>
</figure>
<figure>
<img src="/2023/02/08/AI/%E5%89%AA%E6%9E%9D/image-20230208163830112.png" alt="image-20230208163830112">
<figcaption aria-hidden="true">image-20230208163830112</figcaption>
</figure>
<figure>
<img src="/2023/02/08/AI/%E5%89%AA%E6%9E%9D/image-20230208164045725.png" alt="image-20230208164045725">
<figcaption aria-hidden="true">image-20230208164045725</figcaption>
</figure>
<p>结构化剪枝：</p>
<figure>
<img src="/2023/02/08/AI/%E5%89%AA%E6%9E%9D/image-20230208213740958.png" alt="image-20230208213740958">
<figcaption aria-hidden="true">image-20230208213740958</figcaption>
</figure>
]]></content>
  </entry>
  <entry>
    <title>GAN原理</title>
    <url>/2023/01/14/AI/GAN/</url>
    <content><![CDATA[<p>GAN：隐式的生成模型</p>
<h2 id="生成对抗原理">生成对抗原理</h2>
<p><img src="/2023/01/14/AI/GAN/image-20230114161027777.png"></p>
<p>生成器与判别器损失总体优化目标：</p>
<p><span class="math inline">\(\min \max V(D, G)=E_{x \sim p_{\text
{data }}(x)}[\log \mathrm{D}(\mathrm{x})]+E_{z \sim p_z(z)}[\log
(1-\mathrm{D}(\mathrm{G}(\mathrm{z})))]\)</span></p>
<p><span class="math inline">\(E_{x \sim p_{\text {data }}(x)}[\log
\mathrm{D}(\mathrm{x})]\)</span> :真实样本输入到判别器的输出 --&gt;
期望这一项越大越好</p>
<p><span class="math inline">\(E_{z \sim p_z(z)}[\log
(1-\mathrm{D}(\mathrm{G}(\mathrm{z})))]\)</span>
:噪声样本输入生成器，再输入判别器以后的样本，应该越小越好，因为用<span class="math inline">\(1-\mathrm{D}(\mathrm{G}(\mathrm{z}))\)</span>
所以是越大越好。</p>
<p>D的学习目标：D(X)大，D(G(Z))小：</p>
<p><span class="math inline">\(\max _\theta \mathbb{E}_{x \sim p_{\text
{data }}}[\log D(x)]+\mathbb{E}_{z \sim p_z}[\log
(1-D(G(z)))]\)</span></p>
<p>G的学习目标： D(G(Z))大 <span class="math inline">\(\min
_\theta\mathbb{E}_{z \sim p_z}[\log (1-D(G(z)))]\)</span></p>
<h2 id="梯度问题">梯度问题</h2>
<p>生成器早期的梯度消失问题：</p>
<p><img src="/2023/01/14/AI/GAN/image-20230114163131328.png"></p>
<p>梯度消失问题：</p>
<p>判别器输出是0~1的需要通过sigmoid函数</p>
<p><img src="/2023/01/14/AI/GAN/image-20230114163251992.png"></p>
<p><img src="/2023/01/14/AI/GAN/image-20230114163543211.png"></p>
<p>KL散度不对称会造成：</p>
<p><img src="/2023/01/14/AI/GAN/image-20230114163737997.png"></p>
<h2 id="gan的基本结构">GAN的基本结构</h2>
<p><img src="/2023/01/14/AI/GAN/image-20230114163947283.png"></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测</title>
    <url>/2023/01/08/AI/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="什么是目标检测">什么是目标检测</h2>
<p><img src="/2023/01/08/AI/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/image-20230108115751362.png" alt="image-20230108115751362" style="zoom:50%;"></p>
<p>识别图片中有哪些物体并找到物体存在的位置</p>
<p>多任务：位置+类别</p>
<p>主要挑战：</p>
<ul>
<li>目标种类与数量繁多问题</li>
<li>目标尺度不均问题</li>
<li>遮挡、噪声外部环境干扰</li>
</ul>
<p><img src="/2023/01/08/AI/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/image-20230108120052904.png"></p>
<h2 id="nms">NMS</h2>
<p><img src="/2023/01/08/AI/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/image-20230108120131114.png"></p>
<h2 id="常用数据集">常用数据集</h2>
<h3 id="voc">VOC</h3>
<p><img src="/2023/01/08/AI/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/image-20230108120303461.png"></p>
<h3 id="coco">COCO</h3>
<p><img src="/2023/01/08/AI/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/image-20230108120342169.png"></p>
<h2 id="基本概念及名词解释">基本概念及名词解释</h2>
<h3 id="iou评估检测框质量">IOU评估检测框质量</h3>
<p>基于IOU评估检测框的检测质量</p>
<p><img src="/2023/01/08/AI/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/image-20230108120456564.png"></p>
<h3 id="正负样本划分">正负样本划分</h3>
<p><img src="/2023/01/08/AI/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/image-20230108120626468.png"></p>
<h3 id="ar-与ap">AR 与AP</h3>
<p><img src="/2023/01/08/AI/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/image-20230108121333156.png"></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>图像分割</title>
    <url>/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h2 id="图像分割分类">图像分割分类</h2>
<figure>
<img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230107225200305.png" alt="image-20230107225200305">
<figcaption aria-hidden="true">image-20230107225200305</figcaption>
</figure>
<p>语义分割：每一个像素必须且只能属于一类，预测结果为掩膜</p>
<p>实例分割：只预测前景目标的类别属性以及边框，个体ID，每一个像素可以属于多个ID</p>
<figure>
<img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230107225809249.png" alt="image-20230107225809249">
<figcaption aria-hidden="true">image-20230107225809249</figcaption>
</figure>
<p>比如上面所示因为有遮挡所以每一个像素可以属于多个ID</p>
<p>全景分割（panoptic
segmentation）每个像素点分配一个语义类别和一个<strong>唯一</strong>的实例ID</p>
<ul>
<li><p>如果所有的类别都是stuff那么全景分割除了度
量，与语义分割相同。</p></li>
<li><p>全景分割中不允许重叠，但实例分割可以；实例分割需要每个分割的置信概率，但全景分割不需要。</p></li>
</ul>
<h2 id="经典数据集">经典数据集</h2>
<h3 id="pascal-voc">pascal VOC</h3>
<figure>
<img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230107230213794.png" alt="image-20230107230213794">
<figcaption aria-hidden="true">image-20230107230213794</figcaption>
</figure>
<p>一共2913张图，1464张训练图片，1449张验证图片</p>
<h3 id="cityscape">Cityscape</h3>
<figure>
<img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230107230323009.png" alt="image-20230107230323009">
<figcaption aria-hidden="true">image-20230107230323009</figcaption>
</figure>
<p>5000张精细标注的图像（2975张训练图,立硏长验证图和1525张测试图）、20000
张粗略标注图像</p>
<figure>
<img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230107230434354.png" alt="image-20230107230434354">
<figcaption aria-hidden="true">image-20230107230434354</figcaption>
</figure>
<h3 id="coco">COCO</h3>
<figure>
<img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230107230635130.png" alt="image-20230107230635130">
<figcaption aria-hidden="true">image-20230107230635130</figcaption>
</figure>
<p>共 91 类，以人类 4 岁小孩能够辨识为基准，其中 82 类有超过 5 000 个
instance。</p>
<h2 id="评估指标与优化标准">评估指标与优化标准</h2>
<p>评估指标</p>
<ul>
<li><p>Pixel Accuracy 逐像素分类精度</p>
<p><span class="math inline">\(\mathrm{PA}=\frac{\sum_{\mathrm{i}=0}^k
p_{i i}}{\sum_{i=0}^k \sum_{j=0}^k p_{i j}}\)</span></p></li>
<li><p>Mean Pixel Accuracy 每个类内被正确分类像素数的比例</p></li>
<li><p>IOU ：前景目标交并比。</p>
<p><span class="math inline">\(I o U_0=\frac{\mathrm{A} \cap
\mathrm{B}}{\mathrm{A} \cup \mathrm{B}}\)</span></p>
<figure>
<img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230107234531078.png" alt="image-20230107234531078">
<figcaption aria-hidden="true">image-20230107234531078</figcaption>
</figure></li>
<li><p>FWIOU 每个类的 foU 平均值：根据每个类出现的频率给 mioU
计算权重</p></li>
</ul>
<p>优化目标</p>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230107231727165.png"></p>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230107232016372.png" alt="image-20230107232016372" style="zoom:80%;"></p>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230107232104818.png"></p>
<h2 id="上采样方法">上采样方法</h2>
<p>上采样：得到语义分割的掩膜</p>
<p>图像分割网络的两个模块卷积模块：</p>
<ul>
<li><p>提取特征反卷积模块</p></li>
<li><p>上采样恢复到原图尺度</p></li>
</ul>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230107234628180.png"></p>
<h3 id="上采样实现一插值法">上采样实现一插值法</h3>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230107235043023.png"></p>
<h3 id="上采样实现一转置卷积">上采样实现一转置卷积</h3>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230107235716530.png"></p>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230107235903668.png"></p>
<p><strong>典型图像分割网络</strong></p>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108000042897.png"></p>
<h2 id="语义分割经典模型">语义分割经典模型</h2>
<h3 id="fcn-fully-convolutional-network">FCN (Fully convolutional
network)</h3>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108000312306.png"></p>
<p>类似 VGG+双线性上采样</p>
<p>随着网络加深特征图越来越小，特征越来越抽象</p>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108000539139.png"></p>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108000906883.png"></p>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108001411621.png"></p>
<ul>
<li><p>FCN32x：对conv7的预测结果进行32倍上采样（对应步长pool5）</p></li>
<li><p>FCN16x·对conv7的预测结果上采样2倍，与poo14+conv预测结果相加，然后进行16倍上采样</p></li>
<li><p>FCN8x：对FCN16x预测结果上采样2倍，poo13+conv预测结果相加，然后进行8倍上采样</p></li>
<li><p>中间两个上采样使用双线性插值初始化并进行学习，最后一个上采样不学习</p></li>
</ul>
<h3 id="segnet">SegNet</h3>
<h4 id="segnet网络结构">SEGNET网络结构</h4>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108093010812.png"></p>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108093215937.png"></p>
<h4 id="segnet网络细节">SEGNET网络细节</h4>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108094522966.png"></p>
<h3 id="unet">UNet</h3>
<p>Unet结构：</p>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108095705398.png"></p>
<h2 id="语义分割模型改进">语义分割模型改进</h2>
<h3 id="语义分割难题">语义分割难题</h3>
<ol type="1">
<li>分辨率问题</li>
</ol>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108100135509.png"></p>
<p>空间不变性：CNN分类的时候换一个位置分类还是相同的，但是分割问题要求不同位置的像素分类是不同的（比如两个人）</p>
<ol start="2" type="1">
<li>分类错误问题</li>
</ol>
<p>相似形状与复杂纹理带来的分类错误</p>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108100537739.png"></p>
<p>合理的先验关系（Mismatched
Relationship）（如上图第一行，车在水里不符合先验关系）
混淆的类别（Confusion Categories） 不容易区分的类别（lnconspicuous
Classes）</p>
<p>解决思路：</p>
<p>从更高分辨率的特征图开始恢复
利用充足的上下文信息（Cntext，感受野）</p>
<h3 id="膨胀卷积空洞卷积">膨胀卷积（空洞卷积）</h3>
<p>原来的<span class="math inline">\(3\times3\)</span>卷积只能覆盖边界为3的区域，膨胀后覆盖的区域变大</p>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108101943717.png"></p>
<p>与其他曾加感受野的方法相比，膨胀卷积优势明显：
与使用更大的卷积核比较：有更少的卷积参数
与池化相比：保留了更大的卷积特征图
与增加网络深度比较：有更少的网络层和计算量</p>
<h4 id="膨胀卷积结构设计">膨胀卷积结构设计</h4>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108102332153.png"></p>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108102446730.png"></p>
<p>应用：</p>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108102517972.png"></p>
<h3 id="可变形卷积deformable-conv">可变形卷积（deformable conv）</h3>
<p>!(./图像分割/image-20230108102615922.png)</p>
<h3 id="多尺度特征融合框架">多尺度特征融合框架</h3>
<h4 id="parsenet">parseNet</h4>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108103114866.png"></p>
<p>全局特征与局部特征融合</p>
<h4 id="pspnet金字塔池化">PSPNet（金字塔池化）</h4>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108103236667.png"></p>
<h4 id="refinenet">RefineNet</h4>
<p>逐层进行多种分辨率的特征图融合</p>
<ul>
<li>首先用卷积层获得尺寸不变的特征</li>
<li>然后使用上采样操做将所有特征图扩展为尺寸相同的特征图</li>
<li>最后使用求和操作融合所有的特征图</li>
</ul>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108103655080.png"></p>
<h3 id="crf">CRF</h3>
<h4 id="cnn的缺陷">cnn的缺陷</h4>
<p>CNN是对每一个像素单独进行预测，没有更好的考虑像素间的关系。</p>
<p>经典的cnn是局部的方法，即感受野是局部而不个图像
cnn具有空间变换不变性，这也了降低了分割的边缘定位精度</p>
<h4 id="crf-原理">CRF 原理</h4>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108103953333.png"></p>
<p>区域能量项：picewise</p>
<p>相同区域的像素分到一起（类似聚类）</p>
<p>一般使用直方图或混合高斯模型：</p>
<p>属于同一个目标的，颜色一般会比较一致</p>
<p>$U(, , )=_n-h(z_n ; _n) $</p>
<p><span class="math inline">\(\quad D\left(\alpha_n, k_n,
\underline{\theta}, z_n\right)=-\log \pi\left(\alpha_n,
k_n\right)+\frac{1}{2} \log \operatorname{det} \Sigma\left(\alpha_n,
k_n\right)\)</span> <span class="math inline">\(+\frac{1}{2}\left[z_n-\mu\left(\alpha_n,
k_n\right)\right]^{\top} \Sigma\left(\alpha_n,
k_n\right)^{-1}\left[z_n-\mu\left(\alpha_n,
k_n\right)\right]\)</span></p>
<p>边缘能量项：pairwise</p>
<p>衡量两个不相同区域的相似性的</p>
<p>平滑能量项（如果是不同目标，就应该取不同的标签，如果取了相同的标签，就给一个惩罚：</p>
<p><span class="math inline">\(\exp
-\beta\left(z_m-z_n\right)^2\)</span></p>
<p><span class="math inline">\(V(\underline{\alpha}, \mathbf{z})=\gamma
\sum_{(m, n) \in \mathbf{C}} \operatorname{dis}(m, n)^{-1}\left[\alpha_n
\neq \alpha_m\right] \exp -\beta\left(z_m-z_n\right)^2\)</span></p>
<h4 id="crf的使用">CRF的使用</h4>
<ol type="1">
<li>直接分步后处理。将其用于处理cnn网络的输出。例如：</li>
</ol>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108112014166.png"></p>
<ol start="2" type="1">
<li>直接融合进cnn的框架。如牛津大学Torr-Vision提出的crf as
Cnn在边缘定位精度取得很大提升</li>
</ol>
<p><img src="/2023/01/07/AI/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/image-20230108111922640.png"></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积集锦</title>
    <url>/2023/01/07/AI/%E5%8D%B7%E7%A7%AF%E9%9B%86%E9%94%A6/</url>
    <content><![CDATA[<h2 id="卷积拆分">卷积拆分</h2>
<figure>
<img src="/2023/01/07/AI/%E5%8D%B7%E7%A7%AF%E9%9B%86%E9%94%A6/image-20230107115007216.png" alt="image-20230107115007216">
<figcaption aria-hidden="true">image-20230107115007216</figcaption>
</figure>
<p>应用</p>
<figure>
<img src="/2023/01/07/AI/%E5%8D%B7%E7%A7%AF%E9%9B%86%E9%94%A6/image-20230107115131230.png" alt="image-20230107115131230">
<figcaption aria-hidden="true">image-20230107115131230</figcaption>
</figure>
<h2 id="深度可分离卷积">深度可分离卷积</h2>
<p>先执行空间卷积，再执行<span class="math inline">\(1\times
1\)</span>卷积</p>
<figure>
<img src="/2023/01/07/AI/%E5%8D%B7%E7%A7%AF%E9%9B%86%E9%94%A6/image-20230107115347713.png" alt="image-20230107115347713">
<figcaption aria-hidden="true">image-20230107115347713</figcaption>
</figure>
<figure>
<img src="/2023/01/07/AI/%E5%8D%B7%E7%A7%AF%E9%9B%86%E9%94%A6/image-20230107115956429.png" alt="image-20230107115956429">
<figcaption aria-hidden="true">image-20230107115956429</figcaption>
</figure>
<p><img src="/2023/01/07/AI/%E5%8D%B7%E7%A7%AF%E9%9B%86%E9%94%A6/image-20230107120019334.png" alt="image-20230107120019334" style="zoom:67%;"></p>
<figure>
<img src="/2023/01/07/AI/%E5%8D%B7%E7%A7%AF%E9%9B%86%E9%94%A6/image-20230107120237867.png" alt="image-20230107120237867">
<figcaption aria-hidden="true">image-20230107120237867</figcaption>
</figure>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>经典神经网络学习笔记</title>
    <url>/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/</url>
    <content><![CDATA[<p>写在前面：本文是阅读有三AI博主课程的笔记</p>
<h2 id="alexnet">AlexNet</h2>
<ul>
<li>更深的网络结构</li>
<li>使用卷积层+卷积层+池化层提取图像特征</li>
<li>dropout</li>
<li>数据增强</li>
<li>RELU替换sigmoid</li>
<li>多GPU训练</li>
</ul>
<h3 id="训练技巧">训练技巧</h3>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230106104745510.png" alt="image-20230106104745510">
<figcaption aria-hidden="true">image-20230106104745510</figcaption>
</figure>
<ul>
<li><p>多GPU训练：（与只是用一个GPU想不，top-1和top-5的错误率减少1.7%和1.2%）</p>
<p>使得神经元并行，并使通信限制在了某些网络层。从上图中可以看出，c1,c2层是独立的，c4,c5是独立的，c3层两个GPU有通信</p></li>
</ul>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230106105552881.png" alt="image-20230106105552881">
<figcaption aria-hidden="true">image-20230106105552881</figcaption>
</figure>
<ul>
<li><p>Dropout</p>
<p>随机裁剪一部分神经元，每次裁剪后生成的网络结构都不一样，通过组合多个模型的方式能有效减少过拟合</p></li>
</ul>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230106105847910.png" alt="image-20230106105847910">
<figcaption aria-hidden="true">image-20230106105847910</figcaption>
</figure>
<ul>
<li><p>数据增强</p>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230106110213739.png" alt="image-20230106110213739">
<figcaption aria-hidden="true">image-20230106110213739</figcaption>
</figure></li>
</ul>
<h2 id="vgg">VGG</h2>
<h3 id="小卷积">小卷积</h3>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230106110607663.png" alt="image-20230106110607663">
<figcaption aria-hidden="true">image-20230106110607663</figcaption>
</figure>
<p>3<em>3卷积卷两次得到的图的大小和进行一次5 </em>
5卷积得到的大小一样</p>
<p>使用3*3卷积的优点：</p>
<p>1.网络层数增加因此非线性表达能力更强</p>
<p>2.网络层参数减少 （2 * 3 * 3 =18 5* 5 =25）</p>
<p>VGG16相比AlexNet的一个改进是<strong>采用连续的几个3x3的卷积核代替AlexNet中的较大卷积核（11x11，7x7，5x5）</strong>。对于给定的感受野（与输出有关的输入图片的局部大小），采用堆积的小卷积核是优于采用大的卷积核，因为多层非线性层可以增加网络深度来保证学习更复杂的模式，而且代价还比较小（参数更少）。</p>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230106111526174.png" alt="image-20230106111526174">
<figcaption aria-hidden="true">image-20230106111526174</figcaption>
</figure>
<p>19的性能没有明显的优势</p>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230106112004104.png" alt="image-20230106112004104">
<figcaption aria-hidden="true">image-20230106112004104</figcaption>
</figure>
<h2 id="googlenet">GoogLeNet</h2>
<p>比VGG更深，但是参数量更少</p>
<h3 id="背景">背景</h3>
<h4 id="卷积">1*1卷积</h4>
<p>RGB转灰度</p>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230106112404868.png" alt="image-20230106112404868">
<figcaption aria-hidden="true">image-20230106112404868</figcaption>
</figure>
<p>使用1* 1卷积层可以实现上述转换</p>
<h4 id="卷积的作用">1*1 卷积的作用</h4>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230106112509822.png" alt="image-20230106112509822">
<figcaption aria-hidden="true">image-20230106112509822</figcaption>
</figure>
<p>降维以后可以进行一些计算，降低参数量</p>
<h4 id="卷积实验">1*1 卷积实验</h4>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107103105060.png" alt="image-20230107103105060">
<figcaption aria-hidden="true">image-20230107103105060</figcaption>
</figure>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107103259910.png" alt="image-20230107103259910">
<figcaption aria-hidden="true">image-20230107103259910</figcaption>
</figure>
<p><strong>引入<span class="math inline">\(1\times1\)</span>卷积之后</strong></p>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107103721751.png" alt="image-20230107103721751">
<figcaption aria-hidden="true">image-20230107103721751</figcaption>
</figure>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107104021134.png" alt="image-20230107104021134">
<figcaption aria-hidden="true">image-20230107104021134</figcaption>
</figure>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107104035555.png" alt="image-20230107104035555">
<figcaption aria-hidden="true">image-20230107104035555</figcaption>
</figure>
<h3 id="incption-module">incption Module</h3>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230106113152260.png" alt="image-20230106113152260">
<figcaption aria-hidden="true">image-20230106113152260</figcaption>
</figure>
<p>对于同一张图片，不同尺寸的卷积核的表现效果是不一样的，因为他们的感受野不同。Inception便能够满足这样的需求，一个Inception模块中并列提供多种卷积核的操作，网络在训练的过程中通过调节参数自己去选择使用。</p>
<h2 id="resnet">Resnet</h2>
<h3 id="short-connect">short connect</h3>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107104629763.png" alt="image-20230107104629763">
<figcaption aria-hidden="true">image-20230107104629763</figcaption>
</figure>
<h3 id="残差网络有效性">残差网络有效性</h3>
<ul>
<li>从信号角度</li>
</ul>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107105846052.png" alt="image-20230107105846052">
<figcaption aria-hidden="true">image-20230107105846052</figcaption>
</figure>
<ul>
<li>从集成角度看</li>
</ul>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107110122318.png" alt="image-20230107110122318">
<figcaption aria-hidden="true">image-20230107110122318</figcaption>
</figure>
<p>从模型结构看</p>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107113714388.png" alt="image-20230107113714388">
<figcaption aria-hidden="true">image-20230107113714388</figcaption>
</figure>
<p>如果网络退化则说明参数的矩阵的秩比较低，矩阵行向量之间的线性相关性比较强</p>
<h3 id="densenet">densenet</h3>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107113903794.png" alt="image-20230107113903794">
<figcaption aria-hidden="true">image-20230107113903794</figcaption>
</figure>
<h3 id="cliquenet">cliqueNet</h3>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107113934974.png" alt="image-20230107113934974">
<figcaption aria-hidden="true">image-20230107113934974</figcaption>
</figure>
<h2 id="mobilenet">MobileNet</h2>
<h3 id="v1存在的问题">v1存在的问题</h3>
<p>RELU信息丢失：小于0d=的信息直接丢失了</p>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107121002456.png" alt="image-20230107121002456">
<figcaption aria-hidden="true">image-20230107121002456</figcaption>
</figure>
<h3 id="v2">V2</h3>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107121249695.png" alt="image-20230107121249695">
<figcaption aria-hidden="true">image-20230107121249695</figcaption>
</figure>
<p>反转残差模块</p>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107121449665.png" alt="image-20230107121449665">
<figcaption aria-hidden="true">image-20230107121449665</figcaption>
</figure>
<p>V1 和V2的结构对比</p>
<figure>
<img src="/2023/01/06/AI/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E4%BA%8C/image-20230107121500373.png" alt="image-20230107121500373">
<figcaption aria-hidden="true">image-20230107121500373</figcaption>
</figure>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>HEXO+Next主题配置笔记</title>
    <url>/2023/01/06/hexonote/</url>
    <content><![CDATA[<h2 id="相关环境配置">相关环境配置</h2>
<p>下载最新<a href="http://nodejs.cn/download/">node.js</a>安装，运行<code>node -v</code>和<code>npm -v</code>，显示正常的版本则说明安装完毕。</p>
<h2 id="hexo安装">Hexo安装</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>执行以下命令确认hexo已安装好，该命令会显示hexo的版本及依赖的包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<h2 id="hexo创建及运行博客">Hexo创建及运行博客</h2>
<ul>
<li><p>创建一个空白文件夹blog，作为博客根目录，在该根目录下，执行以下命令初始化博客</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="全文显示配置">全文显示配置</h2>
<p>Hexo 的 Next
主题默认是首页显示你每篇文章的全文内容。想要在网站首页只显示每篇文章的部分内容，不要全部内容都展示出来。</p>
<h3 id="使用npm安装hexo-excerpt">1：使用npm安装hexo-excerpt</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-excerpt --save</span><br></pre></td></tr></table></figure>
<h3 id="打开-themesnext-目录下的-_config.yml-文件找到这段代码">2. 打开
themes/next 目录下的 _config.yml 文件，找到这段代码：</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Automatically excerpt description <span class="keyword">in</span> homepage as preamble text.</span></span><br><span class="line">excerpt_description: true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Read more button</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If <span class="literal">true</span>, the <span class="built_in">read</span> more button will be displayed <span class="keyword">in</span> excerpt section.</span></span><br><span class="line">read_more_btn: true</span><br></pre></td></tr></table></figure>
<p>把<code>false</code>改成<code>true</code>就行了</p>
<h2 id="配置头像">配置头像</h2>
<p>打开 themes/next 目录下的 _config.yml 文件，找到这段代码：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/medias/avatars/baojie.jpg</span> </span><br><span class="line">  <span class="comment"># If true, the avatar will be displayed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>在url处输入地址</p>
<p>注意这里的路径指的是相对于 themes 的路径</p>
<h2 id="latex公式渲染">latex公式渲染</h2>
<p>目前Next提供两种数学公式渲染引擎，分别是Mathjax和Katex。 使用 Mathjax
进行数学公式渲染，需要使用 hexo-renderer-pandoc 或者
hexo-renderer-kramed （官方不推荐）作为 Hexo 的 Markdown 渲染器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked  # 先将原有的渲染器卸载</span><br><span class="line">npm i hexo-renderer-pandoc		# 安装pandoc</span><br></pre></td></tr></table></figure>
<p>修改配置文件在主题配置文件_config.yml 中找到:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="comment"># Default (false) will load mathjax / katex script on demand.</span></span><br><span class="line"><span class="comment"># That is it only render those page which has `mathjax: true` in front-matter.</span></span><br><span class="line"><span class="comment"># If you set it to true, it will load mathjax / katex script EVERY PAGE.</span></span><br><span class="line"><span class="attr">every_page:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">  <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>将mathjax的false改为true。注意，mathjax和katex只能有一个置为true。</p>
<p>注意：every_page选项，默认为false，表示只对文章开头（front-matter）含有mathjax:
true语句的文章进行渲染。为true表示会所有文章进行渲染:</p>
<figure>
<img src="/2023/01/06/hexonote/image-20230107093616507.png" alt="image-20230107093616507">
<figcaption aria-hidden="true">image-20230107093616507</figcaption>
</figure>
<p>本地安装pandoc使用pandoc还需要在本地安装，在官网上下载pandoc，直接安装即可。</p>
<p>安装完后，电脑重启</p>
<p>重启后，hexo clean，hexo g，hexo s就可以看到效果了</p>
<h2 id="hexo建立草稿和发布草稿">hexo建立草稿和发布草稿</h2>
<p>建立新的草稿： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new draft &lt;title&gt;</span><br></pre></td></tr></table></figure></p>
<p>本机预览草稿</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo S --draft</span><br></pre></td></tr></table></figure>
<p>将草稿发布为正式文章</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo P &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<h2 id="hexo-本机预览部署github">hexo 本机预览&amp;部署github</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g == hexo generate #生成</span><br><span class="line">hexo s == hexo server #启动服务预览</span><br><span class="line">hexo d == hexo deploy #部署</span><br><span class="line">hexo clean #清理</span><br></pre></td></tr></table></figure>
<h2 id="hexo-分类多级分类">hexo 分类+多级分类</h2>
<h3 id="打开分类">打开分类</h3>
<p>首先在thems的config文件中取消注释</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br></pre></td></tr></table></figure>
<p>生成“分类”页并添加tpye属性</p>
<p>打开命令行，进入博客所在文件夹。执行命令</p>
<p><code>hexo new page categories</code></p>
<p>找到<code>index.md</code>这个文件，打开后默认内容是这样的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line"><span class="section">date: </span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<p>添加<code>type: "categories"</code>到内容中，添加后是这样的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2023-01-01 11:44:32</span><br><span class="line">type: categories</span><br><span class="line">layout: categories</span><br></pre></td></tr></table></figure>
<h3 id="单级分类">单级分类</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> Hexo 博客</span><br></pre></td></tr></table></figure>
<h3 id="多级分类">多级分类</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories: </span><br><span class="line"><span class="bullet">-</span> [日常小技能,hexo]</span><br></pre></td></tr></table></figure>
<h3 id="父子分类">父子分类</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- 前端</span><br><span class="line">- 笔记</span><br></pre></td></tr></table></figure>
<h2 id="hexo-新建文章">hexo 新建文章</h2>
<p><code>hexo new title</code></p>
<h2 id="hexo图片显示问题">hexo图片显示问题</h2>
<p>图片路径写相对路径，是:<code>./哈工大操作系统实验系统调用\image-20231119230212969.png</code>而不是<code>.\哈工大操作系统实验系统调用\image-20231119230212969.png</code>虽然在windows下都可以，但是好像后者显示在网页上就生成不出来</p>
]]></content>
      <categories>
        <category>日常小技能</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Rt-Thread 和STM32F103的温湿度采集系统设计</title>
    <url>/2022/01/13/STM32F103%E7%9A%84%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>写在前面： 入门RT-Thread的课设作业，自娱自乐，hhh</p>
<p>## RT-Thread内核移植</p>
<p>详细的工程模板建立步骤参见野火的说明文档： <a href="https://doc.embedfire.com/rtos/rtthread/zh/latest/application/porting_to_stm32.html">https://doc.embedfire.com/rtos/rtthread/zh/latest/application/porting_to_stm32.html</a>
这里只是用了裁剪后的RT-Thread内核，我们可以rtconfig.h文件里面配置相关的参数，比如我们的工程里面用到了动态的内存分配，消息队列等需要在里面定义相关的宏，打开相应的功能：
<img src="/2022/01/13/STM32F103%E7%9A%84%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1.png" alt="在这里插入图片描述"></p>
<h1 id="工程程序实现">工程程序实现</h1>
<p>## 系统功能组成</p>
<p>系统涉及到的硬件由以下几部分组成：</p>
<p>1.交互输入部分：按键</p>
<ol start="2" type="1">
<li>输出部分：TFTLCD屏幕显示，SD卡存储，led灯报警</li>
<li>传感器采集：DHT11温湿度采集</li>
<li>通讯部分：串口，wifi模块</li>
<li>计时部分：RTC时钟计时 系统框图：<img src="/2022/01/13/STM32F103%E7%9A%84%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/2.png" alt="系统框图"></li>
</ol>
<h2 id="系统软件设计">系统软件设计</h2>
<p>软件程序结构： <img src="/2022/01/13/STM32F103%E7%9A%84%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/3.png" alt="软件程序结构"></p>
<p>其中在定时器超函数中周期性采集温湿度信息，并发送消息队列到处理缓存传感器信息的线程，和超温处理线程，同时发布采集到一次传感器的事件。超温处理线程接收消息判断是否超过温度，wifi模块通过串口2将温湿度信息发送给wifi模块，由wifi模块实时上传到服务器。同时串口温度上传任务同时接收定时器发送的事件和PC机通过串口1发送的获取温度标志所触发的事件。当采集到传感器信息且上位机要求获取温湿度信息的事情同时发生时，通过串口1向PC发送温湿度信息。由于SD卡存储缓慢，所以由温湿度信息缓存线程在内存池中申请内存，并将获取到的温湿度信息缓存到内存中，同时更新LCD曲线绘制的历史温湿度信息缓存。LCD处理线程处理IO口中断发送过来的标志信息，并据此显示相应的菜单，温度湿度信息，显示所设定采样频率与阈值的情况等。SD卡存储任务作为后台任务，从缓存存储温湿度信息的内存中读取温湿度信息，并通过FATFS文件系统将相应的温湿度信息存入SD卡，同时根据每片内存的头部时间信息以及定时器采样频率推算本片内存中其他数据的时间信息，并将采样时间一起保存到SD卡中。在存储完一片内存片后，释放该内存到内存池之中。流程图如下所示：
<img src="/2022/01/13/STM32F103%E7%9A%84%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/4.png" alt="流程图"></p>
<h2 id="部分工程效果展示">部分工程效果展示</h2>
<p>主菜单显示：
主菜单分为5个功能：1.温度阈值设定2.湿度阈值设定3.采样频率设定
4.温湿度曲线显示 5.温湿度实时数值显示 <img src="/2022/01/13/STM32F103%E7%9A%84%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/5.png" alt="功能展示">
温湿度，采样频率设定：</p>
<p><img src="/2022/01/13/STM32F103%E7%9A%84%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/6.png" alt="采样频率设定"> 温湿度曲线：
其中实时的温湿度用黑线表示，红线是当前设定的温湿度阈值 <img src="/2022/01/13/STM32F103%E7%9A%84%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/7.png" alt="温湿度曲线">
在原子云端查看wifi发送的信息： <img src="/2022/01/13/STM32F103%E7%9A%84%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/8ec580d03f214153b2118b8392a57c0b.png" alt="在这里插入图片描述"> SD卡csv温湿度信息文件存储效果： <img src="/2022/01/13/STM32F103%E7%9A%84%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/8.png" alt="文件存储效果"></p>
<h2 id="工程源代码获取">工程源代码获取</h2>
<p>源代码可以访问下面的链接在github上获取，本人还是小白，工程还不完善，欢迎提交修改！！！
<a href="https://github.com/sherecho/Rt-Thread-STM32F103ZET6-emperature-and-humidity-acquisition-system">https://github.com/sherecho/Rt-Thread-STM32F103ZET6-emperature-and-humidity-acquisition-system</a>.</p>
]]></content>
      <categories>
        <category>通信嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>单片机</tag>
        <tag>RTOS</tag>
      </tags>
  </entry>
</search>
