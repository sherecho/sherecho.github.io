<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">


<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"sherecho.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="linux 0.11 文件系统总结 文件系统 详见：操作系统文件系统。 操作系统中的文件系统可以分为两部分：操作系统内核中或者在硬盘软盘虚拟盘中。一个物理设备可以分为多个逻辑设备，比如一个物理硬盘可以分为多个逻辑硬盘。而一个逻辑设备只有一个文件系统，一个文件系统只包含一个i结点的树结构。一个逻辑设备只能有一个根i结点。   image-20231203234247319  未安装文">
<meta property="og:type" content="article">
<meta property="og:title" content="linux 0.11 文件系统总结">
<meta property="og:url" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="sherecho的个人博客">
<meta property="og:description" content="linux 0.11 文件系统总结 文件系统 详见：操作系统文件系统。 操作系统中的文件系统可以分为两部分：操作系统内核中或者在硬盘软盘虚拟盘中。一个物理设备可以分为多个逻辑设备，比如一个物理硬盘可以分为多个逻辑硬盘。而一个逻辑设备只有一个文件系统，一个文件系统只包含一个i结点的树结构。一个逻辑设备只能有一个根i结点。   image-20231203234247319  未安装文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203234247319.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203233251707.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211195002220.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205203527644.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205203724496.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205204603044.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203234309406.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203234655944.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203232737245.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205210257879.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/文件系统.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205214503609.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205200445043.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215101438019.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215101527658.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205221522997.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211092132558.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/readsuper.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211095203241.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211100257070.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211102021214.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211131847124.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/文件系统加载示意图.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211225204563.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/open文件流程.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/default.jpg">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211233150934.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/findentry.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/iget.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231212095622262.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/新建文件inode.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215154349111.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/bmap0.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/bmap1.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/new_block.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215212431360.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215235324252.png">
<meta property="og:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215214155373.png">
<meta property="article:published_time" content="2023-12-11T16:28:24.000Z">
<meta property="article:modified_time" content="2024-01-23T15:26:42.980Z">
<meta property="article:author" content="sherecho">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203234247319.png">


<link rel="canonical" href="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/","path":"2023/12/12/Linux011内核学习笔记/linux 0.11 文件系统总结/","title":"linux 0.11 文件系统总结"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>linux 0.11 文件系统总结 | sherecho的个人博客</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>



<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">sherecho的个人博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">弱小和无知不是生存的障碍，傲慢才是</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#linux-0.11-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93"><span class="nav-number">1.</span> <span class="nav-text">linux 0.11 文件系统总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.1.</span> <span class="nav-text">文件系统树形结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">加载文件过程举例：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5c%E8%AF%AD%E8%A8%80open%E5%92%8Cclose%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E8%A7%A3%E9%87%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">以c语言open和close返回的是什么解释文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#i%E7%BB%93%E7%82%B9%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E7%9A%84"><span class="nav-number">1.1.4.</span> <span class="nav-text">i结点是如何管理文件的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.2.</span> <span class="nav-text">根文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%8D%A2%E6%A0%B9%E8%AE%BE%E5%A4%87%E8%BF%9B%E7%A8%8B1%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%99%9A%E6%8B%9F%E7%9B%98%E5%B9%B6%E6%9B%B4%E6%8D%A2%E8%B7%9F%E8%AE%BE%E5%A4%87%E4%B8%BA%E8%99%9A%E6%8B%9F%E7%9B%98"><span class="nav-number">1.2.1.</span> <span class="nav-text">更换根设备（进程1格式化虚拟盘并更换跟设备为虚拟盘）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">加载根文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A6%96%E5%85%88%E6%8C%82%E8%BD%BDsuper_block%E6%95%B0%E7%BB%84%E5%92%8Cfile_table%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.3.</span> <span class="nav-text">首先挂载super_block数组和file_table数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read_super%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B6%85%E7%BA%A7%E5%9D%97"><span class="nav-number">1.2.4.</span> <span class="nav-text">read_super加载文件系统超级块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#get_super"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">get_super</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8super_block%E9%87%8C%E9%9D%A2%E6%89%BE%E5%88%B0%E7%A9%BA%E9%A1%B9"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">在super_block里面找到空项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%8A%E8%B6%85%E7%BA%A7%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%88%B0%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%8D%E5%8A%A0%E8%BD%BD%E5%88%B0super-block"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">把超级块加载到缓冲区，再加载到super
block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%96%84super-blok%E4%B8%ADi%E7%BB%93%E7%82%B9%E4%BD%8D%E5%9B%BE%E9%80%BB%E8%BE%91%E4%BD%8D%E5%9B%BE"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">完善super
blok中i结点位图逻辑位图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%A0%B9%E8%AE%BE%E5%A4%87%E7%9A%84%E6%A0%B9i%E7%BB%93%E7%82%B9%E6%8C%82%E8%BD%BDsuper-block%E4%B8%8A"><span class="nav-number">1.2.5.</span> <span class="nav-text">将根设备的根i结点挂载super
block上</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#igetget_empty_inode"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">iget:get_empty_inode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iget"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">iget</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read_inode"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">read_inode</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BF%9B%E7%A8%8B1%E5%85%B3%E8%81%94%E8%AE%BE%E7%BD%AEroot%E5%92%8Cpwd"><span class="nav-number">1.2.6.</span> <span class="nav-text">将根文件系统与进程1关联，设置root和pwd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E8%99%9A%E6%8B%9F%E7%9B%98%E7%A9%BA%E9%97%B2%E5%9D%97%E4%BF%A1%E6%81%AF"><span class="nav-number">1.2.7.</span> <span class="nav-text">计算虚拟盘空闲块信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E9%80%9A%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.</span> <span class="nav-text">更通用的安装文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sys_mount"><span class="nav-number">1.3.1.</span> <span class="nav-text">sys_mount</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="nav-number">1.4.</span> <span class="nav-text">打开文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sys_open"><span class="nav-number">1.4.1.</span> <span class="nav-text">sys_open</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E8%BF%9B%E7%A8%8B%E7%9A%84filp%E5%92%8Cfile_table%E6%8C%82%E6%8E%A5"><span class="nav-number">1.4.2.</span> <span class="nav-text">将进程的*filp和file_table挂接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84i%E7%BB%93%E7%82%B9opennamei"><span class="nav-number">1.4.3.</span> <span class="nav-text">获取文件的i结点：opennamei</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dir_namei"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">dir_namei</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#get_dir"><span class="nav-number">1.4.3.1.1.</span> <span class="nav-text">get_dir</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#find_entry"><span class="nav-number">1.4.3.1.2.</span> <span class="nav-text">find_entry</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#iget-1"><span class="nav-number">1.4.3.1.3.</span> <span class="nav-text">iget</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9Edir_namei"><span class="nav-number">1.4.3.1.4.</span> <span class="nav-text">返回dir_namei</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#opennamei%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6i%E8%8A%82%E7%82%B9"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">opennamei:获取目标文件i节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E6%96%87%E4%BB%B6i%E7%BB%93%E7%82%B9%E4%B8%8Efile_table64%E6%8C%82%E6%8E%A5"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">将文件i结点与file_table[64]挂接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#namei"><span class="nav-number">1.4.4.</span> <span class="nav-text">namei</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-number">1.5.</span> <span class="nav-text">读文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sys_read"><span class="nav-number">1.5.1.</span> <span class="nav-text">sys_read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#file_read"><span class="nav-number">1.5.2.</span> <span class="nav-text">file_read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bmap"><span class="nav-number">1.5.3.</span> <span class="nav-text">_bmap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="nav-number">1.6.</span> <span class="nav-text">新建文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new_inode"><span class="nav-number">1.6.1.</span> <span class="nav-text">new_inode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#add_entry"><span class="nav-number">1.6.2.</span> <span class="nav-text">add_entry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bmap-1"><span class="nav-number">1.6.3.</span> <span class="nav-text">_bmap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E7%B4%A2%E5%BC%95%E9%83%A8%E5%88%86-block7"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">直接索引部分 （block&lt;7)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BA%A7%E7%B4%A2%E5%BC%95%E9%83%A8%E5%88%86"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">一级索引部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E9%83%A8%E5%88%86"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">二级索引部分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-block"><span class="nav-number">1.6.4.</span> <span class="nav-text">new block</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">1.7.</span> <span class="nav-text">写文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="nav-number">1.8.</span> <span class="nav-text">关闭文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="nav-number">1.9.</span> <span class="nav-text">删除文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#i_nlinks"><span class="nav-number">1.9.1.</span> <span class="nav-text">i_nlinks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys_unlink"><span class="nav-number">1.9.2.</span> <span class="nav-text">sys_unlink</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#truncate"><span class="nav-number">1.9.3.</span> <span class="nav-text">truncate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free_inode"><span class="nav-number">1.9.4.</span> <span class="nav-text">free_inode</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sherecho"
      src="/medias/avatars/baojie.jpg">
  <p class="site-author-name" itemprop="name">sherecho</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/sherecho" title="Github → https:&#x2F;&#x2F;github.com&#x2F;sherecho" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>Github</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_45934869/" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_45934869&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-user fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sherecho.cn/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/medias/avatars/baojie.jpg">
      <meta itemprop="name" content="sherecho">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sherecho的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="linux 0.11 文件系统总结 | sherecho的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux 0.11 文件系统总结
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-12 00:28:24" itemprop="dateCreated datePublished" datetime="2023-12-12T00:28:24+08:00">2023-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-23 23:26:42" itemprop="dateModified" datetime="2024-01-23T23:26:42+08:00">2024-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/LINUX011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">LINUX011内核学习笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>42k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>38 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="linux-0.11-文件系统总结">linux 0.11 文件系统总结</h1>
<h2 id="文件系统">文件系统</h2>
<p>详见：操作系统文件系统。</p>
<p>操作系统中的文件系统可以分为两部分：操作系统内核中或者在硬盘软盘虚拟盘中。一个物理设备可以分为多个逻辑设备，比如一个物理硬盘可以分为多个逻辑硬盘。而一个逻辑设备只有一个文件系统，一个文件系统只包含一个i结点的树结构。一个逻辑设备只能有一个根i结点。</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203234247319.png" alt="image-20231203234247319">
<figcaption aria-hidden="true">image-20231203234247319</figcaption>
</figure>
<p>未安装文件系统的磁盘称之为生磁盘，生磁盘也可以作为文件读写，linux中一切皆文件。</p>
<p>生磁盘可以被分区，分区中可以安装文件系统，常见的文件系统有fat32、ext2、ext4等。</p>
<p>MINIX 文件系统与标准 UNIX 的文件系统基本相同。它由 6
个部分组成。分区内可以安装指定文件系统，同一磁盘多个分区文件系统不要求相同。MINIX文件系统布局如下：(下述部分是在磁盘上的)</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203233251707.png" alt="MINIX文件系统布局">
<figcaption aria-hidden="true">MINIX文件系统布局</figcaption>
</figure>
<ul>
<li><p>引导块：若作为引导分区，将存放<strong>操作系统的引导程序代码</strong>，否则空置。</p></li>
<li><p>超级块：用于存放磁盘设备上<strong>文件系统结构的信息</strong>，说明各部分的大小。</p></li>
<li><p>i节点位图：标记i节点数据元素是否被使用</p></li>
<li><p>逻辑块位图：标记磁盘数据块是否被使用</p></li>
<li><p>i节点区：用于存放inode节点数据，一个文件对应一个inode节点，inode节点存储文件属性数据。</p></li>
<li><p>数据区：以固定大小盘块（1k）为单位进行动态分配和回收，用于存储数据，类似内存分页。</p>
<p>位图：一个比特对应一个逻辑块，0，1代表是否被占用</p>
<p>删除文件：清理数据块关系清掉，对应逻辑块位图清0，清理i结点和i结点对应位图。</p>
<p>如果一个物理块有多个逻辑块，上述就罗列着摆放：</p>
<p><img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211195002220.png" alt="image-20231211195002220" style="zoom:67%;"></p>
<p><strong>超级块结构：</strong></p></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_ninodes;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_nzones;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_imap_blocks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_zmap_blocks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_firstdatazone;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_log_zone_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_max_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_magic;</span><br><span class="line"><span class="comment">/* These are only in memory */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_imap</span>[8];</span><span class="comment">//位图信息存到了缓冲块里面</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_zmap</span>[8];</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_isup</span>;</span><span class="comment">//文件系统的根i结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_imount</span>;</span><span class="comment">//文件系统挂载到的结点</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_time;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">s_wait</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> s_lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> s_rd_only;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> s_dirt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205203527644.png" alt="超级块结构">
<figcaption aria-hidden="true">超级块结构</figcaption>
</figure>
<p><strong>inode结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_uid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_mtime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_gid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_nlinks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_zone[<span class="number">9</span>];</span><br><span class="line"><span class="comment">/* these are in memory also */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">i_wait</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_atime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_ctime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_dev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_num;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_dirt;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_pipe;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_mount;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_seek;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_update;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205203724496.png" alt="inode结构">
<figcaption aria-hidden="true">inode结构</figcaption>
</figure>
<p><strong>i_zone数组</strong></p>
<p><code>unsigned short i_zone[9];</code></p>
<p>i_zone数组包含直接盘块号、一次间接盘块号和二次间接盘块号。一次盘块号可视为单级页表，一次间接盘块号可视为二级页表、二次间接盘块号可视为三级页表。</p>
<p>这种处理方式的好处在于，对于小文件，通过直接块号可快速定位数据块；对于中等类型的文件，一次间接块可以维护较多数据块的同时，具有较快的访问速度；对于大型文件，二次间接盘块号可以维护大量磁盘块，但访问速度较慢。</p>
<p>内存多级页表与i_zone直接区别：不同进程具有固定大小的虚地址空间，并且对其整个虚地址空间的内存，都有可能访问到，因此使用多级页表。文件系统内存在很多大小不一的文件，综合考虑对不同大小文件的特点，使用1-3级磁盘块表可以分别处理小、中、大文件。</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205204603044.png" alt="izone">
<figcaption aria-hidden="true">izone</figcaption>
</figure>
<h3 id="文件系统树形结构">文件系统树形结构</h3>
<p>所有文件的i结点最终会挂成一个树形结构，树根i结点就是文件系统的根i结点，</p>
<p>加载文件系统就是把一个文件系统的根i结点挂接在另一个文件系统的i结点上，按照这个设计，一个文件系统必须要挂在另一个文件系统上面，最后最根部那个文件系统就是根文件系统</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203234309406.png" alt="加载根文件系统">
<figcaption aria-hidden="true">加载根文件系统</figcaption>
</figure>
<p>根文件系统挂在super_block[8]上。超级块：有一个超级块数组super_block[8]里面每一个元素是一个超级块，只要一个文件系统加载到内核了这个文件系统的根i结点会依次加载到这个数组里面。最多加载8个文件系统</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203234655944.png" alt="总体效果图">
<figcaption aria-hidden="true">总体效果图</figcaption>
</figure>
<p>文件系统用i结点来管理，一个i结点管理一个文件，目录文件也是文件，也有i结点来管理。</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231203232737245.png" alt="文件系统与i结点">
<figcaption aria-hidden="true">文件系统与i结点</figcaption>
</figure>
<h3 id="加载文件过程举例"><strong>加载文件过程举例</strong>：</h3>
<p>通过文件inode节点，可以定位文件数据块，那如何通过文件路径定位到具体文件？</p>
<p>文件系统主要包含文件和目录两种文件，目录是一种特殊的文件，其文件内容存储其目录下文件名-&gt;inode节点号的映射信息。文件查找开始于根目录，根目录号固定为0，不需要查找即可直接打开。</p>
<p>举例说明文件查找过程，给定存在路径<code>/name1/name2/name3</code>查找具体文件过程：</p>
<p>1）通过根节点inode号，打开根目录，读取其文件内容，即目录下文件名-&gt;inode节点号映射表，找到name1目录inode节点号n1</p>
<p>2）通过name1的inode号n1，打开name1目录，读取其文件内容，即目录下文件名-&gt;inode节点号映射表，找到name1目录inode节点号n2</p>
<p>3）通过name2的inode号n2，打开name2目录，读取其文件内容，即目录下文件名-&gt;inode节点号映射表，找到name3目录inode节点号n3</p>
<p>4）通过name3的inode号n3，打开name3文件</p>
<p>怎么打开文件：</p>
<p>通过文件查找找到文件inode节点号，然后打开文件，即读取inode至内存。</p>
<p>定位数据块：通过文件inode节点，访问其i_zone数组，进一步可以定位具体的数据所在磁盘块号。</p>
<p><img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205210257879.png"></p>
<h3 id="以c语言open和close返回的是什么解释文件系统">以c语言open和close返回的是什么解释文件系统</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file_table</span>[<span class="title">NR_FILE</span>];</span><span class="comment">//20</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> <span class="title">super_block</span>[<span class="title">NR_SUPER</span>];</span><span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">f_inode</span>;</span></span><br><span class="line">	<span class="type">off_t</span> f_pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>操作系统只有一个super_blocks数组，每个数组元素是一个超级块，一个超级块管理一个逻辑设备，因此最多挂载8个逻辑设备，其中只有一个根设备。</p></li>
<li><p>inode_table[32]每一个元素就是一个i结点，是在操作系统中所有打开的i结点</p></li>
<li><p>file_table
里面装了file结构体，<code>struct super_block super_block[NR_SUPER]</code></p></li>
</ul>
<p>​ f_inode指针指向inode_table里面的元素</p>
<ul>
<li>task struct里面的filp <code>struct file * filp[NR_OPEN];/</code>：
指针数组，每个元素都是file类型的指针</li>
</ul>
<p>linux
0.11一个进程最多只能打开20个文件（文件是可以重复打开的）可以同一个文件占多个file_table的表项</p>
<p>filp归进程管。进程打开一个文件，首先在filp里面找空闲项，
将这个空闲的位置指向file_table其中的一项，这一项里面的f_inode指针指向inode_table。
c语言里面打开文件返回的句柄就是这个指向的inode_table位置对应的下标索引，例如下图就是0.打开文件就是建立这个指针链接的过程，对应的close文件就是把这个关系链断掉。</p>
<p>file对应的是用户的需求，inode对应的是内核管理</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/文件系统.png" alt="文件系统">
<figcaption aria-hidden="true">文件系统</figcaption>
</figure>
<p>打开同一个文件，指向的inode_table是一个，file_table新开了一个</p>
<p>==file_table【64】是整个kernel只有一个，file_table[32]也是整个操作系统只有一个，每个元素是一个file对象==</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205214503609.png" alt="打开同一个文件">
<figcaption aria-hidden="true">打开同一个文件</figcaption>
</figure>
<p>目录跟结点也要放到inode——table，当路径找完了就把结点pop了</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205200445043.png" alt="image-20231205200445043">
<figcaption aria-hidden="true">image-20231205200445043</figcaption>
</figure>
<h3 id="i结点是如何管理文件的">i结点是如何管理文件的</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_zone[<span class="number">9</span>];</span><br><span class="line">     ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215101438019.png" alt="izone">
<figcaption aria-hidden="true">izone</figcaption>
</figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215101527658.png" alt="izone">
<figcaption aria-hidden="true">izone</figcaption>
</figure>
<p>izone数组是unsigned
short类型，两个字节。前7个是直接的指向7个块。一级间接块大小1k个字节，包含了1k/2
个unsigned short索引</p>
<p>可以指向512个块，二级索引同理。有512*512个数据块。</p>
<p>因此一个inode管理的极限是：（7+512+512*512）KB</p>
<h2 id="根文件系统">根文件系统</h2>
<h3 id="更换根设备进程1格式化虚拟盘并更换跟设备为虚拟盘">更换根设备（进程1格式化虚拟盘并更换跟设备为虚拟盘）</h3>
<p>之前第二章设置了虚拟盘并初始化，但是当时没有进行格式化还不能作为块设备使用。格式化的信息存在boot操作系统的软盘上</p>
<p>进程1调用<code>rd_load();</code>函数格式化虚拟盘调用</p>
<p>rd_load()是虚拟盘根文件加载函数。在系统初始化阶段，该函数被用于尝试从启动引导盘
上指定的磁盘块位置开始处把一个根文件系统加载到虚拟盘中。在函数中，这个起始磁盘块位置被定为256。当然你也可以根据自己的具体要求修改这个值，只要保证这个值所规定的磁盘容量能容纳内核映象
文件即可。这样一个由内核引导映象文件（Bootimage）加上根文件系统映象文件（Rootiamge）组合而
成的“二合一”磁盘，就可以象启动 DOS 系统盘那样来启动 Linux
系统。在进行正常的根文件系统加载之前，系统会首先执行
rd_load()函数，试图从磁盘的第 257 块中读取
根文件系统超级块。若成功，就把该根文件映象文件读到内存虚拟盘中，并把根文件系统设备标志</p>
<p>ROOT_DEV 设置为虚拟盘设备（0x0101），否则退出
rd_load()，系统继续从别的设备上执行根文件加载 操作。
之前根设备是软盘：bootsect.s里面指定的</p>
<p>==把虚拟盘指定为根设备，读硬盘是有中断的。软盘因为比较快就在内存里。所以读软盘不用中断读软盘要用do_rd_request==</p>
<p>==rd虚拟盘，虚拟的是软盘==，相当于把软盘的内容映射过来，然后把虚拟盘替软盘成为根设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rd_load</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>	<span class="title">s</span>;</span></span><br><span class="line">	<span class="type">int</span>		block = <span class="number">256</span>;	<span class="comment">/* Start at block 256 */</span></span><br><span class="line">	<span class="type">int</span>		i = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span>		nblocks;</span><br><span class="line">	<span class="type">char</span>		*cp;		<span class="comment">/* Move pointer */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!rd_length)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	printk(<span class="string">&quot;Ram disk: %d bytes, starting at 0x%x\n&quot;</span>, rd_length,</span><br><span class="line">		(<span class="type">int</span>) rd_start);</span><br><span class="line">	<span class="keyword">if</span> (MAJOR(ROOT_DEV) != <span class="number">2</span>)<span class="comment">//判断是不是软盘</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//block：引导块，block+1超级块//见上面文件系统的格式图</span></span><br><span class="line">	bh = breada(ROOT_DEV,block+<span class="number">1</span>,block,block+<span class="number">2</span>,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Disk error while looking for ramdisk!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*((<span class="keyword">struct</span> d_super_block *) &amp;s) = *((<span class="keyword">struct</span> d_super_block *) bh-&gt;b_data);</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="comment">//判断文件系统是不是minux文件系统</span></span><br><span class="line">	<span class="keyword">if</span> (s.s_magic != SUPER_MAGIC)</span><br><span class="line">		<span class="comment">/* No ram disk image present, assume normal floppy boot */</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	nblocks = s.s_nzones &lt;&lt; s.s_log_zone_size;</span><br><span class="line">	<span class="keyword">if</span> (nblocks &gt; (rd_length &gt;&gt; BLOCK_SIZE_BITS)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Ram disk image too big!  (%d blocks, %d avail)\n&quot;</span>, </span><br><span class="line">			nblocks, rd_length &gt;&gt; BLOCK_SIZE_BITS);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;Loading %d bytes into ram disk... 0000k&quot;</span>, </span><br><span class="line">		nblocks &lt;&lt; BLOCK_SIZE_BITS);</span><br><span class="line">	cp = rd_start;</span><br><span class="line">	<span class="keyword">while</span> (nblocks) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nblocks &gt; <span class="number">2</span>) </span><br><span class="line">			bh = breada(ROOT_DEV, block, block+<span class="number">1</span>, block+<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			bh = bread(ROOT_DEV, block);</span><br><span class="line">		<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">			printk(<span class="string">&quot;I/O error on block %d, aborting load\n&quot;</span>, </span><br><span class="line">				block);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		(<span class="type">void</span>) <span class="built_in">memcpy</span>(cp, bh-&gt;b_data, BLOCK_SIZE);</span><br><span class="line">		brelse(bh);</span><br><span class="line">		printk(<span class="string">&quot;\010\010\010\010\010%4dk&quot;</span>,i);</span><br><span class="line">		cp += BLOCK_SIZE;</span><br><span class="line">		block++;</span><br><span class="line">		nblocks--;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;\010\010\010\010\010done \n&quot;</span>);</span><br><span class="line">	ROOT_DEV=<span class="number">0x0101</span>;<span class="comment">//主设备号换为100:虚拟盘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加载根文件系统">加载根文件系统</h3>
<p>进程1调用mount_root在根设备虚拟盘上加载根文件系统</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_isup</span>;</span><span class="comment">//文件系统的根i结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_imount</span>;</span><span class="comment">//文件系统挂载到的结点</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231205221522997.png" alt="文件系统加载结点">
<figcaption aria-hidden="true">文件系统加载结点</figcaption>
</figure>
<h3 id="首先挂载super_block数组和file_table数组">首先挂载super_block数组和file_table数组</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,<span class="built_in">free</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">mi</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">32</span> != <span class="keyword">sizeof</span> (<span class="keyword">struct</span> d_inode))</span><br><span class="line">		panic(<span class="string">&quot;bad i-node size&quot;</span>);</span><br><span class="line">	<span class="comment">//file_table初始化引用计数清0</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NR_FILE;i++)</span><br><span class="line">		file_table[i].f_count=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//判断是否为软盘</span></span><br><span class="line">	<span class="keyword">if</span> (MAJOR(ROOT_DEV) == <span class="number">2</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Insert root floppy and press ENTER&quot;</span>);</span><br><span class="line">		wait_for_keypress();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化super_block</span></span><br><span class="line">	<span class="keyword">for</span>(p = &amp;super_block[<span class="number">0</span>] ; p &lt; &amp;super_block[NR_SUPER] ; p++) &#123;</span><br><span class="line">		p-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">		p-&gt;s_lock = <span class="number">0</span>;</span><br><span class="line">		p-&gt;s_wait = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211092132558.png" alt="image-20231211092132558">
<figcaption aria-hidden="true">image-20231211092132558</figcaption>
</figure>
<h3 id="read_super加载文件系统超级块">read_super加载文件系统超级块</h3>
<p>整体流程图：</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/readsuper.png" alt="readsuper">
<figcaption aria-hidden="true">readsuper</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (!(p=read_super(ROOT_DEV)))</span><br><span class="line">		panic(<span class="string">&quot;Unable to mount root&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>read_super()用于把指定设备的文件系统的==超级块==读入到==缓冲区==中，并登记到超级块数组中，同时也
把文件系统的 i
节点位图和逻辑块位图读入内存超级块结构的相应数组中。最后并返回该超级块结构的
指针。</p>
<p>首先检查这个要读的超级块是不是已经在super_block[8]中，如果有直接使用不用在加载一次了（和缓冲区看有没有现成的一个意思）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">s</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">int</span> i,block;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	check_disk_change(dev);<span class="comment">//检查是否换过盘</span></span><br><span class="line">	<span class="keyword">if</span> (s = get_super(dev))</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="get_super">get_super</h4>
<p>查这个要读的超级块是不是已经在super_block[8]中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> super_block * <span class="title function_">get_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	s = <span class="number">0</span>+super_block;</span><br><span class="line">	<span class="keyword">while</span> (s &lt; NR_SUPER+super_block)</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;s_dev == dev) &#123;</span><br><span class="line">			wait_on_super(s);</span><br><span class="line">			<span class="keyword">if</span> (s-&gt;s_dev == dev)</span><br><span class="line">				<span class="keyword">return</span> s;</span><br><span class="line">			s = <span class="number">0</span>+super_block;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			s++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超级块上锁等待（别的进程加载了这个文件系统）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wait_on_super</span><span class="params">(<span class="keyword">struct</span> super_block * sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	cli();</span><br><span class="line">	<span class="keyword">while</span> (sb-&gt;s_lock)</span><br><span class="line">		sleep_on(&amp;(sb-&gt;s_wait));</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="在super_block里面找到空项">在super_block里面找到空项</h4>
<p>在super_block中找到一项空的并加锁。这里加载根文件系统，第一项就是空的所以是选了第一个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> (s = <span class="number">0</span>+super_block ;; s++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s &gt;= NR_SUPER+super_block)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (!s-&gt;s_dev)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;s_dev = dev;</span><br><span class="line">	s-&gt;s_isup = <span class="literal">NULL</span>;</span><br><span class="line">	s-&gt;s_imount = <span class="literal">NULL</span>;</span><br><span class="line">	s-&gt;s_time = <span class="number">0</span>;</span><br><span class="line">	s-&gt;s_rd_only = <span class="number">0</span>;</span><br><span class="line">	s-&gt;s_dirt = <span class="number">0</span>;</span><br><span class="line">	lock_super(s);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211095203241.png" alt="image-20231211095203241">
<figcaption aria-hidden="true">image-20231211095203241</figcaption>
</figure>
<h4 id="把超级块加载到缓冲区再加载到super-block">把超级块加载到缓冲区，再加载到super
block</h4>
<p>调用bread读取超级块，这里的设备是rd虚拟盘。块号是1.因此在do
request的时候是do_rd_request.虚拟盘虽然是内存模拟的盘，但是读取的操作完全模仿了外设，但是他毕竟是内存不是外设，因此和读硬盘不同的是：不会发生类似硬盘中断的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (!(bh = bread(dev,<span class="number">1</span>))) &#123;</span><br><span class="line">		s-&gt;s_dev=<span class="number">0</span>;</span><br><span class="line">		free_super(s);<span class="comment">//释放超级块</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//将缓冲区的超级块复制到刚才找到的super_block【0】中</span></span><br><span class="line">	*((<span class="keyword">struct</span> d_super_block *) s) =</span><br><span class="line">		*((<span class="keyword">struct</span> d_super_block *) bh-&gt;b_data);</span><br><span class="line">	brelse(bh);<span class="comment">//释放缓冲块</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;s_magic != SUPER_MAGIC) &#123;</span><br><span class="line">		s-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">		free_super(s);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211100257070.png" alt="image-20231211100257070">
<figcaption aria-hidden="true">image-20231211100257070</figcaption>
</figure>
<h4 id="完善super-blok中i结点位图逻辑位图">完善super
blok中i结点位图逻辑位图</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">//首先初始化imap和zmap</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;I_MAP_SLOTS;i++)</span><br><span class="line">		s-&gt;s_imap[i] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;Z_MAP_SLOTS;i++)</span><br><span class="line">		s-&gt;s_zmap[i] = <span class="literal">NULL</span>;</span><br><span class="line">	block=<span class="number">2</span>;<span class="comment">//虚拟盘的第一块是超级块，第二块开始是i结点位图和逻辑块位图所以这里是2</span></span><br><span class="line">    <span class="comment">//把虚拟盘上的逻辑位图加载到缓冲区中，并都挂载到s_imap上</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; s-&gt;s_imap_blocks ; i++)</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;s_imap[i]=bread(dev,block))</span><br><span class="line">			block++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//挂完i结点的位图挂载逻辑块位图</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; s-&gt;s_zmap_blocks ; i++)</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;s_zmap[i]=bread(dev,block))</span><br><span class="line">			block++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//如果块数量不对说明操作系统出问题了释放之前的缓冲块和超级块</span></span><br><span class="line">	<span class="keyword">if</span> (block != <span class="number">2</span>+s-&gt;s_imap_blocks+s-&gt;s_zmap_blocks) &#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;I_MAP_SLOTS;i++)</span><br><span class="line">			brelse(s-&gt;s_imap[i]);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Z_MAP_SLOTS;i++)</span><br><span class="line">			brelse(s-&gt;s_zmap[i]);</span><br><span class="line">		s-&gt;s_dev=<span class="number">0</span>;</span><br><span class="line">		free_super(s);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//牺牲第一个i结点，防止查找算法返回0</span></span><br><span class="line">	s-&gt;s_imap[<span class="number">0</span>]-&gt;b_data[<span class="number">0</span>] |= <span class="number">1</span>;</span><br><span class="line">	s-&gt;s_zmap[<span class="number">0</span>]-&gt;b_data[<span class="number">0</span>] |= <span class="number">1</span>;</span><br><span class="line">	free_super(s);<span class="comment">//解锁超级块</span></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_super</span><span class="params">(<span class="keyword">struct</span> super_block * sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	cli();</span><br><span class="line">	sb-&gt;s_lock = <span class="number">0</span>;</span><br><span class="line">	wake_up(&amp;(sb-&gt;s_wait));</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211102021214.png" alt="image-20231211102021214">
<figcaption aria-hidden="true">image-20231211102021214</figcaption>
</figure>
<h3 id="将根设备的根i结点挂载super-block上">将根设备的根i结点挂载super
block上</h3>
<p>调用iget从虚拟盘上读取i结点。有了i结点，可以通过根i结点找到文件系统中的任意指定i结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">	<span class="comment">//i number ：i结点位图的序号，iget：给定结点，给定设备，这里在找虚拟盘的根i结点</span></span><br><span class="line">	<span class="keyword">if</span> (!(mi=iget(ROOT_DEV,ROOT_INO)))</span><br><span class="line">		panic(<span class="string">&quot;Unable to read root i-node&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h4 id="igetget_empty_inode">iget:get_empty_inode</h4>
<p>首先在记载所有打开的i结点的数组中申请一个空闲的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">iget</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>, * <span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		panic(<span class="string">&quot;iget with dev==0&quot;</span>);</span><br><span class="line">	empty = get_empty_inode();<span class="comment">//从inode_table[32]中申请一个空闲的i结点</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">get_empty_inode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">last_inode</span> =</span> inode_table; <span class="comment">// last_inode 指向 i 节点表第一项</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 扫描 i 节点表。 </span></span><br><span class="line">		inode = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = NR_INODE; i ; i--) &#123;</span><br><span class="line">            <span class="comment">// 如果 last_inode 已经指向 i 节点表的最后 1 项之后，则让其重新指向 i 节点表开始处。</span></span><br><span class="line">			<span class="keyword">if</span> (++last_inode &gt;= inode_table + NR_INODE)</span><br><span class="line">				last_inode = inode_table;</span><br><span class="line">            <span class="comment">// 如果 last_inode 所指向的 i 节点的计数值为 0，则说明可能找到空闲 i 节点项。让 inode 指向 </span></span><br><span class="line">           <span class="comment">// 该 i 节点。如果该 i 节点的已修改标志和锁定标志均为 0，则我们可以使用该 i 节点，于是退出循环。 </span></span><br><span class="line">			<span class="keyword">if</span> (!last_inode-&gt;i_count) &#123;</span><br><span class="line">				inode = last_inode;</span><br><span class="line">				<span class="keyword">if</span> (!inode-&gt;i_dirt &amp;&amp; !inode-&gt;i_lock)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 如果没有找到空闲 i 节点(inode=NULL)，则将整个 i 节点表打印出来供调试使用，并死机。</span></span><br><span class="line">		<span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_INODE ; i++)</span><br><span class="line">				printk(<span class="string">&quot;%04x: %6d\t&quot;</span>,inode_table[i].i_dev,</span><br><span class="line">					inode_table[i].i_num);</span><br><span class="line">			panic(<span class="string">&quot;No free inodes in mem&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 等待该 i 节点解锁（如果又被上锁的话）。 </span></span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">        <span class="comment">// 如果该 i 节点已修改标志被置位的话，则将该 i 节点刷新，并等待该 i 节点解锁。</span></span><br><span class="line">		<span class="keyword">while</span> (inode-&gt;i_dirt) &#123;</span><br><span class="line">			write_inode(inode);</span><br><span class="line">			wait_on_inode(inode);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (inode-&gt;i_count);<span class="comment">//// 如果 i 节点又被其它占用的话，则重新寻找空闲 i 节点。</span></span><br><span class="line">    <span class="comment">// 已找到空闲 i 节点项。则将该 i 节点项内容清零，并置引用标志为 1，返回该 i 节点指针。</span></span><br><span class="line">	<span class="built_in">memset</span>(inode,<span class="number">0</span>,<span class="keyword">sizeof</span>(*inode));</span><br><span class="line">	inode-&gt;i_count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="iget">iget</h4>
<p>inode_table 初始化的时候:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> <span class="title">inode_table</span>[<span class="title">NR_INODE</span>]=</span>&#123;&#123;<span class="number">0</span>,&#125;,&#125;; <span class="comment">// 内存中 i 节点表（NR_INODE=32 项）。</span></span><br></pre></td></tr></table></figure>
<p>这是对数组进行初始化的语法。它使用了一个嵌套的大括号，将数组中的每个元素初始化为
<code>&#123;0,&#125;</code>，这将初始化结构体中的所有成员为零（或NULL，具体取决于结构体的定义）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">iget</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">     <span class="comment">// 扫描 i 节点表。寻找指定节点号的 i 节点。并递增该节点的引用次数。</span></span><br><span class="line">	inode = inode_table;</span><br><span class="line">	<span class="keyword">while</span> (inode &lt; NR_INODE+inode_table) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_dev != dev || inode-&gt;i_num != nr) &#123;</span><br><span class="line">			inode++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">        <span class="comment">// 如果当前扫描的 i 节点的设备号不等于指定的设备号或者节点号不等于指定的节点号，则继续扫描。</span></span><br><span class="line">        <span class="comment">//MOUNT ROOT调用的时候if (!(mi=iget(ROOT_DEV,ROOT_INO)))。dev=0.nr=1)</span></span><br><span class="line">        <span class="comment">//所以刚初始化完的都是0，找不到所以会跳完这个while</span></span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_dev != dev || inode-&gt;i_num != nr) &#123;</span><br><span class="line">			inode = inode_table;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		inode-&gt;i_count++;</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_mount) &#123;</span><br><span class="line">			<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span> ; i&lt;NR_SUPER ; i++)</span><br><span class="line">				<span class="keyword">if</span> (super_block[i].s_imount==inode)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (i &gt;= NR_SUPER) &#123;</span><br><span class="line">				printk(<span class="string">&quot;Mounted inode hasn&#x27;t got sb\n&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (empty)</span><br><span class="line">					iput(empty);</span><br><span class="line">				<span class="keyword">return</span> inode;</span><br><span class="line">			&#125;</span><br><span class="line">			iput(inode);</span><br><span class="line">			dev = super_block[i].s_dev;</span><br><span class="line">			nr = ROOT_INO;</span><br><span class="line">			inode = inode_table;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (empty)</span><br><span class="line">			iput(empty);</span><br><span class="line">		<span class="keyword">return</span> inode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!empty)</span><br><span class="line">		<span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//第一次初始化的话会跳到这个地方执行，而不会在上面的循环中return 因为有continue</span></span><br><span class="line">    <span class="comment">//将当前的跟设备和块号赋值给找出来的inode table里面空闲的inode</span></span><br><span class="line">	inode=empty;</span><br><span class="line">	inode-&gt;i_dev = dev;</span><br><span class="line">	inode-&gt;i_num = nr;</span><br><span class="line">    </span><br><span class="line">	read_inode(inode);<span class="comment">//从虚拟盘上读出i结点</span></span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="read_inode">read_inode</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_inode</span><span class="params">(<span class="keyword">struct</span> m_inode * inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">int</span> block;</span><br><span class="line"></span><br><span class="line">	lock_inode(inode);<span class="comment">//首先对这个选出来的结点加锁，在解锁之前这个结点都不会被其它进程占用</span></span><br><span class="line">	<span class="keyword">if</span> (!(sb=get_super(inode-&gt;i_dev)))<span class="comment">//获得该节点所在设备的超级块</span></span><br><span class="line">		panic(<span class="string">&quot;trying to read inode without dev&quot;</span>);</span><br><span class="line">  <span class="comment">// 该 i 节点所在的逻辑块号 = (启动块+超级块) + i 节点位图占用的块数 + 逻辑块位图占用的块数 + </span></span><br><span class="line"> <span class="comment">// (i 节点号-1)/每块含有的 i 节点数。</span></span><br><span class="line">	block = <span class="number">2</span> + sb-&gt;s_imap_blocks + sb-&gt;s_zmap_blocks +</span><br><span class="line">		(inode-&gt;i_num<span class="number">-1</span>)/INODES_PER_BLOCK;</span><br><span class="line">    <span class="comment">//将inode的块读到缓冲中                                                               </span></span><br><span class="line">	<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,block)))</span><br><span class="line">		panic(<span class="string">&quot;unable to read i-node block&quot;</span>);</span><br><span class="line">    <span class="comment">//将读入的数据从缓冲块赋值给inode</span></span><br><span class="line">	*(<span class="keyword">struct</span> d_inode *)inode =</span><br><span class="line">		((<span class="keyword">struct</span> d_inode *)bh-&gt;b_data)</span><br><span class="line">			[(inode-&gt;i_num<span class="number">-1</span>)%INODES_PER_BLOCK];</span><br><span class="line">	brelse(bh);<span class="comment">//释放缓冲块</span></span><br><span class="line">	unlock_inode(inode);<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211131847124.png" alt="image-20231211131847124">
<figcaption aria-hidden="true">image-20231211131847124</figcaption>
</figure>
<h3 id="将根文件系统与进程1关联设置root和pwd">将根文件系统与进程1关联，设置root和pwd</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">    <span class="keyword">if</span> (!(mi=iget(ROOT_DEV,ROOT_INO)))</span><br><span class="line">		panic(<span class="string">&quot;Unable to read root i-node&quot;</span>);</span><br><span class="line">    <span class="comment">/* 该 i 节点引用次数递增 3 次。因为下面 </span></span><br><span class="line"><span class="comment">    p-&gt;s_isup = p-&gt;s_imount = mi;</span></span><br><span class="line"><span class="comment">    p-&gt;s_isup = p-&gt;s_imount = mi;</span></span><br><span class="line"><span class="comment">	current-&gt;pwd = mi;</span></span><br><span class="line"><span class="comment">    也引用了该 i 节点。*/</span></span><br><span class="line">    mi-&gt;i_count += <span class="number">3</span> ;	<span class="comment">/* NOTE! it is logically used 4 times, not 1 */</span></span><br><span class="line">	p-&gt;s_isup = p-&gt;s_imount = mi;<span class="comment">//他是最根的i结点。自己挂自己，这句话加载了跟设备的根文件系统，非常重要</span></span><br><span class="line">	current-&gt;pwd = mi;<span class="comment">//当前进程的工作目录（当前进程是进程1）进程1的工作目录是根文件系统的根i结点，从进程1开始才有文件系统</span></span><br><span class="line">	<span class="comment">//进程0没有，绝对路径：从根文件系统往下撸和相对路径，根据pwd往下撸</span></span><br><span class="line">	current-&gt;root = mi; <span class="comment">//后面由于父子进程创建遗传机制，后面的进程也会继承这个特征</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算虚拟盘空闲块信息">计算虚拟盘空闲块信息</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     ... </span><br><span class="line">    <span class="comment">// 统计该设备上空闲块数。首先令 i 等于超级块中表明的设备逻辑块总数。 </span></span><br><span class="line">    <span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">	i=p-&gt;s_nzones;</span><br><span class="line"><span class="comment">// 然后根据逻辑块位图中相应比特位的占用情况统计出空闲块数。这里宏函数 set_bit()只是在测试 </span></span><br><span class="line"> <span class="comment">// 比特位，而非设置比特位。&quot;i&amp;8191&quot;用于取得 i 节点号在当前块中的偏移值。&quot;i&gt;&gt;13&quot;是将 i 除以 </span></span><br><span class="line"> <span class="comment">// 8192，也即除一个磁盘块包含的比特位数。 </span></span><br><span class="line">	<span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_zmap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line">			<span class="built_in">free</span>++;</span><br><span class="line">	printk(<span class="string">&quot;%d/%d free blocks\n\r&quot;</span>,<span class="built_in">free</span>,p-&gt;s_nzones);</span><br><span class="line"><span class="comment">// 统计设备上空闲 i 节点数。首先令 i 等于超级块中表明的设备上 i 节点总数+1。加 1 是将 0 节点 </span></span><br><span class="line"> <span class="comment">// 也统计进去。</span></span><br><span class="line">	<span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">	i=p-&gt;s_ninodes+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 然后根据 i 节点位图中相应比特位的占用情况计算出空闲 i 节点数</span></span><br><span class="line">	<span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_imap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line">			<span class="built_in">free</span>++;</span><br><span class="line">    <span class="comment">// 显示设备上可用的空闲 i 节点数/i 节点总数。</span></span><br><span class="line">	printk(<span class="string">&quot;%d/%d free inodes\n\r&quot;</span>,<span class="built_in">free</span>,p-&gt;s_ninodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此mount_root执行完，同时返回后sys_setip函数也执行完了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_setup</span><span class="params">(<span class="type">void</span> * BIOS)</span> <span class="comment">//首先解决硬盘的驱动器问题</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    rd_load();</span><br><span class="line">	mount_root();</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回到之前调用system_call的地方，一路返回到一开始的init函数。</p>
<h2 id="更通用的安装文件系统">更通用的安装文件系统</h2>
<p>安装文件系统分为三步：</p>
<ol type="1">
<li>把超级块读出来挂载到super block[8]上</li>
<li>将作为挂载结点的虚拟盘上的i结点挂在inode_table上</li>
<li>将硬盘上的需要被挂载的超级块挂在inode table上</li>
</ol>
<p>在shell下输入 <code>mount /dev/hd1  /mnt</code>
的命令可以安装文件系统：将设备hd1的文件系统挂载到mnt目录文件下。此时shell会创建一个新的进程调用mount函数最终映射到sys_mount系统调用函数执行加载文件系统的过程</p>
<h3 id="sys_mount">sys_mount</h3>
<p>挂载流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 dev_name 是设备文件名，dir_name 是安装到的目录名，rw_flag 被安装文件的读写标志。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_mount</span><span class="params">(<span class="type">char</span> * dev_name, <span class="type">char</span> * dir_name, <span class="type">int</span> rw_flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dev_i</span>, * <span class="title">dir_i</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="type">int</span> dev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(dev_i=namei(dev_name)))<span class="comment">//获取设备i结点，通过设备名获取</span></span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">    <span class="comment">// 对于块特殊设备文件，设备号在 i 节点的 i_zone[0]中。</span></span><br><span class="line">	dev = dev_i-&gt;i_zone[<span class="number">0</span>];<span class="comment">//通过i结点获取设备号</span></span><br><span class="line">    <span class="comment">//根据mode判断结点类型，如果不是块设备类型的结点则释放</span></span><br><span class="line">	<span class="keyword">if</span> (!S_ISBLK(dev_i-&gt;i_mode)) &#123;</span><br><span class="line">		iput(dev_i);<span class="comment">//释放</span></span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	iput(dev_i);<span class="comment">//因为dev i结点的挂载的目的就是获得设备号，已经得到了，没有留着的用了就释放掉这个i结点</span></span><br><span class="line">	<span class="keyword">if</span> (!(dir_i=namei(dir_name)))<span class="comment">//找要挂接的目录的i结点</span></span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="comment">//判断目录i结点是不是根结点</span></span><br><span class="line">	<span class="comment">//inum是inode在位图里面的下标，第一个i结点：根i结点</span></span><br><span class="line">	<span class="comment">//// 如果该 i 节点的引用计数不为 1（仅在这里引用），或者该 i 节点的节点号是根文件系统的节点 </span></span><br><span class="line">    <span class="comment">// 号 1，则释放该 i 节点，返回出错码。不能挂载在根结点上面</span></span><br><span class="line">	<span class="keyword">if</span> (dir_i-&gt;i_count != <span class="number">1</span> || dir_i-&gt;i_num == ROOT_INO) &#123;</span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果该节点不是一个目录文件节点，则也释放该 i 节点，返回出错码。 </span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (!S_ISDIR(dir_i-&gt;i_mode)) &#123;</span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 读取将安装文件系统的超级块，如果失败则也释放该 i 节点，返回出错码。根据设备号就可以加载超级块</span></span><br><span class="line">	<span class="keyword">if</span> (!(sb=read_super(dev))) &#123;</span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果将要被安装的文件系统已经安装在其它地方，则释放该 i 节点，返回出错码</span></span><br><span class="line">    <span class="comment">//s_imount 是挂载的inode指针</span></span><br><span class="line">	<span class="keyword">if</span> (sb-&gt;s_imount) &#123;</span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果将要安装到的 i 节点已经安装了文件系统(安装标志已经置位)，则释放该 i 节点，返回出错码。</span></span><br><span class="line">	<span class="keyword">if</span> (dir_i-&gt;i_mount) &#123;</span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	sb-&gt;s_imount=dir_i;</span><br><span class="line">    <span class="comment">//dir inode 已经安装了文件系统。i_dirt置1 说明i结点已经被修改</span></span><br><span class="line">	dir_i-&gt;i_mount=<span class="number">1</span>;</span><br><span class="line">	dir_i-&gt;i_dirt=<span class="number">1</span>;		<span class="comment">/* NOTE! we don&#x27;t iput(dir_i) */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;			<span class="comment">/* we do that in umount */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/文件系统加载示意图.png" alt="文件系统加载结点">
<figcaption aria-hidden="true">文件系统加载结点</figcaption>
</figure>
<pre><code>//看imode区分inode类型，判断是不是目录文件。设备文件i结点找到设备号，第一个就是根i结点
//read super ：先找有没有现成的
//simap 8个缓冲块，每个缓冲块1k，一字节8bit：64kbit，有64ki结点
//64M文件
//超级块里面有两个8个的指针数组。每个指向一个块，</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="comment">/* These are only in memory */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_imap</span>[8];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_zmap</span>[8];</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>超级块在内存的信息里面用于存放i结点位图用的buffer head
*类型的数组。一个buffer head 1k
8个8k字节。一字节8位，所以对应了64K个inode。一个inode对应一个文件一个文件系统最多可以有64k个文件。同理一共64k个逻辑块，注意逻辑块也是块大小是1k，所以一共逻辑系统最多有64M大小的文件。</p>
<h2 id="打开文件">打开文件</h2>
<p>打开文件的本质就是建立*filep【20】，file_table【64】
和inode_table【32】之间的联系</p>
<p>taskstruct 里面有：<code>struct file * filp[NR_OPEN];</code>
每个进程都有一个filep，而file_table和inode_table是内核持有的，只有一个。</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211225204563.png" alt="image-20231211225204563">
<figcaption aria-hidden="true">image-20231211225204563</figcaption>
</figure>
<p>打开文件建立连接的过程：使用open函数打开文件，最终映射到系统调用sys_open</p>
<h3 id="sys_open">sys_open</h3>
<p>总导图：</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/open文件流程.png" alt="open文件流程">
<figcaption aria-hidden="true">open文件流程</figcaption>
</figure>
<h3 id="将进程的filp和file_table挂接">将进程的*filp和file_table挂接</h3>
<p>分别找filp和file_table里面的空闲项，并建立他俩的连接关系：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">int</span> flag,<span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">f</span>;</span></span><br><span class="line">	<span class="type">int</span> i,fd;</span><br><span class="line"></span><br><span class="line">	mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line">	<span class="comment">//打开文件的进程是当前进程，在filep里面找一个空闲项</span></span><br><span class="line">	<span class="keyword">for</span>(fd=<span class="number">0</span> ; fd&lt;NR_OPEN ; fd++) <span class="comment">// #define NR_OPEN 20</span></span><br><span class="line">		<span class="keyword">if</span> (!current-&gt;filp[fd])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span> (fd&gt;=NR_OPEN)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	current-&gt;close_on_exec &amp;= ~(<span class="number">1</span>&lt;&lt;fd);</span><br><span class="line">	f=<span class="number">0</span>+file_table;</span><br><span class="line">	<span class="comment">//找完找file table，引用计数为0的空闲项</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_FILE ; i++,f++)<span class="comment">//#define NR_FILE 64</span></span><br><span class="line">		<span class="keyword">if</span> (!f-&gt;f_count) <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span> (i&gt;=NR_FILE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	(current-&gt;filp[fd]=f)-&gt;f_count++;<span class="comment">//当前进程的空闲的filep的哪一项指向空闲的file table里面的项，引用计数++</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取文件的i结点opennamei">获取文件的i结点：opennamei</h3>
<p>例如要打开的文件路径是：<code>/mnt/user/user1/user2/hellow.txt</code>如何找到hellow.txt文件的i结点？</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/default.jpg" alt="寻找过程">
<figcaption aria-hidden="true">寻找过程</figcaption>
</figure>
<p>主要有目录文件结点和最终的文件结点。通过目录文件结点可以找到目录文件，里面的目录项指向了下一级的结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	<span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">int</span> flag,<span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">//读i结点，filename：sysopen的参数const char*类型，返回给inode</span></span><br><span class="line">	<span class="comment">//如果open_namei成功返回0，失败返回1</span></span><br><span class="line">	<span class="keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">		f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">        ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了open_namei实现上述的寻找过程：</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231211233150934.png" alt="流程图">
<figcaption aria-hidden="true">流程图</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_namei</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname, <span class="type">int</span> flag, <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> m_inode ** res_inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * basename;</span><br><span class="line">	<span class="type">int</span> inr,dev,namelen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>, *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span><span class="comment">//目录项的数据结构，目录文件里面的目录项可多可少</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((flag &amp; O_TRUNC) &amp;&amp; !(flag &amp; O_ACCMODE))</span><br><span class="line">		flag |= O_WRONLY;</span><br><span class="line">	mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line">	mode |= I_REGULAR;</span><br><span class="line">	<span class="comment">//返回枝梢i结点</span></span><br><span class="line">	<span class="keyword">if</span> (!(dir = dir_namei(pathname,&amp;namelen,&amp;basename)))</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先找到枝梢结点，也就是例子里面的user2目录文件inode结点</p>
<h4 id="dir_namei">dir_namei</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> m_inode * <span class="title function_">dir_namei</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> * namelen, <span class="type">const</span> <span class="type">char</span> ** name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * basename;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(dir = get_dir(pathname)))<span class="comment">//分析路径，获取i节点的执行函数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	basename = pathname;</span><br><span class="line">	<span class="comment">//一个一个解析paathname，一次过一个字符串常量字符</span></span><br><span class="line">	<span class="keyword">while</span> (c=get_fs_byte(pathname++))</span><br><span class="line">		<span class="keyword">if</span> (c==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">			basename=pathname;</span><br><span class="line">	*namelen = pathname-basename<span class="number">-1</span>;</span><br><span class="line">	*name = basename;</span><br><span class="line">	<span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="get_dir">get_dir</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> m_inode * <span class="title function_">get_dir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * thisname;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">int</span> namelen,inr,idev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!current-&gt;root || !current-&gt;root-&gt;i_count)</span><br><span class="line">		panic(<span class="string">&quot;No root inode&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!current-&gt;pwd || !current-&gt;pwd-&gt;i_count)</span><br><span class="line">		panic(<span class="string">&quot;No cwd inode&quot;</span>);</span><br><span class="line">	<span class="comment">//如果第一个是/：绝对路径，如果第一个不是/也不是空：相对路径</span></span><br><span class="line">	<span class="keyword">if</span> ((c=get_fs_byte(pathname))==<span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">		inode = current-&gt;root;</span><br><span class="line">		pathname++;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c)</span><br><span class="line">		inode = current-&gt;pwd;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;	<span class="comment">/* empty name is bad */</span></span><br><span class="line">	inode-&gt;i_count++;<span class="comment">//该i节点的引用计数+1</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;<span class="comment">//寻找枝梢 结点</span></span><br><span class="line">		thisname = pathname;<span class="comment">//后面pathname++遍历，thisname没变</span></span><br><span class="line">		<span class="keyword">if</span> (!S_ISDIR(inode-&gt;i_mode) || !permission(inode,MAY_EXEC)) &#123;</span><br><span class="line">			iput(inode);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//不为空“\0&quot;且没遇到/</span></span><br><span class="line">		<span class="keyword">for</span>(namelen=<span class="number">0</span>;(c=get_fs_byte(pathname++))&amp;&amp;(c!=<span class="string">&#x27;/&#x27;</span>);namelen++)</span><br><span class="line">			<span class="comment">/* nothing */</span> ;</span><br><span class="line">		<span class="keyword">if</span> (!c)</span><br><span class="line">			<span class="keyword">return</span> inode;<span class="comment">//返回前一个inode，正常的情况下是在这里结束的，返回枝末梢i结点</span></span><br><span class="line">        <span class="comment">//c不为空，说明还没到末梢，是目录项结点，在目录项文件中寻找包含目录项的块</span></span><br><span class="line">        <span class="comment">//pathname动，this name不动</span></span><br><span class="line">		<span class="keyword">if</span> (!(bh = find_entry(&amp;inode,thisname,namelen,&amp;de))) &#123;<span class="comment">//找到含有目录项的块</span></span><br><span class="line">			iput(inode);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		inr = de-&gt;inode;<span class="comment">//从目录项中提取i结点号 inumber</span></span><br><span class="line">		idev = inode-&gt;i_dev;<span class="comment">//从i结点中提取设备号</span></span><br><span class="line">		brelse(bh);</span><br><span class="line">		iput(inode);</span><br><span class="line">		<span class="keyword">if</span> (!(inode = iget(idev,inr)))<span class="comment">//获取下一级的inode</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="find_entry">find_entry</h5>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/findentry.png" alt="findentry">
<figcaption aria-hidden="true">findentry</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> inode;<span class="comment">//下一级的inode结点在硬盘上，没有指针。用的是位图的index。i节点位图的偏移，inode number</span></span><br><span class="line">	<span class="type">char</span> name[NAME_LEN];<span class="comment">//这一段的目录文件名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buffer_head * <span class="title function_">find_entry</span><span class="params">(<span class="keyword">struct</span> m_inode ** dir,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">char</span> * name, <span class="type">int</span> namelen, <span class="keyword">struct</span> dir_entry ** res_dir)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> entries;</span><br><span class="line">	<span class="type">int</span> block,i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NO_TRUNCATE</span></span><br><span class="line">	<span class="keyword">if</span> (namelen &gt; NAME_LEN)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">if</span> (namelen &gt; NAME_LEN)</span><br><span class="line">		namelen = NAME_LEN;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	entries = (*dir)-&gt;i_size / (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> dir_entry));<span class="comment">//目录项文件大小/每个目录项的大小-&gt;获得目录项的数目</span></span><br><span class="line">	*res_dir = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!namelen)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* check for &#x27;..&#x27;, as we might have to do some &quot;magic&quot; for it */</span></span><br><span class="line">	<span class="keyword">if</span> (namelen==<span class="number">2</span> &amp;&amp; get_fs_byte(name)==<span class="string">&#x27;.&#x27;</span> &amp;&amp; get_fs_byte(name+<span class="number">1</span>)==<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">/* &#x27;..&#x27; in a pseudo-root results in a faked &#x27;.&#x27; (just change namelen) */</span></span><br><span class="line">		<span class="keyword">if</span> ((*dir) == current-&gt;root)</span><br><span class="line">			namelen=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((*dir)-&gt;i_num == ROOT_INO) &#123;</span><br><span class="line"><span class="comment">/* &#x27;..&#x27; over a mount-point results in &#x27;dir&#x27; being exchanged for the mounted</span></span><br><span class="line"><span class="comment">   directory-inode. NOTE! We set mounted, so that we can iput the new dir */</span></span><br><span class="line">			sb=get_super((*dir)-&gt;i_dev);</span><br><span class="line">			<span class="keyword">if</span> (sb-&gt;s_imount) &#123;</span><br><span class="line">				iput(*dir);</span><br><span class="line">				(*dir)=sb-&gt;s_imount;</span><br><span class="line">				(*dir)-&gt;i_count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//目录文件第一个块不能是逻辑块0，不能为空</span></span><br><span class="line">	<span class="keyword">if</span> (!(block = (*dir)-&gt;i_zone[<span class="number">0</span>]))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//不空的话把这个block读入缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh = bread((*dir)-&gt;i_dev,block)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	de = (<span class="keyword">struct</span> dir_entry *) bh-&gt;b_data;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; entries) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="type">char</span> *)de &gt;= BLOCK_SIZE+bh-&gt;b_data) &#123;</span><br><span class="line">			<span class="comment">//如果一个缓冲区全部搜索完还没找到指定的目录项</span></span><br><span class="line">			brelse(bh);</span><br><span class="line">			bh = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span> (!(block = bmap(*dir,i/DIR_ENTRIES_PER_BLOCK)) ||</span><br><span class="line">			    !(bh = bread((*dir)-&gt;i_dev,block))) &#123;</span><br><span class="line">				i += DIR_ENTRIES_PER_BLOCK;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			de = (<span class="keyword">struct</span> dir_entry *) bh-&gt;b_data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (match(namelen,name,de)) &#123;</span><br><span class="line">			*res_dir = de;</span><br><span class="line">			<span class="keyword">return</span> bh;</span><br><span class="line">		&#125;</span><br><span class="line">		de++;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="iget-1">iget</h5>
<p>iget根据目录项中提供的设备号i结点号获取i结点。</p>
<p>首先在inode_table里面看有没有现成的，如果找不到再加载</p>
<p>整体流程图：</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/iget.png" alt="iget">
<figcaption aria-hidden="true">iget</figcaption>
</figure>
<h5 id="返回dir_namei">返回dir_namei</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> m_inode * <span class="title function_">dir_namei</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> * namelen, <span class="type">const</span> <span class="type">char</span> ** name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * basename;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(dir = get_dir(pathname)))<span class="comment">//分析路径，获取i节点的执行函数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	basename = pathname;</span><br><span class="line">	<span class="comment">//一个一个解析paathname，一次过一个字符串常量字符</span></span><br><span class="line">	<span class="keyword">while</span> (c=get_fs_byte(pathname++))</span><br><span class="line">		<span class="keyword">if</span> (c==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">			basename=pathname;</span><br><span class="line">	*namelen = pathname-basename<span class="number">-1</span>;</span><br><span class="line">	*name = basename;</span><br><span class="line">	<span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231212095622262.png" alt="image-20231212095622262" style="zoom:80%;"></p>
<h4 id="opennamei获取目标文件i节点">opennamei:获取目标文件i节点</h4>
<p>上文已经讲述了获得枝梢结点的过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_namei</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname, <span class="type">int</span> flag, <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> m_inode ** res_inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//返回枝梢i结点</span></span><br><span class="line">	<span class="keyword">if</span> (!(dir = dir_namei(pathname,&amp;namelen,&amp;basename)))</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">    <span class="comment">//如果目标文件名字长度为0</span></span><br><span class="line">	<span class="keyword">if</span> (!namelen) &#123;			<span class="comment">/* special case: &#x27;/usr/&#x27; etc */</span></span><br><span class="line">		<span class="keyword">if</span> (!(flag &amp; (O_ACCMODE|O_CREAT|O_TRUNC))) &#123;</span><br><span class="line">			*res_inode=dir;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		iput(dir);</span><br><span class="line">		<span class="keyword">return</span> -EISDIR;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//根据末梢结点和文件名，寻找目标文件再目录项块中的块</span></span><br><span class="line">    bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(flag &amp; O_CREAT)) &#123;</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOENT;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//检查用户权限</span></span><br><span class="line">		<span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">		inode = new_inode(dir-&gt;i_dev);</span><br><span class="line">		<span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">		&#125;</span><br><span class="line">		inode-&gt;i_uid = current-&gt;euid;</span><br><span class="line">		inode-&gt;i_mode = mode;</span><br><span class="line">		inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">		bh = add_entry(dir,basename,namelen,&amp;de);</span><br><span class="line">		<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">			inode-&gt;i_nlinks--;</span><br><span class="line">			iput(inode);</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">		&#125;</span><br><span class="line">		de-&gt;inode = inode-&gt;i_num;</span><br><span class="line">		bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">		brelse(bh);</span><br><span class="line">		iput(dir);</span><br><span class="line">		*res_inode = inode;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	inr = de-&gt;inode;<span class="comment">//i number，这个是双向找的。得到i结点号</span></span><br><span class="line">	dev = dir-&gt;i_dev;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	iput(dir);</span><br><span class="line">	<span class="keyword">if</span> (flag &amp; O_EXCL)</span><br><span class="line">		<span class="keyword">return</span> -EEXIST;</span><br><span class="line">	<span class="keyword">if</span> (!(inode=iget(dev,inr)))</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	<span class="keyword">if</span> ((S_ISDIR(inode-&gt;i_mode) &amp;&amp; (flag &amp; O_ACCMODE)) ||</span><br><span class="line">	    !permission(inode,ACC_MODE(flag))) &#123;</span><br><span class="line">		iput(inode);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_atime = CURRENT_TIME;</span><br><span class="line">	<span class="keyword">if</span> (flag &amp; O_TRUNC)</span><br><span class="line">		truncate(inode);</span><br><span class="line">	*res_inode = inode;<span class="comment">//最终的inode，将inode传回sys_open</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="将文件i结点与file_table64挂接">将文件i结点与file_table[64]挂接</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">int</span> flag,<span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">    <span class="keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">		f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* ttys are somewhat special (ttyxx major==4, tty major==5) */</span></span><br><span class="line">	<span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))<span class="comment">//如果是字符设备文件</span></span><br><span class="line">		<span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">4</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				current-&gt;tty = MINOR(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">				tty_table[current-&gt;tty].pgrp = current-&gt;pgrp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">5</span>)</span><br><span class="line">			<span class="keyword">if</span> (current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				iput(inode);</span><br><span class="line">				current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">				f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> -EPERM;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">/* Likewise with block-devices: check for floppy_change */</span></span><br><span class="line">	<span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))<span class="comment">//如果是块设备文件</span></span><br><span class="line">		check_disk_change(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//设置文件属性，与file_table[64] 挂接</span></span><br><span class="line">	f-&gt;f_mode = inode-&gt;i_mode;</span><br><span class="line">	f-&gt;f_flags = flag;</span><br><span class="line">	f-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">	f-&gt;f_inode = inode;</span><br><span class="line">	f-&gt;f_pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="namei">namei</h3>
<p>将给定的文件路径名映射 到其 i 节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">namei</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * basename;</span><br><span class="line">	<span class="type">int</span> inr,dev,namelen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(dir = dir_namei(pathname,&amp;namelen,&amp;basename)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!namelen)			<span class="comment">/* special case: &#x27;/usr/&#x27; etc */</span></span><br><span class="line">		<span class="keyword">return</span> dir;</span><br><span class="line">	bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	inr = de-&gt;inode;</span><br><span class="line">	dev = dir-&gt;i_dev;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	iput(dir);</span><br><span class="line">	dir=iget(dev,inr);</span><br><span class="line">	<span class="keyword">if</span> (dir) &#123;</span><br><span class="line">		dir-&gt;i_atime=CURRENT_TIME;</span><br><span class="line">		dir-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>izone ：；一个块1k。一个号unsigned short
2字节，一个块：512个号-》512k</p>
<p>inode_table里面的inode只有一个，但是允许别人重复打开，因此有conunt引用计数</p>
<h2 id="读文件">读文件</h2>
<h3 id="sys_read">sys_read</h3>
<p>读文件由用户调用read完成</p>
<p>read函数最终映射到sys_read()系统调用执行</p>
<p>读文件的offset在file结构体里面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd,<span class="type">char</span> * buf,<span class="type">int</span> count)</span><span class="comment">//count是要读取的字节数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//偏置等信息在file结构体里面，可以通过fd找filep里面的指针找到file_table里面的file</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">     <span class="comment">//检查fd和conunt的范围是否合理</span></span><br><span class="line">	<span class="keyword">if</span> (fd&gt;=NR_OPEN || count&lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (!count)<span class="comment">//读取字符为0直接返回</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	verify_area(buf,count);<span class="comment">//对buf所在页面的属性进行验证。如果页面是只读的则复制该页面</span></span><br><span class="line">	inode = file-&gt;f_inode;</span><br><span class="line">    <span class="comment">//针对不同文件类型读</span></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_pipe)</span><br><span class="line">		<span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">1</span>)?read_pipe(inode,buf,count):-EIO;</span><br><span class="line">	<span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))</span><br><span class="line">		<span class="keyword">return</span> rw_char(READ,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line">	<span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line">		<span class="keyword">return</span> block_read(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line">    <span class="comment">//目录文件</span></span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (count+file-&gt;f_pos &gt; inode-&gt;i_size)</span><br><span class="line">			count = inode-&gt;i_size - file-&gt;f_pos;</span><br><span class="line">		<span class="keyword">if</span> (count&lt;=<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> file_read(inode,file,buf,count);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;(Read)inode-&gt;i_mode=%06o\n\r&quot;</span>,inode-&gt;i_mode);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">verify_area</span><span class="params">(<span class="type">void</span> * addr,<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start;</span><br><span class="line"></span><br><span class="line">	start = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line">	size += start &amp; <span class="number">0xfff</span>;</span><br><span class="line">	start &amp;= <span class="number">0xfffff000</span>;</span><br><span class="line">	start += get_base(current-&gt;ldt[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">while</span> (size&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		size -= <span class="number">4096</span>;</span><br><span class="line">		write_verify(start);</span><br><span class="line">		start += <span class="number">4096</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_verify</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> page;</span><br><span class="line">    <span class="comment">// 判断指定地址所对应页目录项的页表是否存在(P)，若不存在(P=0)则返回。4M对齐</span></span><br><span class="line">	<span class="keyword">if</span> (!( (page = *((<span class="type">unsigned</span> <span class="type">long</span> *) ((address&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>)) )&amp;<span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 取页表的地址，加上指定地址的页面在页表中的页表项偏移值，得对应物理页面的页表项指针。</span></span><br><span class="line">	page &amp;= <span class="number">0xfffff000</span>;</span><br><span class="line">	page += ((address&gt;&gt;<span class="number">10</span>) &amp; <span class="number">0xffc</span>);<span class="comment">//高10位置零，低十位置零只留了中间十位，后两位置零了起到乘4的效果，因为每一个偏移量是以4k为单位的，避免后面取到了index再乘4的操作</span></span><br><span class="line">	<span class="comment">// 如果该页面不可写(标志 R/W 没有置位)，则执行共享检验和复制页面操作（写时复制）。</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="number">3</span> &amp; *(<span class="type">unsigned</span> <span class="type">long</span> *) page) == <span class="number">1</span>)  <span class="comment">/* non-writeable, present */</span></span><br><span class="line">		un_wp_page((<span class="type">unsigned</span> <span class="type">long</span> *) page);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="file_read">file_read</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_read</span><span class="params">(<span class="keyword">struct</span> m_inode * inode, <span class="keyword">struct</span> file * filp, <span class="type">char</span> * buf, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> left,chars,nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((left=count)&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (left) &#123;</span><br><span class="line">		<span class="comment">//每次按块读，每次读一个块</span></span><br><span class="line">		<span class="keyword">if</span> (nr = bmap(inode,(filp-&gt;f_pos)/BLOCK_SIZE)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,nr)))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			bh = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="comment">// 计算文件读写指针在数据块中的偏移值 nr，则该块中可读字节数为(BLOCK_SIZE-nr)，然后与还需 </span></span><br><span class="line">     <span class="comment">// 读取的字节数 left 作比较，其中小值即为本次需读的字节数 chars。若(BLOCK_SIZE-nr)大则说明 </span></span><br><span class="line">     <span class="comment">// 该块是需要读取的最后一块数据，反之则还需要读取一块数据。</span></span><br><span class="line">		nr = filp-&gt;f_pos % BLOCK_SIZE;</span><br><span class="line">		chars = MIN( BLOCK_SIZE-nr , left );</span><br><span class="line">     <span class="comment">// 调整读写文件指针。指针前移此次将读取的字节数 chars。剩余字节计数相应减去 chars。</span></span><br><span class="line">		filp-&gt;f_pos += chars;</span><br><span class="line">		left -= chars;</span><br><span class="line">		<span class="keyword">if</span> (bh) &#123;</span><br><span class="line">			<span class="type">char</span> * p = nr + bh-&gt;b_data;</span><br><span class="line">			<span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)</span><br><span class="line">				put_fs_byte(*(p++),buf++);<span class="comment">//从缓冲区往用户拷贝</span></span><br><span class="line">			brelse(bh);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)</span><br><span class="line">				put_fs_byte(<span class="number">0</span>,buf++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_atime = CURRENT_TIME;</span><br><span class="line">	<span class="keyword">return</span> (count-left)?(count-left):-ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bmap">_bmap</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> m_inode * inode,<span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _bmap(inode,block,<span class="number">0</span>);<span class="comment">//注意这里写死了一个0，0表示用已有的，1表示没有就创建一个（izone有块没有就补一下）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="新建文件">新建文件</h2>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/新建文件inode.png" alt="示意图">
<figcaption aria-hidden="true">示意图</figcaption>
</figure>
<p>creat函数，最终映射到sys_create函数，调用sys_open新建文件，和之前打开文件调用open不一样，这回opennamei没有这个i结点会返回空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">int</span> flag,<span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">		f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_namei</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname, <span class="type">int</span> flag, <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> m_inode ** res_inode)</span></span><br><span class="line">&#123;   </span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> (!(dir = dir_namei(pathname,&amp;namelen,&amp;basename)))</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buffer_head * <span class="title function_">find_entry</span><span class="params">(<span class="keyword">struct</span> m_inode ** dir,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">char</span> * name, <span class="type">int</span> namelen, <span class="keyword">struct</span> dir_entry ** res_dir)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">while</span> (i &lt; entries) &#123;</span><br><span class="line">         ...</span><br><span class="line">		<span class="keyword">if</span> (match(namelen,name,de)) &#123;<span class="comment">//匹配当前的名字和目录项里面的名字</span></span><br><span class="line">			*res_dir = de;</span><br><span class="line">			<span class="keyword">return</span> bh;</span><br><span class="line">		&#125;</span><br><span class="line">		de++;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终find_entry会返回null</p>
<p>因此opennamei执行：if (!bh) 里面的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_namei</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname, <span class="type">int</span> flag, <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> m_inode ** res_inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">        <span class="comment">//没有找到文件不一定是要新建文件，可能是用户输错了名字</span></span><br><span class="line">        <span class="comment">//检查flag的O_CREAT标志位是否置位。如果置位了，说明确实是要新建文件</span></span><br><span class="line">		<span class="keyword">if</span> (!(flag &amp; O_CREAT)) &#123;</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOENT;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//检查用户再该目录是否有写权限</span></span><br><span class="line">		<span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//新建inode</span></span><br><span class="line">		inode = new_inode(dir-&gt;i_dev);</span><br><span class="line">		<span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">		&#125;</span><br><span class="line">		inode-&gt;i_uid = current-&gt;euid;</span><br><span class="line">		inode-&gt;i_mode = mode;</span><br><span class="line">		inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">		bh = add_entry(dir,basename,namelen,&amp;de);<span class="comment">//新建目录项</span></span><br><span class="line">		<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">			inode-&gt;i_nlinks--;</span><br><span class="line">			iput(inode);</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">		&#125;</span><br><span class="line">		de-&gt;inode = inode-&gt;i_num;</span><br><span class="line">		bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">		brelse(bh);</span><br><span class="line">		iput(dir);</span><br><span class="line">		*res_inode = inode;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="new_inode">new_inode</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">new_inode</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">    <span class="comment">//在inode_tale里面寻找空闲i结点</span></span><br><span class="line">	<span class="keyword">if</span> (!(inode=get_empty_inode()))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//获取设备超级块</span></span><br><span class="line">	<span class="keyword">if</span> (!(sb = get_super(dev)))</span><br><span class="line">		panic(<span class="string">&quot;new_inode with unknown device&quot;</span>);</span><br><span class="line">	j = <span class="number">8192</span>;<span class="comment">//根据超级块里面的i结点位图信息设置i结点位图</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;<span class="number">8</span> ; i++)</span><br><span class="line">		<span class="keyword">if</span> (bh=sb-&gt;s_imap[i])</span><br><span class="line">			<span class="keyword">if</span> ((j=find_first_zero(bh-&gt;b_data))&lt;<span class="number">8192</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span> (!bh || j &gt;= <span class="number">8192</span> || j+i*<span class="number">8192</span> &gt; sb-&gt;s_ninodes) &#123;</span><br><span class="line">		iput(inode);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (set_bit(j,bh-&gt;b_data))</span><br><span class="line">		panic(<span class="string">&quot;new_inode: bit already set&quot;</span>);</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_count=<span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_nlinks=<span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_dev=dev;</span><br><span class="line">	inode-&gt;i_uid=current-&gt;euid;</span><br><span class="line">	inode-&gt;i_gid=current-&gt;egid;</span><br><span class="line">	inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_num = j + i*<span class="number">8192</span>;</span><br><span class="line">	inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="add_entry">add_entry</h3>
<p>如果在目录文件中找到空闲项，则在此处加载</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215154349111.png" alt="目录文件示意图">
<figcaption aria-hidden="true">目录文件示意图</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buffer_head * <span class="title function_">add_entry</span><span class="params">(<span class="keyword">struct</span> m_inode * dir,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">char</span> * name, <span class="type">int</span> namelen, <span class="keyword">struct</span> dir_entry ** res_dir)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> block,i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">	*res_dir = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NO_TRUNCATE</span></span><br><span class="line">	<span class="keyword">if</span> (namelen &gt; NAME_LEN)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">if</span> (namelen &gt; NAME_LEN)</span><br><span class="line">		namelen = NAME_LEN;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (!namelen)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(block = dir-&gt;i_zone[<span class="number">0</span>]))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(bh = bread(dir-&gt;i_dev,block)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	de = (<span class="keyword">struct</span> dir_entry *) bh-&gt;b_data;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">// 如果当前判别的目录项已经超出当前数据块，则释放该数据块，重新申请一块磁盘块 block。如果 </span></span><br><span class="line">        <span class="comment">// 申请失败，则返回 NULL，退出。</span></span><br><span class="line">		<span class="keyword">if</span> ((<span class="type">char</span> *)de &gt;= BLOCK_SIZE+bh-&gt;b_data) &#123;</span><br><span class="line">            <span class="comment">//整个数据块都没有空闲则加载新的block</span></span><br><span class="line">			brelse(bh);</span><br><span class="line">			bh = <span class="literal">NULL</span>;</span><br><span class="line">			block = create_block(dir,i/DIR_ENTRIES_PER_BLOCK);</span><br><span class="line">			<span class="keyword">if</span> (!block)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span> (!(bh = bread(dir-&gt;i_dev,block))) &#123;</span><br><span class="line">				i += DIR_ENTRIES_PER_BLOCK;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			de = (<span class="keyword">struct</span> dir_entry *) bh-&gt;b_data;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// 如果当前所操作的目录项序号 i*目录结构大小已经超过了该目录所指出的大小 i_size，则说明该第 i </span></span><br><span class="line"> <span class="comment">// 个目录项还未使用，我们可以使用它。于是对该目录项进行设置(置该目录项的 i 节点指针为空)。并 </span></span><br><span class="line"> <span class="comment">// 更新该目录的长度值(加上一个目录项的长度，设置目录的 i 节点已修改标志，再更新该目录的改变</span></span><br><span class="line">时 </span><br><span class="line"> <span class="comment">// 间为当前时间。</span></span><br><span class="line">    <span class="comment">//在末端找到空闲项</span></span><br><span class="line">		<span class="keyword">if</span> (i*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dir_entry) &gt;= dir-&gt;i_size) &#123;</span><br><span class="line">			de-&gt;inode=<span class="number">0</span>;</span><br><span class="line">			dir-&gt;i_size = (i+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dir_entry);</span><br><span class="line">			dir-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">			dir-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//在中间找到空闲项</span></span><br><span class="line">		<span class="keyword">if</span> (!de-&gt;inode) &#123;</span><br><span class="line">			dir-&gt;i_mtime = CURRENT_TIME;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; NAME_LEN ; i++)</span><br><span class="line">				de-&gt;name[i]=(i&lt;namelen)?get_fs_byte(name+i):<span class="number">0</span>;</span><br><span class="line">			bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">			*res_dir = de;</span><br><span class="line">			<span class="keyword">return</span> bh;</span><br><span class="line">		&#125;</span><br><span class="line">		de++;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_block</span><span class="params">(<span class="keyword">struct</span> m_inode * inode, <span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _bmap(inode,block,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bmap-1">_bmap</h3>
<h4 id="直接索引部分-block7">直接索引部分 （block&lt;7)</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _bmap(<span class="keyword">struct</span> m_inode * inode,<span class="type">int</span> block,<span class="type">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"><span class="comment">// 如果块号小于 0，则死机。</span></span><br><span class="line">	<span class="keyword">if</span> (block&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;_bmap: block&lt;0&quot;</span>);</span><br><span class="line"><span class="comment">// 如果块号大于直接块数 + 间接块数 + 二次间接块数，超出文件系统表示范围，则死机。		</span></span><br><span class="line">	<span class="keyword">if</span> (block &gt;= <span class="number">7</span>+<span class="number">512</span>+<span class="number">512</span>*<span class="number">512</span>)</span><br><span class="line">		panic(<span class="string">&quot;_bmap: block&gt;big&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (block&lt;<span class="number">7</span>) &#123;</span><br><span class="line"> <span class="comment">// 如果创建标志置位，并且 i 节点中对应该块的逻辑块（区段）字段为 0，则向相应设备申请一磁盘 </span></span><br><span class="line"> <span class="comment">// 块（逻辑块，区块），并将盘上逻辑块号（盘块号）填入逻辑块字段中。然后设置 i 节点修改时间，</span></span><br><span class="line">		<span class="keyword">if</span> (create &amp;&amp; !inode-&gt;i_zone[block])</span><br><span class="line">			<span class="keyword">if</span> (inode-&gt;i_zone[block]=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">				inode-&gt;i_ctime=CURRENT_TIME;</span><br><span class="line">				inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> inode-&gt;i_zone[block];</span><br><span class="line">	&#125;</span><br><span class="line">	block -= <span class="number">7</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/bmap0.png" alt="bmap">
<figcaption aria-hidden="true">bmap</figcaption>
</figure>
<h4 id="一级索引部分">一级索引部分</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _bmap(<span class="keyword">struct</span> m_inode * inode,<span class="type">int</span> block,<span class="type">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (block&lt;<span class="number">512</span>) &#123;</span><br><span class="line"> <span class="comment">// 如果是创建，并且该 i 节点中对应间接块字段为 0，表明文件是首次使用间接块，则需申请 </span></span><br><span class="line"> <span class="comment">// 一磁盘块用于存放间接块信息，并将此实际磁盘块号填入间接块字段中。然后设置 i 节点 </span></span><br><span class="line"> <span class="comment">// 已修改标志和修改时间。</span></span><br><span class="line">		<span class="keyword">if</span> (create &amp;&amp; !inode-&gt;i_zone[<span class="number">7</span>])</span><br><span class="line">			<span class="keyword">if</span> (inode-&gt;i_zone[<span class="number">7</span>]=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">				inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">				inode-&gt;i_ctime=CURRENT_TIME;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (!inode-&gt;i_zone[<span class="number">7</span>])</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!(bh = bread(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">7</span>])))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		i = ((<span class="type">unsigned</span> <span class="type">short</span> *) (bh-&gt;b_data))[block];</span><br><span class="line">		<span class="keyword">if</span> (create &amp;&amp; !i)</span><br><span class="line">			<span class="keyword">if</span> (i=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">				((<span class="type">unsigned</span> <span class="type">short</span> *) (bh-&gt;b_data))[block]=i;</span><br><span class="line">				bh-&gt;b_dirt=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		brelse(bh);</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	block -= <span class="number">512</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/bmap1.png" alt="bmap1">
<figcaption aria-hidden="true">bmap1</figcaption>
</figure>
<h4 id="二级索引部分">二级索引部分</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _bmap(<span class="keyword">struct</span> m_inode * inode,<span class="type">int</span> block,<span class="type">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (create &amp;&amp; !inode-&gt;i_zone[<span class="number">8</span>])</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_zone[<span class="number">8</span>]=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">			inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">			inode-&gt;i_ctime=CURRENT_TIME;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_zone[<span class="number">8</span>])</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">8</span>])))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	i = ((<span class="type">unsigned</span> <span class="type">short</span> *)bh-&gt;b_data)[block&gt;&gt;<span class="number">9</span>];</span><br><span class="line">	<span class="keyword">if</span> (create &amp;&amp; !i)</span><br><span class="line">		<span class="keyword">if</span> (i=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">			((<span class="type">unsigned</span> <span class="type">short</span> *) (bh-&gt;b_data))[block&gt;&gt;<span class="number">9</span>]=i;</span><br><span class="line">			bh-&gt;b_dirt=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">if</span> (!i)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,i)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	i = ((<span class="type">unsigned</span> <span class="type">short</span> *)bh-&gt;b_data)[block&amp;<span class="number">511</span>];</span><br><span class="line">	<span class="keyword">if</span> (create &amp;&amp; !i)</span><br><span class="line">		<span class="keyword">if</span> (i=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">			((<span class="type">unsigned</span> <span class="type">short</span> *) (bh-&gt;b_data))[block&amp;<span class="number">511</span>]=i;</span><br><span class="line">			bh-&gt;b_dirt=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="new-block">new block</h3>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/new_block.png" alt="new block">
<figcaption aria-hidden="true">new block</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">new_block</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(sb = get_super(dev)))</span><br><span class="line">		panic(<span class="string">&quot;trying to get new block from nonexistant device&quot;</span>);</span><br><span class="line">	j = <span class="number">8192</span>;</span><br><span class="line">	<span class="comment">// 扫描逻辑块位图，寻找首个 0 比特位，寻找空闲逻辑块，获取放置该逻辑块的块号。</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;<span class="number">8</span> ; i++)</span><br><span class="line">		<span class="keyword">if</span> (bh=sb-&gt;s_zmap[i])</span><br><span class="line">			<span class="keyword">if</span> ((j=find_first_zero(bh-&gt;b_data))&lt;<span class="number">8192</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"> <span class="comment">// 如果全部扫描完还没找到(i&gt;=8 或 j&gt;=8192)或者位图所在的缓冲块无效(bh=NULL)则 返回 0， </span></span><br><span class="line"> <span class="comment">// 退出（没有空闲逻辑块）。</span></span><br><span class="line">	<span class="keyword">if</span> (i&gt;=<span class="number">8</span> || !bh || j&gt;=<span class="number">8192</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (set_bit(j,bh-&gt;b_data))</span><br><span class="line">		panic(<span class="string">&quot;new_block: bit already set&quot;</span>);</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">	 <span class="comment">// 置对应缓冲区块的已修改标志。如果新逻辑块大于该设备上的总逻辑块数，则说明指定逻辑块在 </span></span><br><span class="line"> <span class="comment">// 对应设备上不存在。申请失败，返回 0，退出。</span></span><br><span class="line">	j += i*<span class="number">8192</span> + sb-&gt;s_firstdatazone<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (j &gt;= sb-&gt;s_nzones)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 读取设备上的该新逻辑块数据（验证）。如果失败则死机。</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh=getblk(dev,j)))</span><br><span class="line">		panic(<span class="string">&quot;new_block: cannot get block&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_count != <span class="number">1</span>)</span><br><span class="line">		panic(<span class="string">&quot;new block: count is != 1&quot;</span>);</span><br><span class="line">		<span class="comment">// 将该新逻辑块清零，并置位更新标志和已修改标志。然后释放对应缓冲区，返回逻辑块号。</span></span><br><span class="line">	clear_block(bh-&gt;b_data);</span><br><span class="line">	bh-&gt;b_uptodate = <span class="number">1</span>;</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="写文件">写文件</h2>
<p>写入文件最终映射到sys_write,sys_write判断要写的文件的类型，对于目录文件调用file_write</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_write</span><span class="params">(<span class="keyword">struct</span> m_inode * inode, <span class="keyword">struct</span> file * filp, <span class="type">char</span> * buf, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">off_t</span> pos;</span><br><span class="line">	<span class="type">int</span> block,c;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">char</span> * p;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ok, append may not work when many processes are writing at the same time</span></span><br><span class="line"><span class="comment"> * but so what. That way leads to madness anyway.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">if</span> (filp-&gt;f_flags &amp; O_APPEND)<span class="comment">//如果设置了文件尾部添加标志，将pos移动到文件末尾</span></span><br><span class="line">		pos = inode-&gt;i_size;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pos = filp-&gt;f_pos;</span><br><span class="line">	<span class="keyword">while</span> (i&lt;count) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(block = create_block(inode,pos/BLOCK_SIZE))) <span class="comment">//创建逻辑块并反回块号</span></span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,block)))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 求出文件读写指针在数据块中的偏移值 c，将 p 指向读出数据块缓冲区中开始读取的位置。置该 </span></span><br><span class="line"> <span class="comment">// 缓冲区已修改标志。</span></span><br><span class="line">		c = pos % BLOCK_SIZE;</span><br><span class="line">		p = c + bh-&gt;b_data;</span><br><span class="line">		bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line"> <span class="comment">// 从开始读写位置到块末共可写入 c=(BLOCK_SIZE-c)个字节。若 c 大于剩余还需写入的字节数 </span></span><br><span class="line"> <span class="comment">// (count-i)，则此次只需再写入 c=(count-i)即可。</span></span><br><span class="line">		c = BLOCK_SIZE-c;</span><br><span class="line">		<span class="keyword">if</span> (c &gt; count-i) c = count-i;</span><br><span class="line">  <span class="comment">// 文件读写指针前移此次需写入的字节数。如果当前文件读写指针位置值超过了文件的大小，则 </span></span><br><span class="line"> <span class="comment">// 修改 i 节点中文件大小字段，并置 i 节点已修改标志。</span></span><br><span class="line">		pos += c;</span><br><span class="line">		<span class="keyword">if</span> (pos &gt; inode-&gt;i_size) &#123;</span><br><span class="line">			inode-&gt;i_size = pos;</span><br><span class="line">			inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// 已写入字节计数累加此次写入的字节数 c。从用户缓冲区 buf 中复制 c 个字节到高速缓冲区中 p </span></span><br><span class="line"> <span class="comment">// 指向开始的位置处。然后释放该缓冲区。</span></span><br><span class="line">		i += c;</span><br><span class="line">		<span class="keyword">while</span> (c--&gt;<span class="number">0</span>)</span><br><span class="line">			*(p++) = get_fs_byte(buf++);</span><br><span class="line">		brelse(bh);</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_mtime = CURRENT_TIME;</span><br><span class="line">    <span class="comment">// 如果此次操作不是在文件尾添加数据，则把文件读写指针调整到当前读写位置，并更改 i 节点修改 </span></span><br><span class="line"> <span class="comment">// 时间为当前时间。</span></span><br><span class="line">	<span class="keyword">if</span> (!(filp-&gt;f_flags &amp; O_APPEND)) &#123;</span><br><span class="line">		filp-&gt;f_pos = pos;</span><br><span class="line">		inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (i?i:<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关闭文件">关闭文件</h2>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215212431360.png" alt="关闭文件">
<figcaption aria-hidden="true">关闭文件</figcaption>
</figure>
<p>注意file_table[64]是所有进程共享的，所以这里是减小引用计数而不是清零。当引用计数为0的时候空闲</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd)</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= NR_OPEN)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	current-&gt;close_on_exec &amp;= ~(<span class="number">1</span>&lt;&lt;fd);</span><br><span class="line">	<span class="keyword">if</span> (!(filp = current-&gt;filp[fd]))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	current-&gt;filp[fd] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (filp-&gt;f_count == <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;Close: file count is 0&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (--filp-&gt;f_count)</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	iput(filp-&gt;f_inode);<span class="comment">//释放文件i结点。减小在inode_table[32]里面的引用计数。当引用计数为0的时候空闲</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除文件">删除文件</h2>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215235324252.png" alt="删除文件">
<figcaption aria-hidden="true">删除文件</figcaption>
</figure>
<h3 id="i_nlinks">i_nlinks</h3>
<p>linux文件可以建立链接。文件没多被链接一次文件的的inode的i_nlinks会加1。也就是多个目录项链接到一个文件inode</p>
<figure>
<img src="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%200.11%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/image-20231215214155373.png" alt="i_nlinks">
<figcaption aria-hidden="true">i_nlinks</figcaption>
</figure>
<h3 id="sys_unlink">sys_unlink</h3>
<p>检查文件是否能被删除。函数整个流程和打开文件很类似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * basename;</span><br><span class="line">	<span class="type">int</span> namelen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>, * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(dir = dir_namei(name,&amp;namelen,&amp;basename)))</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="keyword">if</span> (!namelen) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(inode = iget(dir-&gt;i_dev, de-&gt;inode))) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		brelse(bh);</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((dir-&gt;i_mode &amp; S_ISVTX) &amp;&amp; !suser() &amp;&amp;</span><br><span class="line">	    current-&gt;euid != inode-&gt;i_uid &amp;&amp;</span><br><span class="line">	    current-&gt;euid != dir-&gt;i_uid) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		iput(inode);</span><br><span class="line">		brelse(bh);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">		iput(inode);<span class="comment">//释放文件结点</span></span><br><span class="line">		iput(dir); <span class="comment">//释放枝梢结点</span></span><br><span class="line">		brelse(bh);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_nlinks) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Deleting nonexistent file (%04x:%d), %d\n&quot;</span>,</span><br><span class="line">			inode-&gt;i_dev,inode-&gt;i_num,inode-&gt;i_nlinks);</span><br><span class="line">		inode-&gt;i_nlinks=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//具体的文件删除操作：</span></span><br><span class="line">	de-&gt;inode = <span class="number">0</span>;</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	inode-&gt;i_nlinks--;<span class="comment">//修改i_nlinks</span></span><br><span class="line">	inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">	iput(inode);<span class="comment">//释放文件结点</span></span><br><span class="line">	iput(dir);<span class="comment">//释放枝梢结点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>### iput</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iput</span><span class="params">(<span class="keyword">struct</span> m_inode * inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!inode)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	wait_on_inode(inode);</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_count)</span><br><span class="line">		panic(<span class="string">&quot;iput: trying to free free inode&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_pipe) &#123;</span><br><span class="line">		wake_up(&amp;inode-&gt;i_wait);</span><br><span class="line">		<span class="keyword">if</span> (--inode-&gt;i_count)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		free_page(inode-&gt;i_size);</span><br><span class="line">		inode-&gt;i_count=<span class="number">0</span>;</span><br><span class="line">		inode-&gt;i_dirt=<span class="number">0</span>;</span><br><span class="line">		inode-&gt;i_pipe=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_dev) &#123;</span><br><span class="line">		inode-&gt;i_count--;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode)) &#123;</span><br><span class="line">		sync_dev(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">	&#125;</span><br><span class="line">repeat:</span><br><span class="line">    <span class="comment">//减少引用计数</span></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_count&gt;<span class="number">1</span>) &#123;</span><br><span class="line">		inode-&gt;i_count--;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//当链接数目等于0的时候，释放逻辑块</span></span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_nlinks) &#123;</span><br><span class="line">		truncate(inode);<span class="comment">//释放文件在硬盘上占据的逻辑块</span></span><br><span class="line">		free_inode(inode);<span class="comment">//将i结点位图对应的位清空，将inode_table里面对应的表现清空</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//将i结点内容同步到外设</span></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_dirt) &#123;</span><br><span class="line">		write_inode(inode);	<span class="comment">/* we can sleep - so do again */</span></span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_count--;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="truncate">truncate</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">truncate</span><span class="params">(<span class="keyword">struct</span> m_inode * inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">     <span class="comment">//如果该文件不是目录文件或者普通文件则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (!(S_ISREG(inode-&gt;i_mode) || S_ISDIR(inode-&gt;i_mode)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_zone[i]) &#123;</span><br><span class="line">			free_block(inode-&gt;i_dev,inode-&gt;i_zone[i]);<span class="comment">//将izone的前7位对应的逻辑块在逻辑位图上对应清零</span></span><br><span class="line">			inode-&gt;i_zone[i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	free_ind(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">7</span>]);<span class="comment">//释放一级</span></span><br><span class="line">	free_dind(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">8</span>]);<span class="comment">//释放二级</span></span><br><span class="line">	inode-&gt;i_zone[<span class="number">7</span>] = inode-&gt;i_zone[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">	inode-&gt;i_size = <span class="number">0</span>;</span><br><span class="line">	inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="free_inode">free_inode</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_inode</span><span class="params">(<span class="keyword">struct</span> m_inode * inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!inode)<span class="comment">//结点为空返回</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//设备号为0</span></span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_dev) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(inode,<span class="number">0</span>,<span class="keyword">sizeof</span>(*inode));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//结点被多次引用</span></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_count&gt;<span class="number">1</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;trying to free inode with count=%d\n&quot;</span>,inode-&gt;i_count);</span><br><span class="line">		panic(<span class="string">&quot;free_inode&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//结点的nlinks不为0</span></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_nlinks)</span><br><span class="line">		panic(<span class="string">&quot;trying to free inode with links&quot;</span>);</span><br><span class="line">    <span class="comment">//超级块不存在</span></span><br><span class="line">	<span class="keyword">if</span> (!(sb = get_super(inode-&gt;i_dev)))</span><br><span class="line">		panic(<span class="string">&quot;trying to free inode on nonexistent device&quot;</span>);</span><br><span class="line">    <span class="comment">//检查i结点号</span></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_num &lt; <span class="number">1</span> || inode-&gt;i_num &gt; sb-&gt;s_ninodes)</span><br><span class="line">		panic(<span class="string">&quot;trying to free inode 0 or nonexistant inode&quot;</span>);</span><br><span class="line">    <span class="comment">//结点i结点位图不存在</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh=sb-&gt;s_imap[inode-&gt;i_num&gt;&gt;<span class="number">13</span>]))</span><br><span class="line">		panic(<span class="string">&quot;nonexistent imap in superblock&quot;</span>);</span><br><span class="line">    <span class="comment">//清空对应的位</span></span><br><span class="line">	<span class="keyword">if</span> (clear_bit(inode-&gt;i_num&amp;<span class="number">8191</span>,bh-&gt;b_data))</span><br><span class="line">		printk(<span class="string">&quot;free_inode: bit already cleared.\n\r&quot;</span>);</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(inode,<span class="number">0</span>,<span class="keyword">sizeof</span>(*inode));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/12/08/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%C2%B7/" rel="prev" title="并发请求处理">
                  <i class="fa fa-chevron-left"></i> 并发请求处理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/12/12/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%200.11%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E8%A7%A3%E8%AF%BB/" rel="next" title="Linux 0.11中断机制解读">
                  Linux 0.11中断机制解读 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sherecho</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">438k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:39</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
<br /> #运行时间
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("01/01/2022 15:54:40");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/sherecho" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"sherecho","repo":"gittalks","client_id":"9912d1c0be5407c8e1bd","client_secret":"6d0991787716b87d7d041c5d2a38b8cc3ddc5944","admin_user":null,"distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"ca6c8aae16bf1a2350054494eda40517"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
