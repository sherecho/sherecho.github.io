<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">


<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"sherecho.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="进程1的创建和运行与缓冲区相关操作 进程0创建进程1 在linux系统中所有进程都是基于父子进程创建机制，由父进程创建的。通过父进程调用fork函数实现 12345678static inline _syscall0(int,fork) &#x2F;&#x2F;定义了fork函数    void main(void)&amp;#123;...if(!fork())init();...&amp;#125; syscall0">
<meta property="og:type" content="article">
<meta property="og:title" content="进程1的创建和运行与缓冲区相关操作">
<meta property="og:url" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="sherecho的个人博客">
<meta property="og:description" content="进程1的创建和运行与缓冲区相关操作 进程0创建进程1 在linux系统中所有进程都是基于父子进程创建机制，由父进程创建的。通过父进程调用fork函数实现 12345678static inline _syscall0(int,fork) &#x2F;&#x2F;定义了fork函数    void main(void)&amp;#123;...if(!fork())init();...&amp;#125; syscall0">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231021140609566.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231021142821942.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231021194439886.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231024234009247.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231025115927391.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231106001422585.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231111154453412.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115093737912.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115095947238.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115100227526.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115101114916.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115101151894.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231120095719241.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115104420577.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115104420577.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231120112732685.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231122092315542.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/缓冲绘图2.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231127094912326.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203231230513.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129104547640.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129105131834.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129105434871.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129101121864.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129095311681.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129110807043.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129111725176.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129111811437.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129111130011.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203234247319.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203233251707.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205203527644.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205203724496.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205204603044.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203234309406.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203234655944.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203232737245.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205210257879.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/文件系统.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205214503609.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205200445043.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205221522997.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211092132558.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211095203241.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211100257070.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211102021214.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211131847124.png">
<meta property="og:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/文件系统加载示意图.png">
<meta property="article:published_time" content="2023-11-19T16:28:24.000Z">
<meta property="article:modified_time" content="2024-01-22T15:43:19.836Z">
<meta property="article:author" content="sherecho">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231021140609566.png">


<link rel="canonical" href="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/","path":"2023/11/20/Linux011内核学习笔记/第三章笔记/","title":"进程1的创建和运行与缓冲区相关操作"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>进程1的创建和运行与缓冲区相关操作 | sherecho的个人博客</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>



<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">sherecho的个人博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">弱小和无知不是生存的障碍，傲慢才是</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="nav-number">1.</span> <span class="nav-text">进程1的创建和运行与缓冲区相关操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B0%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B1"><span class="nav-number">1.1.</span> <span class="nav-text">进程0创建进程1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#syscall0"><span class="nav-number">1.1.1.</span> <span class="nav-text">syscall0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#system_call"><span class="nav-number">1.1.2.</span> <span class="nav-text">system_call</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys_fork"><span class="nav-number">1.1.3.</span> <span class="nav-text">sys_fork</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find_empty_process"><span class="nav-number">1.1.4.</span> <span class="nav-text">find_empty_process</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy_process"><span class="nav-number">1.1.5.</span> <span class="nav-text">copy_process</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E7%9A%84%E5%88%86%E6%9E%90"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">输入参数的分析:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E8%BF%9B%E7%A8%8B1%E5%88%9B%E5%BB%BAtask_struct%E5%B0%86%E8%BF%9B%E7%A8%8B0%E7%9A%84task_struct%E5%86%85%E5%AE%B9%E5%A4%8D%E5%88%B6%E7%BB%991"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">为进程1创建task_struct,将进程0的task_struct内容复制给1</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#get_free_page"><span class="nav-number">1.1.5.2.1.</span> <span class="nav-text">get_free_page</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8Btss%E5%AF%84%E5%AD%98%E5%99%A8%E7%AD%89%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">子进程tss寄存器等设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E8%BF%9B%E7%A8%8B1%E7%9A%84%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">设置进程1的分页管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#copy_mem"><span class="nav-number">1.1.5.4.1.</span> <span class="nav-text">copy_mem</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#copy_page_tables"><span class="nav-number">1.1.5.4.2.</span> <span class="nav-text">copy_page_tables</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#free_page_tablesfree-tables"><span class="nav-number">1.1.5.4.3.</span> <span class="nav-text">free_page_tables&#x2F;free tables</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy_process%E5%B0%8F%E7%BB%93"><span class="nav-number">1.1.5.5.</span> <span class="nav-text">copy_process小结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy_process-%E5%90%8E%E6%97%B6%E4%BB%A3"><span class="nav-number">1.1.6.</span> <span class="nav-text">copy_process 后时代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sys_fork-1"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">_sys_fork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#system_call-1"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">_system_call</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E5%88%B0%E5%8E%9F%E7%82%B9fork-if__res0"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">回到原点fork： if(__res&gt;&#x3D;0)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E5%88%B0main"><span class="nav-number">1.1.6.4.</span> <span class="nav-text">回到main</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-%E5%9B%BE%E8%A7%A3%E8%BF%9B%E7%A8%8B0%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B1%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.7.</span> <span class="nav-text">小结
：图解进程0创建进程1全过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%81%9A%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">1.2.</span> <span class="nav-text">内核做第一次进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pause"><span class="nav-number">1.2.1.</span> <span class="nav-text">pause</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#schedule"><span class="nav-number">1.2.2.</span> <span class="nav-text">schedule</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch_to"><span class="nav-number">1.2.3.</span> <span class="nav-text">switch_to</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AE%E8%BD%AC%E5%88%B0%E8%BF%9B%E7%A8%8B1%E6%89%A7%E8%A1%8C"><span class="nav-number">1.3.</span> <span class="nav-text">轮转到进程1执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#init"><span class="nav-number">1.3.1.</span> <span class="nav-text">init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setup"><span class="nav-number">1.3.2.</span> <span class="nav-text">setup</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B1%E8%AE%BE%E7%BD%AE%E7%A1%AC%E7%9B%98%E7%9A%84hd_info"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">进程1设置硬盘的hd_info</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E7%A1%AC%E7%9B%98%E7%9A%84%E5%BC%95%E5%AF%BC%E5%9D%97%E5%88%B0%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">读取硬盘的引导块到缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E9%87%8F%E7%BA%A7%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">数量级关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bread"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">bread</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#getblk"><span class="nav-number">1.3.2.5.1.</span> <span class="nav-text">getblk</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#get_hash_table"><span class="nav-number">1.3.2.5.2.</span> <span class="nav-text">get_hash_table</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%90%8C%E6%AD%A5%E5%8A%A0%E9%94%81%E7%AD%89%E5%BE%85%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="nav-number">1.3.2.5.3.</span> <span class="nav-text">一些同步加锁等待函数解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#remove_from_queues"><span class="nav-number">1.3.2.5.4.</span> <span class="nav-text">remove_from_queues</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#insert_into_queues"><span class="nav-number">1.3.2.5.5.</span> <span class="nav-text">insert_into_queues</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ll_rw_block"><span class="nav-number">1.3.2.5.6.</span> <span class="nav-text">ll_rw_block</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#make_request"><span class="nav-number">1.3.2.5.7.</span> <span class="nav-text">make_request</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#add_request"><span class="nav-number">1.3.2.5.8.</span> <span class="nav-text">add_request</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dev-request_fn-do_hd_request"><span class="nav-number">1.3.2.5.9.</span> <span class="nav-text">(dev-&gt;request_fn)();
do_hd_request</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hd_out"><span class="nav-number">1.3.2.5.10.</span> <span class="nav-text">hd_out</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hd_interrupt"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">_hd_interrupt:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E7%9B%98%E8%BF%98%E6%B2%A1%E5%AE%8C%E6%88%90%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%BF%9B%E7%A8%8B01%E7%9A%84%E5%88%87%E6%8D%A2"><span class="nav-number">1.3.2.7.</span> <span class="nav-text">读盘还没完成这个过程中进程0，1的切换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#sleep_on"><span class="nav-number">1.3.2.7.1.</span> <span class="nav-text">sleep_on</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#read_intr"><span class="nav-number">1.3.2.7.2.</span> <span class="nav-text">read_intr</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#end_request"><span class="nav-number">1.3.2.7.3.</span> <span class="nav-text">end_request</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B1%E5%94%A4%E9%86%92"><span class="nav-number">1.3.2.8.</span> <span class="nav-text">进程1唤醒</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#unlock_buffer"><span class="nav-number">1.3.2.8.1.</span> <span class="nav-text">unlock_buffer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#wake_up"><span class="nav-number">1.3.2.8.2.</span> <span class="nav-text">wake_up</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%99%E9%87%8C%E6%98%AFnull%E8%BF%98%E6%98%AFtmp%E7%9A%84%E8%AE%A8%E8%AE%BA---sleep_on%E6%B7%B1%E5%B1%82%E9%80%BB%E8%BE%91%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E6%A0%88%E7%9A%84%E5%94%A4%E9%86%92%E9%98%9F%E5%88%97"><span class="nav-number">1.3.2.8.3.</span> <span class="nav-text">这里是null还是tmp的讨论---sleep_on深层逻辑基于内核栈的唤醒队列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bread%E5%90%8E%E6%97%B6%E4%BB%A3"><span class="nav-number">1.3.2.9.</span> <span class="nav-text">bread后时代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.2.10.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#minix-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.2.10.1.</span> <span class="nav-text">MINIX 文件系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-1"><span class="nav-number">1.3.2.10.2.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A5c%E8%AF%AD%E8%A8%80open%E5%92%8Cclose%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E8%A7%A3%E9%87%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.2.10.3.</span> <span class="nav-text">以c语言open和close返回的是什么解释文件系统</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%8D%A2%E6%A0%B9%E8%AE%BE%E5%A4%87%E8%BF%9B%E7%A8%8B1%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%99%9A%E6%8B%9F%E7%9B%98%E5%B9%B6%E6%9B%B4%E6%8D%A2%E8%B7%9F%E8%AE%BE%E5%A4%87%E4%B8%BA%E8%99%9A%E6%8B%9F%E7%9B%98"><span class="nav-number">1.3.2.11.</span> <span class="nav-text">更换根设备（进程1格式化虚拟盘并更换跟设备为虚拟盘）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.2.12.</span> <span class="nav-text">加载根文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A6%96%E5%85%88%E6%8C%82%E8%BD%BDsuper_block%E6%95%B0%E7%BB%84%E5%92%8Cfile_table%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.2.12.1.</span> <span class="nav-text">首先挂载super_block数组和file_table数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#read_super%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B6%85%E7%BA%A7%E5%9D%97"><span class="nav-number">1.3.2.12.2.</span> <span class="nav-text">read_super加载文件系统超级块</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#get_super"><span class="nav-number">1.3.2.12.2.1.</span> <span class="nav-text">get_super</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%A8super_block%E9%87%8C%E9%9D%A2%E6%89%BE%E5%88%B0%E7%A9%BA%E9%A1%B9"><span class="nav-number">1.3.2.12.2.2.</span> <span class="nav-text">在super_block里面找到空项</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8A%8A%E8%B6%85%E7%BA%A7%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%88%B0%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%8D%E5%8A%A0%E8%BD%BD%E5%88%B0super-block"><span class="nav-number">1.3.2.12.2.3.</span> <span class="nav-text">把超级块加载到缓冲区，再加载到super
block</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%8C%E5%96%84super-blok%E4%B8%ADi%E7%BB%93%E7%82%B9%E4%BD%8D%E5%9B%BE%E9%80%BB%E8%BE%91%E4%BD%8D%E5%9B%BE"><span class="nav-number">1.3.2.12.2.4.</span> <span class="nav-text">完善super
blok中i结点位图逻辑位图</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E6%A0%B9%E8%AE%BE%E5%A4%87%E7%9A%84%E6%A0%B9i%E7%BB%93%E7%82%B9%E6%8C%82%E8%BD%BDsuper-block%E4%B8%8A"><span class="nav-number">1.3.2.12.3.</span> <span class="nav-text">将根设备的根i结点挂载super
block上</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#igetget_empty_inode"><span class="nav-number">1.3.2.12.3.1.</span> <span class="nav-text">iget:get_empty_inode</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#iget"><span class="nav-number">1.3.2.12.3.2.</span> <span class="nav-text">iget</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#read_inode"><span class="nav-number">1.3.2.12.3.3.</span> <span class="nav-text">read_inode</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BF%9B%E7%A8%8B1%E5%85%B3%E8%81%94%E8%AE%BE%E7%BD%AEroot%E5%92%8Cpwd"><span class="nav-number">1.3.2.12.4.</span> <span class="nav-text">将根文件系统与进程1关联，设置root和pwd</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E8%99%9A%E6%8B%9F%E7%9B%98%E7%A9%BA%E9%97%B2%E5%9D%97%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.2.12.5.</span> <span class="nav-text">计算虚拟盘空闲块信息</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dirt-update%E4%BD%8D%E5%88%86%E6%9E%90"><span class="nav-number">1.3.2.13.</span> <span class="nav-text">dirt ，update位分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-%E5%92%8Cinline%E5%88%86%E6%9E%90"><span class="nav-number">1.4.</span> <span class="nav-text">static 和inline分析</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sherecho"
      src="/medias/avatars/baojie.jpg">
  <p class="site-author-name" itemprop="name">sherecho</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/sherecho" title="Github → https:&#x2F;&#x2F;github.com&#x2F;sherecho" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>Github</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_45934869/" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_45934869&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-user fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sherecho.cn/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/medias/avatars/baojie.jpg">
      <meta itemprop="name" content="sherecho">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sherecho的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="进程1的创建和运行与缓冲区相关操作 | sherecho的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          进程1的创建和运行与缓冲区相关操作
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-20 00:28:24" itemprop="dateCreated datePublished" datetime="2023-11-20T00:28:24+08:00">2023-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-22 23:43:19" itemprop="dateModified" datetime="2024-01-22T23:43:19+08:00">2024-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/LINUX011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">LINUX011内核学习笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>69k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:03</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="进程1的创建和运行与缓冲区相关操作">进程1的创建和运行与缓冲区相关操作</h1>
<h2 id="进程0创建进程1">进程0创建进程1</h2>
<p>在linux系统中所有进程都是基于父子进程创建机制，由父进程创建的。通过父进程调用fork函数实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> _syscall0(<span class="type">int</span>,fork) <span class="comment">//定义了fork函数</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(!fork())</span><br><span class="line">init();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="syscall0">syscall0</h3>
<p>执行fork函数实际是执行到unistd.h的syscall0（）：</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231021140609566.png" alt="image-20231021140609566">
<figcaption aria-hidden="true">image-20231021140609566</figcaption>
</figure>
<p>**_syscall0** 是一个宏定义，其实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall0(type,name) \</span></span><br><span class="line"><span class="meta">type name(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">long __res; \</span></span><br><span class="line"><span class="meta">__asm__ volatile (<span class="string">&quot;int $0x80&quot;</span> \</span></span><br><span class="line"><span class="meta">	: <span class="string">&quot;=a&quot;</span> (__res) \</span></span><br><span class="line"><span class="meta">	: <span class="string">&quot;0&quot;</span> (__NR_##name)); \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (__res &gt;= 0) \</span></span><br><span class="line"><span class="meta">	return (type) __res; \</span></span><br><span class="line"><span class="meta">errno = -__res; \</span></span><br><span class="line"><span class="meta">return -1; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>因此这里_syscall0(int,fork) 展开后是这样的：.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="type">long</span> __res; \</span><br><span class="line">__asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span> \ <span class="comment">//init 0x80是所有系统调用函数的总入口，fork是其中之一        </span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;=a&quot;</span> (__res) \ <span class="comment">//第一个冒号之后是输出部分，将_res赋值给eax</span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;0&quot;</span> (__NR_fork))</span>; \ <span class="comment">//第二个冒号后是输入部分，&quot;0&quot;同上寄存器，即eax ，__NR_fork=2，赋值给eax，紧接着就进行了0</span></span><br><span class="line">    <span class="comment">//x80软中断</span></span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \ <span class="comment">//int 0x80中断返回后，将执行这一句</span></span><br><span class="line">	<span class="keyword">return</span> (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__NR_fork=2，其实是描述了操作系统专用性的那几个函数，体现了操作系统的确定性。其定义了
<strong>fork</strong> 函数，其通过 <strong>0x80</strong>
中断进入系统调用。</p>
<p>在 Linux
内核中，每个系统调用都具有唯一的一个系统调用功能号。这些功能号定义在文件
include/unistd.h 中第 60 行开始处。例如，fork系统调用的功能号是
2，定义为符号 ___NR_fork 。这些系统调用功能号实际上对应于
include/linux/sys.h 中定义的系统调用处理程序指针数组表 sys_call_table[]
中项的索引值。因此 write() 系统调用的处理程序指针就位于该数组的项 2 处。
sys_call_table:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn_ptr sys_call_table[] = &#123; sys_setup, sys_exit, sys_fork, sys_read,</span><br><span class="line">sys_write, ...(此处省略）) &#125;;</span><br></pre></td></tr></table></figure>
<p>当应用程序经过库函数向内核发出一个中断调用 int 0x80
时，就开始执行一个系统调用。其中寄存器 eax
中存放着系统调用号，而携带的参数可依次存放在寄存器 ebx、ecx 和 edx
中。因此 Linux 0.11
内核中用户程序能够向内核最多直接传递三个参数，当然也可以不带参数。上面fork就是向内核传了一个参数，处理系统调用中断
int 0x80 的过程是程序 kernel/system_call.s 中的 system_call 。</p>
<p>调用流程：</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231021142821942.png" alt="image-20231021142821942">
<figcaption aria-hidden="true">image-20231021142821942</figcaption>
</figure>
<p>调用int
$0x80cpu从三特权级转到0特权级，硬件对<strong>ss，ESP,EFLAGS,CS,EIP进行压栈</strong>，压栈的EIP指向当前指令的下一行即if(__res&gt;=0)这一行，这就是进程0从fork函数系统调用中断返回后执行的第一条指令位置。跳转到system_call执行：</p>
<h3 id="system_call">system_call</h3>
<p>system_call程序解读如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_system_call:</span><br><span class="line">	cmpl $nr_system_calls-1,%eax #判断是否越界了，系统调用一共72个（sys_call_table),eax 是传入参数，以fork为例传入的eax=2，是_NR_fork</span><br><span class="line">	ja bad_sys_call #如果越界了则跳到越界代码，中断返回，返回eax的值为-1，以fork为例代表创建失败</span><br><span class="line">	push %ds   #下面的6个push都是为了copy_process()的参数</span><br><span class="line">	push %es</span><br><span class="line">	push %fs</span><br><span class="line">	pushl %edx</span><br><span class="line">	pushl %ecx		# push %ebx,%ecx,%edx as parameters</span><br><span class="line">	pushl %ebx		# to the system call</span><br><span class="line">	movl $0x10,%edx		# set up ds,es to kernel space</span><br><span class="line">	mov %dx,%ds</span><br><span class="line">	mov %dx,%es</span><br><span class="line">	movl $0x17,%edx		# fs points to local data space</span><br><span class="line">	mov %dx,%fs</span><br><span class="line">	call _sys_call_table(,%eax,4) #通过查_sys_call_table确定要调用的函数，以fork为例，eax=2，这里就是</span><br><span class="line">	# call ( _sys_call_table+2*4),也就是_sys_fork的入口</span><br><span class="line">	pushl %eax</span><br><span class="line">	movl _current,%eax</span><br><span class="line">	cmpl $0,state(%eax)		# state</span><br><span class="line">	jne reschedule</span><br><span class="line">	cmpl $0,counte</span><br></pre></td></tr></table></figure>
<p>call _sys_call_table(,%eax,4)
#通过查_sys_call_table确定要调用的函数，以fork为例，eax=2，这里就是 call
(
_sys_call_table+2*4),偏移寻址，也就是_sys_fork的入口，因为sys_call_table的每一项都有四个字节，所有就是sys_call_table[2]</p>
<p><strong>注意</strong>：这里system_call函数还没执行完，因此调用sys_call_table会压栈保护现场，这里压栈体现在后面copy_process函数的第六个参数long
none</p>
<h3 id="sys_fork">sys_fork</h3>
<p>sys_fork 函数解析如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_sys_fork:</span><br><span class="line">	call _find_empty_process #调用找到空进程的函数</span><br><span class="line">	testl %eax,%eax #如果返回的是-EAGAIN说明已经有64个进程运行没有空进程 testl 是指令的名称，</span><br><span class="line">	#它用于执行逻辑“与”操作。测试%eax中的值，将结果存储在标志寄存器中，而不更改%eax的值。如果%eax中的值为零</span><br><span class="line">	#那么零标志位（ZF）将被设置为1；否则，ZF将被清除为0。</span><br><span class="line">	js 1f #跳转到ret</span><br><span class="line">	#1f 中的 1 表示标签的唯一标识符或编号。在某些汇编语言中，数字编号用于标识不同的标签，使程序员能够更容易地跟踪和管理它们。</span><br><span class="line">    # f 表示标签的类型。在汇编语言中，f 可能表示 &quot;forward&quot;，</span><br><span class="line">	# 表示这是一个向前跳转的标签。这意味着在程序执行期间，它将在后续的指令中使用，通常用于条件分支或循环的目标。</span><br><span class="line">	push %gs #这5个参数也作为copy_process的参数</span><br><span class="line">	pushl %esi</span><br><span class="line">	pushl %edi</span><br><span class="line">	pushl %ebp</span><br><span class="line">	pushl %eax</span><br><span class="line">	call _copy_process #调用赋值进程函数，这里call没有传参就是因为其实上面压栈的把参数压进去了</span><br><span class="line">	addl $20,%esp</span><br><span class="line">1:	ret</span><br></pre></td></tr></table></figure>
<h3 id="find_empty_process">find_empty_process</h3>
<p><strong>在task[64]中为进程1申请空闲位置并获取进程号</strong></p>
<p>sched_init()函数已经对task[64]除了o以外的项都清空了，这里调用函数得到的就是1，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EAGAIN 11</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_empty_process</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">     <span class="comment">//last_pid 只增不减，起个日志的作用</span></span><br><span class="line">	repeat:</span><br><span class="line">	    <span class="comment">//判断溢出</span></span><br><span class="line">		<span class="keyword">if</span> ((++last_pid)&lt;<span class="number">0</span>) </span><br><span class="line">		   last_pid=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span> ; i&lt;NR_TASKS ; i++)</span><br><span class="line">			<span class="keyword">if</span> (task[i] &amp;&amp; task[i]-&gt;pid == last_pid) </span><br><span class="line">			    <span class="keyword">goto</span> repeat;<span class="comment">//检测有没有进程号撞了</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span> ; i&lt;NR_TASKS ; i++)</span><br><span class="line">		<span class="keyword">if</span> (!task[i])</span><br><span class="line">			<span class="keyword">return</span> i;<span class="comment">//返回空进程</span></span><br><span class="line">	<span class="keyword">return</span> -EAGAIN; <span class="comment">//进程满了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231021194439886.png" alt="image-20231021194439886">
<figcaption aria-hidden="true">image-20231021194439886</figcaption>
</figure>
<h3 id="copy_process">copy_process</h3>
<p>一个函数的参数不是由函数定义的，而是由函数定义以外的程序通过压栈的方式做出来的，是操作系统底层代码与应用层代码的差异之一。</p>
<p><code>call _copy_process #调用赋值进程函数，这里call没有传参就是因为其实上面压栈的把参数压进去了</code></p>
<h4 id="输入参数的分析"><strong>输入参数的分析</strong>:</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc 编译器传参：进栈，在栈里面传参，从右到左压栈</span></span><br><span class="line"> <span class="comment">//none是现场保护，是call_system_table 还没运行完没出栈</span></span><br><span class="line"> <span class="comment">//nr是一，是返回的空闲进程号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr,<span class="type">long</span> ebp,<span class="type">long</span> edi,<span class="type">long</span> esi,<span class="type">long</span> gs,<span class="type">long</span> none,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> ebx,<span class="type">long</span> ecx,<span class="type">long</span> edx,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> fs,<span class="type">long</span> es,<span class="type">long</span> ds,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> eip,<span class="type">long</span> cs,<span class="type">long</span> eflags,<span class="type">long</span> esp,<span class="type">long</span> ss)</span><span class="comment">//调用的时候传参是在压栈的时候就干了的所以看上去好像没传参数</span></span><br></pre></td></tr></table></figure>
<p>gcc 编译器传参：进栈，在栈里面传参，从右到左压栈</p>
<p><code>long eip,long cs,long eflags,long esp,long ss</code>是指发生init
0x80软中断的时候cpu硬件压栈的，EIP指向当前指令的下一行即if(__res&gt;=0)这一行，这就是进程0从fork函数系统调用中断返回后执行的第一条指令位置，cs，是用户的代码段</p>
<p><code>long ebx,long ecx,long edx,long fs,long es,long ds</code>在systemcall里面被压栈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   push %ds   #下面的6个push都是为了copy_process()的参数</span><br><span class="line">push %es</span><br><span class="line">push %fs</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ecx		# push %ebx,%ecx,%edx as parameters</span><br><span class="line">pushl %ebx		# to the system call</span><br></pre></td></tr></table></figure>
<p><code>long none</code> 是现场保护，是call_system_table
还没运行完没出栈</p>
<p><code>int nr,long ebp,long edi,long esi,long gs</code>是sys_fork里面的压栈部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   push %gs #这5个参数也作为copy_process的参数</span><br><span class="line">pushl %esi</span><br><span class="line">pushl %edi</span><br><span class="line">pushl %ebp</span><br><span class="line">pushl %eax</span><br></pre></td></tr></table></figure>
<p>eax是空闲进程号，对应nr</p>
<h4 id="为进程1创建task_struct将进程0的task_struct内容复制给1">为进程1创建task_struct,将进程0的task_struct内容复制给1</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr,<span class="type">long</span> ebp,<span class="type">long</span> edi,<span class="type">long</span> esi,<span class="type">long</span> gs,<span class="type">long</span> none,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> ebx,<span class="type">long</span> ecx,<span class="type">long</span> edx,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> fs,<span class="type">long</span> es,<span class="type">long</span> ds,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> eip,<span class="type">long</span> cs,<span class="type">long</span> eflags,<span class="type">long</span> esp,<span class="type">long</span> ss)</span><span class="comment">//调用的时候传参是在压栈的时候就干了的所以看上去好像没传参数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="comment">// 在16MB内存的最高端获取一页，这里强制类型转换的意思就是把这个页当作task_union使用</span></span><br><span class="line">	p = (<span class="keyword">struct</span> task_struct *) get_free_page();<span class="comment">//获得空闲页：mem_map count=0,mem_map的管理单位是页，从高往低找空闲页。和task不一样，task是从低到高</span></span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	task[nr] = p;</span><br><span class="line">   ...</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get_free_page()算法是从主内存地址的高端向低端递进寻找，进程1是开机以来操作系统第一次在主内存申请空闲页面，因此是16M的最末端。</p>
<p>get_free_page()代码分析如下所示：</p>
<h5 id="get_free_page"><strong>get_free_page</strong></h5>
<p>get_free_page()函数用于在主内存区中申请一页空闲内存页，并返回物理内存页的起始地址。它首先
扫描内存页面字节图数组 mem_map[]，寻找值是 0
的字节项（对应空闲页面）。若无则返回 0 结束，表
示物理内存已使用完。若找到值为 0 的字节，则将其置
1，并换算出对应空闲页面的起始地址。然后对
该内存页面作清零操作。最后返回该空闲页面的物理内存起始地址。</p>
<p><code>"std ; repne ; scasb\n\t"</code></p>
<ol type="1">
<li><code>std</code>：这是 "set direction flag"
的缩写，用于设置字符串操作方向。在使用<code>scasb</code>等指令进行字符串操作时，方向标志的设置将影响字符串操作的方向。<code>std</code>
指令设置方向标志，使字符串操作向前（高地址到低地址）进行。通常，<code>std</code>
用于向后搜索或处理字符串。</li>
<li><code>repne</code>：这是 "repeat while not equal"
的缩写，通常与字符串操作指令一起使用，表示重复执行字符串操作，直到特定条件不再满足。在这种情况下，它可能与
<code>scasb</code>
一起使用，以重复执行比较操作，直到找到匹配的字节或直到遍历整个字符串。</li>
<li><code>scasb</code>：这是 "scan string, compare with byte"
的缩写，用于在字符串中扫描并比较字节。它通常与<code>repne</code>结合使用，以在字符串中搜索特定字节值，并在找到匹配值时停止搜索。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_free_page</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//asm(&quot;ax&quot;)：这是内联汇编指令，它告诉编译器将变量 __res 存储在汇编寄存器 &quot;ax&quot; 中。</span></span><br><span class="line"><span class="comment">//这意味着在编译和运行时，变量 __res 将与寄存器 &quot;ax&quot; 相关联。</span></span><br><span class="line"><span class="keyword">register</span> <span class="type">unsigned</span> <span class="type">long</span> __res <span class="title function_">asm</span><span class="params">(<span class="string">&quot;ax&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">__asm__(<span class="string">&quot;std ; repne ; scasb\n\t&quot;</span> <span class="comment">// 反向扫描串（mem map[])//al(0)与di不相等则重复，找引用计数0的页</span></span><br><span class="line">	<span class="string">&quot;jne 1f\n\t&quot;</span>  <span class="comment">//// 如果没有等于 0 的字节，则跳转结束（返回 0）。</span></span><br><span class="line">	<span class="string">&quot;movb $1,1(%%edi)\n\t&quot;</span> <span class="comment">/// 将对应页面的内存映像位置 1。 将1赋值给edi+1的位置，在mem_map【】中</span></span><br><span class="line">	<span class="string">&quot;sall $12,%%ecx\n\t&quot;</span> <span class="comment">//ecx左移12位，页的相对地址， 页面数*4K = 相对页面起始地址。（&quot;c&quot; (PAGING_PAGES)，ecx=页面数） </span></span><br><span class="line">	<span class="string">&quot;addl %2,%%ecx\n\t&quot;</span> <span class="comment">// 再加上低端内存地址，即获得页面实际物理起始地址。LOW_MEM+ecx</span></span><br><span class="line">	<span class="string">&quot;movl %%ecx,%%edx\n\t&quot;</span> <span class="comment">//将页面实际起始地址Îedx 寄存器。</span></span><br><span class="line">	<span class="string">&quot;movl $1024,%%ecx\n\t&quot;</span> <span class="comment">// 寄存器 ecx 置计数值 1024</span></span><br><span class="line">	<span class="string">&quot;leal 4092(%%edx),%%edi\n\t&quot;</span> <span class="comment">// 将 4092+edx 的位置Îedi(该页面的末端)。 </span></span><br><span class="line">	<span class="string">&quot;rep ; stosl\n\t&quot;</span> <span class="comment">// 将 edi 所指内存清零（反方向，也即将该页面清零）。</span></span><br><span class="line">	<span class="string">&quot;movl %%edx,%%eax\n&quot;</span> <span class="comment">// 将页面起始地址Îeax（返回值）。 </span></span><br><span class="line">	<span class="string">&quot;1:&quot;</span></span><br><span class="line">	:<span class="string">&quot;=a&quot;</span> (__res)</span><br><span class="line">	:<span class="string">&quot;0&quot;</span> (<span class="number">0</span>),<span class="string">&quot;i&quot;</span> (LOW_MEM),<span class="string">&quot;c&quot;</span> (PAGING_PAGES),</span><br><span class="line">	<span class="string">&quot;D&quot;</span> (mem_map+PAGING_PAGES<span class="number">-1</span>) <span class="comment">//函数刚开始的时候edi=LOW_MEM低端内存地址，ecx=页数。edx=mem_map+PAGING_PAGES-1，mem_map的高端</span></span><br><span class="line">	:<span class="string">&quot;di&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> __res; <span class="comment">// 返回空闲页面地址（如果无空闲也则返回 0）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译函数返回值一般是eax寄存器 &gt;为啥是从高往低找空闲页？
让线性地址和物理地址之间的映射关系更加难以捉摸
&gt;拿的是线性页还是物理页？ &gt;拿的页是0特权还是三特权
拿的是物理内存的页，16M的最后一个页
&gt;为什么用父进程创建子进程而不是用模版的机制？</p>
<p>引导，子进程先共享父进程的代码 &gt;父进程怎么没倒腾页表？</p>
<p>进程0和内核的代码是在一起的，段是重叠的，进程0用了一部分kernel的代码</p>
<h4 id="子进程tss寄存器等设置">子进程tss寄存器等设置</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr,<span class="type">long</span> ebp,<span class="type">long</span> edi,<span class="type">long</span> esi,<span class="type">long</span> gs,<span class="type">long</span> none,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> ebx,<span class="type">long</span> ecx,<span class="type">long</span> edx,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> fs,<span class="type">long</span> es,<span class="type">long</span> ds,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> eip,<span class="type">long</span> cs,<span class="type">long</span> eflags,<span class="type">long</span> esp,<span class="type">long</span> ss)</span><span class="comment">//调用的时候传参是在压栈的时候就干了的所以看上去好像没传参数</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    task[nr] = p;<span class="comment">//nr是eax传进来的空进程，创建子进程1时nr=1</span></span><br><span class="line">	*p = *current;	<span class="comment">//当前进程是父进程，将进程0的task struct复制给进程1，栈没用复制，只是复制了task struct/* NOTE! this doesn&#x27;t copy the supervisor stack */</span></span><br><span class="line">	p-&gt;state = TASK_UNINTERRUPTIBLE;<span class="comment">//子进程挂起，中断也唤不醒，看看这个是不是真的有效？？</span></span><br><span class="line">	p-&gt;pid = last_pid;<span class="comment">//开始子进程的个性化设置</span></span><br><span class="line">	p-&gt;father = current-&gt;pid;</span><br><span class="line">	p-&gt;counter = p-&gt;priority;</span><br><span class="line">	p-&gt;signal = <span class="number">0</span>;</span><br><span class="line">	p-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">	p-&gt;leader = <span class="number">0</span>;		<span class="comment">/* process leadership doesn&#x27;t inherit */</span></span><br><span class="line">	p-&gt;utime = p-&gt;stime = <span class="number">0</span>;</span><br><span class="line">	p-&gt;cutime = p-&gt;cstime = <span class="number">0</span>;</span><br><span class="line">	p-&gt;start_time = jiffies;</span><br><span class="line">	p-&gt;tss.back_link = <span class="number">0</span>;</span><br><span class="line">	p-&gt;tss.esp0 = PAGE_SIZE + (<span class="type">long</span>) p;</span><br><span class="line">	p-&gt;tss.ss0 = <span class="number">0x10</span>;</span><br><span class="line">	p-&gt;tss.eip = eip;<span class="comment">//为第二次执行fork中的if(__res&gt;=0)埋下伏笔                                      </span></span><br><span class="line">	p-&gt;tss.eflags = eflags;</span><br><span class="line">	p-&gt;tss.eax = <span class="number">0</span>;</span><br><span class="line">	p-&gt;tss.ecx = ecx;</span><br><span class="line">	p-&gt;tss.edx = edx;</span><br><span class="line">	p-&gt;tss.ebx = ebx;</span><br><span class="line">	p-&gt;tss.esp = esp;</span><br><span class="line">	p-&gt;tss.ebp = ebp;</span><br><span class="line">	p-&gt;tss.esi = esi;</span><br><span class="line">	p-&gt;tss.edi = edi;</span><br><span class="line">	p-&gt;tss.es = es &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.cs = cs &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.ss = ss &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.ds = ds &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.fs = fs &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.gs = gs &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.ldt = _LDT(nr);<span class="comment">//挂接子进程的ldt</span></span><br><span class="line">	p-&gt;tss.trace_bitmap = <span class="number">0x80000000</span>;</span><br><span class="line">	<span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">		__asm__(<span class="string">&quot;clts ; fnsave %0&quot;</span>::<span class="string">&quot;m&quot;</span> (p-&gt;tss.i387));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ <img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231024234009247.png" alt="image-20231024234009247"></p>
<h4 id="设置进程1的分页管理">设置进程1的分页管理</h4>
<p>4GB的空间 ,64个进程，4*1024 MB <span class="math inline">\(2^{12}/2^6=64\)</span>
MB，进程段限长：0~0x9f：0xa0. 段限长 <span class="math inline">\(160\times4KB=640KB\)</span></p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231025115927391.png" alt="image-20231025115927391">
<figcaption aria-hidden="true">image-20231025115927391</figcaption>
</figure>
<p>分页机制是基于保护模式的，访问控制是基于段的，不存在没有pe的pg。要设置进程1的分页，首先要设置进程1的分段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr,<span class="type">long</span> ebp,<span class="type">long</span> edi,<span class="type">long</span> esi,<span class="type">long</span> gs,<span class="type">long</span> none,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> ebx,<span class="type">long</span> ecx,<span class="type">long</span> edx,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> fs,<span class="type">long</span> es,<span class="type">long</span> ds,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> eip,<span class="type">long</span> cs,<span class="type">long</span> eflags,<span class="type">long</span> esp,<span class="type">long</span> ss)</span><span class="comment">//调用的时候传参是在压栈的时候就干了的所以看上去好像没传参数</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">		__asm__(<span class="string">&quot;clts ; fnsave %0&quot;</span>::<span class="string">&quot;m&quot;</span> (p-&gt;tss.i387));</span><br><span class="line">	<span class="keyword">if</span> (copy_mem(nr,p)) &#123;</span><br><span class="line">		task[nr] = <span class="literal">NULL</span>;</span><br><span class="line">		free_page((<span class="type">long</span>) p);</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	&#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="copy_mem">copy_mem</h5>
<p>设置子进程的代码段，数据段及创建复制子进程的第一个页表</p>
<p>设置新的进程的代码段基址是nr*64MB，每个进程分配了64MB的线性地址空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_mem</span><span class="params">(<span class="type">int</span> nr,<span class="keyword">struct</span> task_struct * p)</span></span><br><span class="line">    <span class="comment">/*首先要维护线性地址，因此需要得到父进程代码段数据 段的基址和限长，这个基址存在于当前进程的ldt中</span></span><br><span class="line"><span class="comment">     给子进程分配新的代码段和数据段，系统设置给每个进程分配64M的虚拟内存空间，因此第nr个进程代码段和数据段的基址就是nr *         0x4000000（因为linux0.11版本默认的虚拟空间是共用一个虚拟空间互不重叠的，这个在高版本是有所变化的。然后把设置好的基       址填到子进程的ldt中。至此就完成了段-线性地址的设置，下面设置分页。</span></span><br><span class="line"><span class="comment">     这里的策略是拷贝父进程的页表，也就是说子进程和父进程共享相同的页面，完成这个过程需要用到copy_page_tables函数进行操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#123;   <span class="comment">//段基质（两个不一样），段限长（两个一样）</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> old_data_base,new_data_base,data_limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> old_code_base,new_code_base,code_limit;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取父进程的段基址和段限ch</span></span><br><span class="line">	code_limit=get_limit(<span class="number">0x0f</span>);<span class="comment">//0x0f段选择子，得到段限长</span></span><br><span class="line">	data_limit=get_limit(<span class="number">0x17</span>);</span><br><span class="line">	old_code_base = get_base(current-&gt;ldt[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//current 是一个全局的结构体指针定义如下所示，指向当前指向的进程，一开始指向的是进程0</span></span><br><span class="line">    <span class="comment">//struct task_struct *current = &amp;(init_task.task);</span></span><br><span class="line">	old_data_base = get_base(current-&gt;ldt[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//数据段和代码段要对齐</span></span><br><span class="line">	<span class="keyword">if</span> (old_data_base != old_code_base)</span><br><span class="line">		panic(<span class="string">&quot;We don&#x27;t support separate I&amp;D&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (data_limit &lt; code_limit)</span><br><span class="line">		panic(<span class="string">&quot;Bad data_limit&quot;</span>);</span><br><span class="line">	<span class="comment">//新的代码段和数据段对齐，0x4000 000 ：64M</span></span><br><span class="line">	new_data_base = new_code_base = nr * <span class="number">0x4000000</span>;</span><br><span class="line">	p-&gt;start_code = new_code_base;</span><br><span class="line">	set_base(p-&gt;ldt[<span class="number">1</span>],new_code_base);<span class="comment">//设置子进程段基址</span></span><br><span class="line">	set_base(p-&gt;ldt[<span class="number">2</span>],new_data_base);</span><br><span class="line">	<span class="comment">//把子进程的内存的线性地址折腾完了</span></span><br><span class="line">    <span class="comment">//折腾物理地址</span></span><br><span class="line">	<span class="keyword">if</span> (copy_page_tables(old_data_base,new_data_base,data_limit)) &#123;</span><br><span class="line">		free_page_tables(new_data_base,data_limit); <span class="comment">//copy失败，释放新的页表</span></span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>求段基址和段限长</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 取段选择符 segment 指定的描述符中的段限长值。 </span></span><br><span class="line"> <span class="comment">// 指令 lsl 是 Load Segment Limit 缩写。它从指定段描述符中取出分散的限长比特位拼成完整的 </span></span><br><span class="line"> <span class="comment">// 段限长值放入指定寄存器中。所得的段限长是实际字节数减 1，因此这里还需要加 1 后才返回。 </span></span><br><span class="line"> <span class="comment">// %0 - 存放段长值(字节数)；%1 - 段选择符 segment。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_limit(segment) (&#123; \</span></span><br><span class="line"><span class="meta">unsigned long __limit; \</span></span><br><span class="line"><span class="meta">__asm__(<span class="string">&quot;lsll %1,%0\n\tincl %0&quot;</span>:<span class="string">&quot;=r&quot;</span> (__limit):<span class="string">&quot;r&quot;</span> (segment)); \</span></span><br><span class="line"><span class="meta">__limit;&#125;)</span></span><br><span class="line"><span class="comment">//求段基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_base(ldt) _get_base( ((char *)&amp;(ldt)) )</span></span><br><span class="line"><span class="comment">// 从地址 addr 处描述符中取段基地址。功能与_set_base()正好相反。 </span></span><br><span class="line"><span class="comment">// edx - 存放基地址(__base)；%1 - 地址 addr 偏移 2；%2 - 地址 addr 偏移 4；%3 - addr 偏移 7。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _get_base(addr) (&#123;\</span></span><br><span class="line"><span class="meta">unsigned long __base; \</span></span><br><span class="line"><span class="meta">__asm__(<span class="string">&quot;movb %3,%%dh\n\t&quot;</span> \ <span class="comment">// 取[addr+7]处基址高 16 位的高 8 位(位 31-24)-&gt;dh</span></span></span><br><span class="line">	<span class="string">&quot;movb %2,%%dl\n\t&quot;</span> \  <span class="comment">// 取[addr+4]处基址高 16 位的低 8 位(位 23-16)-&gt;dl。</span></span><br><span class="line">	<span class="string">&quot;shll $16,%%edx\n\t&quot;</span> \ <span class="comment">// 基地址高 16 位移到 edx 中高 16 位处。</span></span><br><span class="line">	<span class="string">&quot;movw %1,%%dx&quot;</span> \ <span class="comment">// 取[addr+2]处基址低 16 位(位 15-0)Îdx。</span></span><br><span class="line">	:<span class="string">&quot;=d&quot;</span> (__base) \</span><br><span class="line">	:<span class="string">&quot;m&quot;</span> (*((addr)+<span class="number">2</span>)), \</span><br><span class="line">	 <span class="string">&quot;m&quot;</span> (*((addr)+<span class="number">4</span>)), \</span><br><span class="line">	 <span class="string">&quot;m&quot;</span> (*((addr)+<span class="number">7</span>))); \</span><br><span class="line">__base;&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="copy_page_tables">copy_page_tables</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from 父进程的段基地址，to子进程的段基地址</span></span><br><span class="line"><span class="comment">/*分页实现的是从线性地址到物理地址的转换，因此函数的输入一定是线性地址，</span></span><br><span class="line"><span class="comment">  为了方便遍历，把单位换算为M,此处硬件MMU要求页目录项的地址4M对齐*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_page_tables</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> from,<span class="type">unsigned</span> <span class="type">long</span> to,<span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> * from_page_table;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> * to_page_table;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> this_page;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> * from_dir, * to_dir;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr;</span><br><span class="line">	<span class="comment">//0x3fffff 是4M，是一个页表的管辖范围，22位from和to必须是4MB的整数倍，一个页表对应的4MB连续的线性地址空间必须是从0开始的4MB的整数倍数</span></span><br><span class="line">    <span class="comment">//4M一个页表的覆盖范围，如果4M没有对齐则panic，cpu的要求，cpu分页要对齐，页目录表项要4M对齐</span></span><br><span class="line">	<span class="keyword">if</span> ((from&amp;<span class="number">0x3fffff</span>) || (to&amp;<span class="number">0x3fffff</span>)) <span class="comment">//必须满足后面22位都是0才能不panic</span></span><br><span class="line">		panic(<span class="string">&quot;copy_page_tables called with wrong alignment&quot;</span>);</span><br><span class="line">	<span class="comment">//父进程页目录表项的位置，一个线性地址空间对应一个页目录表</span></span><br><span class="line">	<span class="comment">//from右移20位：以MB为单位，例如0010 0000 0000 0000 0000 000》0010就是2M</span></span><br><span class="line">    <span class="comment">//确保from_dir是4M的倍数</span></span><br><span class="line">	from_dir = (<span class="type">unsigned</span> <span class="type">long</span> *) ((from&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>); <span class="comment">/* _pg_dir = 0 */</span><span class="comment">//地址数由字节数变成M，c：1100，ffc肯定是4的倍数，因此是4M的倍数,</span></span><br><span class="line">	<span class="comment">//有ff是因为32位地址，右移20，还剩12位，ffc，十二位</span></span><br><span class="line">	<span class="comment">//确保to_dir是4M的倍数</span></span><br><span class="line">	to_dir = (<span class="type">unsigned</span> <span class="type">long</span> *) ((to&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>);</span><br><span class="line">	<span class="comment">//22 4MB，这里是不足4M强行等于一个4M</span></span><br><span class="line">	size = ((<span class="type">unsigned</span>) (size+<span class="number">0x3fffff</span>)) &gt;&gt; <span class="number">22</span>;</span><br><span class="line">	<span class="comment">//基地址的低第一位：是P位，指示页表是否存在</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    以进程0创建进程1为例：</span></span><br><span class="line"><span class="comment">    此时from：0</span></span><br><span class="line"><span class="comment">       to :0x4000000(64M)</span></span><br><span class="line"><span class="comment">       SIZE:段限长：0x9f（0xa0)160*4k=640k</span></span><br><span class="line"><span class="comment">       进行单位换算以后就变成了：from 0M TO 64 M size=1M ,如下所示的from和to两个指针进行拷贝操作</span></span><br><span class="line"><span class="comment">       ---------</span></span><br><span class="line"><span class="comment">       ^(0M from_dir)</span></span><br><span class="line"><span class="comment">       ----...----</span></span><br><span class="line"><span class="comment">              ^(64M to_dir)</span></span><br><span class="line"><span class="comment">       两层循环：</span></span><br><span class="line"><span class="comment">       for 父进程的遍历页目录项对应的每一个页表</span></span><br><span class="line"><span class="comment">           if子进程页目录项存在报错</span></span><br><span class="line"><span class="comment">           if 父进程页目录项不存在则跳过，继续便历下一项</span></span><br><span class="line"><span class="comment">                    为子进程的页表分配页面</span></span><br><span class="line"><span class="comment">         for 遍历该页目录项指向的页表对应的页面</span></span><br><span class="line"><span class="comment">             if（父进程该页表不存在，则跳过，继续遍历下一个页表）</span></span><br><span class="line"><span class="comment">             (用nr来记录要遍历的页面的数量，如果from是0M也就是进程0，则要遍历的页面长度是段限长640K.这是因为进程0比较特殊，与内核公用了一个页表，进程0的东西不能都被拷贝给子进程，否则就有问题了.比如进程0的页目录由16	M后两页的内容，后两页有子进程1的task_struct 和页表项，这俩子进程应该无权访问，否则子进程就可以修改自己的页面映射关系了显然不大对。)</span></span><br><span class="line"><span class="comment">             注意：1M以内的页面不参与用户分页管理</span></span><br><span class="line"><span class="comment">             1.设置页面的权限，因为子进程共享了父进程的页面，因此应该把子进程的权限设置位只读，否则两个进程如果存在同时写的情况就会出错。子进程如果需要修改页面，则会引出后面要讲的copy on write</span></span><br><span class="line"><span class="comment">             2.将页面填到子进程的页表（页框frame）里面，完成映射关系</span></span><br><span class="line"><span class="comment">             3.修改mem_map里面的引用计数，表面该页面被新增的进程占用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">for</span>( ; size--&gt;<span class="number">0</span> ; from_dir++,to_dir++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> &amp; *to_dir)<span class="comment">//1:p位。</span></span><br><span class="line">			panic(<span class="string">&quot;copy_page_tables: already exist&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (!(<span class="number">1</span> &amp; *from_dir)) <span class="comment">//from的页表不存在，则没必要进行下去了</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//0xfffff000 低12位清零，from_dir是页目录项的地址，高20位是页表的地址</span></span><br><span class="line">		from_page_table = (<span class="type">unsigned</span> <span class="type">long</span> *) (<span class="number">0xfffff000</span> &amp; *from_dir);</span><br><span class="line">		<span class="keyword">if</span> (!(to_page_table = (<span class="type">unsigned</span> <span class="type">long</span> *) get_free_page()))<span class="comment">//获得空页面。上次调用是在找一个空页面放         task_struct</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">/* Out of memory, see freeing */</span></span><br><span class="line">		*to_dir = ((<span class="type">unsigned</span> <span class="type">long</span>) to_page_table) | <span class="number">7</span>;<span class="comment">//这次是给子进程的基地址段分配页面</span></span><br><span class="line">		nr = (from==<span class="number">0</span>)?<span class="number">0xA0</span>:<span class="number">1024</span>; <span class="comment">//0xa0：0x9f 可以查看init task里面的ldt的断限长计算，把父进程的160个页表项640KB空间的内容复制给子进程</span></span><br><span class="line">		<span class="keyword">for</span> ( ; nr-- &gt; <span class="number">0</span> ; from_page_table++,to_page_table++) &#123;</span><br><span class="line">			this_page = *from_page_table;</span><br><span class="line">			<span class="keyword">if</span> (!(<span class="number">1</span> &amp; this_page)) </span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			this_page &amp;= ~<span class="number">2</span>;<span class="comment">//设置页表属性~2:101 用户，只读，存在</span></span><br><span class="line">			*to_page_table = this_page;</span><br><span class="line">			<span class="keyword">if</span> (this_page &gt; LOW_MEM) &#123;<span class="comment">//1MB以内的内核区域不参与用户分页管理</span></span><br><span class="line">				*from_page_table = this_page;</span><br><span class="line">				this_page -= LOW_MEM;</span><br><span class="line">				this_page &gt;&gt;= <span class="number">12</span>; <span class="comment">//</span></span><br><span class="line">				mem_map[this_page]++; <span class="comment">//增加引用计数，说明这个页被这个进程占用了</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	invalidate();<span class="comment">//重置CR3为0，刷新页变换高速缓存</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="free_page_tablesfree-tables">free_page_tables/free tables</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 根据指定的线性地址和限长（页表个数），释放对应内存页表所指定的内存块并置表项空闲。 </span></span><br><span class="line"> <span class="comment">// 页目录位于物理地址 0 开始处，共 1024 项，占 4K 字节。每个目录项指定一个页表。 </span></span><br><span class="line"> <span class="comment">// 页表从物理地址 0x1000 处开始（紧接着目录空间），每个页表有 1024 项，也占 4K 内存。 </span></span><br><span class="line"> <span class="comment">// 每个页表项对应一页物理内存（4K）。目录项和页表项的大小均为 4 个字节。 </span></span><br><span class="line"> <span class="comment">// 参数：from - 起始基地址；size - 释放的长度。 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">free_page_tables</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> from,<span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *pg_table;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> * dir, nr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (from &amp; <span class="number">0x3fffff</span>)</span><br><span class="line">		panic(<span class="string">&quot;free_page_tables called with wrong alignment&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!from)</span><br><span class="line">		panic(<span class="string">&quot;Trying to free up swapper memory space&quot;</span>);</span><br><span class="line">	size = (size + <span class="number">0x3fffff</span>) &gt;&gt; <span class="number">22</span>; <span class="comment">// 计算所占页目录项数(4M 的进位整数倍)，也即所占页表数。整数不足1为1</span></span><br><span class="line">	dir = (<span class="type">unsigned</span> <span class="type">long</span> *) ((from&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>); <span class="comment">/* _pg_dir = 0 */</span></span><br><span class="line">	<span class="keyword">for</span> ( ; size--&gt;<span class="number">0</span> ; dir++) &#123; <span class="comment">// size 现在是需要被释放内存的目录项数。</span></span><br><span class="line">		<span class="keyword">if</span> (!(<span class="number">1</span> &amp; *dir)) <span class="comment">// 如果该目录项无效(P 位=0)，则继续。</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		pg_table = (<span class="type">unsigned</span> <span class="type">long</span> *) (<span class="number">0xfffff000</span> &amp; *dir); <span class="comment">// 取目录项中页表地址。 </span></span><br><span class="line">		<span class="keyword">for</span> (nr=<span class="number">0</span> ; nr&lt;<span class="number">1024</span> ; nr++) &#123; <span class="comment">// 每个页表有 1024 个页项。</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="number">1</span> &amp; *pg_table) <span class="comment">// 若该页表项有效(P 位=1)，则释放对应内存页。</span></span><br><span class="line">				free_page(<span class="number">0xfffff000</span> &amp; *pg_table);</span><br><span class="line">			*pg_table = <span class="number">0</span>; <span class="comment">// 该页表项内容清零。</span></span><br><span class="line">			pg_table++; <span class="comment">// 指向页表中下一项。</span></span><br><span class="line">		&#125;</span><br><span class="line">		free_page(<span class="number">0xfffff000</span> &amp; *dir); <span class="comment">// 释放该页表所占内存页面。但由于页表在 </span></span><br><span class="line">       <span class="comment">// 物理地址 1M 以内，所以这句什么都不做。</span></span><br><span class="line">		*dir = <span class="number">0</span>; <span class="comment">// 对相应页表的目录项清零。 </span></span><br><span class="line">	&#125;</span><br><span class="line">	invalidate();<span class="comment">// 刷新页变换高速缓冲</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (addr &lt; LOW_MEM) <span class="keyword">return</span>;<span class="comment">//1M一下的内核页不操作直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (addr &gt;= HIGH_MEMORY) </span><br><span class="line">		panic(<span class="string">&quot;trying to free nonexistent page&quot;</span>);</span><br><span class="line">	addr -= LOW_MEM;</span><br><span class="line">	addr &gt;&gt;= <span class="number">12</span>;</span><br><span class="line">	<span class="comment">//修改引用计数</span></span><br><span class="line">	<span class="keyword">if</span> (mem_map[addr]--) <span class="keyword">return</span>; </span><br><span class="line">	mem_map[addr]=<span class="number">0</span>;</span><br><span class="line">	panic(<span class="string">&quot;trying to free free page&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="copy_process小结">copy_process小结：</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr,<span class="type">long</span> ebp,<span class="type">long</span> edi,<span class="type">long</span> esi,<span class="type">long</span> gs,<span class="type">long</span> none,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> ebx,<span class="type">long</span> ecx,<span class="type">long</span> edx,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> fs,<span class="type">long</span> es,<span class="type">long</span> ds,</span></span><br><span class="line"><span class="params">		<span class="type">long</span> eip,<span class="type">long</span> cs,<span class="type">long</span> eflags,<span class="type">long</span> esp,<span class="type">long</span> ss)</span><span class="comment">//调用的时候传参是在压栈的时候就干了的所以看上去好像没传参数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span><span class="comment">//子进程的task struct</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">    </span><br><span class="line">	p = (<span class="keyword">struct</span> task_struct *) get_free_page();<span class="comment">//获得空闲页：mem_map count=0,mem_map的管理单位是页，从高往低找空闲页。和task astruct不一样</span></span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	task[nr] = p;<span class="comment">//nr是eax传进来的空进程，创建子进程1时nr=1</span></span><br><span class="line">	*p = *current;	<span class="comment">//当前进程是父进程，将进程0的task struct复制给进程1，栈没用复制，只是复制了task struct/* NOTE! this doesn&#x27;t copy the supervisor stack */</span></span><br><span class="line">	p-&gt;state = TASK_UNINTERRUPTIBLE;<span class="comment">//子进程挂起，中断也唤不醒，看看这个是不是真的有效？？</span></span><br><span class="line">	p-&gt;pid = last_pid;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">		__asm__(<span class="string">&quot;clts ; fnsave %0&quot;</span>::<span class="string">&quot;m&quot;</span> (p-&gt;tss.i387));</span><br><span class="line">	<span class="keyword">if</span> (copy_mem(nr,p)) &#123;</span><br><span class="line">		task[nr] = <span class="literal">NULL</span>;</span><br><span class="line">		free_page((<span class="type">long</span>) p);</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*设置task_struct中与文件相关的成员，包括打开了那些文件p-&gt;filp【20】*/</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NR_OPEN;i++)</span><br><span class="line">		<span class="keyword">if</span> (f=p-&gt;filp[i])</span><br><span class="line">			f-&gt;f_count++;</span><br><span class="line">    <span class="comment">//设置当前工作目录i结点结构</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;pwd)</span><br><span class="line">		current-&gt;pwd-&gt;i_count++;</span><br><span class="line">    <span class="comment">//设置根目录i节点结构</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;root)</span><br><span class="line">		current-&gt;root-&gt;i_count++;</span><br><span class="line">    <span class="comment">//设置执行文件的i结点结构</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;executable)</span><br><span class="line">		current-&gt;executable-&gt;i_count++;</span><br><span class="line">    <span class="comment">//设置子进程的ldt和tss</span></span><br><span class="line">	set_tss_desc(gdt+(nr&lt;&lt;<span class="number">1</span>)+FIRST_TSS_ENTRY,&amp;(p-&gt;tss));</span><br><span class="line">	set_ldt_desc(gdt+(nr&lt;&lt;<span class="number">1</span>)+FIRST_LDT_ENTRY,&amp;(p-&gt;ldt));</span><br><span class="line">    <span class="comment">//改为就绪态</span></span><br><span class="line">	p-&gt;state = TASK_RUNNING;	<span class="comment">/* do this last, just in case */</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">return</span> last_pid;<span class="comment">//last_pid 是在find empty process里面确定的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要创建子进程主要包括以下几个阶段：</p>
<ol type="1">
<li><p>首先要挂号注册，相当于公安局上户口。这一步需要为进程1创建task_struct（其实和PCB的概念一样）。task_struct的内容复制进程0，并对进程1的task_struct,tss做个性化设置。注意，此时数据栈没有复制，这是因为两个进程代码可以是同一份，但是数据不能是同一个。此时用一个空闲页存放task_struct
和内核栈的共用体。</p></li>
<li><p>第二步要建立实体，因为此时虽然登记了，但是没有给子进程分配内存。一个程序要运行要完成取指执行的过程，因此必须要把代码加载到内存中。因此需要建立内存调用的机制，也就是要完善（线性地址和分页）段-&gt;逻辑（线性）地址，和逻辑（线性）地址-&gt;物理地址的映射关系。</p>
<p>这一部分由copy_mem函数完成。首先要维护线性地址，因此需要得到父进程代码段数据
段的基址和限长，这个基址存在于当前进程的ldt中给子进程分配新的代码段和数据段，系统设置给每个进程分配64M的虚拟内存空间，因此第nr个进程代码段和数据段的基址就是nr
*
0x4000000（因为linux0.11版本默认的虚拟空间是共用一个虚拟空间互不重叠的，这个在高版本是有所变化的。然后把设置好的基
址填到子进程的ldt中。至此就完成了段-线性地址的设置，下面设置分页。这里的策略是拷贝父进程的页表，也就是说子进程和父进程共享相同的页面，完成这个过程需要用到copy_page_tables函数进行操作。</p>
<p>copy_page_tables:
==先拷贝页目录表项再拷贝页表项==，这里子进程拥有自己的页表项，这里页表创建以后由于子进程的页面共享了父进程的页面，因此要把父进程的页表项内容复制给子进程的页表项。而页目录项的空间在分页机制建立的时候就已经建好了。这一个函数干的事情就是：填子进程的页目录项，页目录项需要指向的页表就从内存中申请页面把地址填进去，页表指向的页面就是父进程的页面。疑问：既然都是复制，为啥不直接复制父进程的页表（frame
页框)？因为那子进程就完全没有自主性了，也就是说进程的内存共享是页面的共享，但是页表项和页目录项是独立的。这样后面子进程想写入的时候可以copy
on write ，让页表指向新的页面。
这里为啥不用创建页目录表。因为低版本的linux是不同进程共用了一个虚拟空间
，所以是本来就有页目录表的，填进去就可以了，所以里不用创建。</p></li>
<li><p>进程1共享进程0的文件，设置进程1的GDT项</p></li>
<li><p>将进程1设置为就绪态，使得进程可以参与进程间的轮转。</p>
<p><strong>几个小问题</strong>：</p>
<ol type="1">
<li>一个进程线性地址空间：64M，最多页表：<span class="math inline">\(64/4=16个\)</span>
（一个页表管理的空间是4K*1K=4M),那么实际物理内存就16M，可以填满64M的虚拟内存吗？答：可以填满，因为存在共享内存，可以一个物理地址映射到多个线性地址，这实际上就会涉及内存的装入装出问题）</li>
<li>问：为啥head.s设置分页的时候是+7 ，111（user r/w
p）。因为是进程0要用，必须是用户而不是su因此是7不是3</li>
<li>代码哪里体现进程不能访问页表的？</li>
<li>get free page 是物理的地址还是线性的地址？
线性地址。因为恒等映射看上去一样</li>
<li>为什么要用父进程创建子进程，共享了一部分父进程的的代码？因为此时子进程的代码还在磁盘里面，需要利用父进程的机制把子进程的代码加载进来子进程才能运行。</li>
</ol></li>
</ol>
<h3 id="copy_process-后时代">copy_process 后时代</h3>
<h4 id="sys_fork-1">_sys_fork</h4>
<p>执行完copy_process return 返回到sys_fork</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_sys_fork:</span><br><span class="line">	push %gs #这5个参数也作为copy_process的参数</span><br><span class="line">	pushl %esi</span><br><span class="line">	pushl %edi</span><br><span class="line">	pushl %ebp</span><br><span class="line">	pushl %eax</span><br><span class="line">	call _copy_process #调用赋值进程函数，这里call没有传参就是因为其实上面压栈的把参数压进去了</span><br><span class="line">	addl $20,%esp #清栈，把上面push的那五个清理了。因为栈是从高到低生长的，入栈栈顶指针减小，出栈栈顶指针增加。注意：eax是4个字节，gs是两个字节，那为啥是20个字节，因为这里有字节对齐：align 2（2个字（4个字节）对齐））</span><br><span class="line">1:	ret #目前还在0特权级，返回system call</span><br></pre></td></tr></table></figure>
<h4 id="system_call-1">_system_call</h4>
<p>sys_fork
返回则返回到system_call,注意这里的sys_fork是通过<code>call _sys_call_table</code>调用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">reschedule:</span><br><span class="line">	pushl $ret_from_sys_call #先push再jmp其实就是call  _schedule</span><br><span class="line">	jmp _schedule</span><br><span class="line"></span><br><span class="line">_system_call:</span><br><span class="line">	...</span><br><span class="line">	call _sys_call_table(,%eax,4) #通过查_sys_call_table确定要调用的函数，以fork为例，eax=2，这里就是</span><br><span class="line">	# call ( _sys_call_table+2*4),也就是_sys_fork的入口</span><br><span class="line">	pushl %eax  #eax是函数的返回值，也就是sys_fork的返回值：last pid</span><br><span class="line">	movl _current,%eax     #把当前的子进程task_struct 复制给eax</span><br><span class="line">	cmpl $0,state(%eax)		# state 判断当前的子进程状态是不是就绪态0，不是的话可能当前进程时间片到了需要重新调度</span><br><span class="line">	jne reschedule #重新调度</span><br><span class="line">	cmpl $0,counter(%eax)		# counter，检测时间片是否跑完</span><br><span class="line">	je reschedule#如果时间片跑完了重新调度</span><br><span class="line">ret_from_sys_call:</span><br><span class="line">	movl _current,%eax		# task[0] cannot have signals</span><br><span class="line">	cmpl _task,%eax          #将task的首地址（task[0]的地址）和eax做比较，也就是判断当前进程是否为进程0</span><br><span class="line">	je 3f                    #如果是进程0，则直接跳转到下面的3执行</span><br><span class="line">	cmpw $0x0f,CS(%esp)		# was old code segment supervisor ?</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">3:	popl %eax # 将last pid 出栈给cpu的eax#将7个寄存器的值出栈给cpu ，对应前面push进来的七个值</span><br><span class="line">	popl %ebx</span><br><span class="line">	popl %ecx</span><br><span class="line">	popl %edx</span><br><span class="line">	pop %fs</span><br><span class="line">	pop %es</span><br><span class="line">	pop %ds</span><br><span class="line">	iret #中断返回，将cpu硬件在int 80中断压栈的ss esp eflags cs eip的值出栈给cpu对应的寄存器，此时cs：eip指向fork()中int 0x80的下一行 if(__res&gt;=0)处执行</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h4 id="回到原点fork-if__res0">回到原点fork： if(__res&gt;=0)</h4>
<p>绕了一大圈，诸位可能都忘了我们从哪里进来的，进程0创建进程1调用了fork的宏展开，现在我们又回到了fork</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="type">long</span> __res; \</span><br><span class="line">__asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span> \ <span class="comment">//init 0x80是所有系统调用函数的总入口，fork是其中之一        </span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;=a&quot;</span> (__res) \ <span class="comment">//第一个冒号之后是输出部分，将_res赋值给eax</span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;0&quot;</span> (__NR_fork))</span>; \ <span class="comment">//第二个冒号后是输入部分，&quot;0&quot;同上寄存器，即eax ，__NR_fork=2，赋值给eax，紧接着就进行了0</span></span><br><span class="line">    <span class="comment">//x80软中断</span></span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \ <span class="comment">//int 0x80中断返回后，将执行这一句</span></span><br><span class="line">	<span class="keyword">return</span> (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意此处，res代表的就是eax：:<code>"=a" (__res)</code>,因此<code>if (__res &gt;= 0)</code>判断eax是不是大于等于0.此时的eax就是上面popl的eax，也就是last
pid=1（进程1），所以这里是大于等于0的，所以fork返回last pid=1。</p>
<h4 id="回到main">回到main</h4>
<p>fork 返回值是last pid=1，也就是刚创建的子进程pid，这里！last
pid=0,因此跳到pause()函数中执行，这是一个死循环，因为如果不是死循环操作系统就退出了。进入pause就即将开始第一次进程调度过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">   ...</span><br><span class="line">	<span class="keyword">if</span> (!fork()) &#123;		<span class="comment">/* we count on this going ok */</span></span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   NOTE!!   For any other task &#x27;pause()&#x27; would mean we have to get a</span></span><br><span class="line"><span class="comment"> * signal to awaken, but task0 is the sole exception (see &#x27;schedule()&#x27;)</span></span><br><span class="line"><span class="comment"> * as task 0 gets activated at every idle moment (when no other tasks</span></span><br><span class="line"><span class="comment"> * can run). For task0 &#x27;pause()&#x27; just means we go check if some other</span></span><br><span class="line"><span class="comment"> * task can run, and if not we return here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">for</span>(;;) pause();<span class="comment">//死循环，进程调度开始</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结-图解进程0创建进程1全过程">小结
：图解进程0创建进程1全过程</h3>
<h2 id="内核做第一次进程调度">内核做第一次进程调度</h2>
<p>在linux 0.11 进程调度机制中，发生进程切换存在两种情形：</p>
<ul>
<li>时间片用完</li>
<li>进程运行停止（比如等待外设提供数据）</li>
</ul>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231106001422585.png" alt="image-20231106001422585">
<figcaption aria-hidden="true">image-20231106001422585</figcaption>
</figure>
<h3 id="pause">pause</h3>
<p>上一小结说到，fork后，执行到了死循环里面的pause，pause和fork调用一样，也是syscall0的一个宏展开。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//问这里inline去了有区别吗，static只在当前文件有效</span></span><br><span class="line"><span class="comment">//这里的static关键字并不是静态的函数的意思，而是指该函数只在当前文件有效。这里的inline是内联函数，表示</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> _syscall0(<span class="type">int</span>,fork) </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> _syscall0(<span class="type">int</span>,pause)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span> \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="type">long</span> __res; \</span><br><span class="line">__asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span> \ <span class="comment">//init 0x80是所有系统调用函数的总入口，fork是其中之一        </span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;=a&quot;</span> (__res) \ <span class="comment">//第一个冒号之后是输出部分，将_res赋值给eax</span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;0&quot;</span> (__NR_pause))</span>; \ <span class="comment">//第二个冒号后是输入部分，&quot;0&quot;同上寄存器，即eax ，__NR_fork=2，赋值给eax，紧接着就进行了0</span></span><br><span class="line">    <span class="comment">//x80软中断</span></span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \ <span class="comment">//int 0x80中断返回后，将执行这一句</span></span><br><span class="line">	<span class="keyword">return</span> (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们又跳回了熟悉的system_call
,下面的压栈过程和fork的时候如出一辙，只是在<code>call _sys_call_table(,%eax,4)</code>的时候出现差别，这里调用的是<code>sys_pause</code>。因为这里传入的<code>eax</code>是<code>_NR_pause</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_system_call:</span><br><span class="line">	cmpl $nr_system_calls-1,%eax </span><br><span class="line">	ja bad_sys_call #如果越界了则跳到越界代码，中断返回，返回eax的值为-1，以fork为例代表创建失败</span><br><span class="line">	push %ds   #下面的6个push都是为了copy_process()的参数</span><br><span class="line">	...</span><br><span class="line">	call _sys_call_table(,%eax,4) #通过查_sys_call_table确定要调用的函数，以fork为例，eax=2，这里就是</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_pause</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里的TASK_INTERRUPTIBLE，将进程0状态切换到可中断打断状态，注意这里并不是马上就硬件上切换了，要在schedule();才切</span></span><br><span class="line">	<span class="comment">//可中断等待状态：当其它进程发生特定信号才可能将这个进程状态改为就绪态</span></span><br><span class="line">    current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="schedule">schedule</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,next,c;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span><span class="comment">//指针的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span></span><br><span class="line"><span class="comment">/* 检测 alarm（进程的报警定时值），唤醒任何已得到信号的可中断任务 */</span> </span><br><span class="line"><span class="comment">// 从任务数组中最后一个任务开始检测 alarm。</span></span><br><span class="line">	<span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">		<span class="keyword">if</span> (*p) &#123;</span><br><span class="line"><span class="comment">// 如果设置过任务的定时值 alarm，并且已经过期(alarm&lt;jiffies),则在信号位图中置 SIGALRM 信号， </span></span><br><span class="line"><span class="comment">// 即向任务发送 SIGALARM 信号。然后清 alarm。该信号的默认操作是终止进程。 </span></span><br><span class="line"><span class="comment">// jiffies 是系统从开机开始算起的滴答数（10ms/滴答）。定义在 sched.h 第 139 行。</span></span><br><span class="line">			<span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;</span><br><span class="line">					(*p)-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGALRM<span class="number">-1</span>));</span><br><span class="line">					(*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line"><span class="comment">// 如果信号位图中除被阻塞的信号外还有其它信号，并且任务处于可中断状态，则置任务为就绪状态。 </span></span><br><span class="line"><span class="comment">// 其中&#x27;~(_BLOCKABLE &amp; (*p)-&gt;blocked)&#x27;用于忽略被阻塞的信号，但 SIGKILL 和 SIGSTOP 不能被阻塞。</span></span><br><span class="line">			<span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="line">			(*p)-&gt;state==TASK_INTERRUPTIBLE)</span><br><span class="line">				(*p)-&gt;state=TASK_RUNNING;<span class="comment">//置为就绪（可执行）状态。 </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">/* this is the scheduler proper: */</span></span><br><span class="line"><span class="comment">/* 这里是调度程序的主要部分 */</span> </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		c = <span class="number">-1</span>;</span><br><span class="line">		next = <span class="number">0</span>;<span class="comment">//要切换的下一个进程，初始化置0</span></span><br><span class="line">		i = NR_TASKS;<span class="comment">//64</span></span><br><span class="line">		p = &amp;task[NR_TASKS];</span><br><span class="line"><span class="comment">// 这段代码也是从任务数组的最后一个任务开始循环处理，并跳过不含任务的数组槽。比较每个就绪 </span></span><br><span class="line"><span class="comment">// 状态任务的 counter（任务运行时间的递减滴答计数）值，哪一个值大，运行时间还不长，next 就 </span></span><br><span class="line"><span class="comment">// 指向哪个的任务号。</span></span><br><span class="line">		<span class="keyword">while</span> (--i) &#123; <span class="comment">//task数组是从高往低便利的，和find empty process的顺序是不一样的，思考原因：</span></span><br><span class="line">			<span class="keyword">if</span> (!*--p)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//找就绪态度且优先级高的（时间片多）。linux0.11的优先级折成了时间片，把级别折成钱了。时间片越多级别越高</span></span><br><span class="line">			<span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">				c = (*p)-&gt;counter, next = i;</span><br><span class="line">			<span class="comment">// 切换到任务号为 next 的任务运行。next 被初始化为 0。因此若系统中没有任何其它任务 </span></span><br><span class="line">           <span class="comment">// 可运行时，则 next 始终为 0。因此调度函数会在系统空闲时去执行任务 0。此时任务 0 仅执行 </span></span><br><span class="line">          <span class="comment">// pause()系统调用，并又会调用本函数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果比较得出有 counter 值大于 0 的结果，则退出 循环，执行任务切换 </span></span><br><span class="line">		<span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// 否则就根据每个任务的优先权值，更新每一个任务的 counter 值. </span></span><br><span class="line">       <span class="comment">// counter 值的计算方式为 counter = counter /2 + priority。这里计算过程不考虑进程的状态。</span></span><br><span class="line">		<span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">			<span class="keyword">if</span> (*p)</span><br><span class="line">				(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">						(*p)-&gt;priority;</span><br><span class="line">	&#125;</span><br><span class="line">	switch_to(next);<span class="comment">// 切换到任务号为 next 的任务，并运行之。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch_to">switch_to</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> //这段代码属于内核态</span><br><span class="line">#define switch_to(n) &#123;\  </span><br><span class="line">struct &#123;long a,b;&#125; __tmp; \ </span><br><span class="line">__asm__(&quot;cmpl %%ecx,_current\n\t&quot; \ // 任务 n 是当前任务吗?(current ==task[n]?) </span><br><span class="line">	&quot;je 1f\n\t&quot; \ // 如果是当前任务，则什么都不做，退出。</span><br><span class="line">	&quot;movw %%dx,%1\n\t&quot; \  //把edx的里面的tss复制给tmp.b也就是基址，把edx低16位给b，也就是把cs赋值给b</span><br><span class="line">	//这里1%是tmp.b存放tss的段选择子，也就是基址。其中tss任务切换的时候偏移就是0，所以不用给tmp.a赋值，初始化的时候就是0</span><br><span class="line">	&quot;xchgl %%ecx,_current\n\t&quot; \ //交换把目标进程里面tss保存的东西恢复 // current = task[n]；ecx = 被切换出的任务。 </span><br><span class="line">	//上面是进程0的内核态，ljmp以后就跑到了进程1.注意此时进程0还没跑完，还挂着呢，切换以后到res跑到三特权的进程1运行了</span><br><span class="line">	&quot;ljmp %0\n\t&quot; \ // 执行长跳转至*&amp;__tmp，造成任务切换。</span><br><span class="line">	//因此这里偏移是0，不是要跳到tss数据段执行，而是要让tss段东西恢复当前进程状态</span><br><span class="line">    //ljmp以后后面的代码段就不执行了，要看tss里面的eip指向的是哪里就执行哪里，此时task0 的栈没清理</span><br><span class="line">	//这里的ljmp不是一个简单的跳转，是一个进程切换的机制，要参考ＩＡ３2手册。先保存进程0的状态，保存在tss0里面，然后再恢复tss1</span><br><span class="line">	//那后面这几条语句什么时候执行？ 的切回进程0的时候才继续跑。</span><br><span class="line">	//进程1eip跳哪里去了？ 在copy process里面有eip，保存的位置是 init80 压入的syscall0的if（ res__&gt;=0)</span><br><span class="line">	//此时已经走了两次init80 ，一个是fork 一个是pause 这里的init 80 是fork的时候存入的，现在它的res是0，因为copy process里面存的eax=0 所以res=0</span><br><span class="line">	&quot;cmpl %%ecx,_last_task_used_math\n\t&quot; \ // 新任务上次使用过协处理器吗？</span><br><span class="line">	&quot;jne 1f\n\t&quot; \  // 没有则跳转，退出。</span><br><span class="line">	&quot;clts\n&quot; \ // 新任务上次使用过协处理器，则清 cr0 的 TS 标志。</span><br><span class="line">	&quot;1:&quot; \</span><br><span class="line">	::&quot;m&quot; (*&amp;__tmp.a),&quot;m&quot; (*&amp;__tmp.b), \ //一个是段选择子（b是段选择子），一个是偏移（a是偏移），任务门切换只需要跳到新的tss段就可，不需要偏移</span><br><span class="line">	&quot;d&quot; (_TSS(n)),&quot;c&quot; ((long) task[n])); \ //在进程切换走的时候，当前进程的状态保存在了tss（n）里面，edx保存了tss n的索引号 </span><br><span class="line">     //因此在切回来的时候，tss段里面有当前的进程状态。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tss_n:</p>
<p>tss位于gdt中的第四项，其中每项8字节，所以<code>(FIRST_TSS_ENTRY&lt;&lt;3)</code>
,每个进程tss+ldt16个字节，所以第n个进程在gdt表中的相对第0个tss的偏移量：<code>(((unsigned long) n)&lt;&lt;4)</code>
,由于这个段选择子是0特权+gdt后三位是0，不用改，所以段选择子就是长这样了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define FIRST_TSS_ENTRY 4</span><br><span class="line">#define FIRST_LDT_ENTRY (FIRST_TSS_ENTRY+1) </span><br><span class="line">#define _TSS(n) ((((unsigned long) n)&lt;&lt;4)+(FIRST_TSS_ENTRY&lt;&lt;3)) </span><br></pre></td></tr></table></figure>
<h2 id="轮转到进程1执行">轮转到进程1执行</h2>
<p>进程1的eip在tss初始化的时候由进程0进程赋值，因此切换到进程1时，程序跳转到fork结束后的<code>if (__res &gt;= 0)</code>处执行，此时的eax是在父进程创建子进程的时候，copy
process个性化设置tss的时候赋值的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="type">long</span> __res; \</span><br><span class="line">__asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span> \ <span class="comment">//init 0x80是所有系统调用函数的总入口，fork是其中之一        </span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;=a&quot;</span> (__res) \ <span class="comment">//第一个冒号之后是输出部分，将_res赋值给eax</span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;0&quot;</span> (__NR_fork))</span>; \ <span class="comment">//第二个冒号后是输入部分，&quot;0&quot;同上寄存器，即eax ，__NR_fork=2，赋值给eax，紧接着就进行了0</span></span><br><span class="line">    <span class="comment">//x80软中断</span></span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \ <span class="comment">//int 0x80中断返回后，将执行这一句</span></span><br><span class="line">	<span class="keyword">return</span> (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;tss.eax = <span class="number">0</span>;</span><br><span class="line">p-&gt;tss.ecx = ecx;</span><br></pre></td></tr></table></figure>
<p>因此res=0，fork的返回值是0</p>
<p>因此回到main函数中！fork()为真，因此下一步就开始执行init</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>	&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">if</span> (!fork()) &#123;		<span class="comment">/* we count on this going ok */</span></span><br><span class="line">		init(); </span><br><span class="line">		<span class="comment">//进程本来已经走到pause了，</span></span><br><span class="line">	<span class="comment">//	但是因为eip是fork的eip所以返回的时候是从fork这里出来的</span></span><br><span class="line">	<span class="comment">//eax是在tss初始化里面设置为0，所以res=0所以返回值就是0，所以！fork为真，所以进程1就执行到这里面的init里了</span></span><br><span class="line">	<span class="comment">//因此此时属于三特权的进程1的代码</span></span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="init">init</h3>
<h3 id="setup">setup</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> pid,i;</span><br><span class="line"></span><br><span class="line">	setup((<span class="type">void</span> *) &amp;drive_info);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>首先调用setup函数</p>
<p>setup不是通过syscall0而是通过syscall1实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> _syscall1(<span class="type">int</span>,setup,<span class="type">void</span> *,BIOS)</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall1(type,name,atype,a) \</span></span><br><span class="line"><span class="meta">type name(atype a) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">long __res; \</span></span><br><span class="line"><span class="meta">__asm__ volatile (<span class="string">&quot;int $0x80&quot;</span> \</span></span><br><span class="line"><span class="meta">	: <span class="string">&quot;=a&quot;</span> (__res) \</span></span><br><span class="line"><span class="meta">	: <span class="string">&quot;0&quot;</span> (__NR_##name),<span class="string">&quot;b&quot;</span> ((long)(a))); \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (__res &gt;= 0) \</span></span><br><span class="line"><span class="meta">	return (type) __res; \</span></span><br><span class="line"><span class="meta">errno = -__res; \</span></span><br><span class="line"><span class="meta">return -1; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>因此这里展开就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setup</span><span class="params">(<span class="type">void</span>* BIOS)</span> \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="type">long</span> __res; \</span><br><span class="line">__asm__ <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span> \</span></span><br><span class="line"><span class="params">	: <span class="string">&quot;=a&quot;</span> (__res) \</span></span><br><span class="line"><span class="params">	: <span class="string">&quot;0&quot;</span> (__NR_setup),<span class="string">&quot;b&quot;</span> ((<span class="type">long</span>)(a)))</span>; \</span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \</span><br><span class="line">	<span class="keyword">return</span> (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时依旧会调用init 0x80 ,
__system_call,call_sys_table(,%eax,4),最后调用到sys_setup</p>
<hr>
<p>注意：进程0 pause函数的init
0x80中断还没有返回，而setup又产生了·一个中断</p>
<hr>
<h4 id="进程1设置硬盘的hd_info">进程1设置硬盘的hd_info</h4>
<p>根据机器系统数据中的drive_info 设置内核hd_info</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231111154453412.png" alt="image-20231111154453412">
<figcaption aria-hidden="true">image-20231111154453412</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This may be used only once, enforced by &#x27;static int callable&#x27; */</span></span><br><span class="line"><span class="comment">// 程序从 BIOS 取得的 2 个硬盘的基本参数表(32 字节)。硬盘参数表信息参见下面列表后的说明。 </span></span><br><span class="line"><span class="comment">// 本函数主要功能是读取 CMOS 和硬盘参数表信息，用于设置硬盘分区结构 hd，并加载 RAM 虚拟盘和 </span></span><br><span class="line"><span class="comment">// 根文件系统</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_setup</span><span class="params">(<span class="type">void</span> * BIOS)</span> <span class="comment">//首先解决硬盘的驱动器问题</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> callable = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i,drive;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> cmos_disks;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">partition</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">   <span class="comment">// 初始化时 callable=1，当运行该函数时将其设置为 0，使本函数只能执行一次。</span></span><br><span class="line">	<span class="keyword">if</span> (!callable)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	callable = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果没有在 config.h 中定义硬盘参数，就从 0x90080 处读入</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HD_TYPE</span></span><br><span class="line">	<span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;<span class="number">2</span> ; drive++) &#123;</span><br><span class="line">		hd_info[drive].cyl = *(<span class="type">unsigned</span> <span class="type">short</span> *) BIOS;<span class="comment">// 柱面数。</span></span><br><span class="line">		hd_info[drive].head = *(<span class="type">unsigned</span> <span class="type">char</span> *) (<span class="number">2</span>+BIOS);<span class="comment">// 磁头数。</span></span><br><span class="line">		hd_info[drive].wpcom = *(<span class="type">unsigned</span> <span class="type">short</span> *) (<span class="number">5</span>+BIOS); <span class="comment">// 写前预补偿柱面号。 </span></span><br><span class="line">		hd_info[drive].ctl = *(<span class="type">unsigned</span> <span class="type">char</span> *) (<span class="number">8</span>+BIOS); <span class="comment">// 控制字节。</span></span><br><span class="line">		hd_info[drive].lzone = *(<span class="type">unsigned</span> <span class="type">short</span> *) (<span class="number">12</span>+BIOS); <span class="comment">// 磁头着陆区柱面号。 </span></span><br><span class="line">		hd_info[drive].sect = *(<span class="type">unsigned</span> <span class="type">char</span> *) (<span class="number">14</span>+BIOS); <span class="comment">// 每磁道扇区数。 </span></span><br><span class="line">		BIOS += <span class="number">16</span>; <span class="comment">// 每个硬盘的参数表长 16 字节，这里 BIOS 指向下一个表。</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// setup.s 程序在取 BIOS 中的硬盘参数表信息时，如果只有 1 个硬盘，就会将对应第 2 个硬盘的 </span></span><br><span class="line"> <span class="comment">// 16 字节全部清零。因此这里只要判断第 2 个硬盘柱面数是否为 0 就可以知道有没有第 2 个硬盘了。</span></span><br><span class="line">	<span class="keyword">if</span> (hd_info[<span class="number">1</span>].cyl)</span><br><span class="line">		NR_HD=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		NR_HD=<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 设置每个硬盘的起始扇区号和扇区总数。</span></span><br><span class="line"><span class="comment">//一个物理硬盘最多可以分4个逻辑盘，0是物理盘，1~4是逻辑盘，第一个物理盘·0*5，第二个物理盘1*5</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_HD ; i++) &#123;</span><br><span class="line">		hd[i*<span class="number">5</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">		hd[i*<span class="number">5</span>].nr_sects = hd_info[i].head*</span><br><span class="line">				hd_info[i].sect*hd_info[i].cyl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((cmos_disks = CMOS_READ(<span class="number">0x12</span>)) &amp; <span class="number">0xf0</span>)</span><br><span class="line">		<span class="keyword">if</span> (cmos_disks &amp; <span class="number">0x0f</span>)</span><br><span class="line">			NR_HD = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			NR_HD = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		NR_HD = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = NR_HD ; i &lt; <span class="number">2</span> ; i++) &#123;</span><br><span class="line">		hd[i*<span class="number">5</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">		hd[i*<span class="number">5</span>].nr_sects = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//做根设备的分区表</span></span><br><span class="line">	<span class="comment">//为啥用块？为了碎片整理，当年操作系统比较小，块不标准：1k现在应该是4k</span></span><br><span class="line">	<span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;NR_HD ; drive++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(bh = bread(<span class="number">0x300</span> + drive*<span class="number">5</span>,<span class="number">0</span>))) &#123;</span><br><span class="line">			printk(<span class="string">&quot;Unable to read partition table of drive %d\n\r&quot;</span>,</span><br><span class="line">				drive);</span><br><span class="line">			panic(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读取硬盘的引导块到缓冲区">读取硬盘的引导块到缓冲区</h4>
<p>在linux0.11中，硬盘最基础的信息就是分区表，其它信息都可以从这个信息引导出来，这个信息所在的块就是引导块。一块硬盘只有唯一的一个引导块（0号逻辑盘）。引导块有两个扇区，真正有用的是第一个扇区。bread函数实现读取引导快到缓冲区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_setup</span><span class="params">(<span class="type">void</span> * BIOS)</span> <span class="comment">//首先解决硬盘的驱动器问题</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;NR_HD ; drive++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(bh = bread(<span class="number">0x300</span> + drive*<span class="number">5</span>,<span class="number">0</span>))) &#123;</span><br><span class="line">			printk(<span class="string">&quot;Unable to read partition table of drive %d\n\r&quot;</span>,</span><br><span class="line">				drive);</span><br><span class="line">			panic(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数量级关系">数量级关系</h4>
<p>一般hash数据结构数组比链表快一个数量级左右所以307个哈希块，每个后面串10个，一共是3000多个buffer块。</p>
<p>为啥是307？缓冲区和硬盘的速度差了两个量级。缓冲区3000多对应请求项32.缓冲区对应缓冲区到用户进程的东西，request负责缓冲区到硬盘，速度差了两个数量级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NR_HASH 307</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_BUFFERS nr_buffers</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _hashfn(dev,block) (((unsigned)(dev^block))%NR_HASH)<span class="comment">//为啥是307？量级差不多是两个量级。307:10</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hash(dev,block) hash_table[_hashfn(dev,block)]<span class="comment">//有可能不同的设备号块号找到了同一个哈希值</span></span></span><br></pre></td></tr></table></figure>
<h4 id="缓冲区">缓冲区</h4>
<p>初始化在上一章节中做过： <a href="./第二章笔记.md###初始化缓冲区管理结构">缓冲区初始化</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> * b_data;	<span class="comment">// 指向数据块的指针（数据块为 1024 字节）	/* pointer to data block (1024 bytes) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> b_blocknr;	<span class="comment">// 块号//块号/* block number */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> b_dev;	<span class="comment">// 数据源的设备号（0 表示未用）。	/* device (0 = free) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_uptodate; <span class="comment">// 更新标志：表示数据是否已更新。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_dirt;	<span class="comment">// 修改标志：0-未修改，1-已修改。	/* 0-clean,1-dirty */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_count;		<span class="comment">// 使用该数据块的用户数。 /* users using this block */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> b_lock;	<span class="comment">// 缓冲区是否被锁定，0-未锁；1-已锁定。	/* 0 - ok, 1 -locked */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">b_wait</span>;</span><span class="comment">// 指向等待该缓冲区解锁的任务。 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev</span>;</span> <span class="comment">// 前一块（这四个指针用于缓冲区的管理）。 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next</span>;</span>  <span class="comment">// 下一块。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev_free</span>;</span> <span class="comment">// 前一空闲块。 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next_free</span>;</span> <span class="comment">// 下一空闲块。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>缓冲区：开一块内存，磁盘内容先读到缓冲区，在缓冲区读到内存</p>
</blockquote>
<p>//怎么设计缓冲区才能重复使用。</p>
<blockquote>
<p>为啥使用缓冲区快：存在重复读写的时候变快，有点像catche</p>
<p>怎么设计缓冲区才能满足重复使用，使得读写变快？</p>
<p>思路：缓冲区的数据一旦进了缓冲区就尽可能呆在缓冲区时间长：怎么设计</p>
<p>如果counter=0且没有新的请求或者缓冲区没满，那么这个conuter的buffer
head还得在缓冲区里面放着，满足在缓冲区时间长</p>
<p>如果缓冲区满了，有新的请求，则把counter=0的挪出去，把新的加进来</p>
<p>如果缓冲区满了，没有counter=0的，有新的请求，则新的请求等待。</p>
</blockquote>
<p>前提：从内存读比从磁盘读快200倍</p>
<p><img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115093737912.png" alt="image-20231115093737912" style="zoom:55%;"></p>
<p>缓冲区：高速缓冲区位于内核代码块和主内存区之间</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115095947238.png" alt="image-20231115095947238">
<figcaption aria-hidden="true">image-20231115095947238</figcaption>
</figure>
<p>整个高速缓冲区被划分成 1024
字节大小的缓冲块，正好与块设备上的磁盘逻辑块大小相同。高速缓冲采用 hash
表和空闲缓冲块队列进行操作管理。在缓冲区初始化过程中，从缓冲区的两端开始，同时分别设置缓冲块头结构和划分出对应的缓冲块。缓冲区的高端被划分成一个个
1024 字节的缓冲块，低端则 分别建立起对应各缓冲块的缓冲头结构
buffer_head，用于描述对应缓冲块的
属性和把所有缓冲头连接成链表。直到它们之间已经不能再划分出缓冲块为止。</p>
<p><img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115100227526.png" alt="image-20231115100227526" style="zoom:80%;"></p>
<p>buffer_head 被链接成一个空闲缓冲块双向链表结构。</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115101114916.png" alt="image-20231115101114916">
<figcaption aria-hidden="true">image-20231115101114916</figcaption>
</figure>
<p>为了能够快速地在缓冲区中寻找请求的数据块是否已经被读入到缓冲区中，buffer.c
程序使用了具有307 个 buffer_head 指针项的==hash 表结构==。上图中
buffer_head 结构的指针 b_prev、b_next 就是用于
hash表中散列在同一项上多个缓冲块之间的双向连接。Hash
表所使用的散列函数由==设备号和逻辑块号组合而成==。程序中使用的具体函数是：==(设备号^逻辑块号)
Mod 307==。</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=CnRR_UENZ2s">什么是哈希表</a></p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115101151894.png" alt="image-20231115101151894">
<figcaption aria-hidden="true">image-20231115101151894</figcaption>
</figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231120095719241.png" alt="image-20231120095719241">
<figcaption aria-hidden="true">image-20231120095719241</figcaption>
</figure>
<h4 id="bread">bread</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">bread</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> block)</span><span class="comment">//读指定的dev，block，第一块dev是0x300   block：0</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">    <span class="comment">//先到缓冲区里面找有没有相同的块</span></span><br><span class="line">	<span class="comment">//dev设备号block 块号</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh=getblk(dev,block))) <span class="comment">//在缓冲区找与dev，block相符合的缓冲块</span></span><br><span class="line">		panic(<span class="string">&quot;bread: getblk returned NULL\n&quot;</span>); <span class="comment">//因为现在是进程一第一次使用缓冲区不可能没有空闲块</span></span><br><span class="line">    <span class="comment">/*找到缓冲块与请求项挂载*/</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_uptodate) <span class="comment">//如果在缓冲区找到了相符合的块，如果该缓冲区中的数据是有效的（已更新的），否则可能内存还没向缓冲区完成写</span></span><br><span class="line">		<span class="keyword">return</span> bh;   <span class="comment">//返回块</span></span><br><span class="line">	<span class="comment">// 否则调用 ll_rw_block()函数，产生读设备块请求。并等待缓冲区解锁。</span></span><br><span class="line">	ll_rw_block(READ,bh); </span><br><span class="line">	wait_on_buffer(bh);<span class="comment">//之前调用了读盘的操作，数据还没用从硬盘中读完，因此等待</span></span><br><span class="line">	<span class="comment">// 如果该缓冲区已更新，则返回缓冲区头指针，退出。</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_uptodate)</span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line">	<span class="comment">// 否则表明读设备操作失败，释放该缓冲区，返回 NULL 指针，退出。 </span></span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="getblk">getblk</h5>
<p><img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115104420577.png" alt="image-20231115104420577" style="zoom:80%;"></p>
<p>缓冲块搜索函数 getblk()，以获取适合的缓冲块。该函数首先 调用
get_hash_table()函数，在 hash
表队列中搜索指定设备号和逻辑块号的缓冲块是否已经存在。如果存在就立刻返回对应缓冲头结构的指针；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">getblk</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">tmp</span>, * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">	<span class="keyword">if</span> (bh = get_hash_table(dev,block))</span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不存在，则从空闲链表头开始，对空闲链表进行扫描，寻找
一个空闲缓冲块。在寻找过程中还要对找到的空闲缓冲块作比较，根据赋予修改标志和锁定标志组合而成的权值，比较哪个空闲块最适合。若找到的空闲块既没有被修改也没有被锁定，就不用继续寻找了。</p>
<p>这里的dirt指的是进程方向的，dirt=1指的是进程修改了缓冲块，还没有写到硬盘中，而update是硬盘方向的，update=1指的是硬盘刷新过的缓冲块，数据已经读入内存。dirt和lock的区别体现在，lock是指缓冲块正在同步（正在写入硬盘），而dirt还不知道什么时候写，所以相比之下，dirt位比lock位更加的不好。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BADNESS(bh) (((bh)-&gt;b_dirt<span class="string">&lt;&lt;1)+(bh)-&gt;</span>b_lock)</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">free_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">getblk</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	tmp = free_list;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">//如果被人用了就接着往下遍历</span></span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;b_count)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//BADNESS：dirt&lt;&lt;2+lock</span></span><br><span class="line">			<span class="comment">//一读一写才有竞争，生产者消费者模型，谁是自动化的，谁是主动的进程可以干预的，所以要锁住内存到缓冲区的路径</span></span><br><span class="line">			<span class="comment">//因此一加锁说明缓冲区到磁盘正在自动化操作</span></span><br><span class="line">			<span class="comment">//dirt说明缓冲区被进程写过，还没开始自动化的过程</span></span><br><span class="line">			<span class="comment">//因此dirt和lock选一个，选lock，因为lock干的时间短</span></span><br><span class="line">			<span class="comment">//dirt左移说明加了权重了</span></span><br><span class="line">			<span class="comment">//要从11 10 01 00 里面找最小的一个</span></span><br><span class="line">		<span class="keyword">if</span> (!bh || BADNESS(tmp)&lt;BADNESS(bh)) &#123;</span><br><span class="line">			bh = tmp;</span><br><span class="line">			<span class="keyword">if</span> (!BADNESS(tmp))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/* and repeat until we find something good */</span></span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">while</span> ((tmp = tmp-&gt;b_next_free) != free_list);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		sleep_on(&amp;buffer_wait);</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>若没有找到空闲块，则让当前进程进入睡眠状态，待继续执行时再次寻找。若该空闲块被锁定，则进程也需进入睡眠，等待其它进程解锁。</p>
<p>若在睡眠等待的过程中，该缓冲块又被其它进程占用，那么只要再
重头开始搜索缓冲块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait_on_buffer(bh);<span class="comment">//等待写完缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_count)<span class="comment">//不空闲则重复上面的操作//在buffer_init里面初始化的时候设置成0</span></span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br></pre></td></tr></table></figure>
<p>否则判断该缓冲块是否已被修改过，若是，则将该块写盘，并等待该块解锁。此
时如果该缓冲块又被别的进程占用，那么又一次全功尽弃，只好再重头开始执行
getblk()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//脏位置一，说明缓冲块被写了，当前正等待用户写</span></span><br><span class="line">	<span class="keyword">while</span> (bh-&gt;b_dirt) &#123;</span><br><span class="line">		sync_dev(bh-&gt;b_dev);</span><br><span class="line">		wait_on_buffer(bh);</span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_count)</span><br><span class="line">			<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在经历了以上
折腾后，此时有可能出现另外一个意外情况，也就是在我们睡眠时，可能其它进程已经将我们所需要的
缓冲块加进了 hash 队列中，因此这里需要最后一次搜索一下 hash
队列。如果真的在 hash 队列中找到了
我们所需要的缓冲块，那么我们又得对找到的缓冲块进行以上判断处理，因此，又一次需要重头开始执
行
getblk()。最后，我们才算找到了一块没有被进程使用、没有被上锁，而且是干净（修改标志未置位）
的空闲缓冲块。于是我们就将该块的引用次数置
1，并复位其它几个标志，然后从空闲表中移出该块的
缓冲头结构。在设置了该缓冲块所属的设备号和相应的逻辑号后，在将其放入
hash 表对应表项的第一个
和空闲队列的末尾处。最终，返回该缓冲块头的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">getblk</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (find_buffer(dev,block))</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="comment">/* OK, FINALLY we know that this buffer is the only one of it&#x27;s kind, */</span></span><br><span class="line"><span class="comment">/* and that it&#x27;s unused (b_count=0), unlocked (b_lock=0), and clean */</span></span><br><span class="line">	bh-&gt;b_count=<span class="number">1</span>;<span class="comment">//占用该缓冲块</span></span><br><span class="line">	bh-&gt;b_dirt=<span class="number">0</span>;<span class="comment">//还没有读盘dirt不置1</span></span><br><span class="line">	bh-&gt;b_uptodate=<span class="number">0</span>;</span><br><span class="line">	remove_from_queues(bh);<span class="comment">//假设都满了就会在叉子上面摘下来，放到其他的设备号块号上面</span></span><br><span class="line">	bh-&gt;b_dev=dev;<span class="comment">//更换设备号块号</span></span><br><span class="line">	bh-&gt;b_blocknr=block;</span><br><span class="line">	<span class="comment">//要把缓冲块叉在hash上面才算纳入了缓冲区的管理范围</span></span><br><span class="line">	insert_into_queues(bh);<span class="comment">//重新插到合适的位置</span></span><br><span class="line">	<span class="keyword">return</span> bh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="get_hash_table">get_hash_table</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">get_hash_table</span><span class="params">(<span class="type">int</span> dev, <span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(bh=find_buffer(dev,block)))<span class="comment">//在hash的链表中找相同设备号块号的缓冲区</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		bh-&gt;b_count++;<span class="comment">//增加缓冲块的引用计数</span></span><br><span class="line">		wait_on_buffer(bh);<span class="comment">//等待缓冲块，因为之前的进程不一定用完了，如果是lock的该进程sleep</span></span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_dev == dev &amp;&amp; bh-&gt;b_blocknr == block)</span><br><span class="line">			<span class="keyword">return</span> bh;</span><br><span class="line">		bh-&gt;b_count--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="一些同步加锁等待函数解析">一些同步加锁等待函数解析</h5>
<p>加锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">lock_buffer</span><span class="params">(<span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line">	cli();<span class="comment">//这个地方关中断是置EFLAGS相当于是关了进程的中断，后面虽然进程调度切换出去了</span></span><br><span class="line">	<span class="comment">//没运行sti但是进程切换的时候mtss里面有自己的EFLAGS，就没有中断了所以别的进程是有中断的</span></span><br><span class="line">	<span class="keyword">while</span> (bh-&gt;b_lock)</span><br><span class="line">		sleep_on(&amp;bh-&gt;b_wait);</span><br><span class="line">	bh-&gt;b_lock=<span class="number">1</span>;</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等待缓冲区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">wait_on_buffer</span><span class="params">(<span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line">	cli();<span class="comment">//关中断，原子操作</span></span><br><span class="line">	<span class="comment">// 如果已被上锁，则进程进入睡眠，等待其解锁。</span></span><br><span class="line">	<span class="keyword">while</span> (bh-&gt;b_lock)<span class="comment">//为啥不是if？说明这个还会循环</span></span><br><span class="line">		sleep_on(&amp;bh-&gt;b_wait);</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用。同步设备和内存高速缓冲中数据。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sync</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	sync_inodes();		<span class="comment">/* write out inodes into buffers */</span><span class="comment">//将 i 节点写入高速缓冲</span></span><br><span class="line">	bh = start_buffer;</span><br><span class="line">	<span class="comment">// 扫描所有高速缓冲区，对于已被修改的缓冲块产生写盘请求，将缓冲中数据与设备中同步。 </span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_BUFFERS ; i++,bh++) &#123;</span><br><span class="line">		wait_on_buffer(bh);</span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_dirt)</span><br><span class="line">			ll_rw_block(WRITE,bh);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="remove_from_queues">remove_from_queues</h5>
<p><img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231115104420577.png" alt="image-20231115104420577" style="zoom:100%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从 hash 队列中移除缓冲块 */</span> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">remove_from_queues</span><span class="params">(<span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* remove from hash-queue */</span></span><br><span class="line"><span class="comment">//hash队列链表上删除结点，但是始终都在双向环链表上面</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_next)</span><br><span class="line">		bh-&gt;b_next-&gt;b_prev = bh-&gt;b_prev;</span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_prev)</span><br><span class="line">		bh-&gt;b_prev-&gt;b_next = bh-&gt;b_next;</span><br><span class="line"><span class="comment">// 如果该缓冲区是该队列的头一个块，则让 hash 表的对应项指向本队列中的下一个缓冲区。</span></span><br><span class="line">	<span class="keyword">if</span> (hash(bh-&gt;b_dev,bh-&gt;b_blocknr) == bh)</span><br><span class="line">		hash(bh-&gt;b_dev,bh-&gt;b_blocknr) = bh-&gt;b_next;</span><br><span class="line"><span class="comment">/* remove from free list */</span></span><br><span class="line"><span class="comment">/* 从空闲缓冲区的双向环链表中移除缓冲块 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh-&gt;b_prev_free) || !(bh-&gt;b_next_free))</span><br><span class="line">		panic(<span class="string">&quot;Free block list corrupted&quot;</span>);</span><br><span class="line">	bh-&gt;b_prev_free-&gt;b_next_free = bh-&gt;b_next_free;</span><br><span class="line">	bh-&gt;b_next_free-&gt;b_prev_free = bh-&gt;b_prev_free;</span><br><span class="line">	<span class="keyword">if</span> (free_list == bh)</span><br><span class="line">		free_list = bh-&gt;b_next_free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="insert_into_queues">insert_into_queues</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 将指定缓冲区插入空闲链表尾并放入 hash 队列中。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">insert_into_queues</span><span class="params">(<span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* put at end of free list */</span></span><br><span class="line"><span class="comment">/* 放在空闲链表末尾处 */</span> </span><br><span class="line">	bh-&gt;b_next_free = free_list;</span><br><span class="line">	bh-&gt;b_prev_free = free_list-&gt;b_prev_free;</span><br><span class="line">	free_list-&gt;b_prev_free-&gt;b_next_free = bh;</span><br><span class="line">	free_list-&gt;b_prev_free = bh;</span><br><span class="line"><span class="comment">/* put the buffer in new hash-queue if it has a device */</span></span><br><span class="line"><span class="comment">/* 如果该缓冲块对应一个设备，则将其插入新 hash 队列中，头插入 */</span></span><br><span class="line">	bh-&gt;b_prev = <span class="literal">NULL</span>;</span><br><span class="line">	bh-&gt;b_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!bh-&gt;b_dev)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	bh-&gt;b_next = hash(bh-&gt;b_dev,bh-&gt;b_blocknr);</span><br><span class="line">	hash(bh-&gt;b_dev,bh-&gt;b_blocknr) = bh;</span><br><span class="line">	bh-&gt;b_next-&gt;b_prev = bh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ll_rw_block">ll_rw_block</h5>
<p>ll底层的读写块操作</p>
<p>blk.h：</p>
<p><code>\#define NR_BLK_DEV  7</code></p>
<p>系统管理外设的重要数据结构：对于各种块设备，内核使用了一张块设备表
blk_dev[]来进行管理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> &#123;</span> </span><br><span class="line"> <span class="type">void</span> (*request_fn)(<span class="type">void</span>); <span class="comment">// 请求项操作的函数指针。 </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">current_request</span>;</span> <span class="comment">// 当前请求项指针。 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> <span class="title">blk_dev</span>[<span class="title">NR_BLK_DEV</span>] =</span> &#123;</span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* no_dev */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev mem */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev fd */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev hd */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev ttyx */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,		<span class="comment">/* dev tty */</span></span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;		<span class="comment">/* dev lp */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231120112732685.png" alt="image-20231120112732685">
<figcaption aria-hidden="true">image-20231120112732685</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ll_rw_block</span><span class="params">(<span class="type">int</span> rw, <span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> major;</span><br><span class="line">    <span class="comment">//NR_BLK_DEV:最开始在blk_dev 操作系统)管理外设的据结构里面见过</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> ((major=MAJOR(bh-&gt;b_dev)) &gt;= NR_BLK_DEV ||!(blk_dev[major].request_fn))</span><br><span class="line">    &#123;<span class="comment">//blk_dev[major].request 在hd_init里面做了初始化</span></span><br><span class="line">		<span class="comment">//printk：只有文件系统起来以后才能用printf，这个地方还不能用printf只能用printk</span></span><br><span class="line">		printk(<span class="string">&quot;Trying to read nonexistent block-device\n\r&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	make_request(major,rw,bh);<span class="comment">//  创建请求项并插入请求队列。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>if ((major=MAJOR(bh-&gt;b_dev)) &gt;= NR_BLK_DEV ||!(blk_dev[major].request_fn))</code></p>
</blockquote>
<p>这段的条件解析：或条件，说明两个满足一个就会报错试图读不存在的块设备</p>
<p><code>(major=MAJOR(bh-&gt;b_dev)) &gt;= NR_BLK_DEV</code></p>
<p><code>#define MAJOR(a) (((unsigned)(a))&gt;&gt;8)</code>右移8位取高字节（主设备号）。</p>
<p>将<code>bh-&gt;b_dev</code>主设备号是0~6，NR_BLK_DEV是7，大于说明不存在。</p>
<blockquote>
<p><code>!(blk_dev[major].request_fn)</code></p>
</blockquote>
<p>blk_dev[major].request
在hd_init里面做了初始化，挂载了请求项函数：do_hd_request</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_REQUEST do_hd_request</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hd_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的判断语句是指如果没有初始化，对应的就是上面表里面的NULL，！null为真，就会报错</p>
<p>挂载的另一个request*也在之前做过初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blk_dev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//NR_REQUEST是请求项的数量=32</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_REQUEST ; i++) &#123;</span><br><span class="line">		request[i].dev = <span class="number">-1</span>;<span class="comment">//设为空闲，说明这个请求项还没有聚体对应那个设备，用于判断请求项当前设备是否空闲</span></span><br><span class="line">		request[i].next = <span class="literal">NULL</span>;<span class="comment">//互不挂接，说明还没形成请求队列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个是七个blk_dev的一个是32个的request(是一个数组链表)</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231122092315542.png" alt="image-20231122092315542">
<figcaption aria-hidden="true">image-20231122092315542</figcaption>
</figure>
<h5 id="make_request">make_request</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bufferd 的时候major=3，rw=READ （0）bh：在缓冲区找到一个空闲的</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">make_request</span><span class="params">(<span class="type">int</span> major,<span class="type">int</span> rw, <span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">req</span>;</span></span><br><span class="line">	<span class="type">int</span> rw_ahead;</span><br><span class="line">	<span class="comment">//预读</span></span><br><span class="line">	<span class="keyword">if</span> (rw_ahead = (rw == READA || rw == WRITEA)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_lock)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (rw == READA)</span><br><span class="line">			rw = READ;                                                                          </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			rw = WRITE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rw!=READ &amp;&amp; rw!=WRITE)</span><br><span class="line">		panic(<span class="string">&quot;Bad block dev command, must be R/W/RA/WA&quot;</span>);</span><br><span class="line">    <span class="comment">//加锁，锁住进程向buffer的方向。</span></span><br><span class="line">	<span class="comment">//竞争：生产者消费者</span></span><br><span class="line">	lock_buffer(bh);</span><br><span class="line">	<span class="comment">//如果是写操作你又不需要写，是读操作又是最新的不需要读，矛盾</span></span><br><span class="line">	<span class="keyword">if</span> ((rw == WRITE &amp;&amp; !bh-&gt;b_dirt) || (rw == READ &amp;&amp; bh-&gt;b_uptodate)) &#123;</span><br><span class="line">		unlock_buffer(bh);<span class="comment">//sleep on 利用内核栈构造了一串等待队列</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">repeat:</span><br><span class="line">    <span class="comment">//读从最后开始，写从2/3开始，从后往前，读比写范围更大</span></span><br><span class="line">	<span class="comment">//why？读比写多？因为读的话用户比较着急，写的话用户已经写到缓冲区了用户不着急了，只要在断电前完成写就可以了。</span></span><br><span class="line">	<span class="keyword">if</span> (rw == READ)</span><br><span class="line">		req = request+NR_REQUEST;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		req = request+((NR_REQUEST*<span class="number">2</span>)/<span class="number">3</span>);</span><br><span class="line"><span class="comment">//-1是没有request 参看 blk_dev_init 数组链表</span></span><br><span class="line">	<span class="keyword">while</span> (--req &gt;= request)</span><br><span class="line">		<span class="keyword">if</span> (req-&gt;dev&lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;	</span><br><span class="line">	<span class="comment">//没找到空闲</span></span><br><span class="line">	<span class="keyword">if</span> (req &lt; request) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rw_ahead) &#123;</span><br><span class="line">			unlock_buffer(bh);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//之前的sleep等具体的buffer解锁，现在等整个请求项</span></span><br><span class="line">		sleep_on(&amp;wait_for_request);</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">	req-&gt;dev = bh-&gt;b_dev;</span><br><span class="line">	req-&gt;cmd = rw;</span><br><span class="line">	req-&gt;errors=<span class="number">0</span>;</span><br><span class="line">	req-&gt;sector = bh-&gt;b_blocknr&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	req-&gt;nr_sectors = <span class="number">2</span>;<span class="comment">//块比较小1k，扇区512，一个块对应2个扇区</span></span><br><span class="line">	req-&gt;buffer = bh-&gt;b_data;</span><br><span class="line">	req-&gt;waiting = <span class="literal">NULL</span>;</span><br><span class="line">	req-&gt;bh = bh;</span><br><span class="line">	req-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//到这里为止，缓冲块做出来了，还没有进入队列</span></span><br><span class="line">	<span class="comment">//物理上是在32个的数组里面做的，但是还没进链表，是按照链上的东西进行同步的</span></span><br><span class="line">	<span class="comment">//第二阶段，缓冲区3000多对应请求项32.缓冲区对应缓冲区到用户进程的东西</span></span><br><span class="line">	<span class="comment">//request负责缓冲区到硬盘，速度差了两个数量级</span></span><br><span class="line">	add_request(major+blk_dev,req);<span class="comment">//本质就是进入链表 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="add_request">add_request</h5>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/缓冲绘图2.png" alt="缓冲绘图">
<figcaption aria-hidden="true">缓冲绘图</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_request</span><span class="params">(<span class="keyword">struct</span> blk_dev_struct * dev, <span class="keyword">struct</span> request * req)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">	req-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	cli(); <span class="comment">//原子操作，思考什么引发了竞争</span></span><br><span class="line">	<span class="keyword">if</span> (req-&gt;bh)<span class="comment">//req不为空，说明make好了一个request</span></span><br><span class="line">		req-&gt;bh-&gt;b_dirt = <span class="number">0</span>;<span class="comment">//清dirt位</span></span><br><span class="line">	<span class="keyword">if</span>(!(tmp=dev-&gt;current_request))&#123;</span><br><span class="line">		dev-&gt;current_request = req; <span class="comment">//blk dev在之前init的时候是null后来request fun设定了但是curent request还是空的,这里相当于做一个链表的头节点</span></span><br><span class="line">		sti();</span><br><span class="line">		(dev-&gt;request_fn)();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;		</span><br><span class="line">	<span class="comment">//使用电梯算法，让磁头移动的距离最小</span></span><br><span class="line">	<span class="keyword">for</span> ( ; tmp-&gt;next ; tmp=tmp-&gt;next)<span class="comment">//当dev blk不为空的时候，相当于头节点不为空了，所以这里进行插入结点</span></span><br><span class="line">		<span class="keyword">if</span> ((IN_ORDER(tmp,req) ||</span><br><span class="line">		    !IN_ORDER(tmp,tmp-&gt;next)) &amp;&amp;</span><br><span class="line">		    IN_ORDER(req,tmp-&gt;next))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	req-&gt;next=tmp-&gt;next;</span><br><span class="line">	tmp-&gt;next=req;</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="dev-request_fn-do_hd_request">(dev-&gt;request_fn)();
do_hd_request</h5>
<p>hd_init的时候挂载了请求项函数：<code>#define DEVICE_REQUEST do_hd_request</code></p>
<p><code>blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;</code></p>
<p>do_hd_request()是硬盘请求项的操作函数。其操作流程如下：</p>
<ul>
<li><p>首先判断当前请求项是否存在，若当前请求项指针为空，则说明目前硬盘块设备已经没有待处理
的请求项，因此立刻退出程序。这是在宏 INIT_REQUEST
中执行的语句。否则就继续处理当前请 求项。</p></li>
<li><p>对当前请求项中指明的设备号和请求的盘起始扇区号的合理性进行验证；</p></li>
<li><p>根据当前请求项提供的信息计算请求数据的磁盘磁道号、磁头号和柱面号；</p></li>
<li><p>如果复位标志（reset）已被设置，则也设置硬盘重新校正标志（recalibrate），并对硬盘执行复位操
作，向控制器重新发送“建立驱动器参数”命令（WIN_SPECIFY）。该命令不会引发硬盘中断；</p></li>
<li><p>如果重新校正标志被置位的话，就向控制器发送硬盘重新校正命令（WIN_RESTORE），并在发送
之前预先设置好该命令引发的中断中需要执行的 C
函数（recal_intr()），并退出。recal_intr()函数的
主要作用是：当控制器执行该命令结束并引发中断时，能重新（继续）执行本函数。</p></li>
<li><p>如果当前请求项指定是写操作，则首先设置硬盘控制器调用的 C 函数为
write_intr()，向控制器发</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_hd_request</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,r;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> block,dev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sec,head,cyl;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nsect;</span><br><span class="line">    <span class="comment">// 检测请求项的合法性，若已没有请求项则退出</span></span><br><span class="line">	INIT_REQUEST;<span class="comment">//repeat在这个宏里面</span></span><br><span class="line">	dev = MINOR(CURRENT-&gt;dev);</span><br><span class="line">	block = CURRENT-&gt;sector;</span><br><span class="line">	<span class="comment">// 如果子设备号不存在或者起始扇区大于该分区扇区数-2，则结束该请求，并跳转到标号 repeat 处 </span></span><br><span class="line">    <span class="comment">// （定义在 INIT_REQUEST 开始处）。因为一次要求读写 2 个扇区（512*2 字节），所以请求的扇区号 </span></span><br><span class="line">    <span class="comment">// 不能大于分区中最后倒数第二个扇区号。</span></span><br><span class="line">	<span class="keyword">if</span> (dev &gt;= <span class="number">5</span>*NR_HD || block+<span class="number">2</span> &gt; hd[dev].nr_sects) &#123;</span><br><span class="line">		end_request(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过加上本分区的起始扇区号，把将所需读写的块对应到整个硬盘的绝对扇区号上</span></span><br><span class="line">	block += hd[dev].start_sect;</span><br><span class="line">	dev /= <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 下面嵌入汇编代码用来从硬盘信息结构中根据起始扇区号和每磁道扇区数计算在磁道中的 </span></span><br><span class="line">    <span class="comment">// 扇区号(sec)、所在柱面号(cyl)和磁头号(head)。</span></span><br><span class="line">	__asm__(<span class="string">&quot;divl %4&quot;</span>:<span class="string">&quot;=a&quot;</span> (block),<span class="string">&quot;=d&quot;</span> (sec):<span class="string">&quot;0&quot;</span> (block),<span class="string">&quot;1&quot;</span> (<span class="number">0</span>),</span><br><span class="line">		<span class="string">&quot;r&quot;</span> (hd_info[dev].sect));</span><br><span class="line">	__asm__(<span class="string">&quot;divl %4&quot;</span>:<span class="string">&quot;=a&quot;</span> (cyl),<span class="string">&quot;=d&quot;</span> (head):<span class="string">&quot;0&quot;</span> (block),<span class="string">&quot;1&quot;</span> (<span class="number">0</span>),</span><br><span class="line">		<span class="string">&quot;r&quot;</span> (hd_info[dev].head));</span><br><span class="line">	sec++;</span><br><span class="line">	nsect = CURRENT-&gt;nr_sectors;</span><br><span class="line">	<span class="comment">// 如果 reset 标志是置位的，则执行复位操作。复位硬盘和控制器，并置需要重新校正标志，返回。</span></span><br><span class="line">	<span class="keyword">if</span> (reset) &#123;</span><br><span class="line">		reset = <span class="number">0</span>;</span><br><span class="line">		recalibrate = <span class="number">1</span>;</span><br><span class="line">		reset_hd(CURRENT_DEV);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果重新校正标志(recalibrate)置位，则首先复位该标志，然后向硬盘控制器发送重新校正命令。 </span></span><br><span class="line">    <span class="comment">// 该命令会执行寻道操作，让处于任何地方的磁头移动到 0 柱面。</span></span><br><span class="line">	<span class="keyword">if</span> (recalibrate) &#123;</span><br><span class="line">		recalibrate = <span class="number">0</span>;</span><br><span class="line">		hd_out(dev,hd_info[CURRENT_DEV].sect,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">			WIN_RESTORE,&amp;recal_intr);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//和驱动挂钩子了</span></span><br><span class="line">	<span class="comment">// 如果当前请求是写扇区操作，则发送写命令，循环读取状态寄存器信息并判断请求服务标志 </span></span><br><span class="line">   <span class="comment">// DRQ_STAT 是否置位。DRQ_STAT 是硬盘状态寄存器的请求服务位，表示驱动器已经准备好在主机和 </span></span><br><span class="line">   <span class="comment">// 数据端口之间传输一个字或一个字节的数据。</span></span><br><span class="line"> 	<span class="keyword">if</span> (CURRENT-&gt;cmd == WRITE) &#123;</span><br><span class="line">		hd_out(dev,nsect,sec,head,cyl,WIN_WRITE,&amp;write_intr);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span> ; i&lt;<span class="number">3000</span> &amp;&amp; !(r=inb_p(HD_STATUS)&amp;DRQ_STAT) ; i++)</span><br><span class="line">			<span class="comment">/* nothing */</span> ;</span><br><span class="line">		<span class="keyword">if</span> (!r) &#123;</span><br><span class="line">			bad_rw_intr();</span><br><span class="line">			<span class="keyword">goto</span> repeat;</span><br><span class="line">		&#125;</span><br><span class="line">		port_write(HD_DATA,CURRENT-&gt;buffer,<span class="number">256</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CURRENT-&gt;cmd == READ) &#123;</span><br><span class="line">		hd_out(dev,nsect,sec,head,cyl,WIN_READ,&amp;read_intr);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		panic(<span class="string">&quot;unknown hd-command&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="hd_out">hd_out</h5>
<p><code>hd_out(dev,nsect,sec,head,cyl,WIN_READ,&amp;read_intr);</code></p>
<p><code>hd_out(dev,nsect,sec,head,cyl,WIN_WRITE,&amp;write_intr);</code></p>
<p>后两个实参<code>read_intr</code>
是读盘对应的中断服务函数，是一个钩子，要提取这个函数的地址准备挂接，读挂接read_intr，写挂接write_intr</p>
<p><code>unsigned int cmd</code>对应接下来要进行的操作</p>
<p>是硬盘控制器操作命令发送函数。该函数带有一个中断过程中调用的 C
函数指针参数，在
向控制器发送命令之前，它首先使用这个参数预置好中断过程中会调用的函数指针（do_hd）</p>
<p>然后它按 照规定的方式依次向硬盘控制器 0x1f0 至 0x1f7
发送命令参数块。：<code>\#define outb_p(value,port)</code></p>
<p>除控制器诊断（WIN_DIAGNOSE）和
建立驱动器参数（WIN_SPECIFY）两个命令以外，硬盘控制器在接收到任何其它命令并执行了命令以后，
都会向 CPU 发出中断请求信号，从而引发系统去执行硬盘中断处理过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hd_out</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> drive,<span class="type">unsigned</span> <span class="type">int</span> nsect,<span class="type">unsigned</span> <span class="type">int</span> sect,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> head,<span class="type">unsigned</span> <span class="type">int</span> cyl,<span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">		<span class="type">void</span> (*intr_addr)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="type">int</span> port <span class="title function_">asm</span><span class="params">(<span class="string">&quot;dx&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (drive&gt;<span class="number">1</span> || head&gt;<span class="number">15</span>)</span><br><span class="line">		panic(<span class="string">&quot;Trying to write bad sector&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!controller_ready())</span><br><span class="line">		panic(<span class="string">&quot;HD controller not ready&quot;</span>);</span><br><span class="line">	do_hd = intr_addr;<span class="comment">//把read intr挂上去//// do_hd 函数指针将在硬盘中断程序中被调用。</span></span><br><span class="line">	<span class="comment">//一次命令是一个块，一个操做两个扇区，一个命令跑两次</span></span><br><span class="line">	outb_p(hd_info[drive].ctl,HD_CMD);<span class="comment">//// 向控制寄存器(0x3f6)输出控制字节。</span></span><br><span class="line">	port=HD_DATA;<span class="comment">//置 dx 为数据寄存器端口(0x1f0)。</span></span><br><span class="line">	outb_p(hd_info[drive].wpcom&gt;&gt;<span class="number">2</span>,++port);<span class="comment">// 参数：写预补偿柱面号(需除 4)。 </span></span><br><span class="line">	outb_p(nsect,++port);<span class="comment">// 参数：读/写扇区总数。</span></span><br><span class="line">	outb_p(sect,++port);<span class="comment">// 参数：起始扇区。</span></span><br><span class="line">	outb_p(cyl,++port);<span class="comment">// 参数：柱面号低 8 位。 </span></span><br><span class="line">	outb_p(cyl&gt;&gt;<span class="number">8</span>,++port);<span class="comment">// 参数：柱面号高 8 位</span></span><br><span class="line">	outb_p(<span class="number">0xA0</span>|(drive&lt;&lt;<span class="number">4</span>)|head,++port);<span class="comment">// 参数：驱动器号+磁头号。 </span></span><br><span class="line">	outb(cmd,++port);<span class="comment">// 命令：硬盘控制命令。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="hd_interrupt">_hd_interrupt:</h4>
<p>do_hd已经挂接了函数，在执行硬盘中断函数的时候会自动执行</p>
<p>_hd_interrupt位于system_call.s</p>
<p>这里中断函数的挂接在hd_init中完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hd_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	set_intr_gate(<span class="number">0x2E</span>,&amp;hd_interrupt);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">_hd_interrupt:</span><br><span class="line">	pushl %eax</span><br><span class="line">	pushl %ecx</span><br><span class="line">	pushl %edx</span><br><span class="line">	push %ds</span><br><span class="line">	push %es</span><br><span class="line">	push %fs</span><br><span class="line">	movl $0x10,%eax  ## ds,es 置为内核数据段。</span><br><span class="line">	mov %ax,%ds</span><br><span class="line">	mov %ax,%es</span><br><span class="line">	movl $0x17,%eax  #fs置为调用程序的局部数据段。</span><br><span class="line">	mov %ax,%fs</span><br><span class="line">	# 由于初始化中断控制芯片时没有采用自动 EOI，所以这里需要发指令结束该硬件中断。</span><br><span class="line">	movb $0x20,%al</span><br><span class="line">	outb %al,$0xA0		# EOI to interrupt controller #1</span><br><span class="line">	jmp 1f			# give port chance to breathe</span><br><span class="line">1:	jmp 1f</span><br><span class="line">1:	xorl %edx,%edx #清零</span><br><span class="line">	xchgl _do_hd,%edx # do_hd 定义为一个函数指针，将被赋值 read_intr()或write_intr()函数地址。(kernel/blk_drv/hd.c) </span><br><span class="line">	# 放到 edx 寄存器后就将 do_hd 指针变量置为 NULL。</span><br><span class="line">	testl %edx,%edx # 测试函数指针是否为 Null。</span><br><span class="line">	jne 1f # 若空，则使指针指向 C 函数 unexpected_hd_interrupt()</span><br><span class="line">	movl $_unexpected_hd_interrupt,%edx # 送主 8259A 中断控制器 EOI 指令（结束硬件中断）。</span><br><span class="line">1:	outb %al,$0x20</span><br><span class="line">	call *%edx		# &quot;interesting&quot; way of handling intr.</span><br><span class="line">	pop %fs #上句调用 do_hd 指向的 C 函数</span><br><span class="line">	pop %es</span><br><span class="line">	pop %ds</span><br><span class="line">	popl %edx</span><br><span class="line">	popl %ecx</span><br><span class="line">	popl %eax</span><br><span class="line">	iret</span><br></pre></td></tr></table></figure>
<p>硬盘开始将引导块中的数据不断读入缓存中，同时函数一路返回到bread</p>
<h4 id="读盘还没完成这个过程中进程01的切换">读盘还没完成这个过程中进程0，1的切换</h4>
<p>进入<code>wait_on_buffer(bh);</code></p>
<p>进入<code>sleep_on</code>，此时进程1设置为不可中断等待状态，进入schedule函数</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231127094912326.png" alt="image-20231127094912326">
<figcaption aria-hidden="true">image-20231127094912326</figcaption>
</figure>
<h5 id="sleep_on">sleep_on</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span><span class="comment">//p是指向b_wait的志珍</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (current == &amp;(init_task.task))<span class="comment">//当前进程是不是进程0</span></span><br><span class="line">		panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">	tmp = *p;<span class="comment">//*p就是b_wait，目前是null在初始化的时候是null（buffer init）第一个缓冲块初始化到现在还没动过</span></span><br><span class="line">	*p = current;<span class="comment">//b_wait 指向进程1的task struct。                                                                                            </span></span><br><span class="line">	current-&gt;state = TASK_UNINTERRUPTIBLE;<span class="comment">//进程·0进程1都挂起了</span></span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">if</span> (tmp)</span><br><span class="line">		tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getblk 是先进去再读写数据
可能不同进程用同一个缓冲块。因为进入队列以后没有立刻写数据，getblk找现成的找到了同一个缓冲块，一个进程sleep
on的时候，其他的进程也sleep on 了 目前在内核态，tmp在内核栈里面</p>
<p>buffer head是全局的变量（buffer init） ##### 进程0被强制唤醒</p>
<p>这次遍历task的时候，进程0和进程1都是不可中断等待状态，这时进程0就以不可中断状态的姿态强制执行了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...	</span><br><span class="line"><span class="comment">// 如果比较得出有 counter 值大于 0 的结果，则退出 循环，执行任务切换 </span></span><br><span class="line">		<span class="keyword">if</span> (c) <span class="keyword">break</span>;<span class="comment">//当没有找到进程的时候break，也就是所有的进程都挂起就切回默认的进程0</span></span><br><span class="line">		<span class="comment">// 否则就根据每个任务的优先权值，更新每一个任务的 counter 值. </span></span><br><span class="line">       <span class="comment">// counter 值的计算方式为 counter = counter /2 + priority。这里计算过程不考虑进程的状态。</span></span><br><span class="line">		<span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">			<span class="keyword">if</span> (*p)</span><br><span class="line">				(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>)+ </span><br><span class="line">						(*p)-&gt;priority;</span><br><span class="line">	&#125;</span><br><span class="line">	switch_to(next);<span class="comment">// 切换到任务号为 next 的任务，并运行之。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前进程0被切换到进程1的时候，进程0停在了switch_to函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> switch_to(n) &#123;\  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">long</span> a,b;&#125; __tmp; \ </span><br><span class="line">__asm__(<span class="string">&quot;cmpl %%ecx,_current\n\t&quot;</span> \ <span class="comment">// 任务 n 是当前任务吗?(current ==task[n]?) </span></span><br><span class="line">  ...</span><br><span class="line">	<span class="string">&quot;ljmp %0\n\t&quot;</span> \ <span class="comment">// 执行长跳转至*&amp;__tmp，造成任务切换。</span></span><br><span class="line">	<span class="string">&quot;cmpl %%ecx,_last_task_used_math\n\t&quot;</span> \ <span class="comment">// 新任务上次使用过协处理器吗？</span></span><br><span class="line">	<span class="string">&quot;jne 1f\n\t&quot;</span> \  <span class="comment">// 没有则跳转，退出。</span></span><br><span class="line">	<span class="string">&quot;clts\n&quot;</span> \ <span class="comment">// 新任务上次使用过协处理器，则清 cr0 的 TS 标志。</span></span><br><span class="line">	<span class="string">&quot;1:&quot;</span> \</span><br><span class="line">	::<span class="string">&quot;m&quot;</span> (*&amp;__tmp.a),<span class="string">&quot;m&quot;</span> (*&amp;__tmp.b), \ <span class="comment">//一个是段选择子（b是段选择子），一个是偏移（a是偏移），任务门切换只需要跳到新的tss段就可，不需要偏移</span></span><br><span class="line">	<span class="string">&quot;d&quot;</span> (_TSS(n)),<span class="string">&quot;c&quot;</span> ((<span class="type">long</span>) task[n])); \ <span class="comment">//在进程切换走的时候，当前进程的状态保存在了tss（n）里面，edx保存了tss n的索引号 </span></span><br><span class="line">     <span class="comment">//因此在切回来的时候，tss段里面有当前的进程状态。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切到进程1的时候执行了<code>ljmp %0\n\</code>进程切走了，而进程0自己的tss里面保存的要执行的下一条指令的eip：<code>cmpl %%ecx,_last_task_used_math\n\t</code>
是这条指令，因此切回进程0从这条语句开始执行</p>
<p>进程0将处于挂起状态执行：pause(),sys_pause(),schedule(),switch_to(0).进程0起到怠速作用</p>
<p>当过了一段时间，硬盘剩下的数据读完了硬件产生中断，读盘中断服务程序响应中断，进入read_intr判断缓冲区是否读完，这里一共一个块要读两次，两次都读完就读完了</p>
<p>不执行<code>if (--CURRENT-&gt;nr_sectors)</code>里面·的·语句，直接跳到<code>end_request(1)</code>语句执行</p>
<h5 id="read_intr">read_intr</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_intr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (win_result()) &#123;</span><br><span class="line">		bad_rw_intr();</span><br><span class="line">		do_hd_request();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	port_read(HD_DATA,CURRENT-&gt;buffer,<span class="number">256</span>);</span><br><span class="line">	CURRENT-&gt;errors = <span class="number">0</span>;</span><br><span class="line">	CURRENT-&gt;buffer += <span class="number">512</span>;</span><br><span class="line">	CURRENT-&gt;sector++;</span><br><span class="line">	<span class="keyword">if</span> (--CURRENT-&gt;nr_sectors) &#123;</span><br><span class="line">		do_hd = &amp;read_intr;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	end_request(<span class="number">1</span>);</span><br><span class="line">	do_hd_request();<span class="comment">//请求项里面只要有任意一个请求项走到同步操作，</span></span><br><span class="line">	<span class="comment">//就一直走走到走完为止（主设备的那一条链上的request）</span></span><br><span class="line">	<span class="comment">//类似于从中断引发的递归 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203231230513.png" alt="image-20231203231230513">
<figcaption aria-hidden="true">image-20231203231230513</figcaption>
</figure>
<h5 id="end_request">end_request</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CURRENT (blk_dev[MAJOR_NR].current_request) <span class="comment">//CURRENT是当前请求项</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">wait_for_request</span> =</span> <span class="literal">NULL</span>;<span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">end_request</span><span class="params">(<span class="type">int</span> uptodate)</span></span><br><span class="line">&#123;</span><br><span class="line">	DEVICE_OFF(CURRENT-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (CURRENT-&gt;bh) &#123;</span><br><span class="line">		CURRENT-&gt;bh-&gt;b_uptodate = uptodate;</span><br><span class="line">		unlock_buffer(CURRENT-&gt;bh);<span class="comment">//解锁缓冲块</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!uptodate) &#123;</span><br><span class="line">		printk(DEVICE_NAME <span class="string">&quot; I/O error\n\r&quot;</span>);</span><br><span class="line">		printk(<span class="string">&quot;dev %04x, block %d\n\r&quot;</span>,CURRENT-&gt;dev,</span><br><span class="line">			CURRENT-&gt;bh-&gt;b_blocknr);</span><br><span class="line">	&#125;</span><br><span class="line">	wake_up(&amp;CURRENT-&gt;waiting);<span class="comment">//这个没用过</span></span><br><span class="line">	wake_up(&amp;wait_for_request);<span class="comment">//唤醒由于请求项用完了而休眠的进程</span></span><br><span class="line">	CURRENT-&gt;dev = <span class="number">-1</span>;<span class="comment">//反应请求项是否被占用</span></span><br><span class="line">	CURRENT = CURRENT-&gt;next;<span class="comment">//req仍然在数组中，但从链上脱钩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时磁盘已经全部读进来，update=1位置1</p>
<h4 id="进程1唤醒">进程1唤醒</h4>
<h5 id="unlock_buffer">unlock_buffer</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">unlock_buffer</span><span class="params">(<span class="keyword">struct</span> buffer_head * bh)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!bh-&gt;b_lock)</span><br><span class="line">		printk(DEVICE_NAME <span class="string">&quot;: free buffer being unlocked\n&quot;</span>);</span><br><span class="line">	bh-&gt;b_lock=<span class="number">0</span>;<span class="comment">//解锁，之前给缓冲块向进程（1）之间加锁</span></span><br><span class="line">	wake_up(&amp;bh-&gt;b_wait);<span class="comment">//唤醒进程（1）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="wake_up">wake_up</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//p 指向b_wait的指针</span></span><br><span class="line">    <span class="comment">//*p b_wait</span></span><br><span class="line">	<span class="comment">//**p b_wait指向的东西，task—struct</span></span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; *p) &#123;</span><br><span class="line">		(**p).state=<span class="number">0</span>;</span><br><span class="line">		*p=<span class="literal">NULL</span>;<span class="comment">//tmp </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="这里是null还是tmp的讨论---sleep_on深层逻辑基于内核栈的唤醒队列">这里是null还是tmp的讨论---sleep_on深层逻辑基于内核栈的唤醒队列</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span><span class="comment">//p是指向b_wait的志珍</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (current == &amp;(init_task.task))<span class="comment">//当前进程是不是进程0</span></span><br><span class="line">		panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">	tmp = *p;<span class="comment">//*p就是b_wait，目前是null在初始化的时候是null（buffer init）第一个缓冲块初始化到现在还没动过</span></span><br><span class="line">	*p = current;<span class="comment">//b_wait 指向进程1的task struct。                                                                                            </span></span><br><span class="line">	current-&gt;state = TASK_UNINTERRUPTIBLE;<span class="comment">//进程·0进程1都挂起了</span></span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">if</span> (tmp)</span><br><span class="line">		tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">	*p=tmp;<span class="comment">//加这一句会更好，比较对称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep on 构成的队列分析：</p>
<p>因为sleep_on是在内核态调用的，所以这里的tmp是在内核栈中，b_wait是全局变量。一开始只有进程A申请的时候，最开始的b_wait=null</p>
<p>假设一开始只有进程A，A申请缓冲块，一开始没有现成的的缓冲块，进程A调用<code>getblk</code>,首先在hash表里面找<code>get_hash_table</code></p>
<p>没有现成的，然后沿着free_list在缓冲块的双向环链表上面寻找，顺着链找一块没被别的进程占用（引用计数为0（别的进程已经走了），并且最好是lock或者完全没被用过的，其次才是dirt的），此时假设缓冲区全是新的（和进程1一样），此时A会把该缓冲块插入hash的叉子上，然后进程A需要等待磁盘将内容加载到它选择的这块缓冲块里面，在等待的过程中进程A
sleep。具体而言，在<code>make_request</code>中开始加锁：<code>lock_buffer</code>，进程A在执行到bread的<code>wait_on_buffer(bh);</code>的时候睡眠等待磁盘把缓冲区写完。</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129104547640.png" alt="A stack">
<figcaption aria-hidden="true">A stack</figcaption>
</figure>
<p>此时如果切到新的进程B也要申请和A相同的设备号块号，B在调用getblk的时候：执行<code>if (bh = get_hash_table(dev,block)) return bh</code>的时候，因为A已经把缓冲块放到Hash队列里面了，所以进程B找到了现成的，此时进程A还没有用完，进程B在wait
buffer的时候调用sleep_on。</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129105131834.png" alt="B内核栈">
<figcaption aria-hidden="true">B内核栈</figcaption>
</figure>
<p>同理如果又来了进程C也请求了该缓冲块就变成：形成一个由内核栈构成的等待队列</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129105434871.png" alt="等待队列">
<figcaption aria-hidden="true">等待队列</figcaption>
</figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129101121864.png" alt="该缓冲块插入hash的叉子上">
<figcaption aria-hidden="true">该缓冲块插入hash的叉子上</figcaption>
</figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129095311681.png" alt="image-20231129095311681">
<figcaption aria-hidden="true">image-20231129095311681</figcaption>
</figure>
<p>那么现在回到wake up</p>
<p>当进程A完成磁盘的操作后，唤醒进程的时候是通过b
wait唤醒，如果是null的效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//p 指向b_wait的指针</span></span><br><span class="line">    <span class="comment">//*p b_wait</span></span><br><span class="line">	<span class="comment">//**p b_wait指向的东西，task—struct</span></span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; *p) &#123;</span><br><span class="line">		(**p).state=<span class="number">0</span>;</span><br><span class="line">		*p=<span class="literal">NULL</span>;<span class="comment">//tmp </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129110807043.png" alt="image-20231129110807043">
<figcaption aria-hidden="true">image-20231129110807043</figcaption>
</figure>
<p>切回来以后进程继续沿着sleep_on执行</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129111725176.png" alt="image-20231129111725176">
<figcaption aria-hidden="true">image-20231129111725176</figcaption>
</figure>
<p>唤醒tmp所指的进程B</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129111811437.png" alt="image-20231129111811437">
<figcaption aria-hidden="true">image-20231129111811437</figcaption>
</figure>
<p>在schedule的时候会用到state，由于此时state已经设为0解锁了，调度的时候就可以切到该进程执行。</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231129111130011.png" alt="image-20231129111130011">
<figcaption aria-hidden="true">image-20231129111130011</figcaption>
</figure>
<p>在这个框架下面其他的进程怎么唤醒？由链子上面的上一个进程负责唤醒下一个进程</p>
<h4 id="bread后时代">bread后时代</h4>
<p>回到<code>sys_setup</code>执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_setup</span><span class="params">(<span class="type">void</span> * BIOS)</span> <span class="comment">//首先解决硬盘的驱动器问题</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;NR_HD ; drive++) &#123;</span><br><span class="line">         <span class="comment">//300hd 200fd 100 虚拟盘</span></span><br><span class="line">		<span class="keyword">if</span> (!(bh = bread(<span class="number">0x300</span> + drive*<span class="number">5</span>,<span class="number">0</span>))) &#123;</span><br><span class="line">			printk(<span class="string">&quot;Unable to read partition table of drive %d\n\r&quot;</span>,</span><br><span class="line">				drive);</span><br><span class="line">			panic(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//缓冲块里，装着引导块的内容，如果扇区最后两个字节不是55AA说明扇区数据无效</span></span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_data[<span class="number">510</span>] != <span class="number">0x55</span> || (<span class="type">unsigned</span> <span class="type">char</span>)</span><br><span class="line">		    bh-&gt;b_data[<span class="number">511</span>] != <span class="number">0xAA</span>) &#123;</span><br><span class="line">			printk(<span class="string">&quot;Bad partition table on drive %d\n\r&quot;</span>,drive);</span><br><span class="line">			panic(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		p = <span class="number">0x1BE</span> + (<span class="type">void</span> *)bh-&gt;b_data;<span class="comment">//根据引导块中的信息设置分区hd</span></span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++,p++) &#123;</span><br><span class="line">			hd[i+<span class="number">5</span>*drive].start_sect = p-&gt;start_sect;</span><br><span class="line">			hd[i+<span class="number">5</span>*drive].nr_sects = p-&gt;nr_sects;</span><br><span class="line">		&#125;</span><br><span class="line">		brelse(bh);<span class="comment">//该缓冲块的历史使命已经完成，释放</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (NR_HD)</span><br><span class="line">		printk(<span class="string">&quot;Partition table%s ok.\n\r&quot;</span>,(NR_HD&gt;<span class="number">1</span>)?<span class="string">&quot;s&quot;</span>:<span class="string">&quot;&quot;</span>);</span><br><span class="line">	rd_load();</span><br><span class="line">	mount_root();</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引导块0，超级块1，一个分区一个</p>
<h4 id="文件系统">文件系统</h4>
<h5 id="minix-文件系统">MINIX <strong>文件系统</strong></h5>
<p>详见：操作系统文件系统。</p>
<p>操作系统中的文件系统可以分为两部分：操作系统内核中或者在硬盘软盘虚拟盘中。一个物理设备可以分为多个逻辑设备，比如一个物理硬盘可以分为多个逻辑硬盘。而一个逻辑设备只有一个文件系统，一个文件系统只包含一个i结点的树结构。一个逻辑设备只能有一个根i结点。</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203234247319.png" alt="image-20231203234247319">
<figcaption aria-hidden="true">image-20231203234247319</figcaption>
</figure>
<p>未安装文件系统的磁盘称之为生磁盘，生磁盘也可以作为文件读写，linux中一切皆文件。</p>
<p>生磁盘可以被分区，分区中可以安装文件系统，常见的文件系统有fat32、ext2、ext4等。</p>
<p>MINIX 文件系统与标准 UNIX 的文件系统基本相同。它由 6
个部分组成。分区内可以安装指定文件系统，同一磁盘多个分区文件系统不要求相同。MINIX文件系统布局如下：(下述部分是在磁盘上的)</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203233251707.png" alt="MINIX文件系统布局">
<figcaption aria-hidden="true">MINIX文件系统布局</figcaption>
</figure>
<ul>
<li><p>引导块：若作为引导分区，将存放<strong>操作系统的引导程序代码</strong>，否则空置。</p></li>
<li><p>超级块：用于存放磁盘设备上<strong>文件系统结构的信息</strong>，说明各部分的大小。</p></li>
<li><p>i节点位图：标记i节点数据元素是否被使用</p></li>
<li><p>逻辑块位图：标记磁盘数据块是否被使用</p></li>
<li><p>i节点区：用于存放inode节点数据，一个文件对应一个inode节点，inode节点存储文件属性数据。</p></li>
<li><p>数据区：以固定大小盘块（1k）为单位进行动态分配和回收，用于存储数据，类似内存分页。</p>
<p>位图：一个比特对应一个逻辑块，0，1代表是否被占用</p>
<p>删除文件：清理数据块关系清掉，对应逻辑块位图清0，清理i结点和i结点对应位图。</p>
<p><strong>超级块结构：</strong></p></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_ninodes;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_nzones;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_imap_blocks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_zmap_blocks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_firstdatazone;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_log_zone_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_max_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_magic;</span><br><span class="line"><span class="comment">/* These are only in memory */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_imap</span>[8];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_zmap</span>[8];</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_isup</span>;</span><span class="comment">//文件系统的根i结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_imount</span>;</span><span class="comment">//文件系统挂载到的结点</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_time;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">s_wait</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> s_lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> s_rd_only;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> s_dirt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205203527644.png" alt="超级块结构">
<figcaption aria-hidden="true">超级块结构</figcaption>
</figure>
<p><strong>inode结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_uid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_mtime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_gid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_nlinks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_zone[<span class="number">9</span>];</span><br><span class="line"><span class="comment">/* these are in memory also */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">i_wait</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_atime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_ctime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_dev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_num;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_dirt;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_pipe;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_mount;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_seek;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_update;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205203724496.png" alt="inode结构">
<figcaption aria-hidden="true">inode结构</figcaption>
</figure>
<p><strong>i_zone数组</strong></p>
<p><code>unsigned short i_zone[9];</code></p>
<p>i_zone数组包含直接盘块号、一次间接盘块号和二次间接盘块号。一次盘块号可视为单级页表，一次间接盘块号可视为二级页表、二次间接盘块号可视为三级页表。</p>
<p>这种处理方式的好处在于，对于小文件，通过直接块号可快速定位数据块；对于中等类型的文件，一次间接块可以维护较多数据块的同时，具有较快的访问速度；对于大型文件，二次间接盘块号可以维护大量磁盘块，但访问速度较慢。</p>
<p>内存多级页表与i_zone直接区别：不同进程具有固定大小的虚地址空间，并且对其整个虚地址空间的内存，都有可能访问到，因此使用多级页表。文件系统内存在很多大小不一的文件，综合考虑对不同大小文件的特点，使用1-3级磁盘块表可以分别处理小、中、大文件。</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205204603044.png" alt="izone">
<figcaption aria-hidden="true">izone</figcaption>
</figure>
<h5 id="文件系统-1">文件系统</h5>
<p>所有文件的i结点最终会挂成一个树形结构，树根i结点就是文件系统的根i结点，</p>
<p>加载文件系统就是把一个文件系统的根i结点挂接在另一个文件系统的i结点上，按照这个设计，一个文件系统必须要挂在另一个文件系统上面，最后最根部那个文件系统就是根文件系统</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203234309406.png" alt="加载根文件系统">
<figcaption aria-hidden="true">加载根文件系统</figcaption>
</figure>
<p>根文件系统挂在super_block[8]上。超级块：有一个超级块数组super_block[8]里面每一个元素是一个超级块，只要一个文件系统加载到内核了这个文件系统的根i结点会依次加载到这个数组里面。最多加载8个文件系统</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203234655944.png" alt="总体效果图">
<figcaption aria-hidden="true">总体效果图</figcaption>
</figure>
<p>文件系统用i结点来管理，一个i结点管理一个文件，目录文件也是文件，也有i结点来管理。</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231203232737245.png" alt="文件系统与i结点">
<figcaption aria-hidden="true">文件系统与i结点</figcaption>
</figure>
<p><strong>加载文件过程举例</strong>：</p>
<p>通过文件inode节点，可以定位文件数据块，那如何通过文件路径定位到具体文件？</p>
<p>文件系统主要包含文件和目录两种文件，目录是一种特殊的文件，其文件内容存储其目录下文件名-&gt;inode节点号的映射信息。文件查找开始于根目录，根目录号固定为0，不需要查找即可直接打开。</p>
<p>举例说明文件查找过程，给定存在路径<code>/name1/name2/name3</code>查找具体文件过程：</p>
<p>1）通过根节点inode号，打开根目录，读取其文件内容，即目录下文件名-&gt;inode节点号映射表，找到name1目录inode节点号n1</p>
<p>2）通过name1的inode号n1，打开name1目录，读取其文件内容，即目录下文件名-&gt;inode节点号映射表，找到name1目录inode节点号n2</p>
<p>3）通过name2的inode号n2，打开name2目录，读取其文件内容，即目录下文件名-&gt;inode节点号映射表，找到name3目录inode节点号n3</p>
<p>4）通过name3的inode号n3，打开name3文件</p>
<p>怎么打开文件：</p>
<p>通过文件查找找到文件inode节点号，然后打开文件，即读取inode至内存。</p>
<p>定位数据块：通过文件inode节点，访问其i_zone数组，进一步可以定位具体的数据所在磁盘块号。</p>
<p><img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205210257879.png"></p>
<h5 id="以c语言open和close返回的是什么解释文件系统">以c语言open和close返回的是什么解释文件系统</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file_table</span>[<span class="title">NR_FILE</span>];</span><span class="comment">//20</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> <span class="title">super_block</span>[<span class="title">NR_SUPER</span>];</span><span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">f_inode</span>;</span></span><br><span class="line">	<span class="type">off_t</span> f_pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>操作系统只有一个super_blocks数组，每个数组元素是一个超级块，一个超级块管理一个逻辑设备，因此最多挂载8个逻辑设备，其中只有一个根设备。</p></li>
<li><p>inode_table[32]每一个元素就是一个i结点，是在操作系统中所有打开的i结点</p></li>
<li><p>file_table
里面装了file结构体，<code>struct super_block super_block[NR_SUPER]</code></p></li>
</ul>
<p>​ f_inode指针指向inode_table里面的元素</p>
<ul>
<li>task struct里面的filp <code>struct file * filp[NR_OPEN];/</code>：
指针数组，每个元素都是file类型的指针</li>
</ul>
<p>linux
0.11一个进程最多只能打开20个文件（文件是可以重复打开的）可以同一个文件占多个file_table的表项</p>
<p>filp归进程管。进程打开一个文件，首先在filp里面找空闲项，
将这个空闲的位置指向file_table其中的一项，这一项里面的f_inode指针指向inode_table。
c语言里面打开文件返回的句柄就是这个指向的inode_table位置对应的下标索引，例如下图就是0.打开文件就是建立这个指针链接的过程，对应的close文件就是把这个关系链断掉。</p>
<p>file对应的是用户的需求，inode对应的是内核管理</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/文件系统.png" alt="文件系统">
<figcaption aria-hidden="true">文件系统</figcaption>
</figure>
<p>打开同一个文件，指向的inode_table是一个，file_table新开了一个</p>
<p>file_table【64】是整个kernel只有一个，file_table[32]也是整个操作系统只有一个，每个元素是一个file对象</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205214503609.png" alt="打开同一个文件">
<figcaption aria-hidden="true">打开同一个文件</figcaption>
</figure>
<p>目录跟结点也要放到inode——table，当路径找完了就把结点pop了</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205200445043.png" alt="image-20231205200445043">
<figcaption aria-hidden="true">image-20231205200445043</figcaption>
</figure>
<h4 id="更换根设备进程1格式化虚拟盘并更换跟设备为虚拟盘">更换根设备（进程1格式化虚拟盘并更换跟设备为虚拟盘）</h4>
<p>之前第二章设置了虚拟盘并初始化，但是当时没有进行格式化还不能作为块设备使用。格式化的信息存在boot操作系统的软盘上</p>
<p>进程1调用<code>rd_load();</code>函数格式化虚拟盘调用</p>
<p>rd_load()是虚拟盘根文件加载函数。在系统初始化阶段，该函数被用于尝试从启动引导盘
上指定的磁盘块位置开始处把一个根文件系统加载到虚拟盘中。在函数中，这个起始磁盘块位置被定为256。当然你也可以根据自己的具体要求修改这个值，只要保证这个值所规定的磁盘容量能容纳内核映象
文件即可。这样一个由内核引导映象文件（Bootimage）加上根文件系统映象文件（Rootiamge）组合而
成的“二合一”磁盘，就可以象启动 DOS 系统盘那样来启动 Linux
系统。在进行正常的根文件系统加载之前，系统会首先执行
rd_load()函数，试图从磁盘的第 257 块中读取
根文件系统超级块。若成功，就把该根文件映象文件读到内存虚拟盘中，并把根文件系统设备标志</p>
<p>ROOT_DEV 设置为虚拟盘设备（0x0101），否则退出
rd_load()，系统继续从别的设备上执行根文件加载 操作。
之前根设备是软盘：bootsect.s里面指定的</p>
<p>==把虚拟盘指定为根设备，读硬盘是有中断的。软盘因为比较快就在内存里。所以读软盘不用中断读软盘要用do_rd_request==</p>
<p>==rd虚拟盘，虚拟的是软盘==，相当于把软盘的内容映射过来，然后把虚拟盘替软盘成为根设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rd_load</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>	<span class="title">s</span>;</span></span><br><span class="line">	<span class="type">int</span>		block = <span class="number">256</span>;	<span class="comment">/* Start at block 256 */</span></span><br><span class="line">	<span class="type">int</span>		i = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span>		nblocks;</span><br><span class="line">	<span class="type">char</span>		*cp;		<span class="comment">/* Move pointer */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!rd_length)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	printk(<span class="string">&quot;Ram disk: %d bytes, starting at 0x%x\n&quot;</span>, rd_length,</span><br><span class="line">		(<span class="type">int</span>) rd_start);</span><br><span class="line">	<span class="keyword">if</span> (MAJOR(ROOT_DEV) != <span class="number">2</span>)<span class="comment">//判断是不是软盘</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//block：引导块，block+1超级块//见上面文件系统的格式图</span></span><br><span class="line">	bh = breada(ROOT_DEV,block+<span class="number">1</span>,block,block+<span class="number">2</span>,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Disk error while looking for ramdisk!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*((<span class="keyword">struct</span> d_super_block *) &amp;s) = *((<span class="keyword">struct</span> d_super_block *) bh-&gt;b_data);</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="comment">//判断文件系统是不是minux文件系统</span></span><br><span class="line">	<span class="keyword">if</span> (s.s_magic != SUPER_MAGIC)</span><br><span class="line">		<span class="comment">/* No ram disk image present, assume normal floppy boot */</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	nblocks = s.s_nzones &lt;&lt; s.s_log_zone_size;</span><br><span class="line">	<span class="keyword">if</span> (nblocks &gt; (rd_length &gt;&gt; BLOCK_SIZE_BITS)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Ram disk image too big!  (%d blocks, %d avail)\n&quot;</span>, </span><br><span class="line">			nblocks, rd_length &gt;&gt; BLOCK_SIZE_BITS);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;Loading %d bytes into ram disk... 0000k&quot;</span>, </span><br><span class="line">		nblocks &lt;&lt; BLOCK_SIZE_BITS);</span><br><span class="line">	cp = rd_start;</span><br><span class="line">	<span class="keyword">while</span> (nblocks) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nblocks &gt; <span class="number">2</span>) </span><br><span class="line">			bh = breada(ROOT_DEV, block, block+<span class="number">1</span>, block+<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			bh = bread(ROOT_DEV, block);</span><br><span class="line">		<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">			printk(<span class="string">&quot;I/O error on block %d, aborting load\n&quot;</span>, </span><br><span class="line">				block);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		(<span class="type">void</span>) <span class="built_in">memcpy</span>(cp, bh-&gt;b_data, BLOCK_SIZE);</span><br><span class="line">		brelse(bh);</span><br><span class="line">		printk(<span class="string">&quot;\010\010\010\010\010%4dk&quot;</span>,i);</span><br><span class="line">		cp += BLOCK_SIZE;</span><br><span class="line">		block++;</span><br><span class="line">		nblocks--;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;\010\010\010\010\010done \n&quot;</span>);</span><br><span class="line">	ROOT_DEV=<span class="number">0x0101</span>;<span class="comment">//主设备号换为100:虚拟盘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加载根文件系统">加载根文件系统</h4>
<p>进程1调用mount_root在根设备虚拟盘上加载根文件系统</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_isup</span>;</span><span class="comment">//文件系统的根i结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_imount</span>;</span><span class="comment">//文件系统挂载到的结点</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231205221522997.png" alt="文件系统加载结点">
<figcaption aria-hidden="true">文件系统加载结点</figcaption>
</figure>
<h5 id="首先挂载super_block数组和file_table数组">首先挂载super_block数组和file_table数组</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,<span class="built_in">free</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">mi</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">32</span> != <span class="keyword">sizeof</span> (<span class="keyword">struct</span> d_inode))</span><br><span class="line">		panic(<span class="string">&quot;bad i-node size&quot;</span>);</span><br><span class="line">	<span class="comment">//file_table初始化引用计数清0</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NR_FILE;i++)</span><br><span class="line">		file_table[i].f_count=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//判断是否为软盘</span></span><br><span class="line">	<span class="keyword">if</span> (MAJOR(ROOT_DEV) == <span class="number">2</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Insert root floppy and press ENTER&quot;</span>);</span><br><span class="line">		wait_for_keypress();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化super_block</span></span><br><span class="line">	<span class="keyword">for</span>(p = &amp;super_block[<span class="number">0</span>] ; p &lt; &amp;super_block[NR_SUPER] ; p++) &#123;</span><br><span class="line">		p-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">		p-&gt;s_lock = <span class="number">0</span>;</span><br><span class="line">		p-&gt;s_wait = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211092132558.png" alt="image-20231211092132558">
<figcaption aria-hidden="true">image-20231211092132558</figcaption>
</figure>
<h5 id="read_super加载文件系统超级块">read_super加载文件系统超级块</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (!(p=read_super(ROOT_DEV)))</span><br><span class="line">		panic(<span class="string">&quot;Unable to mount root&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>read_super()用于把指定设备的文件系统的==超级块==读入到==缓冲区==中，并登记到超级块数组中，同时也
把文件系统的 i
节点位图和逻辑块位图读入内存超级块结构的相应数组中。最后并返回该超级块结构的
指针。</p>
<p>首先检查这个要读的超级块是不是已经在super_block[8]中，如果有直接使用不用在加载一次了（和缓冲区看有没有现成的一个意思）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">s</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">int</span> i,block;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	check_disk_change(dev);<span class="comment">//检查是否换过盘</span></span><br><span class="line">	<span class="keyword">if</span> (s = get_super(dev))</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="get_super">get_super</h6>
<p>查这个要读的超级块是不是已经在super_block[8]中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> super_block * <span class="title function_">get_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	s = <span class="number">0</span>+super_block;</span><br><span class="line">	<span class="keyword">while</span> (s &lt; NR_SUPER+super_block)</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;s_dev == dev) &#123;</span><br><span class="line">			wait_on_super(s);</span><br><span class="line">			<span class="keyword">if</span> (s-&gt;s_dev == dev)</span><br><span class="line">				<span class="keyword">return</span> s;</span><br><span class="line">			s = <span class="number">0</span>+super_block;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			s++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超级块上锁等待（别的进程加载了这个文件系统）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wait_on_super</span><span class="params">(<span class="keyword">struct</span> super_block * sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	cli();</span><br><span class="line">	<span class="keyword">while</span> (sb-&gt;s_lock)</span><br><span class="line">		sleep_on(&amp;(sb-&gt;s_wait));</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="在super_block里面找到空项">在super_block里面找到空项</h6>
<p>在super_block中找到一项空的并加锁。这里加载根文件系统，第一项就是空的所以是选了第一个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> (s = <span class="number">0</span>+super_block ;; s++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s &gt;= NR_SUPER+super_block)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (!s-&gt;s_dev)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;s_dev = dev;</span><br><span class="line">	s-&gt;s_isup = <span class="literal">NULL</span>;</span><br><span class="line">	s-&gt;s_imount = <span class="literal">NULL</span>;</span><br><span class="line">	s-&gt;s_time = <span class="number">0</span>;</span><br><span class="line">	s-&gt;s_rd_only = <span class="number">0</span>;</span><br><span class="line">	s-&gt;s_dirt = <span class="number">0</span>;</span><br><span class="line">	lock_super(s);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211095203241.png" alt="image-20231211095203241">
<figcaption aria-hidden="true">image-20231211095203241</figcaption>
</figure>
<h6 id="把超级块加载到缓冲区再加载到super-block">把超级块加载到缓冲区，再加载到super
block</h6>
<p>调用bread读取超级块，这里的设备是rd虚拟盘。块号是1.因此在do
request的时候是do_rd_request.虚拟盘虽然是内存模拟的盘，但是读取的操作完全模仿了外设，但是他毕竟是内存不是外设，因此和读硬盘不同的是：不会发生类似硬盘中断的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (!(bh = bread(dev,<span class="number">1</span>))) &#123;</span><br><span class="line">		s-&gt;s_dev=<span class="number">0</span>;</span><br><span class="line">		free_super(s);<span class="comment">//释放超级块</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//将缓冲区的超级块复制到刚才找到的super_block【0】中</span></span><br><span class="line">	*((<span class="keyword">struct</span> d_super_block *) s) =</span><br><span class="line">		*((<span class="keyword">struct</span> d_super_block *) bh-&gt;b_data);</span><br><span class="line">	brelse(bh);<span class="comment">//释放缓冲块</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;s_magic != SUPER_MAGIC) &#123;</span><br><span class="line">		s-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">		free_super(s);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211100257070.png" alt="image-20231211100257070">
<figcaption aria-hidden="true">image-20231211100257070</figcaption>
</figure>
<h6 id="完善super-blok中i结点位图逻辑位图">完善super
blok中i结点位图逻辑位图</h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> super_block * <span class="title function_">read_super</span><span class="params">(<span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">//首先初始化imap和zmap</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;I_MAP_SLOTS;i++)</span><br><span class="line">		s-&gt;s_imap[i] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;Z_MAP_SLOTS;i++)</span><br><span class="line">		s-&gt;s_zmap[i] = <span class="literal">NULL</span>;</span><br><span class="line">	block=<span class="number">2</span>;<span class="comment">//虚拟盘的第一块是超级块，第二块开始是i结点位图和逻辑块位图所以这里是2</span></span><br><span class="line">    <span class="comment">//把虚拟盘上的逻辑位图加载到缓冲区中，并都挂载到s_imap上</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; s-&gt;s_imap_blocks ; i++)</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;s_imap[i]=bread(dev,block))</span><br><span class="line">			block++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//挂完i结点的位图挂载逻辑块位图</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; s-&gt;s_zmap_blocks ; i++)</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;s_zmap[i]=bread(dev,block))</span><br><span class="line">			block++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//如果块数量不对说明操作系统出问题了释放之前的缓冲块和超级块</span></span><br><span class="line">	<span class="keyword">if</span> (block != <span class="number">2</span>+s-&gt;s_imap_blocks+s-&gt;s_zmap_blocks) &#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;I_MAP_SLOTS;i++)</span><br><span class="line">			brelse(s-&gt;s_imap[i]);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Z_MAP_SLOTS;i++)</span><br><span class="line">			brelse(s-&gt;s_zmap[i]);</span><br><span class="line">		s-&gt;s_dev=<span class="number">0</span>;</span><br><span class="line">		free_super(s);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//牺牲第一个i结点，防止查找算法返回0</span></span><br><span class="line">	s-&gt;s_imap[<span class="number">0</span>]-&gt;b_data[<span class="number">0</span>] |= <span class="number">1</span>;</span><br><span class="line">	s-&gt;s_zmap[<span class="number">0</span>]-&gt;b_data[<span class="number">0</span>] |= <span class="number">1</span>;</span><br><span class="line">	free_super(s);<span class="comment">//解锁超级块</span></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_super</span><span class="params">(<span class="keyword">struct</span> super_block * sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	cli();</span><br><span class="line">	sb-&gt;s_lock = <span class="number">0</span>;</span><br><span class="line">	wake_up(&amp;(sb-&gt;s_wait));</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211102021214.png" alt="image-20231211102021214">
<figcaption aria-hidden="true">image-20231211102021214</figcaption>
</figure>
<h5 id="将根设备的根i结点挂载super-block上">将根设备的根i结点挂载super
block上</h5>
<p>调用iget从虚拟盘上读取i结点。有了i结点，可以通过根i结点找到文件系统中的任意指定i结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">	<span class="comment">//i number ：i结点位图的序号，iget：给定结点，给定设备，这里在找虚拟盘的根i结点</span></span><br><span class="line">	<span class="keyword">if</span> (!(mi=iget(ROOT_DEV,ROOT_INO)))</span><br><span class="line">		panic(<span class="string">&quot;Unable to read root i-node&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h6 id="igetget_empty_inode">iget:get_empty_inode</h6>
<p>首先在记载所有打开的i结点的数组中申请一个空闲的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">iget</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>, * <span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		panic(<span class="string">&quot;iget with dev==0&quot;</span>);</span><br><span class="line">	empty = get_empty_inode();<span class="comment">//从inode_table[32]中申请一个空闲的i结点</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">get_empty_inode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">last_inode</span> =</span> inode_table; <span class="comment">// last_inode 指向 i 节点表第一项</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 扫描 i 节点表。 </span></span><br><span class="line">		inode = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = NR_INODE; i ; i--) &#123;</span><br><span class="line">            <span class="comment">// 如果 last_inode 已经指向 i 节点表的最后 1 项之后，则让其重新指向 i 节点表开始处。</span></span><br><span class="line">			<span class="keyword">if</span> (++last_inode &gt;= inode_table + NR_INODE)</span><br><span class="line">				last_inode = inode_table;</span><br><span class="line">            <span class="comment">// 如果 last_inode 所指向的 i 节点的计数值为 0，则说明可能找到空闲 i 节点项。让 inode 指向 </span></span><br><span class="line">           <span class="comment">// 该 i 节点。如果该 i 节点的已修改标志和锁定标志均为 0，则我们可以使用该 i 节点，于是退出循环。 </span></span><br><span class="line">			<span class="keyword">if</span> (!last_inode-&gt;i_count) &#123;</span><br><span class="line">				inode = last_inode;</span><br><span class="line">				<span class="keyword">if</span> (!inode-&gt;i_dirt &amp;&amp; !inode-&gt;i_lock)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 如果没有找到空闲 i 节点(inode=NULL)，则将整个 i 节点表打印出来供调试使用，并死机。</span></span><br><span class="line">		<span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_INODE ; i++)</span><br><span class="line">				printk(<span class="string">&quot;%04x: %6d\t&quot;</span>,inode_table[i].i_dev,</span><br><span class="line">					inode_table[i].i_num);</span><br><span class="line">			panic(<span class="string">&quot;No free inodes in mem&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 等待该 i 节点解锁（如果又被上锁的话）。 </span></span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">        <span class="comment">// 如果该 i 节点已修改标志被置位的话，则将该 i 节点刷新，并等待该 i 节点解锁。</span></span><br><span class="line">		<span class="keyword">while</span> (inode-&gt;i_dirt) &#123;</span><br><span class="line">			write_inode(inode);</span><br><span class="line">			wait_on_inode(inode);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (inode-&gt;i_count);<span class="comment">//// 如果 i 节点又被其它占用的话，则重新寻找空闲 i 节点。</span></span><br><span class="line">    <span class="comment">// 已找到空闲 i 节点项。则将该 i 节点项内容清零，并置引用标志为 1，返回该 i 节点指针。</span></span><br><span class="line">	<span class="built_in">memset</span>(inode,<span class="number">0</span>,<span class="keyword">sizeof</span>(*inode));</span><br><span class="line">	inode-&gt;i_count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="iget">iget</h6>
<p>inode_table 初始化的时候:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> <span class="title">inode_table</span>[<span class="title">NR_INODE</span>]=</span>&#123;&#123;<span class="number">0</span>,&#125;,&#125;; <span class="comment">// 内存中 i 节点表（NR_INODE=32 项）。</span></span><br></pre></td></tr></table></figure>
<p>这是对数组进行初始化的语法。它使用了一个嵌套的大括号，将数组中的每个元素初始化为
<code>&#123;0,&#125;</code>，这将初始化结构体中的所有成员为零（或NULL，具体取决于结构体的定义）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> m_inode * <span class="title function_">iget</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">     <span class="comment">// 扫描 i 节点表。寻找指定节点号的 i 节点。并递增该节点的引用次数。</span></span><br><span class="line">	inode = inode_table;</span><br><span class="line">	<span class="keyword">while</span> (inode &lt; NR_INODE+inode_table) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_dev != dev || inode-&gt;i_num != nr) &#123;</span><br><span class="line">			inode++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">        <span class="comment">// 如果当前扫描的 i 节点的设备号不等于指定的设备号或者节点号不等于指定的节点号，则继续扫描。</span></span><br><span class="line">        <span class="comment">//MOUNT ROOT调用的时候if (!(mi=iget(ROOT_DEV,ROOT_INO)))。dev=0.nr=1)</span></span><br><span class="line">        <span class="comment">//所以刚初始化完的都是0，找不到所以会跳完这个while</span></span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_dev != dev || inode-&gt;i_num != nr) &#123;</span><br><span class="line">			inode = inode_table;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		inode-&gt;i_count++;</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_mount) &#123;</span><br><span class="line">			<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span> ; i&lt;NR_SUPER ; i++)</span><br><span class="line">				<span class="keyword">if</span> (super_block[i].s_imount==inode)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (i &gt;= NR_SUPER) &#123;</span><br><span class="line">				printk(<span class="string">&quot;Mounted inode hasn&#x27;t got sb\n&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (empty)</span><br><span class="line">					iput(empty);</span><br><span class="line">				<span class="keyword">return</span> inode;</span><br><span class="line">			&#125;</span><br><span class="line">			iput(inode);</span><br><span class="line">			dev = super_block[i].s_dev;</span><br><span class="line">			nr = ROOT_INO;</span><br><span class="line">			inode = inode_table;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (empty)</span><br><span class="line">			iput(empty);</span><br><span class="line">		<span class="keyword">return</span> inode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!empty)</span><br><span class="line">		<span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//第一次初始化的话会跳到这个地方执行，而不会在上面的循环中return 因为有continue</span></span><br><span class="line">    <span class="comment">//将当前的跟设备和块号赋值给找出来的inode table里面空闲的inode</span></span><br><span class="line">	inode=empty;</span><br><span class="line">	inode-&gt;i_dev = dev;</span><br><span class="line">	inode-&gt;i_num = nr;</span><br><span class="line">    </span><br><span class="line">	read_inode(inode);<span class="comment">//从虚拟盘上读出i结点</span></span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="read_inode">read_inode</h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_inode</span><span class="params">(<span class="keyword">struct</span> m_inode * inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="type">int</span> block;</span><br><span class="line"></span><br><span class="line">	lock_inode(inode);<span class="comment">//首先对这个选出来的结点加锁，在解锁之前这个结点都不会被其它进程占用</span></span><br><span class="line">	<span class="keyword">if</span> (!(sb=get_super(inode-&gt;i_dev)))<span class="comment">//获得该节点所在设备的超级块</span></span><br><span class="line">		panic(<span class="string">&quot;trying to read inode without dev&quot;</span>);</span><br><span class="line">  <span class="comment">// 该 i 节点所在的逻辑块号 = (启动块+超级块) + i 节点位图占用的块数 + 逻辑块位图占用的块数 + </span></span><br><span class="line"> <span class="comment">// (i 节点号-1)/每块含有的 i 节点数。</span></span><br><span class="line">	block = <span class="number">2</span> + sb-&gt;s_imap_blocks + sb-&gt;s_zmap_blocks +</span><br><span class="line">		(inode-&gt;i_num<span class="number">-1</span>)/INODES_PER_BLOCK;</span><br><span class="line">    <span class="comment">//将inode的块读到缓冲中                                                               </span></span><br><span class="line">	<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,block)))</span><br><span class="line">		panic(<span class="string">&quot;unable to read i-node block&quot;</span>);</span><br><span class="line">    <span class="comment">//将读入的数据从缓冲块赋值给inode</span></span><br><span class="line">	*(<span class="keyword">struct</span> d_inode *)inode =</span><br><span class="line">		((<span class="keyword">struct</span> d_inode *)bh-&gt;b_data)</span><br><span class="line">			[(inode-&gt;i_num<span class="number">-1</span>)%INODES_PER_BLOCK];</span><br><span class="line">	brelse(bh);<span class="comment">//释放缓冲块</span></span><br><span class="line">	unlock_inode(inode);<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/image-20231211131847124.png" alt="image-20231211131847124">
<figcaption aria-hidden="true">image-20231211131847124</figcaption>
</figure>
<h5 id="将根文件系统与进程1关联设置root和pwd">将根文件系统与进程1关联，设置root和pwd</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">    <span class="keyword">if</span> (!(mi=iget(ROOT_DEV,ROOT_INO)))</span><br><span class="line">		panic(<span class="string">&quot;Unable to read root i-node&quot;</span>);</span><br><span class="line">    <span class="comment">/* 该 i 节点引用次数递增 3 次。因为下面 </span></span><br><span class="line"><span class="comment">    p-&gt;s_isup = p-&gt;s_imount = mi;</span></span><br><span class="line"><span class="comment">    p-&gt;s_isup = p-&gt;s_imount = mi;</span></span><br><span class="line"><span class="comment">	current-&gt;pwd = mi;</span></span><br><span class="line"><span class="comment">    也引用了该 i 节点。*/</span></span><br><span class="line">    mi-&gt;i_count += <span class="number">3</span> ;	<span class="comment">/* NOTE! it is logically used 4 times, not 1 */</span></span><br><span class="line">	p-&gt;s_isup = p-&gt;s_imount = mi;<span class="comment">//他是最根的i结点。自己挂自己，这句话加载了跟设备的根文件系统，非常重要</span></span><br><span class="line">	current-&gt;pwd = mi;<span class="comment">//当前进程的工作目录（当前进程是进程1）进程1的工作目录是根文件系统的根i结点，从进程1开始才有文件系统</span></span><br><span class="line">	<span class="comment">//进程0没有，绝对路径：从根文件系统往下撸和相对路径，根据pwd往下撸</span></span><br><span class="line">	current-&gt;root = mi; <span class="comment">//后面由于父子进程创建遗传机制，后面的进程也会继承这个特征</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计算虚拟盘空闲块信息">计算虚拟盘空闲块信息</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     ... </span><br><span class="line">    <span class="comment">// 统计该设备上空闲块数。首先令 i 等于超级块中表明的设备逻辑块总数。 </span></span><br><span class="line">    <span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">	i=p-&gt;s_nzones;</span><br><span class="line"><span class="comment">// 然后根据逻辑块位图中相应比特位的占用情况统计出空闲块数。这里宏函数 set_bit()只是在测试 </span></span><br><span class="line"> <span class="comment">// 比特位，而非设置比特位。&quot;i&amp;8191&quot;用于取得 i 节点号在当前块中的偏移值。&quot;i&gt;&gt;13&quot;是将 i 除以 </span></span><br><span class="line"> <span class="comment">// 8192，也即除一个磁盘块包含的比特位数。 </span></span><br><span class="line">	<span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_zmap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line">			<span class="built_in">free</span>++;</span><br><span class="line">	printk(<span class="string">&quot;%d/%d free blocks\n\r&quot;</span>,<span class="built_in">free</span>,p-&gt;s_nzones);</span><br><span class="line"><span class="comment">// 统计设备上空闲 i 节点数。首先令 i 等于超级块中表明的设备上 i 节点总数+1。加 1 是将 0 节点 </span></span><br><span class="line"> <span class="comment">// 也统计进去。</span></span><br><span class="line">	<span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">	i=p-&gt;s_ninodes+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 然后根据 i 节点位图中相应比特位的占用情况计算出空闲 i 节点数</span></span><br><span class="line">	<span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_imap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line">			<span class="built_in">free</span>++;</span><br><span class="line">    <span class="comment">// 显示设备上可用的空闲 i 节点数/i 节点总数。</span></span><br><span class="line">	printk(<span class="string">&quot;%d/%d free inodes\n\r&quot;</span>,<span class="built_in">free</span>,p-&gt;s_ninodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此mount_root执行完，同时返回后sys_setip函数也执行完了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_setup</span><span class="params">(<span class="type">void</span> * BIOS)</span> <span class="comment">//首先解决硬盘的驱动器问题</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    rd_load();</span><br><span class="line">	mount_root();</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回到之前调用system_call的地方，一路返回到一开始的init函数。</p>
<p>#### sys_mount</p>
<blockquote>
<p>函数说明：除了根文件系统以外其它一般的文件系统挂载的流程。</p>
</blockquote>
<p>完成挂载： 1.找到要安装的结点 2.找到要挂接的结点 3.连接
拿到设备号一定可以拿到超级块，把超级块加载到super
block数组里面——》安装文件系统 首先在获取设备i结点</p>
<p>此时再看copy_process 可以看出子进程复制了父进程打开的文件
进程0创建进程1的时候因为进程0的pwd和root都是空，因此进程1刚建立的时候还没有pwd和root
进程1是在current-&gt;pad=mi的时候才有的，后面的进程集成了基础1也有==（<em>p=</em>current）==
这个root不一定是根i结点的根
每个硬件设备都有一个引导块，每个逻辑设备都有一个超级块，如果一个物理设备有多个逻辑设备往后复制一下上图
iput 释放在inode_table[32]的结点 wait_on_inode:和 wait buffer 相似
get_super 在super block里面找同样的 iget</p>
<figure>
<img src="/2023/11/20/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/文件系统加载示意图.png" alt="文件系统加载结点">
<figcaption aria-hidden="true">文件系统加载结点</figcaption>
</figure>
<p>首先获取设备inode，根据设备inode就可以获得设备号（然后这个结点就没有用了，iput释放)</p>
<p>目录文件的i结点指向目录文件。目录文件里面有目录项。根据目录项可以找到下一级目录文件的i结点</p>
<p>最后一个目录文件的i结点叫做枝梢i结点。通过枝梢i结点可以找到硬盘上包含要找的目录项的块，把这个块读到缓冲区，在缓冲区倒腾目录项都有那些内容。然后再把内容放到inode里面。这个结点最终要到inode
table32</p>
<p>还缺少imode ：区分i结点是目录i结点还是文件i结点</p>
<h4 id="dirt-update位分析">dirt ，update位分析</h4>
<p>对缓冲块的共享有两个方向：</p>
<ul>
<li>进程方向：进程能共享哪些缓冲块，不能共享哪些</li>
<li>硬盘方向：哪些缓冲块需要同步到外设，哪些不用同步</li>
</ul>
<p>缓冲块管理结构 buffer_head 的 <code>b_uptodate</code> 和
<code>b_dirt</code> 字段就是为了保证缓冲块和逻辑块数据的正确性</p>
<ul>
<li><code>b_uptodate</code>：针对进程方向。它的作用是告诉内核，只要缓冲块的
b_uptodate 字段被设置为
1，缓冲块的数据已经是最新的，可以放心地支持进程共享缓冲块的数据；反之，如果设置为
0，就提醒内核缓冲块数据并没有更新，不支持进程共享该缓冲块。</li>
</ul>
<p>需要<strong>特别注意</strong>的是，<code>b_uptodate 字段为 1 并不代表缓冲块的数据跟块设备逻辑块上的数据是一致的，它们可以不一样。</code>。</p>
<p>申请逻辑块是一种特殊情况。<code>将 b_uptodate 字段设置为 1 只是表明该缓冲块的数据是最新，进程可以直接读或写，但并不意味着缓冲块的数据跟逻辑块的数据是一致的。</code>设想将
b_uptodate 字段设置为
0，进程以为该缓冲块数据不是最新的，就会从逻辑块将数据读入，而此时逻辑块数据并没有清零，读入的必然是垃圾数据。另外，因为是新建逻辑块，内核不会去读该逻辑块，只会向该逻辑块写数据，所以当该缓冲块的
b_dirt 字段为 1
时，将缓冲块数据同步到该逻辑块自然能够覆盖掉该逻辑块之前的垃圾数据。</p>
<ul>
<li><code>b_dirt</code>：针对硬盘方向。只要缓冲块的 b_dirt 字段被设置为
1，就是告诉内核，这个缓冲块中的内容已经被进程修改过，需要同步到块设备上；反之，如果为
0，不需要同步。b_uptodate 字段设置为 1
后，内核就支持进程共享该缓冲块的数据，读写都可以。读操作不会改变缓冲块的数据；但写操作会改变缓冲块的内容，需要将
b_dirt 字段设置为 1，标志该缓冲块需要同步。</li>
</ul>
<blockquote>
<p>在buffer init的时候会初始化：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h-&gt;b_dirt = <span class="number">0</span>; <span class="comment">// 脏标志，也即缓冲区修改标志。</span></span><br><span class="line">h-&gt;b_count = <span class="number">0</span>;<span class="comment">// 该缓冲区引用计数。</span></span><br><span class="line">h-&gt;b_lock = <span class="number">0</span>;<span class="comment">// 缓冲区锁定标志</span></span><br><span class="line">h-&gt;b_uptodate = <span class="number">0</span>;<span class="comment">// 缓冲区更新标志（或称数据有效标志）。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在getblk的时候，如果没有找到现成的缓冲块，从空闲区域找到后会对块操作：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bh-&gt;b_dirt=<span class="number">0</span>;<span class="comment">//还没有读盘dirt不置1</span></span><br><span class="line">bh-&gt;b_uptodate=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>缓冲块的同步有两种方法：一种是 update
进程定期同步；另一种是因缓冲区使用达到极限，操作系统强行同步。这两种同步方法最终都会调用
<code>sys_sync</code> 函数</p>
<p>uptodate 创建新文件的时候uptodate直接置1</p>
<h2 id="static-和inline分析">static 和inline分析</h2>
<p><a href="./Linux%200.11%20里面的%20inline%20问题">Linux 0.11 里面的
inline 问题</a></p>
<p>去掉inline行不行？原理是什么？ #### C程序运行结构
内存：代码区，静态数据区。动态数据区 cpu：eip（指向下一条指令）
ebp（栈底） esp（栈顶指针）
函数调用时，参数入栈顺序，从右向左），函数调用的时候首先将传参压入数据栈中。
然后将函数执行完的返回地址压栈，保存main函数的栈底（压栈），ebp挪到fun函数栈底，运行函数程序
函数局部变量压栈。
函数返回，根据栈中内容恢复现场，函数传参已经没用了，进行清栈。
用的是用户栈，是共用一个栈：理由copy page tables
进程0完全复制给进程1了，因此物理内存是一个物理内存，线性地址空间不一样，但是物理空间一样，所以可以看成共用一个栈，当发生写时复制才变两个栈，因为进程0本来是可读写的所以没导致copy
on write 所以还是共用了一个栈。 注意：进程0的压栈没有导致写时复制
为啥卡在pause？
因为进程0压栈了fork和pause的返回地址，但是fork返回了就清栈了，所以现在栈里面就是pause所以fork跳出来的时候返回到pause里面去了
有没有可能跑对？有可能
为啥有的时候行有的时候不行，因为操作系统调度是根据时间片进行的，而不是指令数。时间比较依赖cpu
硬件或虚拟机类型 当前进程有tss switch to 里面也有一套tss ============｜
======== c 运行的程序 | ST 里面 TSS（0） |TSS（1） CS.EiP |cs.eip
进程1第一次运行，他的运行状态记录tss是否存在？存在。是在父进程创建的时候就被创建出来，不然开始运行的时候不知道从哪里开始运行。进程1返回的时候，eip（__res_)在用户态
有两个验证： 1.iret 2.在trap设置里面设置了特权级是用户态。</p>
<p>## 小结 1. 进程0从哪里蹦出来的： move to usermod</p>
<pre><code>2.taskstruct 是共用体前端，和内核栈在一个union ，分配了一个页：4k，task struct一般也就1k，也就是说，内核栈再怎么用页不会超过3k。注意一个进程有两个栈，调用fork的时候跑的是用户栈，copyprocess的一系列操作的时候用的是内核栈。</code></pre>
<ol start="2" type="1">
<li><p>init 80
在用户态执行，fork进程0压栈五个，进的是内核栈还是用户栈？内核栈。进程0用户栈：user
stack 压栈最本质是为了配合iret执行，iret在内核态</p></li>
<li><p>假设有inline在int 80
返回之后有可能出时钟，这个时钟里面也有一堆call这会不会把fork里面的那个返回值搞乱了？不会。do
timer来了以后在内核态，用的是内核栈，fork的返回值在用户栈里</p></li>
<li><p>get free page 获得空闲页不是共享页，get free
page是物理地址上还是线性地址上？获得的是线性地址，但是获得的是物理页。为啥是线性的地址？
cr3时物理的，页目录表里面要指向一个页表，这里也是一个物理地址（20位），页表有1k的页表项里面指向的也是物理地址，</p></li>
<li><p>p=(strict
task_struct*)get_free_page(),这里面得到的页是线性地址，这里的页面有没有挂到页表里面？挂过了，在head.s里面就挂了。挂到页表和用过是不等价的，只有memmap的引用计数可以看出来有没有用过</p></li>
<li><p>进程1能不能访问到自己的task
struct的那个页？。不可以，这个页挂在了进程0的页表上，进程1用不了，进程1的页目录表：64M-128M上没用挂过这个页</p></li>
</ol>
<pre><code>8.是不是所有的get free page用户程序都访问不了？：不一定</code></pre>
<ol start="7" type="1">
<li><p>get free
page是从后往前遍历？这样映射关系就变得不那么线性了，增加安全性，物理地址和线性地址的映射关系就会更复杂一点。</p></li>
<li><p>没有一个脱离进程的绝对的内核，内核是进程的内核态</p></li>
<li><p>时间片在内核态和用户态都在跑，详见do_timer</p></li>
<li><p>in32
里面又的指令是绝对特权的，在0特权级列表里面，还有一些是通过IOPL设定他能不能被用户态度操作的
，在init
task里面的eflags=0的时候设定的，此时IOPL也被清零了。因为存在父子进程创建机制，因此后面所有进程的eflags都等于0</p></li>
<li><p>要用逻辑体系的思维保证滴水不漏</p></li>
<li><p>为啥都从fork出来
main函数代表内核，一般肯定不能走完，结束前肯定有一个死循环：<code>for（；；）pause（）;</code>
这个死循环谁做：进程0</p></li>
<li><p>进程0:进程的祖宗，当其他进程都不动的时候进程0怠速状态idle
由进程0负责让操作系统不熄火。所以说，创建进程在fork，怠速在pause
那其他进程只能从fork出来了，linux的设计思想</p></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/11/10/Linux011%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="ldt中断函数挂接以及进程及相关设备初始化">
                  <i class="fa fa-chevron-left"></i> ldt中断函数挂接以及进程及相关设备初始化
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/11/20/Linux%E7%BD%91%E7%BB%9C/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/" rel="next" title="Linux网络编程基础API学习笔记">
                  Linux网络编程基础API学习笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sherecho</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">438k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:39</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
<br /> #运行时间
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("01/01/2022 15:54:40");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/sherecho" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"sherecho","repo":"gittalks","client_id":"9912d1c0be5407c8e1bd","client_secret":"6d0991787716b87d7d041c5d2a38b8cc3ddc5944","admin_user":null,"distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"53723ab55b4f551a2ccd15a568e1dcc0"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
